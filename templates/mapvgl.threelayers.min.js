(function(Nb, If) {
  "object" === typeof exports && "undefined" !== typeof module
    ? If(exports)
    : "function" === typeof define && define.amd
    ? define(["exports"], If)
    : ((Nb = Nb || self), If((Nb.mapvgl = Nb.mapvgl || {})));
})(this, function(Nb) {
  function If() {
    throw Error(
      "Dynamic requires are not currently supported by rollup-plugin-commonjs"
    );
  }
  function ad(a, b) {
    return (b = { exports: {} }), a(b, b.exports), b.exports;
  }
  function Nd() {}
  function Wk(a, b) {
    for (var c in b) a[c] = b[c];
  }
  function bd(a, b) {
    this.lng = a;
    this.lat = b;
  }
  function Xk(a, b) {
    this.x = a;
    this.y = b;
  }
  function jn(a, b) {
    return function(c) {
      return b(a(c));
    };
  }
  function kn(a) {
    var b = function(b) {
      if (void 0 === b || null === b) return b;
      1 < arguments.length && (b = Array.prototype.slice.call(arguments));
      return a(b);
    };
    "conversion" in a && (b.conversion = a.conversion);
    return b;
  }
  function ln(a) {
    var b = function(b) {
      if (void 0 === b || null === b) return b;
      1 < arguments.length && (b = Array.prototype.slice.call(arguments));
      var c = a(b);
      if ("object" === ("undefined" === typeof c ? "undefined" : nk(c)))
        for (var e = c.length, f = 0; f < e; f++) c[f] = Math.round(c[f]);
      return c;
    };
    "conversion" in a && (b.conversion = a.conversion);
    return b;
  }
  function cb(a, b) {
    if (!(this instanceof cb)) return new cb(a, b);
    b && b in Yk && (b = null);
    if (b && !(b in ub)) throw Error("Unknown model: " + b);
    if ("undefined" === typeof a)
      (this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1);
    else if (a instanceof cb)
      (this.model = a.model),
        (this.color = a.color.slice()),
        (this.valpha = a.valpha);
    else if ("string" === typeof a) {
      b = cd.get(a);
      if (null === b) throw Error("Unable to parse color from string: " + a);
      this.model = b.model;
      var c = ub[this.model].channels;
      this.color = b.value.slice(0, c);
      this.valpha = "number" === typeof b.value[c] ? b.value[c] : 1;
    } else if (a.length)
      (this.model = b || "rgb"),
        (c = ub[this.model].channels),
        (b = uj.call(a, 0, c)),
        (this.color = Cg(b, c)),
        (this.valpha = "number" === typeof a[c] ? a[c] : 1);
    else if ("number" === typeof a)
      (a &= 16777215),
        (this.model = "rgb"),
        (this.color = [(a >> 16) & 255, (a >> 8) & 255, a & 255]),
        (this.valpha = 1);
    else {
      this.valpha = 1;
      b = Object.keys(a);
      "alpha" in a &&
        (b.splice(b.indexOf("alpha"), 1),
        (this.valpha = "number" === typeof a.alpha ? a.alpha : 0));
      b = b.sort().join("");
      if (!(b in Dg))
        throw Error("Unable to parse color from object: " + JSON.stringify(a));
      this.model = Dg[b];
      c = ub[this.model].labels;
      var d = [];
      for (b = 0; b < c.length; b++) d.push(a[c[b]]);
      this.color = Cg(d);
    }
    if (Jf[this.model])
      for (c = ub[this.model].channels, b = 0; b < c; b++)
        (a = Jf[this.model][b]) && (this.color[b] = a(this.color[b]));
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    Object.freeze && Object.freeze(this);
  }
  function mn(a) {
    return function(b) {
      return Number(b.toFixed(a));
    };
  }
  function Ba(a, b, c) {
    a = Array.isArray(a) ? a : [a];
    a.forEach(function(a) {
      (Jf[a] || (Jf[a] = []))[b] = c;
    });
    a = a[0];
    return function(d) {
      if (arguments.length) {
        c && (d = c(d));
        var e = this[a]();
        e.color[b] = d;
        return e;
      }
      e = this[a]().color[b];
      c && (e = c(e));
      return e;
    };
  }
  function ta(a) {
    return function(b) {
      return Math.max(0, Math.min(a, b));
    };
  }
  function Cg(a, b) {
    for (var c = 0; c < b; c++) "number" !== typeof a[c] && (a[c] = 0);
    return a;
  }
  function lc() {}
  function E(a, b) {
    this.x = a || 0;
    this.y = b || 0;
  }
  function mb(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== d ? d : 1;
  }
  function r(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
  }
  function Ya() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length &&
      console.error(
        "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
      );
  }
  function pa(a, b, c, d, e, f, h, k, l, m) {
    Object.defineProperty(this, "id", { value: nn++ });
    this.uuid = ca.generateUUID();
    this.name = "";
    this.image = void 0 !== a ? a : pa.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : pa.DEFAULT_MAPPING;
    this.wrapS = void 0 !== c ? c : 1001;
    this.wrapT = void 0 !== d ? d : 1001;
    this.magFilter = void 0 !== e ? e : 1006;
    this.minFilter = void 0 !== f ? f : 1008;
    this.anisotropy = void 0 !== l ? l : 1;
    this.format = void 0 !== h ? h : 1023;
    this.type = void 0 !== k ? k : 1009;
    this.offset = new E(0, 0);
    this.repeat = new E(1, 1);
    this.center = new E(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = !0;
    this.matrix = new Ya();
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== m ? m : 3e3;
    this.version = 0;
    this.onUpdate = null;
  }
  function Ca(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== d ? d : 1;
  }
  function Za(a, b, c) {
    this.width = a;
    this.height = b;
    this.scissor = new Ca(0, 0, a, b);
    this.scissorTest = !1;
    this.viewport = new Ca(0, 0, a, b);
    c = c || {};
    this.texture = new pa(
      void 0,
      void 0,
      c.wrapS,
      c.wrapT,
      c.magFilter,
      c.minFilter,
      c.format,
      c.type,
      c.anisotropy,
      c.encoding
    );
    this.texture.image = {};
    this.texture.image.width = a;
    this.texture.image.height = b;
    this.texture.generateMipmaps =
      void 0 !== c.generateMipmaps ? c.generateMipmaps : !1;
    this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
    this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
  }
  function Zk(a, b, c) {
    Za.call(this, a, b, c);
    this.samples = 4;
  }
  function fa() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length &&
      console.error(
        "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
      );
  }
  function Od(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = d || Od.DefaultOrder;
  }
  function $k() {
    this.mask = 1;
  }
  function D() {
    Object.defineProperty(this, "id", { value: on++ });
    this.uuid = ca.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = D.DefaultUp.clone();
    var a = new r(),
      b = new Od(),
      c = new mb(),
      d = new r(1, 1, 1);
    b._onChange(function() {
      c.setFromEuler(b, !1);
    });
    c._onChange(function() {
      b.setFromQuaternion(c, void 0, !1);
    });
    Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: a },
      rotation: { configurable: !0, enumerable: !0, value: b },
      quaternion: { configurable: !0, enumerable: !0, value: c },
      scale: { configurable: !0, enumerable: !0, value: d },
      modelViewMatrix: { value: new fa() },
      normalMatrix: { value: new Ya() }
    });
    this.matrix = new fa();
    this.matrixWorld = new fa();
    this.matrixAutoUpdate = D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = !1;
    this.layers = new $k();
    this.visible = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.renderOrder = 0;
    this.userData = {};
  }
  function Kf() {
    D.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.background = null;
    this.autoUpdate = !0;
    "undefined" !== typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
  }
  function dd(a, b) {
    this.min = void 0 !== a ? a : new r(Infinity, Infinity, Infinity);
    this.max = void 0 !== b ? b : new r(-Infinity, -Infinity, -Infinity);
  }
  function vj(a, b, c, d, e) {
    var f;
    var h = 0;
    for (f = a.length - 3; h <= f; h += 3) {
      Pd.fromArray(a, h);
      var k =
          e.x * Math.abs(Pd.x) + e.y * Math.abs(Pd.y) + e.z * Math.abs(Pd.z),
        l = b.dot(Pd),
        m = c.dot(Pd),
        n = d.dot(Pd);
      if (Math.max(-Math.max(l, m, n), Math.min(l, m, n)) > k) return !1;
    }
    return !0;
  }
  function ed(a, b) {
    this.center = void 0 !== a ? a : new r();
    this.radius = void 0 !== b ? b : 0;
  }
  function Ob(a, b) {
    this.origin = void 0 !== a ? a : new r();
    this.direction = void 0 !== b ? b : new r();
  }
  function Ma(a, b, c) {
    this.a = void 0 !== a ? a : new r();
    this.b = void 0 !== b ? b : new r();
    this.c = void 0 !== c ? c : new r();
  }
  function L(a, b, c) {
    return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c);
  }
  function Eg(a, b, c) {
    0 > c && (c += 1);
    1 < c && --c;
    return c < 1 / 6
      ? a + 6 * (b - a) * c
      : 0.5 > c
      ? b
      : c < 2 / 3
      ? a + 6 * (b - a) * (2 / 3 - c)
      : a;
  }
  function wj(a) {
    return 0.04045 > a
      ? 0.0773993808 * a
      : Math.pow(0.9478672986 * a + 0.0521327014, 2.4);
  }
  function xj(a) {
    return 0.0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, 0.41666) - 0.055;
  }
  function Lf(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = d && d.isVector3 ? d : new r();
    this.vertexNormals = Array.isArray(d) ? d : [];
    this.color = e && e.isColor ? e : new L();
    this.vertexColors = Array.isArray(e) ? e : [];
    this.materialIndex = void 0 !== f ? f : 0;
  }
  function T() {
    Object.defineProperty(this, "id", { value: pn++ });
    this.uuid = ca.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = !0;
    this.blending = 1;
    this.side = 0;
    this.vertexTangents = this.flatShading = !1;
    this.vertexColors = 0;
    this.opacity = 1;
    this.transparent = !1;
    this.blendSrc = 204;
    this.blendDst = 205;
    this.blendEquation = 100;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = 3;
    this.depthWrite = this.depthTest = !0;
    this.stencilWriteMask = 255;
    this.stencilFunc = 519;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
    this.stencilWrite = !1;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = !1;
    this.shadowSide = null;
    this.colorWrite = !0;
    this.precision = null;
    this.polygonOffset = !1;
    this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.dithering = !1;
    this.alphaTest = 0;
    this.premultipliedAlpha = !1;
    this.toneMapped = this.visible = !0;
    this.userData = {};
    this.needsUpdate = !0;
  }
  function vb(a) {
    T.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new L(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphTargets = this.skinning = !1;
    this.setValues(a);
  }
  function ba(a, b, c) {
    if (Array.isArray(a))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    this.name = "";
    this.array = a;
    this.itemSize = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.normalized = !0 === c;
    this.dynamic = !1;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  function Sh(a, b, c) {
    ba.call(this, new Int8Array(a), b, c);
  }
  function yj(a, b, c) {
    ba.call(this, new Uint8Array(a), b, c);
  }
  function zj(a, b, c) {
    ba.call(this, new Uint8ClampedArray(a), b, c);
  }
  function Th(a, b, c) {
    ba.call(this, new Int16Array(a), b, c);
  }
  function fd(a, b, c) {
    ba.call(this, new Uint16Array(a), b, c);
  }
  function Uh(a, b, c) {
    ba.call(this, new Int32Array(a), b, c);
  }
  function gd(a, b, c) {
    ba.call(this, new Uint32Array(a), b, c);
  }
  function O(a, b, c) {
    ba.call(this, new Float32Array(a), b, c);
  }
  function Vh(a, b, c) {
    ba.call(this, new Float64Array(a), b, c);
  }
  function al() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function bl(a) {
    if (0 === a.length) return -Infinity;
    for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
    return b;
  }
  function F() {
    Object.defineProperty(this, "id", { value: (qn += 2) });
    this.uuid = ca.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  function oa(a, b) {
    D.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== a ? a : new F();
    this.material =
      void 0 !== b ? b : new vb({ color: 16777215 * Math.random() });
    this.drawMode = 0;
    this.updateMorphTargets();
  }
  function cl(a, b, c, d, e, f, h, k) {
    if (
      null ===
      (1 === b.side
        ? d.intersectTriangle(h, f, e, !0, k)
        : d.intersectTriangle(e, f, h, 2 !== b.side, k))
    )
      return null;
    Mf.copy(k);
    Mf.applyMatrix4(a.matrixWorld);
    b = c.ray.origin.distanceTo(Mf);
    return b < c.near || b > c.far
      ? null
      : { distance: b, point: Mf.clone(), object: a };
  }
  function Nf(a, b, c, d, e, f, h, k, l, m, n) {
    Qe.fromBufferAttribute(e, l);
    Qd.fromBufferAttribute(e, m);
    Re.fromBufferAttribute(e, n);
    e = a.morphTargetInfluences;
    if (b.morphTargets && f && e) {
      Wh.set(0, 0, 0);
      Xh.set(0, 0, 0);
      Yh.set(0, 0, 0);
      for (var q = 0, t = f.length; q < t; q++) {
        var y = e[q],
          u = f[q];
        0 !== y &&
          (dl.fromBufferAttribute(u, l),
          el.fromBufferAttribute(u, m),
          fl.fromBufferAttribute(u, n),
          Wh.addScaledVector(dl.sub(Qe), y),
          Xh.addScaledVector(el.sub(Qd), y),
          Yh.addScaledVector(fl.sub(Re), y));
      }
      Qe.add(Wh);
      Qd.add(Xh);
      Re.add(Yh);
    }
    if ((a = cl(a, b, c, d, Qe, Qd, Re, Of)))
      h &&
        (mc.fromBufferAttribute(h, l),
        nc.fromBufferAttribute(h, m),
        Pb.fromBufferAttribute(h, n),
        (a.uv = Ma.getUV(Of, Qe, Qd, Re, mc, nc, Pb, new E()))),
        k &&
          (mc.fromBufferAttribute(k, l),
          nc.fromBufferAttribute(k, m),
          Pb.fromBufferAttribute(k, n),
          (a.uv2 = Ma.getUV(Of, Qe, Qd, Re, mc, nc, Pb, new E()))),
        (h = new Lf(l, m, n)),
        Ma.getNormal(Qe, Qd, Re, h.normal),
        (a.face = h);
    return a;
  }
  function W() {
    Object.defineProperty(this, "id", { value: (rn += 2) });
    this.uuid = ca.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function Se(a) {
    var b = {},
      c;
    for (c in a) {
      b[c] = {};
      for (var d in a[c]) {
        var e = a[c][d];
        e &&
        (e.isColor ||
          e.isMatrix3 ||
          e.isMatrix4 ||
          e.isVector2 ||
          e.isVector3 ||
          e.isVector4 ||
          e.isTexture)
          ? (b[c][d] = e.clone())
          : Array.isArray(e)
          ? (b[c][d] = e.slice())
          : (b[c][d] = e);
      }
    }
    return b;
  }
  function Oa(a) {
    for (var b = {}, c = 0; c < a.length; c++) {
      var d = Se(a[c]),
        e;
      for (e in d) b[e] = d[e];
    }
    return b;
  }
  function Pa(a) {
    T.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader =
      "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader =
      "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
    this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    };
    this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = !1;
    void 0 !== a &&
      (void 0 !== a.attributes &&
        console.error(
          "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
        ),
      this.setValues(a));
  }
  function oc() {
    D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new fa();
    this.projectionMatrix = new fa();
    this.projectionMatrixInverse = new fa();
  }
  function Ua(a, b, c, d) {
    oc.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== a ? a : 50;
    this.zoom = 1;
    this.near = void 0 !== c ? c : 0.1;
    this.far = void 0 !== d ? d : 2e3;
    this.focus = 10;
    this.aspect = void 0 !== b ? b : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  function hd(a, b, c, d) {
    D.call(this);
    this.type = "CubeCamera";
    var e = new Ua(90, 1, a, b);
    e.up.set(0, -1, 0);
    e.lookAt(new r(1, 0, 0));
    this.add(e);
    var f = new Ua(90, 1, a, b);
    f.up.set(0, -1, 0);
    f.lookAt(new r(-1, 0, 0));
    this.add(f);
    var h = new Ua(90, 1, a, b);
    h.up.set(0, 0, 1);
    h.lookAt(new r(0, 1, 0));
    this.add(h);
    var k = new Ua(90, 1, a, b);
    k.up.set(0, 0, -1);
    k.lookAt(new r(0, -1, 0));
    this.add(k);
    var l = new Ua(90, 1, a, b);
    l.up.set(0, -1, 0);
    l.lookAt(new r(0, 0, 1));
    this.add(l);
    var m = new Ua(90, 1, a, b);
    m.up.set(0, -1, 0);
    m.lookAt(new r(0, 0, -1));
    this.add(m);
    d = d || { format: 1022, magFilter: 1006, minFilter: 1006 };
    this.renderTarget = new Rd(c, c, d);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(a, b) {
      null === this.parent && this.updateMatrixWorld();
      var c = a.getRenderTarget(),
        d = this.renderTarget,
        n = d.texture.generateMipmaps;
      d.texture.generateMipmaps = !1;
      a.setRenderTarget(d, 0);
      a.render(b, e);
      a.setRenderTarget(d, 1);
      a.render(b, f);
      a.setRenderTarget(d, 2);
      a.render(b, h);
      a.setRenderTarget(d, 3);
      a.render(b, k);
      a.setRenderTarget(d, 4);
      a.render(b, l);
      d.texture.generateMipmaps = n;
      a.setRenderTarget(d, 5);
      a.render(b, m);
      a.setRenderTarget(c);
    };
    this.clear = function(a, b, c, d) {
      for (
        var f = a.getRenderTarget(), e = this.renderTarget, h = 0;
        6 > h;
        h++
      )
        a.setRenderTarget(e, h), a.clear(b, c, d);
      a.setRenderTarget(f);
    };
  }
  function Rd(a, b, c) {
    Za.call(this, a, b, c);
  }
  function pc(a, b, c, d, e, f, h, k, l, m, n, q) {
    pa.call(this, null, f, h, k, l, m, d, e, n, q);
    this.image = { data: a || null, width: b || 1, height: c || 1 };
    this.magFilter = void 0 !== l ? l : 1003;
    this.minFilter = void 0 !== m ? m : 1003;
    this.flipY = this.generateMipmaps = !1;
    this.unpackAlignment = 1;
    this.needsUpdate = !0;
  }
  function qc(a, b) {
    this.normal = void 0 !== a ? a : new r(1, 0, 0);
    this.constant = void 0 !== b ? b : 0;
  }
  function Fg(a, b, c, d, e, f) {
    this.planes = [
      void 0 !== a ? a : new qc(),
      void 0 !== b ? b : new qc(),
      void 0 !== c ? c : new qc(),
      void 0 !== d ? d : new qc(),
      void 0 !== e ? e : new qc(),
      void 0 !== f ? f : new qc()
    ];
  }
  function Gg() {
    function a(e, f) {
      !1 !== c && (d(e, f), b.requestAnimationFrame(a));
    }
    var b = null,
      c = !1,
      d = null;
    return {
      start: function() {
        !0 !== c && null !== d && (b.requestAnimationFrame(a), (c = !0));
      },
      stop: function() {
        c = !1;
      },
      setAnimationLoop: function(a) {
        d = a;
      },
      setContext: function(a) {
        b = a;
      }
    };
  }
  function sn(a) {
    function b(b, c) {
      var d = b.array,
        e = b.dynamic ? 35048 : 35044,
        k = a.createBuffer();
      a.bindBuffer(c, k);
      a.bufferData(c, d, e);
      b.onUploadCallback();
      c = 5126;
      d instanceof Float32Array
        ? (c = 5126)
        : d instanceof Float64Array
        ? console.warn(
            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
          )
        : d instanceof Uint16Array
        ? (c = 5123)
        : d instanceof Int16Array
        ? (c = 5122)
        : d instanceof Uint32Array
        ? (c = 5125)
        : d instanceof Int32Array
        ? (c = 5124)
        : d instanceof Int8Array
        ? (c = 5120)
        : d instanceof Uint8Array && (c = 5121);
      return {
        buffer: k,
        type: c,
        bytesPerElement: d.BYTES_PER_ELEMENT,
        version: b.version
      };
    }
    var c = new WeakMap();
    return {
      get: function(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        return c.get(a);
      },
      remove: function(b) {
        b.isInterleavedBufferAttribute && (b = b.data);
        var d = c.get(b);
        d && (a.deleteBuffer(d.buffer), c.delete(b));
      },
      update: function(d, e) {
        d.isInterleavedBufferAttribute && (d = d.data);
        var f = c.get(d);
        if (void 0 === f) c.set(d, b(d, e));
        else if (f.version < d.version) {
          var h = d,
            k = h.array,
            l = h.updateRange;
          a.bindBuffer(e, f.buffer);
          !1 === h.dynamic
            ? a.bufferData(e, k, 35044)
            : -1 === l.count
            ? a.bufferSubData(e, 0, k)
            : 0 === l.count
            ? console.error(
                "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
              )
            : (a.bufferSubData(
                e,
                l.offset * k.BYTES_PER_ELEMENT,
                k.subarray(l.offset, l.offset + l.count)
              ),
              (l.count = -1));
          f.version = d.version;
        }
      }
    };
  }
  function Hg(a, b, c, d) {
    W.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {
      width: a,
      height: b,
      widthSegments: c,
      heightSegments: d
    };
    this.fromBufferGeometry(new id(a, b, c, d));
    this.mergeVertices();
  }
  function id(a, b, c, d) {
    F.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {
      width: a,
      height: b,
      widthSegments: c,
      heightSegments: d
    };
    a = a || 1;
    b = b || 1;
    var e = a / 2,
      f = b / 2;
    c = Math.floor(c) || 1;
    d = Math.floor(d) || 1;
    var h = c + 1,
      k = d + 1,
      l = a / c,
      m = b / d,
      n = [],
      q = [],
      t = [],
      y = [];
    for (a = 0; a < k; a++) {
      var u = a * m - f;
      for (b = 0; b < h; b++)
        q.push(b * l - e, -u, 0),
          t.push(0, 0, 1),
          y.push(b / c),
          y.push(1 - a / d);
    }
    for (a = 0; a < d; a++)
      for (b = 0; b < c; b++)
        (e = b + h * (a + 1)),
          (f = b + 1 + h * (a + 1)),
          (k = b + 1 + h * a),
          n.push(b + h * a, e, k),
          n.push(e, f, k);
    this.setIndex(n);
    this.addAttribute("position", new O(q, 3));
    this.addAttribute("normal", new O(t, 3));
    this.addAttribute("uv", new O(y, 2));
  }
  function tn(a, b, c, d) {
    function e(a, c) {
      b.buffers.color.setClear(a.r, a.g, a.b, c, d);
    }
    var f = new L(0),
      h = 0,
      k,
      l,
      m = null,
      n = 0;
    return {
      getClearColor: function() {
        return f;
      },
      setClearColor: function(a, b) {
        f.set(a);
        h = void 0 !== b ? b : 1;
        e(f, h);
      },
      getClearAlpha: function() {
        return h;
      },
      setClearAlpha: function(a) {
        h = a;
        e(f, h);
      },
      render: function(b, d, y, u) {
        d = d.background;
        y = a.vr;
        (y = y.getSession && y.getSession()) &&
          "additive" === y.environmentBlendMode &&
          (d = null);
        null === d
          ? (e(f, h), (m = null), (n = 0))
          : d && d.isColor && (e(d, 1), (u = !0), (m = null), (n = 0));
        (a.autoClear || u) &&
          a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
        if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
          void 0 === l &&
            ((l = new oa(
              new Ig(1, 1, 1),
              new Pa({
                type: "BackgroundCubeMaterial",
                uniforms: Se(hb.cube.uniforms),
                vertexShader: hb.cube.vertexShader,
                fragmentShader: hb.cube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
              })
            )),
            l.geometry.removeAttribute("normal"),
            l.geometry.removeAttribute("uv"),
            (l.onBeforeRender = function(a, b, c) {
              this.matrixWorld.copyPosition(c.matrixWorld);
            }),
            Object.defineProperty(l.material, "map", {
              get: function() {
                return this.uniforms.tCube.value;
              }
            }),
            c.update(l));
          u = d.isWebGLRenderTargetCube ? d.texture : d;
          l.material.uniforms.tCube.value = u;
          l.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ? 1 : -1;
          if (m !== d || n !== u.version)
            (l.material.needsUpdate = !0), (m = d), (n = u.version);
          b.unshift(l, l.geometry, l.material, 0, 0, null);
        } else if (d && d.isTexture) {
          void 0 === k &&
            ((k = new oa(
              new id(2, 2),
              new Pa({
                type: "BackgroundMaterial",
                uniforms: Se(hb.background.uniforms),
                vertexShader: hb.background.vertexShader,
                fragmentShader: hb.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
              })
            )),
            k.geometry.removeAttribute("normal"),
            Object.defineProperty(k.material, "map", {
              get: function() {
                return this.uniforms.t2D.value;
              }
            }),
            c.update(k));
          k.material.uniforms.t2D.value = d;
          !0 === d.matrixAutoUpdate && d.updateMatrix();
          k.material.uniforms.uvTransform.value.copy(d.matrix);
          if (m !== d || n !== d.version)
            (k.material.needsUpdate = !0), (m = d), (n = d.version);
          b.unshift(k, k.geometry, k.material, 0, 0, null);
        }
      }
    };
  }
  function un(a, b, c, d) {
    var e;
    this.setMode = function(a) {
      e = a;
    };
    this.render = function(b, d) {
      a.drawArrays(e, b, d);
      c.update(d, e);
    };
    this.renderInstances = function(f, h, k, l) {
      if (0 !== l) {
        if (d.isWebGL2) {
          f = a;
          var m = "drawArraysInstanced";
        } else if (
          ((f = b.get("ANGLE_instanced_arrays")),
          (m = "drawArraysInstancedANGLE"),
          null === f)
        ) {
          console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
          return;
        }
        f[m](e, h, k, l);
        c.update(k, e, l);
      }
    };
  }
  function vn(a, b, c) {
    function d(b) {
      if ("highp" === b) {
        if (
          0 < a.getShaderPrecisionFormat(35633, 36338).precision &&
          0 < a.getShaderPrecisionFormat(35632, 36338).precision
        )
          return "highp";
        b = "mediump";
      }
      return "mediump" === b &&
        0 < a.getShaderPrecisionFormat(35633, 36337).precision &&
        0 < a.getShaderPrecisionFormat(35632, 36337).precision
        ? "mediump"
        : "lowp";
    }
    var e,
      f =
        "undefined" !== typeof WebGL2RenderingContext &&
        a instanceof WebGL2RenderingContext,
      h = void 0 !== c.precision ? c.precision : "highp",
      k = d(h);
    k !== h &&
      (console.warn(
        "THREE.WebGLRenderer:",
        h,
        "not supported, using",
        k,
        "instead."
      ),
      (h = k));
    c = !0 === c.logarithmicDepthBuffer;
    k = a.getParameter(34930);
    var l = a.getParameter(35660),
      m = a.getParameter(3379),
      n = a.getParameter(34076),
      q = a.getParameter(34921),
      t = a.getParameter(36347),
      y = a.getParameter(36348),
      u = a.getParameter(36349),
      v = 0 < l,
      A = f || !!b.get("OES_texture_float"),
      r = v && A,
      z = f ? a.getParameter(36183) : 0;
    return {
      isWebGL2: f,
      getMaxAnisotropy: function() {
        if (void 0 !== e) return e;
        var c = b.get("EXT_texture_filter_anisotropic");
        return (e =
          null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
      },
      getMaxPrecision: d,
      precision: h,
      logarithmicDepthBuffer: c,
      maxTextures: k,
      maxVertexTextures: l,
      maxTextureSize: m,
      maxCubemapSize: n,
      maxAttributes: q,
      maxVertexUniforms: t,
      maxVaryings: y,
      maxFragmentUniforms: u,
      vertexTextures: v,
      floatFragmentTextures: A,
      floatVertexTextures: r,
      maxSamples: z
    };
  }
  function wn() {
    function a() {
      m.value !== d && ((m.value = d), (m.needsUpdate = 0 < e));
      c.numPlanes = e;
      c.numIntersection = 0;
    }
    function b(a, b, d, f) {
      var e = null !== a ? a.length : 0,
        h = null;
      if (0 !== e) {
        h = m.value;
        if (!0 !== f || null === h) {
          f = d + 4 * e;
          b = b.matrixWorldInverse;
          l.getNormalMatrix(b);
          if (null === h || h.length < f) h = new Float32Array(f);
          for (f = 0; f !== e; ++f, d += 4)
            k.copy(a[f]).applyMatrix4(b, l),
              k.normal.toArray(h, d),
              (h[d + 3] = k.constant);
        }
        m.value = h;
        m.needsUpdate = !0;
      }
      c.numPlanes = e;
      return h;
    }
    var c = this,
      d = null,
      e = 0,
      f = !1,
      h = !1,
      k = new qc(),
      l = new Ya(),
      m = { value: null, needsUpdate: !1 };
    this.uniform = m;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(a, c, h) {
      var k = 0 !== a.length || c || 0 !== e || f;
      f = c;
      d = b(a, h, 0);
      e = a.length;
      return k;
    };
    this.beginShadows = function() {
      h = !0;
      b(null);
    };
    this.endShadows = function() {
      h = !1;
      a();
    };
    this.setState = function(c, k, l, y, u, v) {
      if (!f || null === c || 0 === c.length || (h && !l)) h ? b(null) : a();
      else {
        l = h ? 0 : e;
        var n = 4 * l,
          q = u.clippingState || null;
        m.value = q;
        q = b(c, y, n, v);
        for (c = 0; c !== n; ++c) q[c] = d[c];
        u.clippingState = q;
        this.numIntersection = k ? this.numPlanes : 0;
        this.numPlanes += l;
      }
    };
  }
  function xn(a) {
    var b = {};
    return {
      get: function(c) {
        if (void 0 !== b[c]) return b[c];
        switch (c) {
          case "WEBGL_depth_texture":
            var d =
              a.getExtension("WEBGL_depth_texture") ||
              a.getExtension("MOZ_WEBGL_depth_texture") ||
              a.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            d =
              a.getExtension("EXT_texture_filter_anisotropic") ||
              a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            d =
              a.getExtension("WEBGL_compressed_texture_s3tc") ||
              a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            d =
              a.getExtension("WEBGL_compressed_texture_pvrtc") ||
              a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            d = a.getExtension(c);
        }
        null === d &&
          console.warn(
            "THREE.WebGLRenderer: " + c + " extension not supported."
          );
        return (b[c] = d);
      }
    };
  }
  function yn(a, b, c) {
    function d(a) {
      var e = a.target;
      a = f.get(e);
      null !== a.index && b.remove(a.index);
      for (var k in a.attributes) b.remove(a.attributes[k]);
      e.removeEventListener("dispose", d);
      f.delete(e);
      if ((k = h.get(a))) b.remove(k), h.delete(a);
      c.memory.geometries--;
    }
    function e(a) {
      var c = [],
        d = a.index,
        f = a.attributes.position;
      if (null !== d) {
        var e = d.array;
        d = d.version;
        f = 0;
        for (var k = e.length; f < k; f += 3) {
          var y = e[f + 0],
            u = e[f + 1],
            v = e[f + 2];
          c.push(y, u, u, v, v, y);
        }
      } else for (e = f.array, d = f.version, f = 0, k = e.length / 3 - 1; f < k; f += 3) (y = f + 0), (u = f + 1), (v = f + 2), c.push(y, u, u, v, v, y);
      c = new (65535 < bl(c) ? gd : fd)(c, 1);
      c.version = d;
      b.update(c, 34963);
      (e = h.get(a)) && b.remove(e);
      h.set(a, c);
    }
    var f = new WeakMap(),
      h = new WeakMap();
    return {
      get: function(a, b) {
        var e = f.get(b);
        if (e) return e;
        b.addEventListener("dispose", d);
        b.isBufferGeometry
          ? (e = b)
          : b.isGeometry &&
            (void 0 === b._bufferGeometry &&
              (b._bufferGeometry = new F().setFromObject(a)),
            (e = b._bufferGeometry));
        f.set(b, e);
        c.memory.geometries++;
        return e;
      },
      update: function(a) {
        var c = a.index,
          d = a.attributes;
        null !== c && b.update(c, 34963);
        for (var f in d) b.update(d[f], 34962);
        a = a.morphAttributes;
        for (f in a) {
          c = a[f];
          d = 0;
          for (var e = c.length; d < e; d++) b.update(c[d], 34962);
        }
      },
      getWireframeAttribute: function(a) {
        var b = h.get(a);
        if (b) {
          var c = a.index;
          null !== c && b.version < c.version && e(a);
        } else e(a);
        return h.get(a);
      }
    };
  }
  function zn(a, b, c, d) {
    var e, f, h;
    this.setMode = function(a) {
      e = a;
    };
    this.setIndex = function(a) {
      f = a.type;
      h = a.bytesPerElement;
    };
    this.render = function(b, d) {
      a.drawElements(e, d, f, b * h);
      c.update(d, e);
    };
    this.renderInstances = function(k, l, m, n) {
      if (0 !== n) {
        if (d.isWebGL2) {
          k = a;
          var q = "drawElementsInstanced";
        } else if (
          ((k = b.get("ANGLE_instanced_arrays")),
          (q = "drawElementsInstancedANGLE"),
          null === k)
        ) {
          console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
          return;
        }
        k[q](e, m, f, l * h, n);
        c.update(m, e, n);
      }
    };
  }
  function An(a) {
    var b = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: b,
      programs: null,
      autoReset: !0,
      reset: function() {
        b.frame++;
        b.calls = 0;
        b.triangles = 0;
        b.points = 0;
        b.lines = 0;
      },
      update: function(a, d, e) {
        e = e || 1;
        b.calls++;
        switch (d) {
          case 4:
            b.triangles += (a / 3) * e;
            break;
          case 5:
          case 6:
            b.triangles += e * (a - 2);
            break;
          case 1:
            b.lines += (a / 2) * e;
            break;
          case 3:
            b.lines += e * (a - 1);
            break;
          case 2:
            b.lines += e * a;
            break;
          case 0:
            b.points += e * a;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", d);
        }
      }
    };
  }
  function Bn(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function Cn(a) {
    var b = {},
      c = new Float32Array(8);
    return {
      update: function(d, e, f, h) {
        var k = d.morphTargetInfluences,
          l = k.length;
        d = b[e.id];
        if (void 0 === d) {
          d = [];
          for (var m = 0; m < l; m++) d[m] = [m, 0];
          b[e.id] = d;
        }
        var n = f.morphTargets && e.morphAttributes.position;
        f = f.morphNormals && e.morphAttributes.normal;
        for (m = 0; m < l; m++) {
          var q = d[m];
          0 !== q[1] &&
            (n && e.removeAttribute("morphTarget" + m),
            f && e.removeAttribute("morphNormal" + m));
        }
        for (m = 0; m < l; m++) (q = d[m]), (q[0] = m), (q[1] = k[m]);
        d.sort(Bn);
        for (m = 0; 8 > m; m++) {
          if ((q = d[m]))
            if (((k = q[0]), (l = q[1]))) {
              n && e.addAttribute("morphTarget" + m, n[k]);
              f && e.addAttribute("morphNormal" + m, f[k]);
              c[m] = l;
              continue;
            }
          c[m] = 0;
        }
        h.getUniforms().setValue(a, "morphTargetInfluences", c);
      }
    };
  }
  function Dn(a, b, c, d) {
    var e = {};
    return {
      update: function(a) {
        var f = d.render.frame,
          k = a.geometry,
          l = b.get(a, k);
        e[l.id] !== f &&
          (k.isGeometry && l.updateFromObject(a), b.update(l), (e[l.id] = f));
        a.isInstancedMesh && c.update(a.instanceMatrix, 34962);
        return l;
      },
      dispose: function() {
        e = {};
      }
    };
  }
  function Sd(a, b, c, d, e, f, h, k, l, m) {
    a = void 0 !== a ? a : [];
    pa.call(
      this,
      a,
      void 0 !== b ? b : 301,
      c,
      d,
      e,
      f,
      void 0 !== h ? h : 1022,
      k,
      l,
      m
    );
    this.flipY = !1;
  }
  function jd(a, b, c, d) {
    pa.call(this, null);
    this.image = {
      data: a || null,
      width: b || 1,
      height: c || 1,
      depth: d || 1
    };
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = !1;
    this.needsUpdate = !0;
  }
  function kd(a, b, c, d) {
    pa.call(this, null);
    this.image = {
      data: a || null,
      width: b || 1,
      height: c || 1,
      depth: d || 1
    };
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = !1;
    this.needsUpdate = !0;
  }
  function Qb(a, b, c) {
    var d = a[0];
    if (0 >= d || 0 < d) return a;
    var e = b * c,
      f = gl[e];
    void 0 === f && ((f = new Float32Array(e)), (gl[e] = f));
    if (0 !== b)
      for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)
        (e += c), a[d].toArray(f, e);
    return f;
  }
  function Eb(a, b) {
    if (a.length !== b.length) return !1;
    for (var c = 0, d = a.length; c < d; c++) if (a[c] !== b[c]) return !1;
    return !0;
  }
  function wb(a, b) {
    for (var c = 0, d = b.length; c < d; c++) a[c] = b[c];
  }
  function hl(a, b) {
    var c = il[b];
    void 0 === c && ((c = new Int32Array(b)), (il[b] = c));
    for (var d = 0; d !== b; ++d) c[d] = a.allocateTextureUnit();
    return c;
  }
  function En(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1f(this.addr, b), (c[0] = b));
  }
  function Fn(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y)
        a.uniform2f(this.addr, b.x, b.y), (c[0] = b.x), (c[1] = b.y);
    } else Eb(c, b) || (a.uniform2fv(this.addr, b), wb(c, b));
  }
  function Gn(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z)
        a.uniform3f(this.addr, b.x, b.y, b.z),
          (c[0] = b.x),
          (c[1] = b.y),
          (c[2] = b.z);
    } else if (void 0 !== b.r) {
      if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b)
        a.uniform3f(this.addr, b.r, b.g, b.b),
          (c[0] = b.r),
          (c[1] = b.g),
          (c[2] = b.b);
    } else Eb(c, b) || (a.uniform3fv(this.addr, b), wb(c, b));
  }
  function Hn(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w)
        a.uniform4f(this.addr, b.x, b.y, b.z, b.w),
          (c[0] = b.x),
          (c[1] = b.y),
          (c[2] = b.z),
          (c[3] = b.w);
    } else Eb(c, b) || (a.uniform4fv(this.addr, b), wb(c, b));
  }
  function In(a, b) {
    var c = this.cache,
      d = b.elements;
    void 0 === d
      ? Eb(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), wb(c, b))
      : Eb(c, d) ||
        (jl.set(d), a.uniformMatrix2fv(this.addr, !1, jl), wb(c, d));
  }
  function Jn(a, b) {
    var c = this.cache,
      d = b.elements;
    void 0 === d
      ? Eb(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), wb(c, b))
      : Eb(c, d) ||
        (kl.set(d), a.uniformMatrix3fv(this.addr, !1, kl), wb(c, d));
  }
  function Kn(a, b) {
    var c = this.cache,
      d = b.elements;
    void 0 === d
      ? Eb(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), wb(c, b))
      : Eb(c, d) ||
        (ll.set(d), a.uniformMatrix4fv(this.addr, !1, ll), wb(c, d));
  }
  function Ln(a, b, c) {
    var d = this.cache,
      e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), (d[0] = e));
    c.safeSetTexture2D(b || ml, e);
  }
  function Mn(a, b, c) {
    var d = this.cache,
      e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), (d[0] = e));
    c.setTexture2DArray(b || Nn, e);
  }
  function On(a, b, c) {
    var d = this.cache,
      e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), (d[0] = e));
    c.setTexture3D(b || Pn, e);
  }
  function Qn(a, b, c) {
    var d = this.cache,
      e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), (d[0] = e));
    c.safeSetTextureCube(b || nl, e);
  }
  function Rn(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1i(this.addr, b), (c[0] = b));
  }
  function Sn(a, b) {
    var c = this.cache;
    Eb(c, b) || (a.uniform2iv(this.addr, b), wb(c, b));
  }
  function Tn(a, b) {
    var c = this.cache;
    Eb(c, b) || (a.uniform3iv(this.addr, b), wb(c, b));
  }
  function Un(a, b) {
    var c = this.cache;
    Eb(c, b) || (a.uniform4iv(this.addr, b), wb(c, b));
  }
  function Vn(a) {
    switch (a) {
      case 5126:
        return En;
      case 35664:
        return Fn;
      case 35665:
        return Gn;
      case 35666:
        return Hn;
      case 35674:
        return In;
      case 35675:
        return Jn;
      case 35676:
        return Kn;
      case 35678:
      case 36198:
        return Ln;
      case 35679:
        return On;
      case 35680:
        return Qn;
      case 36289:
        return Mn;
      case 5124:
      case 35670:
        return Rn;
      case 35667:
      case 35671:
        return Sn;
      case 35668:
      case 35672:
        return Tn;
      case 35669:
      case 35673:
        return Un;
    }
  }
  function Wn(a, b) {
    a.uniform1fv(this.addr, b);
  }
  function Xn(a, b) {
    a.uniform1iv(this.addr, b);
  }
  function Yn(a, b) {
    a.uniform2iv(this.addr, b);
  }
  function Zn(a, b) {
    a.uniform3iv(this.addr, b);
  }
  function $n(a, b) {
    a.uniform4iv(this.addr, b);
  }
  function ao(a, b) {
    b = Qb(b, this.size, 2);
    a.uniform2fv(this.addr, b);
  }
  function bo(a, b) {
    b = Qb(b, this.size, 3);
    a.uniform3fv(this.addr, b);
  }
  function co(a, b) {
    b = Qb(b, this.size, 4);
    a.uniform4fv(this.addr, b);
  }
  function eo(a, b) {
    b = Qb(b, this.size, 4);
    a.uniformMatrix2fv(this.addr, !1, b);
  }
  function fo(a, b) {
    b = Qb(b, this.size, 9);
    a.uniformMatrix3fv(this.addr, !1, b);
  }
  function go(a, b) {
    b = Qb(b, this.size, 16);
    a.uniformMatrix4fv(this.addr, !1, b);
  }
  function ho(a, b, c) {
    var d = b.length,
      e = hl(c, d);
    a.uniform1iv(this.addr, e);
    for (a = 0; a !== d; ++a) c.safeSetTexture2D(b[a] || ml, e[a]);
  }
  function io(a, b, c) {
    var d = b.length,
      e = hl(c, d);
    a.uniform1iv(this.addr, e);
    for (a = 0; a !== d; ++a) c.safeSetTextureCube(b[a] || nl, e[a]);
  }
  function jo(a) {
    switch (a) {
      case 5126:
        return Wn;
      case 35664:
        return ao;
      case 35665:
        return bo;
      case 35666:
        return co;
      case 35674:
        return eo;
      case 35675:
        return fo;
      case 35676:
        return go;
      case 35678:
        return ho;
      case 35680:
        return io;
      case 5124:
      case 35670:
        return Xn;
      case 35667:
      case 35671:
        return Yn;
      case 35668:
      case 35672:
        return Zn;
      case 35669:
      case 35673:
        return $n;
    }
  }
  function ko(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.setValue = Vn(b.type);
  }
  function ol(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.size = b.size;
    this.setValue = jo(b.type);
  }
  function pl(a) {
    this.id = a;
    this.seq = [];
    this.map = {};
  }
  function Td(a, b) {
    this.seq = [];
    this.map = {};
    for (var c = a.getProgramParameter(b, 35718), d = 0; d < c; ++d) {
      var e = a.getActiveUniform(b, d),
        f = a.getUniformLocation(b, e.name),
        h = this,
        k = e.name,
        l = k.length;
      for (Aj.lastIndex = 0; ; ) {
        var m = Aj.exec(k),
          n = Aj.lastIndex,
          q = m[1],
          t = m[3];
        "]" === m[2] && (q |= 0);
        if (void 0 === t || ("[" === t && n + 2 === l)) {
          k = h;
          e = void 0 === t ? new ko(q, e, f) : new ol(q, e, f);
          k.seq.push(e);
          k.map[e.id] = e;
          break;
        } else
          (t = h.map[q]),
            void 0 === t &&
              ((t = new pl(q)),
              (q = h),
              (h = t),
              q.seq.push(h),
              (q.map[h.id] = h)),
            (h = t);
      }
    }
  }
  function ql(a, b, c) {
    b = a.createShader(b);
    a.shaderSource(b, c);
    a.compileShader(b);
    return b;
  }
  function rl(a) {
    switch (a) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        throw Error("unsupported encoding: " + a);
    }
  }
  function sl(a, b, c) {
    var d = a.getShaderParameter(b, 35713),
      e = a.getShaderInfoLog(b).trim();
    if (d && "" === e) return "";
    a = a.getShaderSource(b).split("\n");
    for (b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
    a = a.join("\n");
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + e + a;
  }
  function Pf(a, b) {
    b = rl(b);
    return (
      "vec4 " +
      a +
      "( vec4 value ) { return " +
      b[0] +
      "ToLinear" +
      b[1] +
      "; }"
    );
  }
  function lo(a, b) {
    b = rl(b);
    return (
      "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"
    );
  }
  function mo(a, b) {
    switch (b) {
      case 1:
        b = "Linear";
        break;
      case 2:
        b = "Reinhard";
        break;
      case 3:
        b = "Uncharted2";
        break;
      case 4:
        b = "OptimizedCineon";
        break;
      case 5:
        b = "ACESFilmic";
        break;
      default:
        throw Error("unsupported toneMapping: " + b);
    }
    return (
      "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
    );
  }
  function no(a, b, c) {
    a = a || {};
    return [
      a.derivatives ||
      b.envMapCubeUV ||
      b.bumpMap ||
      b.tangentSpaceNormalMap ||
      b.clearcoatNormalMap ||
      b.flatShading
        ? "#extension GL_OES_standard_derivatives : enable"
        : "",
      (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth")
        ? "#extension GL_EXT_frag_depth : enable"
        : "",
      a.drawBuffers && c.get("WEBGL_draw_buffers")
        ? "#extension GL_EXT_draw_buffers : require"
        : "",
      (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod")
        ? "#extension GL_EXT_shader_texture_lod : enable"
        : ""
    ]
      .filter(Ud)
      .join("\n");
  }
  function oo(a) {
    var b = [],
      c;
    for (c in a) {
      var d = a[c];
      !1 !== d && b.push("#define " + c + " " + d);
    }
    return b.join("\n");
  }
  function Ud(a) {
    return "" !== a;
  }
  function tl(a, b) {
    return a
      .replace(/NUM_DIR_LIGHTS/g, b.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, b.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows)
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows);
  }
  function ul(a, b) {
    return a
      .replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        b.numClippingPlanes - b.numClipIntersection
      );
  }
  function Jg(a, b) {
    a = ha[b];
    if (void 0 === a) throw Error("Can not resolve #include <" + b + ">");
    return a.replace(Zh, Jg);
  }
  function vl(a, b, c, d) {
    a = "";
    for (b = parseInt(b); b < parseInt(c); b++)
      a += d
        .replace(/\[ i \]/g, "[ " + b + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, b);
    return a;
  }
  function wl(a) {
    var b =
      "precision " +
      a.precision +
      " float;\nprecision " +
      a.precision +
      " int;";
    "highp" === a.precision
      ? (b += "\n#define HIGH_PRECISION")
      : "mediump" === a.precision
      ? (b += "\n#define MEDIUM_PRECISION")
      : "lowp" === a.precision && (b += "\n#define LOW_PRECISION");
    return b;
  }
  function po(a) {
    var b = "SHADOWMAP_TYPE_BASIC";
    1 === a.shadowMapType
      ? (b = "SHADOWMAP_TYPE_PCF")
      : 2 === a.shadowMapType
      ? (b = "SHADOWMAP_TYPE_PCF_SOFT")
      : 3 === a.shadowMapType && (b = "SHADOWMAP_TYPE_VSM");
    return b;
  }
  function qo(a, b) {
    var c = "ENVMAP_TYPE_CUBE";
    if (a.envMap)
      switch (b.envMap.mapping) {
        case 301:
        case 302:
          c = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          c = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          c = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          c = "ENVMAP_TYPE_SPHERE";
      }
    return c;
  }
  function ro(a, b) {
    var c = "ENVMAP_MODE_REFLECTION";
    if (a.envMap)
      switch (b.envMap.mapping) {
        case 302:
        case 304:
          c = "ENVMAP_MODE_REFRACTION";
      }
    return c;
  }
  function so(a, b) {
    var c = "ENVMAP_BLENDING_MULTIPLY";
    if (a.envMap)
      switch (b.combine) {
        case 0:
          c = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          c = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          c = "ENVMAP_BLENDING_ADD";
      }
    return c;
  }
  function to(a, b, c, d, e, f) {
    var h = a.getContext(),
      k = d.defines,
      l = e.vertexShader,
      m = e.fragmentShader,
      n = po(f),
      q = qo(f, d),
      t = ro(f, d),
      y = so(f, d),
      u = 0 < a.gammaFactor ? a.gammaFactor : 1,
      v = f.isWebGL2 ? "" : no(d.extensions, f, b),
      A = oo(k),
      r = h.createProgram(),
      z =
        (k = a.getRenderTarget()) && k.isWebGLMultiviewRenderTarget
          ? k.numViews
          : 0;
    d.isRawShaderMaterial
      ? ((k = [A].filter(Ud).join("\n")),
        0 < k.length && (k += "\n"),
        (b = [v, A].filter(Ud).join("\n")),
        0 < b.length && (b += "\n"))
      : ((k = [
          wl(f),
          "#define SHADER_NAME " + e.name,
          A,
          f.instancing ? "#define USE_INSTANCING" : "",
          f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          "#define GAMMA_FACTOR " + u,
          "#define MAX_BONES " + f.maxBones,
          f.useFog && f.fog ? "#define USE_FOG" : "",
          f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "",
          f.map ? "#define USE_MAP" : "",
          f.envMap ? "#define USE_ENVMAP" : "",
          f.envMap ? "#define " + t : "",
          f.lightMap ? "#define USE_LIGHTMAP" : "",
          f.aoMap ? "#define USE_AOMAP" : "",
          f.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          f.bumpMap ? "#define USE_BUMPMAP" : "",
          f.normalMap ? "#define USE_NORMALMAP" : "",
          f.normalMap && f.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          f.normalMap && f.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          f.displacementMap && f.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          f.specularMap ? "#define USE_SPECULARMAP" : "",
          f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          f.metalnessMap ? "#define USE_METALNESSMAP" : "",
          f.alphaMap ? "#define USE_ALPHAMAP" : "",
          f.vertexTangents ? "#define USE_TANGENT" : "",
          f.vertexColors ? "#define USE_COLOR" : "",
          f.vertexUvs ? "#define USE_UV" : "",
          f.flatShading ? "#define FLAT_SHADED" : "",
          f.skinning ? "#define USE_SKINNING" : "",
          f.useVertexTexture ? "#define BONE_TEXTURE" : "",
          f.morphTargets ? "#define USE_MORPHTARGETS" : "",
          f.morphNormals && !1 === f.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          f.doubleSided ? "#define DOUBLE_SIDED" : "",
          f.flipSided ? "#define FLIP_SIDED" : "",
          f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          f.shadowMapEnabled ? "#define " + n : "",
          f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth"))
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "#ifdef USE_INSTANCING",
          " attribute mat4 instanceMatrix;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#ifdef USE_COLOR",
          "\tattribute vec3 color;",
          "#endif",
          "#ifdef USE_MORPHTARGETS",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n"
        ]
          .filter(Ud)
          .join("\n")),
        (b = [
          v,
          wl(f),
          "#define SHADER_NAME " + e.name,
          A,
          f.alphaTest
            ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0")
            : "",
          "#define GAMMA_FACTOR " + u,
          f.useFog && f.fog ? "#define USE_FOG" : "",
          f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "",
          f.map ? "#define USE_MAP" : "",
          f.matcap ? "#define USE_MATCAP" : "",
          f.envMap ? "#define USE_ENVMAP" : "",
          f.envMap ? "#define " + q : "",
          f.envMap ? "#define " + t : "",
          f.envMap ? "#define " + y : "",
          f.lightMap ? "#define USE_LIGHTMAP" : "",
          f.aoMap ? "#define USE_AOMAP" : "",
          f.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          f.bumpMap ? "#define USE_BUMPMAP" : "",
          f.normalMap ? "#define USE_NORMALMAP" : "",
          f.normalMap && f.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          f.normalMap && f.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          f.specularMap ? "#define USE_SPECULARMAP" : "",
          f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          f.metalnessMap ? "#define USE_METALNESSMAP" : "",
          f.alphaMap ? "#define USE_ALPHAMAP" : "",
          f.sheen ? "#define USE_SHEEN" : "",
          f.vertexTangents ? "#define USE_TANGENT" : "",
          f.vertexColors ? "#define USE_COLOR" : "",
          f.vertexUvs ? "#define USE_UV" : "",
          f.gradientMap ? "#define USE_GRADIENTMAP" : "",
          f.flatShading ? "#define FLAT_SHADED" : "",
          f.doubleSided ? "#define DOUBLE_SIDED" : "",
          f.flipSided ? "#define FLIP_SIDED" : "",
          f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          f.shadowMapEnabled ? "#define " + n : "",
          f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth"))
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          ((d.extensions && d.extensions.shaderTextureLOD) || f.envMap) &&
          (f.isWebGL2 || b.get("EXT_shader_texture_lod"))
            ? "#define TEXTURE_LOD_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          0 !== f.toneMapping ? "#define TONE_MAPPING" : "",
          0 !== f.toneMapping ? ha.tonemapping_pars_fragment : "",
          0 !== f.toneMapping ? mo("toneMapping", f.toneMapping) : "",
          f.dithering ? "#define DITHERING" : "",
          f.outputEncoding ||
          f.mapEncoding ||
          f.matcapEncoding ||
          f.envMapEncoding ||
          f.emissiveMapEncoding
            ? ha.encodings_pars_fragment
            : "",
          f.mapEncoding ? Pf("mapTexelToLinear", f.mapEncoding) : "",
          f.matcapEncoding ? Pf("matcapTexelToLinear", f.matcapEncoding) : "",
          f.envMapEncoding ? Pf("envMapTexelToLinear", f.envMapEncoding) : "",
          f.emissiveMapEncoding
            ? Pf("emissiveMapTexelToLinear", f.emissiveMapEncoding)
            : "",
          f.outputEncoding ? lo("linearToOutputTexel", f.outputEncoding) : "",
          f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "",
          "\n"
        ]
          .filter(Ud)
          .join("\n")));
    l = l.replace(Zh, Jg);
    l = tl(l, f);
    l = ul(l, f);
    m = m.replace(Zh, Jg);
    m = tl(m, f);
    m = ul(m, f);
    l = l.replace(xl, vl);
    m = m.replace(xl, vl);
    f.isWebGL2 &&
      !d.isRawShaderMaterial &&
      ((n = !1),
      (q = /^\s*#version\s+300\s+es\s*\n/),
      d.isShaderMaterial &&
        null !== l.match(q) &&
        null !== m.match(q) &&
        ((n = !0), (l = l.replace(q, "")), (m = m.replace(q, ""))),
      (k =
        "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
        k),
      (b =
        [
          "#version 300 es\n\n#define varying in",
          n ? "" : "out highp vec4 pc_fragColor;",
          n ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"
        ].join("\n") +
        "\n" +
        b),
      0 < z &&
        ((k = k.replace(
          "#version 300 es\n",
          [
            "#version 300 es\n\n#extension GL_OVR_multiview2 : require",
            "layout(num_views = " + z + ") in;",
            "#define VIEW_ID gl_ViewID_OVR"
          ].join("\n")
        )),
        (k = k.replace(
          "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;",
          [
            "uniform mat4 modelViewMatrices[" + z + "];",
            "uniform mat4 projectionMatrices[" + z + "];",
            "uniform mat4 viewMatrices[" + z + "];",
            "uniform mat3 normalMatrices[" + z + "];",
            "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"
          ].join("\n")
        )),
        (b = b.replace(
          "#version 300 es\n",
          "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"
        )),
        (b = b.replace(
          "uniform mat4 viewMatrix;",
          [
            "uniform mat4 viewMatrices[" + z + "];",
            "#define viewMatrix viewMatrices[VIEW_ID]"
          ].join("\n")
        ))));
    m = b + m;
    l = ql(h, 35633, k + l);
    m = ql(h, 35632, m);
    h.attachShader(r, l);
    h.attachShader(r, m);
    void 0 !== d.index0AttributeName
      ? h.bindAttribLocation(r, 0, d.index0AttributeName)
      : !0 === f.morphTargets && h.bindAttribLocation(r, 0, "position");
    h.linkProgram(r);
    if (a.debug.checkShaderErrors) {
      a = h.getProgramInfoLog(r).trim();
      f = h.getShaderInfoLog(l).trim();
      n = h.getShaderInfoLog(m).trim();
      t = q = !0;
      if (!1 === h.getProgramParameter(r, 35714))
        (q = !1),
          (y = sl(h, l, "vertex")),
          (u = sl(h, m, "fragment")),
          console.error(
            "THREE.WebGLProgram: shader error: ",
            h.getError(),
            "35715",
            h.getProgramParameter(r, 35715),
            "gl.getProgramInfoLog",
            a,
            y,
            u
          );
      else if ("" !== a)
        console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a);
      else if ("" === f || "" === n) t = !1;
      t &&
        (this.diagnostics = {
          runnable: q,
          material: d,
          programLog: a,
          vertexShader: { log: f, prefix: k },
          fragmentShader: { log: n, prefix: b }
        });
    }
    h.deleteShader(l);
    h.deleteShader(m);
    var H;
    this.getUniforms = function() {
      void 0 === H && (H = new Td(h, r));
      return H;
    };
    var N;
    this.getAttributes = function() {
      if (void 0 === N) {
        for (
          var a = {}, b = h.getProgramParameter(r, 35721), c = 0;
          c < b;
          c++
        ) {
          var d = h.getActiveAttrib(r, c).name;
          a[d] = h.getAttribLocation(r, d);
        }
        N = a;
      }
      return N;
    };
    this.destroy = function() {
      h.deleteProgram(r);
      this.program = void 0;
    };
    this.name = e.name;
    this.id = uo++;
    this.code = c;
    this.usedTimes = 1;
    this.program = r;
    this.vertexShader = l;
    this.fragmentShader = m;
    this.numMultiviewViews = z;
    return this;
  }
  function vo(a, b, c) {
    function d(a, b) {
      if (a)
        a.isTexture
          ? (c = a.encoding)
          : a.isWebGLRenderTarget &&
            (console.warn(
              "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
            ),
            (c = a.texture.encoding));
      else var c = 3e3;
      3e3 === c && b && (c = 3007);
      return c;
    }
    var e = [],
      f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      },
      h = "precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(
        " "
      );
    this.getParameters = function(b, e, h, n, q, t, y) {
      var k = f[b.type];
      if (y.isSkinnedMesh) {
        var l = y.skeleton.bones;
        if (c.floatVertexTextures) l = 1024;
        else {
          var m = Math.min(
            Math.floor((c.maxVertexUniforms - 20) / 4),
            l.length
          );
          m < l.length
            ? (console.warn(
                "THREE.WebGLRenderer: Skeleton has " +
                  l.length +
                  " bones. This GPU supports " +
                  m +
                  "."
              ),
              (l = 0))
            : (l = m);
        }
      } else l = 0;
      m = c.precision;
      null !== b.precision &&
        ((m = c.getMaxPrecision(b.precision)),
        m !== b.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            b.precision,
            "not supported, using",
            m,
            "instead."
          ));
      var r = a.getRenderTarget();
      return {
        isWebGL2: c.isWebGL2,
        shaderID: k,
        precision: m,
        instancing: !0 === y.isInstancedMesh,
        supportsVertexTextures: c.vertexTextures,
        outputEncoding: d(r ? r.texture : null, a.gammaOutput),
        map: !!b.map,
        mapEncoding: d(b.map, a.gammaInput),
        matcap: !!b.matcap,
        matcapEncoding: d(b.matcap, a.gammaInput),
        envMap: !!b.envMap,
        envMapMode: b.envMap && b.envMap.mapping,
        envMapEncoding: d(b.envMap, a.gammaInput),
        envMapCubeUV:
          !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping),
        lightMap: !!b.lightMap,
        aoMap: !!b.aoMap,
        emissiveMap: !!b.emissiveMap,
        emissiveMapEncoding: d(b.emissiveMap, a.gammaInput),
        bumpMap: !!b.bumpMap,
        normalMap: !!b.normalMap,
        objectSpaceNormalMap: 1 === b.normalMapType,
        tangentSpaceNormalMap: 0 === b.normalMapType,
        clearcoatNormalMap: !!b.clearcoatNormalMap,
        displacementMap: !!b.displacementMap,
        roughnessMap: !!b.roughnessMap,
        metalnessMap: !!b.metalnessMap,
        specularMap: !!b.specularMap,
        alphaMap: !!b.alphaMap,
        gradientMap: !!b.gradientMap,
        sheen: !!b.sheen,
        combine: b.combine,
        vertexTangents: b.normalMap && b.vertexTangents,
        vertexColors: b.vertexColors,
        vertexUvs:
          !!b.map ||
          !!b.bumpMap ||
          !!b.normalMap ||
          !!b.specularMap ||
          !!b.alphaMap ||
          !!b.emissiveMap ||
          !!b.roughnessMap ||
          !!b.metalnessMap ||
          !!b.clearcoatNormalMap,
        fog: !!n,
        useFog: b.fog,
        fogExp2: n && n.isFogExp2,
        flatShading: b.flatShading,
        sizeAttenuation: b.sizeAttenuation,
        logarithmicDepthBuffer: c.logarithmicDepthBuffer,
        skinning: b.skinning && 0 < l,
        maxBones: l,
        useVertexTexture: c.floatVertexTextures,
        morphTargets: b.morphTargets,
        morphNormals: b.morphNormals,
        maxMorphTargets: a.maxMorphTargets,
        maxMorphNormals: a.maxMorphNormals,
        numDirLights: e.directional.length,
        numPointLights: e.point.length,
        numSpotLights: e.spot.length,
        numRectAreaLights: e.rectArea.length,
        numHemiLights: e.hemi.length,
        numDirLightShadows: e.directionalShadowMap.length,
        numPointLightShadows: e.pointShadowMap.length,
        numSpotLightShadows: e.spotShadowMap.length,
        numClippingPlanes: q,
        numClipIntersection: t,
        dithering: b.dithering,
        shadowMapEnabled: a.shadowMap.enabled && 0 < h.length,
        shadowMapType: a.shadowMap.type,
        toneMapping: b.toneMapped ? a.toneMapping : 0,
        physicallyCorrectLights: a.physicallyCorrectLights,
        premultipliedAlpha: b.premultipliedAlpha,
        alphaTest: b.alphaTest,
        doubleSided: 2 === b.side,
        flipSided: 1 === b.side,
        depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
      };
    };
    this.getProgramCode = function(b, c) {
      var d = [];
      c.shaderID
        ? d.push(c.shaderID)
        : (d.push(b.fragmentShader), d.push(b.vertexShader));
      if (void 0 !== b.defines)
        for (var e in b.defines) d.push(e), d.push(b.defines[e]);
      for (e = 0; e < h.length; e++) d.push(c[h[e]]);
      d.push(b.onBeforeCompile.toString());
      d.push(a.gammaOutput);
      d.push(a.gammaFactor);
      return d.join();
    };
    this.acquireProgram = function(c, d, f, h) {
      for (var k, l = 0, m = e.length; l < m; l++) {
        var n = e[l];
        if (n.code === h) {
          k = n;
          ++k.usedTimes;
          break;
        }
      }
      void 0 === k && ((k = new to(a, b, h, c, d, f)), e.push(k));
      return k;
    };
    this.releaseProgram = function(a) {
      if (0 === --a.usedTimes) {
        var b = e.indexOf(a);
        e[b] = e[e.length - 1];
        e.pop();
        a.destroy();
      }
    };
    this.programs = e;
  }
  function wo() {
    var a = new WeakMap();
    return {
      get: function(b) {
        var c = a.get(b);
        void 0 === c && ((c = {}), a.set(b, c));
        return c;
      },
      remove: function(b) {
        a.delete(b);
      },
      update: function(b, c, d) {
        a.get(b)[c] = d;
      },
      dispose: function() {
        a = new WeakMap();
      }
    };
  }
  function xo(a, b) {
    return a.groupOrder !== b.groupOrder
      ? a.groupOrder - b.groupOrder
      : a.renderOrder !== b.renderOrder
      ? a.renderOrder - b.renderOrder
      : a.program !== b.program
      ? a.program.id - b.program.id
      : a.material.id !== b.material.id
      ? a.material.id - b.material.id
      : a.z !== b.z
      ? a.z - b.z
      : a.id - b.id;
  }
  function yo(a, b) {
    return a.groupOrder !== b.groupOrder
      ? a.groupOrder - b.groupOrder
      : a.renderOrder !== b.renderOrder
      ? a.renderOrder - b.renderOrder
      : a.z !== b.z
      ? b.z - a.z
      : a.id - b.id;
  }
  function yl() {
    function a(a, d, e, m, n, q) {
      var h = b[c];
      void 0 === h
        ? ((h = {
            id: a.id,
            object: a,
            geometry: d,
            material: e,
            program: e.program || f,
            groupOrder: m,
            renderOrder: a.renderOrder,
            z: n,
            group: q
          }),
          (b[c] = h))
        : ((h.id = a.id),
          (h.object = a),
          (h.geometry = d),
          (h.material = e),
          (h.program = e.program || f),
          (h.groupOrder = m),
          (h.renderOrder = a.renderOrder),
          (h.z = n),
          (h.group = q));
      c++;
      return h;
    }
    var b = [],
      c = 0,
      d = [],
      e = [],
      f = { id: -1 };
    return {
      opaque: d,
      transparent: e,
      init: function() {
        c = 0;
        d.length = 0;
        e.length = 0;
      },
      push: function(b, c, f, m, n, q) {
        b = a(b, c, f, m, n, q);
        (!0 === f.transparent ? e : d).push(b);
      },
      unshift: function(b, c, f, m, n, q) {
        b = a(b, c, f, m, n, q);
        (!0 === f.transparent ? e : d).unshift(b);
      },
      sort: function() {
        1 < d.length && d.sort(xo);
        1 < e.length && e.sort(yo);
      }
    };
  }
  function zo() {
    function a(c) {
      c = c.target;
      c.removeEventListener("dispose", a);
      b.delete(c);
    }
    var b = new WeakMap();
    return {
      get: function(c, d) {
        var e = b.get(c);
        if (void 0 === e) {
          var f = new yl();
          b.set(c, new WeakMap());
          b.get(c).set(d, f);
          c.addEventListener("dispose", a);
        } else (f = e.get(d)), void 0 === f && ((f = new yl()), e.set(d, f));
        return f;
      },
      dispose: function() {
        b = new WeakMap();
      }
    };
  }
  function Ao() {
    var a = {};
    return {
      get: function(b) {
        if (void 0 !== a[b.id]) return a[b.id];
        switch (b.type) {
          case "DirectionalLight":
            var c = {
              direction: new r(),
              color: new L(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new E()
            };
            break;
          case "SpotLight":
            c = {
              position: new r(),
              direction: new r(),
              color: new L(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new E()
            };
            break;
          case "PointLight":
            c = {
              position: new r(),
              color: new L(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new E(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            c = { direction: new r(), skyColor: new L(), groundColor: new L() };
            break;
          case "RectAreaLight":
            c = {
              color: new L(),
              position: new r(),
              halfWidth: new r(),
              halfHeight: new r()
            };
        }
        return (a[b.id] = c);
      }
    };
  }
  function Bo(a, b) {
    return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
  }
  function Co() {
    for (
      var a = new Ao(),
        b = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          point: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        c = 0;
      9 > c;
      c++
    )
      b.probe.push(new r());
    var d = new r(),
      e = new fa(),
      f = new fa();
    return {
      setup: function(c, k, l) {
        for (var h = 0, n = 0, q = 0, t = 0; 9 > t; t++)
          b.probe[t].set(0, 0, 0);
        var y = (k = 0),
          u = 0,
          v = 0,
          r = 0,
          C = 0,
          z = 0,
          H = 0;
        l = l.matrixWorldInverse;
        c.sort(Bo);
        t = 0;
        for (var N = c.length; t < N; t++) {
          var B = c[t],
            M = B.color,
            xa = B.intensity,
            E = B.distance,
            Ra = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
          if (B.isAmbientLight)
            (h += M.r * xa), (n += M.g * xa), (q += M.b * xa);
          else if (B.isLightProbe)
            for (Ra = 0; 9 > Ra; Ra++)
              b.probe[Ra].addScaledVector(B.sh.coefficients[Ra], xa);
          else if (B.isDirectionalLight) {
            var J = a.get(B);
            J.color.copy(B.color).multiplyScalar(B.intensity);
            J.direction.setFromMatrixPosition(B.matrixWorld);
            d.setFromMatrixPosition(B.target.matrixWorld);
            J.direction.sub(d);
            J.direction.transformDirection(l);
            if ((J.shadow = B.castShadow))
              (xa = B.shadow),
                (J.shadowBias = xa.bias),
                (J.shadowRadius = xa.radius),
                (J.shadowMapSize = xa.mapSize),
                (b.directionalShadowMap[k] = Ra),
                (b.directionalShadowMatrix[k] = B.shadow.matrix),
                C++;
            b.directional[k] = J;
            k++;
          } else if (B.isSpotLight) {
            J = a.get(B);
            J.position.setFromMatrixPosition(B.matrixWorld);
            J.position.applyMatrix4(l);
            J.color.copy(M).multiplyScalar(xa);
            J.distance = E;
            J.direction.setFromMatrixPosition(B.matrixWorld);
            d.setFromMatrixPosition(B.target.matrixWorld);
            J.direction.sub(d);
            J.direction.transformDirection(l);
            J.coneCos = Math.cos(B.angle);
            J.penumbraCos = Math.cos(B.angle * (1 - B.penumbra));
            J.decay = B.decay;
            if ((J.shadow = B.castShadow))
              (xa = B.shadow),
                (J.shadowBias = xa.bias),
                (J.shadowRadius = xa.radius),
                (J.shadowMapSize = xa.mapSize),
                (b.spotShadowMap[u] = Ra),
                (b.spotShadowMatrix[u] = B.shadow.matrix),
                H++;
            b.spot[u] = J;
            u++;
          } else if (B.isRectAreaLight)
            (J = a.get(B)),
              J.color.copy(M).multiplyScalar(xa),
              J.position.setFromMatrixPosition(B.matrixWorld),
              J.position.applyMatrix4(l),
              f.identity(),
              e.copy(B.matrixWorld),
              e.premultiply(l),
              f.extractRotation(e),
              J.halfWidth.set(0.5 * B.width, 0, 0),
              J.halfHeight.set(0, 0.5 * B.height, 0),
              J.halfWidth.applyMatrix4(f),
              J.halfHeight.applyMatrix4(f),
              (b.rectArea[v] = J),
              v++;
          else if (B.isPointLight) {
            J = a.get(B);
            J.position.setFromMatrixPosition(B.matrixWorld);
            J.position.applyMatrix4(l);
            J.color.copy(B.color).multiplyScalar(B.intensity);
            J.distance = B.distance;
            J.decay = B.decay;
            if ((J.shadow = B.castShadow))
              (xa = B.shadow),
                (J.shadowBias = xa.bias),
                (J.shadowRadius = xa.radius),
                (J.shadowMapSize = xa.mapSize),
                (J.shadowCameraNear = xa.camera.near),
                (J.shadowCameraFar = xa.camera.far),
                (b.pointShadowMap[y] = Ra),
                (b.pointShadowMatrix[y] = B.shadow.matrix),
                z++;
            b.point[y] = J;
            y++;
          } else
            B.isHemisphereLight &&
              ((J = a.get(B)),
              J.direction.setFromMatrixPosition(B.matrixWorld),
              J.direction.transformDirection(l),
              J.direction.normalize(),
              J.skyColor.copy(B.color).multiplyScalar(xa),
              J.groundColor.copy(B.groundColor).multiplyScalar(xa),
              (b.hemi[r] = J),
              r++);
        }
        b.ambient[0] = h;
        b.ambient[1] = n;
        b.ambient[2] = q;
        c = b.hash;
        if (
          c.directionalLength !== k ||
          c.pointLength !== y ||
          c.spotLength !== u ||
          c.rectAreaLength !== v ||
          c.hemiLength !== r ||
          c.numDirectionalShadows !== C ||
          c.numPointShadows !== z ||
          c.numSpotShadows !== H
        )
          (b.directional.length = k),
            (b.spot.length = u),
            (b.rectArea.length = v),
            (b.point.length = y),
            (b.hemi.length = r),
            (b.directionalShadowMap.length = C),
            (b.pointShadowMap.length = z),
            (b.spotShadowMap.length = H),
            (b.directionalShadowMatrix.length = C),
            (b.pointShadowMatrix.length = z),
            (b.spotShadowMatrix.length = H),
            (c.directionalLength = k),
            (c.pointLength = y),
            (c.spotLength = u),
            (c.rectAreaLength = v),
            (c.hemiLength = r),
            (c.numDirectionalShadows = C),
            (c.numPointShadows = z),
            (c.numSpotShadows = H),
            (b.version = Do++);
      },
      state: b
    };
  }
  function zl() {
    var a = new Co(),
      b = [],
      c = [];
    return {
      init: function() {
        b.length = 0;
        c.length = 0;
      },
      state: { lightsArray: b, shadowsArray: c, lights: a },
      setupLights: function(d) {
        a.setup(b, c, d);
      },
      pushLight: function(a) {
        b.push(a);
      },
      pushShadow: function(a) {
        c.push(a);
      }
    };
  }
  function Eo() {
    function a(c) {
      c = c.target;
      c.removeEventListener("dispose", a);
      b.delete(c);
    }
    var b = new WeakMap();
    return {
      get: function(c, d) {
        if (!1 === b.has(c)) {
          var e = new zl();
          b.set(c, new WeakMap());
          b.get(c).set(d, e);
          c.addEventListener("dispose", a);
        } else
          !1 === b.get(c).has(d)
            ? ((e = new zl()), b.get(c).set(d, e))
            : (e = b.get(c).get(d));
        return e;
      },
      dispose: function() {
        b = new WeakMap();
      }
    };
  }
  function ld(a) {
    T.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = 3200;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.fog = !1;
    this.setValues(a);
  }
  function Te(a) {
    T.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new r();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = !1;
    this.setValues(a);
  }
  function Al(a, b, c) {
    function d(b, c, d, e, f, h) {
      var k = b.geometry;
      var l = m;
      var u = b.customDepthMaterial;
      d.isPointLight && ((l = n), (u = b.customDistanceMaterial));
      u
        ? (l = u)
        : ((u = !1),
          c.morphTargets &&
            (k && k.isBufferGeometry
              ? (u =
                  k.morphAttributes &&
                  k.morphAttributes.position &&
                  0 < k.morphAttributes.position.length)
              : k &&
                k.isGeometry &&
                (u = k.morphTargets && 0 < k.morphTargets.length)),
          b.isSkinnedMesh &&
            !1 === c.skinning &&
            console.warn(
              "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
              b
            ),
          (b = b.isSkinnedMesh && c.skinning),
          (k = 0),
          u && (k |= 1),
          b && (k |= 2),
          (l = l[k]));
      a.localClippingEnabled &&
        !0 === c.clipShadows &&
        0 !== c.clippingPlanes.length &&
        ((k = l.uuid),
        (u = c.uuid),
        (b = q[k]),
        void 0 === b && ((b = {}), (q[k] = b)),
        (k = b[u]),
        void 0 === k && ((k = l.clone()), (b[u] = k)),
        (l = k));
      l.visible = c.visible;
      l.wireframe = c.wireframe;
      l.side =
        3 === h
          ? null != c.shadowSide
            ? c.shadowSide
            : c.side
          : null != c.shadowSide
          ? c.shadowSide
          : t[c.side];
      l.clipShadows = c.clipShadows;
      l.clippingPlanes = c.clippingPlanes;
      l.clipIntersection = c.clipIntersection;
      l.wireframeLinewidth = c.wireframeLinewidth;
      l.linewidth = c.linewidth;
      d.isPointLight &&
        l.isMeshDistanceMaterial &&
        (l.referencePosition.setFromMatrixPosition(d.matrixWorld),
        (l.nearDistance = e),
        (l.farDistance = f));
      return l;
    }
    function e(c, h, k, l, m) {
      if (!1 !== c.visible) {
        if (
          c.layers.test(h.layers) &&
          (c.isMesh || c.isLine || c.isPoints) &&
          (c.castShadow || (c.receiveShadow && 3 === m)) &&
          (!c.frustumCulled || f.intersectsObject(c))
        ) {
          c.modelViewMatrix.multiplyMatrices(
            k.matrixWorldInverse,
            c.matrixWorld
          );
          var n = b.update(c),
            q = c.material;
          if (Array.isArray(q))
            for (var t = n.groups, u = 0, y = t.length; u < y; u++) {
              var v = t[u],
                r = q[v.materialIndex];
              r &&
                r.visible &&
                ((r = d(c, r, l, k.near, k.far, m)),
                a.renderBufferDirect(k, null, n, r, c, v));
            }
          else
            q.visible &&
              ((r = d(c, q, l, k.near, k.far, m)),
              a.renderBufferDirect(k, null, n, r, c, null));
        }
        c = c.children;
        n = 0;
        for (q = c.length; n < q; n++) e(c[n], h, k, l, m);
      }
    }
    var f = new Fg(),
      h = new E(),
      k = new E(),
      l = new Ca(),
      m = Array(4),
      n = Array(4),
      q = {},
      t = { 0: 1, 1: 0, 2: 2 },
      y = new Pa({
        defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 0.125 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new E() },
          radius: { value: 4 }
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}"
      }),
      u = y.clone();
    u.defines.HORIZONAL_PASS = 1;
    var v = new F();
    v.addAttribute(
      "position",
      new ba(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    var r = new oa(v, y);
    for (v = 0; 4 !== v; ++v) {
      var C = 0 !== (v & 1),
        z = 0 !== (v & 2),
        H = new ld({ depthPacking: 3201, morphTargets: C, skinning: z });
      m[v] = H;
      C = new Te({ morphTargets: C, skinning: z });
      n[v] = C;
    }
    var N = this;
    this.enabled = !1;
    this.autoUpdate = !0;
    this.needsUpdate = !1;
    this.type = 1;
    this.render = function(d, m, n) {
      if (
        !1 !== N.enabled &&
        (!1 !== N.autoUpdate || !1 !== N.needsUpdate) &&
        0 !== d.length
      ) {
        var q = a.getRenderTarget(),
          t = a.getActiveCubeFace(),
          v = a.getActiveMipmapLevel(),
          A = a.state;
        A.setBlending(0);
        A.buffers.color.setClear(1, 1, 1, 1);
        A.buffers.depth.setTest(!0);
        A.setScissorTest(!1);
        for (var z = 0, B = d.length; z < B; z++) {
          var H = d[z],
            na = H.shadow;
          if (void 0 === na)
            console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
          else {
            h.copy(na.mapSize);
            var wa = na.getFrameExtents();
            h.multiply(wa);
            k.copy(na.mapSize);
            if (h.x > c || h.y > c)
              console.warn(
                "THREE.WebGLShadowMap:",
                H,
                "has shadow exceeding max texture size, reducing"
              ),
                h.x > c &&
                  ((k.x = Math.floor(c / wa.x)),
                  (h.x = k.x * wa.x),
                  (na.mapSize.x = k.x)),
                h.y > c &&
                  ((k.y = Math.floor(c / wa.y)),
                  (h.y = k.y * wa.y),
                  (na.mapSize.y = k.y));
            null !== na.map ||
              na.isPointLightShadow ||
              3 !== this.type ||
              ((wa = { minFilter: 1006, magFilter: 1006, format: 1023 }),
              (na.map = new Za(h.x, h.y, wa)),
              (na.map.texture.name = H.name + ".shadowMap"),
              (na.mapPass = new Za(h.x, h.y, wa)),
              na.camera.updateProjectionMatrix());
            null === na.map &&
              ((wa = { minFilter: 1003, magFilter: 1003, format: 1023 }),
              (na.map = new Za(h.x, h.y, wa)),
              (na.map.texture.name = H.name + ".shadowMap"),
              na.camera.updateProjectionMatrix());
            a.setRenderTarget(na.map);
            a.clear();
            wa = na.getViewportCount();
            for (var C = 0; C < wa; C++) {
              var M = na.getViewport(C);
              l.set(k.x * M.x, k.y * M.y, k.x * M.z, k.y * M.w);
              A.viewport(l);
              na.updateMatrices(H, n, C);
              f = na.getFrustum();
              e(m, n, na.camera, H, this.type);
            }
            na.isPointLightShadow ||
              3 !== this.type ||
              ((H = na),
              (na = n),
              (wa = b.update(r)),
              (y.uniforms.shadow_pass.value = H.map.texture),
              (y.uniforms.resolution.value = H.mapSize),
              (y.uniforms.radius.value = H.radius),
              a.setRenderTarget(H.mapPass),
              a.clear(),
              a.renderBufferDirect(na, null, wa, y, r, null),
              (u.uniforms.shadow_pass.value = H.mapPass.texture),
              (u.uniforms.resolution.value = H.mapSize),
              (u.uniforms.radius.value = H.radius),
              a.setRenderTarget(H.map),
              a.clear(),
              a.renderBufferDirect(na, null, wa, u, r, null));
          }
        }
        N.needsUpdate = !1;
        a.setRenderTarget(q, t, v);
      }
    };
  }
  function Fo(a, b, c, d) {
    function e(b, c, d) {
      var e = new Uint8Array(4),
        f = a.createTexture();
      a.bindTexture(b, f);
      a.texParameteri(b, 10241, 9728);
      a.texParameteri(b, 10240, 9728);
      for (b = 0; b < d; b++)
        a.texImage2D(c + b, 0, 6408, 1, 1, 0, 6408, 5121, e);
      return f;
    }
    function f(c, e) {
      C[c] = 1;
      0 === z[c] && (a.enableVertexAttribArray(c), (z[c] = 1));
      H[c] !== e &&
        ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[
          d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](c, e),
        (H[c] = e));
    }
    function h(b) {
      !0 !== N[b] && (a.enable(b), (N[b] = !0));
    }
    function k(b) {
      !1 !== N[b] && (a.disable(b), (N[b] = !1));
    }
    function l(b, d, e, f, l, m, n, q) {
      if (0 === b) E && (k(3042), (E = !1));
      else if ((E || (h(3042), (E = !0)), 5 !== b)) {
        if (b !== O || q !== na) {
          if (100 !== Ra || 100 !== Qf) a.blendEquation(32774), (Qf = Ra = 100);
          if (q)
            switch (b) {
              case 1:
                a.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                a.blendFunc(1, 1);
                break;
              case 3:
                a.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                a.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", b);
            }
          else
            switch (b) {
              case 1:
                a.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                a.blendFunc(770, 1);
                break;
              case 3:
                a.blendFunc(0, 769);
                break;
              case 4:
                a.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", b);
            }
          D = ib = va = J = null;
          O = b;
          na = q;
        }
      } else {
        l = l || d;
        m = m || e;
        n = n || f;
        if (d !== Ra || l !== Qf)
          a.blendEquationSeparate(c.convert(d), c.convert(l)),
            (Ra = d),
            (Qf = l);
        if (e !== J || f !== va || m !== ib || n !== D)
          a.blendFuncSeparate(
            c.convert(e),
            c.convert(f),
            c.convert(m),
            c.convert(n)
          ),
            (J = e),
            (va = f),
            (ib = m),
            (D = n);
        O = b;
        na = null;
      }
    }
    function m(b) {
      wa !== b && (b ? a.frontFace(2304) : a.frontFace(2305), (wa = b));
    }
    function n(b) {
      0 !== b
        ? (h(2884),
          b !== Hk &&
            (1 === b
              ? a.cullFace(1029)
              : 2 === b
              ? a.cullFace(1028)
              : a.cullFace(1032)))
        : k(2884);
      Hk = b;
    }
    function q(b, c, d) {
      if (b) {
        if ((h(32823), Ea !== c || Kg !== d))
          a.polygonOffset(c, d), (Ea = c), (Kg = d);
      } else k(32823);
    }
    function t(b) {
      void 0 === b && (b = 33984 + P - 1);
      L !== b && (a.activeTexture(b), (L = b));
    }
    var y = new (function() {
        var b = !1,
          c = new Ca(),
          d = null,
          e = new Ca(0, 0, 0, 0);
        return {
          setMask: function(c) {
            d === c || b || (a.colorMask(c, c, c, c), (d = c));
          },
          setLocked: function(a) {
            b = a;
          },
          setClear: function(b, d, f, h, k) {
            !0 === k && ((b *= h), (d *= h), (f *= h));
            c.set(b, d, f, h);
            !1 === e.equals(c) && (a.clearColor(b, d, f, h), e.copy(c));
          },
          reset: function() {
            b = !1;
            d = null;
            e.set(-1, 0, 0, 0);
          }
        };
      })(),
      u = new (function() {
        var b = !1,
          c = null,
          d = null,
          e = null;
        return {
          setTest: function(a) {
            a ? h(2929) : k(2929);
          },
          setMask: function(d) {
            c === d || b || (a.depthMask(d), (c = d));
          },
          setFunc: function(b) {
            if (d !== b) {
              if (b)
                switch (b) {
                  case 0:
                    a.depthFunc(512);
                    break;
                  case 1:
                    a.depthFunc(519);
                    break;
                  case 2:
                    a.depthFunc(513);
                    break;
                  case 3:
                    a.depthFunc(515);
                    break;
                  case 4:
                    a.depthFunc(514);
                    break;
                  case 5:
                    a.depthFunc(518);
                    break;
                  case 6:
                    a.depthFunc(516);
                    break;
                  case 7:
                    a.depthFunc(517);
                    break;
                  default:
                    a.depthFunc(515);
                }
              else a.depthFunc(515);
              d = b;
            }
          },
          setLocked: function(a) {
            b = a;
          },
          setClear: function(b) {
            e !== b && (a.clearDepth(b), (e = b));
          },
          reset: function() {
            b = !1;
            e = d = c = null;
          }
        };
      })(),
      v = new (function() {
        var b = !1,
          c = null,
          d = null,
          e = null,
          f = null,
          l = null,
          m = null,
          n = null,
          q = null;
        return {
          setTest: function(a) {
            b || (a ? h(2960) : k(2960));
          },
          setMask: function(d) {
            c === d || b || (a.stencilMask(d), (c = d));
          },
          setFunc: function(b, c, h) {
            if (d !== b || e !== c || f !== h)
              a.stencilFunc(b, c, h), (d = b), (e = c), (f = h);
          },
          setOp: function(b, c, d) {
            if (l !== b || m !== c || n !== d)
              a.stencilOp(b, c, d), (l = b), (m = c), (n = d);
          },
          setLocked: function(a) {
            b = a;
          },
          setClear: function(b) {
            q !== b && (a.clearStencil(b), (q = b));
          },
          reset: function() {
            b = !1;
            q = n = m = l = f = e = d = c = null;
          }
        };
      })(),
      r = a.getParameter(34921),
      C = new Uint8Array(r),
      z = new Uint8Array(r),
      H = new Uint8Array(r),
      N = {},
      B = null,
      M = null,
      E = null,
      O = null,
      Ra = null,
      J = null,
      va = null,
      Qf = null,
      ib = null,
      D = null,
      na = !1,
      wa = null,
      Hk = null,
      Bl = null,
      Ea = null,
      Kg = null,
      P = a.getParameter(35661),
      F = !1;
    r = 0;
    r = a.getParameter(7938);
    -1 !== r.indexOf("WebGL")
      ? ((r = parseFloat(/^WebGL ([0-9])/.exec(r)[1])), (F = 1 <= r))
      : -1 !== r.indexOf("OpenGL ES") &&
        ((r = parseFloat(/^OpenGL ES ([0-9])/.exec(r)[1])), (F = 2 <= r));
    var L = null,
      I = {},
      S = new Ca(),
      V = new Ca(),
      X = {};
    X[3553] = e(3553, 3553, 1);
    X[34067] = e(34067, 34069, 6);
    y.setClear(0, 0, 0, 1);
    u.setClear(1);
    v.setClear(0);
    h(2929);
    u.setFunc(3);
    m(!1);
    n(1);
    h(2884);
    l(0);
    return {
      buffers: { color: y, depth: u, stencil: v },
      initAttributes: function() {
        for (var a = 0, b = C.length; a < b; a++) C[a] = 0;
      },
      enableAttribute: function(a) {
        f(a, 0);
      },
      enableAttributeAndDivisor: f,
      disableUnusedAttributes: function() {
        for (var b = 0, c = z.length; b !== c; ++b)
          z[b] !== C[b] && (a.disableVertexAttribArray(b), (z[b] = 0));
      },
      enable: h,
      disable: k,
      getCompressedTextureFormats: function() {
        if (
          null === B &&
          ((B = []),
          b.get("WEBGL_compressed_texture_pvrtc") ||
            b.get("WEBGL_compressed_texture_s3tc") ||
            b.get("WEBGL_compressed_texture_etc1") ||
            b.get("WEBGL_compressed_texture_astc"))
        )
          for (var c = a.getParameter(34467), d = 0; d < c.length; d++)
            B.push(c[d]);
        return B;
      },
      useProgram: function(b) {
        return M !== b ? (a.useProgram(b), (M = b), !0) : !1;
      },
      setBlending: l,
      setMaterial: function(a, b) {
        2 === a.side ? k(2884) : h(2884);
        var c = 1 === a.side;
        b && (c = !c);
        m(c);
        1 === a.blending && !1 === a.transparent
          ? l(0)
          : l(
              a.blending,
              a.blendEquation,
              a.blendSrc,
              a.blendDst,
              a.blendEquationAlpha,
              a.blendSrcAlpha,
              a.blendDstAlpha,
              a.premultipliedAlpha
            );
        u.setFunc(a.depthFunc);
        u.setTest(a.depthTest);
        u.setMask(a.depthWrite);
        y.setMask(a.colorWrite);
        b = a.stencilWrite;
        v.setTest(b);
        b &&
          (v.setMask(a.stencilWriteMask),
          v.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask),
          v.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass));
        q(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
      },
      setFlipSided: m,
      setCullFace: n,
      setLineWidth: function(b) {
        b !== Bl && (F && a.lineWidth(b), (Bl = b));
      },
      setPolygonOffset: q,
      setScissorTest: function(a) {
        a ? h(3089) : k(3089);
      },
      activeTexture: t,
      bindTexture: function(b, c) {
        null === L && t();
        var d = I[L];
        void 0 === d && ((d = { type: void 0, texture: void 0 }), (I[L] = d));
        if (d.type !== b || d.texture !== c)
          a.bindTexture(b, c || X[b]), (d.type = b), (d.texture = c);
      },
      compressedTexImage2D: function() {
        try {
          a.compressedTexImage2D.apply(a, arguments);
        } catch (ma) {
          console.error("THREE.WebGLState:", ma);
        }
      },
      texImage2D: function() {
        try {
          a.texImage2D.apply(a, arguments);
        } catch (ma) {
          console.error("THREE.WebGLState:", ma);
        }
      },
      texImage3D: function() {
        try {
          a.texImage3D.apply(a, arguments);
        } catch (ma) {
          console.error("THREE.WebGLState:", ma);
        }
      },
      scissor: function(b) {
        !1 === S.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), S.copy(b));
      },
      viewport: function(b) {
        !1 === V.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), V.copy(b));
      },
      reset: function() {
        for (var b = 0; b < z.length; b++)
          1 === z[b] && (a.disableVertexAttribArray(b), (z[b] = 0));
        N = {};
        L = B = null;
        I = {};
        Hk = wa = O = M = null;
        y.reset();
        u.reset();
        v.reset();
      }
    };
  }
  function Go(a, b, c, d, e, f, h) {
    function k(a, b) {
      return va
        ? new OffscreenCanvas(a, b)
        : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function l(a, b, c, d) {
      var e = 1;
      if (a.width > d || a.height > d) e = d / Math.max(a.width, a.height);
      if (1 > e || !0 === b) {
        if (
          ("undefined" !== typeof HTMLImageElement &&
            a instanceof HTMLImageElement) ||
          ("undefined" !== typeof HTMLCanvasElement &&
            a instanceof HTMLCanvasElement) ||
          ("undefined" !== typeof ImageBitmap && a instanceof ImageBitmap)
        )
          return (
            (d = b ? ca.floorPowerOfTwo : Math.floor),
            (b = d(e * a.width)),
            (e = d(e * a.height)),
            void 0 === J && (J = k(b, e)),
            (c = c ? k(b, e) : J),
            (c.width = b),
            (c.height = e),
            c.getContext("2d").drawImage(a, 0, 0, b, e),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                a.width +
                "x" +
                a.height +
                ") to (" +
                b +
                "x" +
                e +
                ")."
            ),
            c
          );
        "data" in a &&
          console.warn(
            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
              a.width +
              "x" +
              a.height +
              ")."
          );
      }
      return a;
    }
    function m(a) {
      return ca.isPowerOfTwo(a.width) && ca.isPowerOfTwo(a.height);
    }
    function n(a, b) {
      return (
        a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter
      );
    }
    function q(b, c, e, f) {
      a.generateMipmap(b);
      d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E;
    }
    function t(a, c) {
      if (!e.isWebGL2) return a;
      var d = a;
      6403 === a &&
        (5126 === c && (d = 33326),
        5131 === c && (d = 33325),
        5121 === c && (d = 33321));
      6407 === a &&
        (5126 === c && (d = 34837),
        5131 === c && (d = 34843),
        5121 === c && (d = 32849));
      6408 === a &&
        (5126 === c && (d = 34836),
        5131 === c && (d = 34842),
        5121 === c && (d = 32856));
      33325 === d || 33326 === d || 34842 === d || 34836 === d
        ? b.get("EXT_color_buffer_float")
        : (34843 === d || 34837 === d) &&
          console.warn(
            "THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."
          );
      return d;
    }
    function y(a) {
      return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729;
    }
    function u(b) {
      b = b.target;
      b.removeEventListener("dispose", u);
      var c = d.get(b);
      void 0 !== c.__webglInit &&
        (a.deleteTexture(c.__webglTexture), d.remove(b));
      b.isVideoTexture && Ra.delete(b);
      h.memory.textures--;
    }
    function v(b) {
      b = b.target;
      b.removeEventListener("dispose", v);
      var c = d.get(b),
        e = d.get(b.texture);
      if (b) {
        void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
        b.depthTexture && b.depthTexture.dispose();
        if (b.isWebGLRenderTargetCube)
          for (e = 0; 6 > e; e++)
            a.deleteFramebuffer(c.__webglFramebuffer[e]),
              c.__webglDepthbuffer &&
                a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
        else
          a.deleteFramebuffer(c.__webglFramebuffer),
            c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
        if (b.isWebGLMultiviewRenderTarget) {
          a.deleteTexture(c.__webglColorTexture);
          a.deleteTexture(c.__webglDepthStencilTexture);
          h.memory.textures -= 2;
          e = 0;
          for (var f = c.__webglViewFramebuffers.length; e < f; e++)
            a.deleteFramebuffer(c.__webglViewFramebuffers[e]);
        }
        d.remove(b.texture);
        d.remove(b);
      }
      h.memory.textures--;
    }
    function r(a, b) {
      var e = d.get(a);
      if (a.isVideoTexture) {
        var f = h.render.frame;
        Ra.get(a) !== f && (Ra.set(a, f), a.update());
      }
      if (0 < a.version && e.__version !== a.version)
        if (((f = a.image), void 0 === f))
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else if (!1 === f.complete)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          B(e, a, b);
          return;
        }
      c.activeTexture(33984 + b);
      c.bindTexture(3553, e.__webglTexture);
    }
    function C(b, h) {
      if (6 === b.image.length) {
        var k = d.get(b);
        if (0 < b.version && k.__version !== b.version) {
          N(k, b);
          c.activeTexture(33984 + h);
          c.bindTexture(34067, k.__webglTexture);
          a.pixelStorei(37440, b.flipY);
          var u = b && b.isCompressedTexture;
          h = b.image[0] && b.image[0].isDataTexture;
          for (var y = [], v = 0; 6 > v; v++)
            y[v] =
              u || h
                ? h
                  ? b.image[v].image
                  : b.image[v]
                : l(b.image[v], !1, !0, e.maxCubemapSize);
          var r = y[0],
            A = m(r) || e.isWebGL2,
            z = f.convert(b.format),
            B = f.convert(b.type),
            C = t(z, B);
          H(34067, b, A);
          if (u) {
            for (v = 0; 6 > v; v++) {
              var na = y[v].mipmaps;
              for (u = 0; u < na.length; u++) {
                var wa = na[u];
                1023 !== b.format && 1022 !== b.format
                  ? -1 < c.getCompressedTextureFormats().indexOf(z)
                    ? c.compressedTexImage2D(
                        34069 + v,
                        u,
                        C,
                        wa.width,
                        wa.height,
                        0,
                        wa.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : c.texImage2D(
                      34069 + v,
                      u,
                      C,
                      wa.width,
                      wa.height,
                      0,
                      z,
                      B,
                      wa.data
                    );
              }
            }
            k.__maxMipLevel = na.length - 1;
          } else {
            na = b.mipmaps;
            for (v = 0; 6 > v; v++)
              if (h)
                for (
                  c.texImage2D(
                    34069 + v,
                    0,
                    C,
                    y[v].width,
                    y[v].height,
                    0,
                    z,
                    B,
                    y[v].data
                  ),
                    u = 0;
                  u < na.length;
                  u++
                )
                  (wa = na[u]),
                    (wa = wa.image[v].image),
                    c.texImage2D(
                      34069 + v,
                      u + 1,
                      C,
                      wa.width,
                      wa.height,
                      0,
                      z,
                      B,
                      wa.data
                    );
              else
                for (
                  c.texImage2D(34069 + v, 0, C, z, B, y[v]), u = 0;
                  u < na.length;
                  u++
                )
                  (wa = na[u]),
                    c.texImage2D(34069 + v, u + 1, C, z, B, wa.image[v]);
            k.__maxMipLevel = na.length;
          }
          n(b, A) && q(34067, b, r.width, r.height);
          k.__version = b.version;
          if (b.onUpdate) b.onUpdate(b);
        } else
          c.activeTexture(33984 + h), c.bindTexture(34067, k.__webglTexture);
      }
    }
    function z(a, b) {
      c.activeTexture(33984 + b);
      c.bindTexture(34067, d.get(a).__webglTexture);
    }
    function H(c, h, k) {
      k
        ? (a.texParameteri(c, 10242, f.convert(h.wrapS)),
          a.texParameteri(c, 10243, f.convert(h.wrapT)),
          (32879 !== c && 35866 !== c) ||
            a.texParameteri(c, 32882, f.convert(h.wrapR)),
          a.texParameteri(c, 10240, f.convert(h.magFilter)),
          a.texParameteri(c, 10241, f.convert(h.minFilter)))
        : (a.texParameteri(c, 10242, 33071),
          a.texParameteri(c, 10243, 33071),
          (32879 !== c && 35866 !== c) || a.texParameteri(c, 32882, 33071),
          (1001 === h.wrapS && 1001 === h.wrapT) ||
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          a.texParameteri(c, 10240, y(h.magFilter)),
          a.texParameteri(c, 10241, y(h.minFilter)),
          1003 !== h.minFilter &&
            1006 !== h.minFilter &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            ));
      !(k = b.get("EXT_texture_filter_anisotropic")) ||
        (1015 === h.type && null === b.get("OES_texture_float_linear")) ||
        (1016 === h.type &&
          null === (e.isWebGL2 || b.get("OES_texture_half_float_linear"))) ||
        !(1 < h.anisotropy || d.get(h).__currentAnisotropy) ||
        (a.texParameterf(
          c,
          k.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(h.anisotropy, e.getMaxAnisotropy())
        ),
        (d.get(h).__currentAnisotropy = h.anisotropy));
    }
    function N(b, c) {
      void 0 === b.__webglInit &&
        ((b.__webglInit = !0),
        c.addEventListener("dispose", u),
        (b.__webglTexture = a.createTexture()),
        h.memory.textures++);
    }
    function B(b, d, h) {
      var k = 3553;
      d.isDataTexture2DArray && (k = 35866);
      d.isDataTexture3D && (k = 32879);
      N(b, d);
      c.activeTexture(33984 + h);
      c.bindTexture(k, b.__webglTexture);
      a.pixelStorei(37440, d.flipY);
      a.pixelStorei(37441, d.premultiplyAlpha);
      a.pixelStorei(3317, d.unpackAlignment);
      h = e.isWebGL2
        ? !1
        : 1001 !== d.wrapS ||
          1001 !== d.wrapT ||
          (1003 !== d.minFilter && 1006 !== d.minFilter);
      h = h && !1 === m(d.image);
      h = l(d.image, h, !1, e.maxTextureSize);
      var u = m(h) || e.isWebGL2,
        v = f.convert(d.format),
        y = f.convert(d.type),
        r = t(v, y);
      H(k, d, u);
      var A = d.mipmaps;
      if (d.isDepthTexture) {
        r = 6402;
        if (1015 === d.type) {
          if (!e.isWebGL2)
            throw Error("Float Depth Texture only supported in WebGL2.0");
          r = 36012;
        } else e.isWebGL2 && (r = 33189);
        1026 === d.format &&
          6402 === r &&
          1012 !== d.type &&
          1014 !== d.type &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
          ),
          (d.type = 1012),
          (y = f.convert(d.type)));
        1027 === d.format &&
          ((r = 34041),
          1020 !== d.type &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
            ),
            (d.type = 1020),
            (y = f.convert(d.type))));
        c.texImage2D(3553, 0, r, h.width, h.height, 0, v, y, null);
      } else if (d.isDataTexture)
        if (0 < A.length && u) {
          for (var z = 0, B = A.length; z < B; z++)
            (k = A[z]),
              c.texImage2D(3553, z, r, k.width, k.height, 0, v, y, k.data);
          d.generateMipmaps = !1;
          b.__maxMipLevel = A.length - 1;
        } else
          c.texImage2D(3553, 0, r, h.width, h.height, 0, v, y, h.data),
            (b.__maxMipLevel = 0);
      else if (d.isCompressedTexture) {
        z = 0;
        for (B = A.length; z < B; z++)
          (k = A[z]),
            1023 !== d.format && 1022 !== d.format
              ? -1 < c.getCompressedTextureFormats().indexOf(v)
                ? c.compressedTexImage2D(
                    3553,
                    z,
                    r,
                    k.width,
                    k.height,
                    0,
                    k.data
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                  )
              : c.texImage2D(3553, z, r, k.width, k.height, 0, v, y, k.data);
        b.__maxMipLevel = A.length - 1;
      } else if (d.isDataTexture2DArray)
        c.texImage3D(35866, 0, r, h.width, h.height, h.depth, 0, v, y, h.data),
          (b.__maxMipLevel = 0);
      else if (d.isDataTexture3D)
        c.texImage3D(32879, 0, r, h.width, h.height, h.depth, 0, v, y, h.data),
          (b.__maxMipLevel = 0);
      else if (0 < A.length && u) {
        z = 0;
        for (B = A.length; z < B; z++)
          (k = A[z]), c.texImage2D(3553, z, r, v, y, k);
        d.generateMipmaps = !1;
        b.__maxMipLevel = A.length - 1;
      } else c.texImage2D(3553, 0, r, v, y, h), (b.__maxMipLevel = 0);
      n(d, u) && q(3553, d, h.width, h.height);
      b.__version = d.version;
      if (d.onUpdate) d.onUpdate(d);
    }
    function M(b, e, h, k) {
      var l = f.convert(e.texture.format),
        m = f.convert(e.texture.type),
        n = t(l, m);
      c.texImage2D(k, 0, n, e.width, e.height, 0, l, m, null);
      a.bindFramebuffer(36160, b);
      a.framebufferTexture2D(36160, h, k, d.get(e.texture).__webglTexture, 0);
      a.bindFramebuffer(36160, null);
    }
    function E(b, c, d) {
      a.bindRenderbuffer(36161, b);
      if (c.depthBuffer && !c.stencilBuffer)
        d
          ? ((d = O(c)),
            a.renderbufferStorageMultisample(
              36161,
              d,
              33189,
              c.width,
              c.height
            ))
          : a.renderbufferStorage(36161, 33189, c.width, c.height),
          a.framebufferRenderbuffer(36160, 36096, 36161, b);
      else if (c.depthBuffer && c.stencilBuffer)
        d
          ? ((d = O(c)),
            a.renderbufferStorageMultisample(
              36161,
              d,
              35056,
              c.width,
              c.height
            ))
          : a.renderbufferStorage(36161, 34041, c.width, c.height),
          a.framebufferRenderbuffer(36160, 33306, 36161, b);
      else {
        b = f.convert(c.texture.format);
        var e = f.convert(c.texture.type);
        b = t(b, e);
        d
          ? ((d = O(c)),
            a.renderbufferStorageMultisample(36161, d, b, c.width, c.height))
          : a.renderbufferStorage(36161, b, c.width, c.height);
      }
      a.bindRenderbuffer(36161, null);
    }
    function O(a) {
      return e.isWebGL2 && a.isWebGLMultisampleRenderTarget
        ? Math.min(e.maxSamples, a.samples)
        : 0;
    }
    var Ra = new WeakMap(),
      J,
      va =
        "undefined" !== typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d"),
      Qf = 0,
      ib = !1,
      D = !1;
    this.allocateTextureUnit = function() {
      var a = Qf;
      a >= e.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            a +
            " texture units while this GPU supports only " +
            e.maxTextures
        );
      Qf += 1;
      return a;
    };
    this.resetTextureUnits = function() {
      Qf = 0;
    };
    this.setTexture2D = r;
    this.setTexture2DArray = function(a, b) {
      var e = d.get(a);
      0 < a.version && e.__version !== a.version
        ? B(e, a, b)
        : (c.activeTexture(33984 + b), c.bindTexture(35866, e.__webglTexture));
    };
    this.setTexture3D = function(a, b) {
      var e = d.get(a);
      0 < a.version && e.__version !== a.version
        ? B(e, a, b)
        : (c.activeTexture(33984 + b), c.bindTexture(32879, e.__webglTexture));
    };
    this.setTextureCube = C;
    this.setTextureCubeDynamic = z;
    this.setupRenderTarget = function(k) {
      var l = d.get(k),
        u = d.get(k.texture);
      k.addEventListener("dispose", v);
      u.__webglTexture = a.createTexture();
      h.memory.textures++;
      var y = !0 === k.isWebGLRenderTargetCube,
        A = !0 === k.isWebGLMultisampleRenderTarget,
        z = !0 === k.isWebGLMultiviewRenderTarget,
        B = m(k) || e.isWebGL2;
      if (y) {
        l.__webglFramebuffer = [];
        for (var C = 0; 6 > C; C++)
          l.__webglFramebuffer[C] = a.createFramebuffer();
      } else if (((l.__webglFramebuffer = a.createFramebuffer()), A))
        if (e.isWebGL2) {
          l.__webglMultisampledFramebuffer = a.createFramebuffer();
          l.__webglColorRenderbuffer = a.createRenderbuffer();
          a.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
          A = f.convert(k.texture.format);
          var N = f.convert(k.texture.type);
          A = t(A, N);
          N = O(k);
          a.renderbufferStorageMultisample(36161, N, A, k.width, k.height);
          a.bindFramebuffer(36160, l.__webglMultisampledFramebuffer);
          a.framebufferRenderbuffer(
            36160,
            36064,
            36161,
            l.__webglColorRenderbuffer
          );
          a.bindRenderbuffer(36161, null);
          k.depthBuffer &&
            ((l.__webglDepthRenderbuffer = a.createRenderbuffer()),
            E(l.__webglDepthRenderbuffer, k, !0));
          a.bindFramebuffer(36160, null);
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
          );
      else if (z) {
        C = k.width;
        var J = k.height;
        A = k.numViews;
        a.bindFramebuffer(36160, l.__webglFramebuffer);
        var va = b.get("OVR_multiview2");
        h.memory.textures += 2;
        N = a.createTexture();
        a.bindTexture(35866, N);
        a.texParameteri(35866, 10240, 9728);
        a.texParameteri(35866, 10241, 9728);
        a.texImage3D(35866, 0, 32856, C, J, A, 0, 6408, 5121, null);
        va.framebufferTextureMultiviewOVR(36160, 36064, N, 0, 0, A);
        var Ra = a.createTexture();
        a.bindTexture(35866, Ra);
        a.texParameteri(35866, 10240, 9728);
        a.texParameteri(35866, 10241, 9728);
        a.texImage3D(35866, 0, 35056, C, J, A, 0, 34041, 34042, null);
        va.framebufferTextureMultiviewOVR(36160, 33306, Ra, 0, 0, A);
        J = Array(A);
        for (C = 0; C < A; ++C)
          (J[C] = a.createFramebuffer()),
            a.bindFramebuffer(36160, J[C]),
            a.framebufferTextureLayer(36160, 36064, N, 0, C);
        l.__webglColorTexture = N;
        l.__webglDepthStencilTexture = Ra;
        l.__webglViewFramebuffers = J;
        a.bindFramebuffer(36160, null);
        a.bindTexture(35866, null);
      }
      if (y) {
        c.bindTexture(34067, u.__webglTexture);
        H(34067, k.texture, B);
        for (C = 0; 6 > C; C++) M(l.__webglFramebuffer[C], k, 36064, 34069 + C);
        n(k.texture, B) && q(34067, k.texture, k.width, k.height);
        c.bindTexture(34067, null);
      } else
        z ||
          (c.bindTexture(3553, u.__webglTexture),
          H(3553, k.texture, B),
          M(l.__webglFramebuffer, k, 36064, 3553),
          n(k.texture, B) && q(3553, k.texture, k.width, k.height),
          c.bindTexture(3553, null));
      if (k.depthBuffer) {
        l = d.get(k);
        u = !0 === k.isWebGLRenderTargetCube;
        if (k.depthTexture) {
          if (u)
            throw Error(
              "target.depthTexture not supported in Cube render targets"
            );
          if (k && k.isWebGLRenderTargetCube)
            throw Error(
              "Depth Texture with cube render targets is not supported"
            );
          a.bindFramebuffer(36160, l.__webglFramebuffer);
          if (!k.depthTexture || !k.depthTexture.isDepthTexture)
            throw Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (d.get(k.depthTexture).__webglTexture &&
            k.depthTexture.image.width === k.width &&
            k.depthTexture.image.height === k.height) ||
            ((k.depthTexture.image.width = k.width),
            (k.depthTexture.image.height = k.height),
            (k.depthTexture.needsUpdate = !0));
          r(k.depthTexture, 0);
          l = d.get(k.depthTexture).__webglTexture;
          if (1026 === k.depthTexture.format)
            a.framebufferTexture2D(36160, 36096, 3553, l, 0);
          else if (1027 === k.depthTexture.format)
            a.framebufferTexture2D(36160, 33306, 3553, l, 0);
          else throw Error("Unknown depthTexture format");
        } else if (u)
          for (l.__webglDepthbuffer = [], u = 0; 6 > u; u++)
            a.bindFramebuffer(36160, l.__webglFramebuffer[u]),
              (l.__webglDepthbuffer[u] = a.createRenderbuffer()),
              E(l.__webglDepthbuffer[u], k);
        else
          a.bindFramebuffer(36160, l.__webglFramebuffer),
            (l.__webglDepthbuffer = a.createRenderbuffer()),
            E(l.__webglDepthbuffer, k);
        a.bindFramebuffer(36160, null);
      }
    };
    this.updateRenderTargetMipmap = function(a) {
      var b = a.texture,
        f = m(a) || e.isWebGL2;
      if (n(b, f)) {
        f = a.isWebGLRenderTargetCube ? 34067 : 3553;
        var h = d.get(b).__webglTexture;
        c.bindTexture(f, h);
        q(f, b, a.width, a.height);
        c.bindTexture(f, null);
      }
    };
    this.updateMultisampleRenderTarget = function(b) {
      if (b.isWebGLMultisampleRenderTarget)
        if (e.isWebGL2) {
          var c = d.get(b);
          a.bindFramebuffer(36008, c.__webglMultisampledFramebuffer);
          a.bindFramebuffer(36009, c.__webglFramebuffer);
          c = b.width;
          var f = b.height,
            h = 16384;
          b.depthBuffer && (h |= 256);
          b.stencilBuffer && (h |= 1024);
          a.blitFramebuffer(0, 0, c, f, 0, 0, c, f, h, 9728);
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
          );
    };
    this.safeSetTexture2D = function(a, b) {
      a &&
        a.isWebGLRenderTarget &&
        (!1 === ib &&
          (console.warn(
            "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
          ),
          (ib = !0)),
        (a = a.texture));
      r(a, b);
    };
    this.safeSetTextureCube = function(a, b) {
      a &&
        a.isWebGLRenderTargetCube &&
        (!1 === D &&
          (console.warn(
            "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
          ),
          (D = !0)),
        (a = a.texture));
      (a && a.isCubeTexture) || (Array.isArray(a.image) && 6 === a.image.length)
        ? C(a, b)
        : z(a, b);
    };
  }
  function Ho(a, b, c) {
    return {
      convert: function(a) {
        if (1e3 === a) return 10497;
        if (1001 === a) return 33071;
        if (1002 === a) return 33648;
        if (1003 === a) return 9728;
        if (1004 === a) return 9984;
        if (1005 === a) return 9986;
        if (1006 === a) return 9729;
        if (1007 === a) return 9985;
        if (1008 === a) return 9987;
        if (1009 === a) return 5121;
        if (1017 === a) return 32819;
        if (1018 === a) return 32820;
        if (1019 === a) return 33635;
        if (1010 === a) return 5120;
        if (1011 === a) return 5122;
        if (1012 === a) return 5123;
        if (1013 === a) return 5124;
        if (1014 === a) return 5125;
        if (1015 === a) return 5126;
        if (1016 === a) {
          if (c.isWebGL2) return 5131;
          var d = b.get("OES_texture_half_float");
          if (null !== d) return d.HALF_FLOAT_OES;
        }
        if (1021 === a) return 6406;
        if (1022 === a) return 6407;
        if (1023 === a) return 6408;
        if (1024 === a) return 6409;
        if (1025 === a) return 6410;
        if (1026 === a) return 6402;
        if (1027 === a) return 34041;
        if (1028 === a) return 6403;
        if (100 === a) return 32774;
        if (101 === a) return 32778;
        if (102 === a) return 32779;
        if (200 === a) return 0;
        if (201 === a) return 1;
        if (202 === a) return 768;
        if (203 === a) return 769;
        if (204 === a) return 770;
        if (205 === a) return 771;
        if (206 === a) return 772;
        if (207 === a) return 773;
        if (208 === a) return 774;
        if (209 === a) return 775;
        if (210 === a) return 776;
        if (33776 === a || 33777 === a || 33778 === a || 33779 === a)
          if (((d = b.get("WEBGL_compressed_texture_s3tc")), null !== d)) {
            if (33776 === a) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === a) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === a) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === a) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (35840 === a || 35841 === a || 35842 === a || 35843 === a)
          if (((d = b.get("WEBGL_compressed_texture_pvrtc")), null !== d)) {
            if (35840 === a) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === a) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === a) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === a) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
        if (
          36196 === a &&
          ((d = b.get("WEBGL_compressed_texture_etc1")), null !== d)
        )
          return d.COMPRESSED_RGB_ETC1_WEBGL;
        if (
          37808 === a ||
          37809 === a ||
          37810 === a ||
          37811 === a ||
          37812 === a ||
          37813 === a ||
          37814 === a ||
          37815 === a ||
          37816 === a ||
          37817 === a ||
          37818 === a ||
          37819 === a ||
          37820 === a ||
          37821 === a
        )
          if (((d = b.get("WEBGL_compressed_texture_astc")), null !== d))
            return a;
        if (103 === a || 104 === a) {
          if (c.isWebGL2) {
            if (103 === a) return 32775;
            if (104 === a) return 32776;
          }
          d = b.get("EXT_blend_minmax");
          if (null !== d) {
            if (103 === a) return d.MIN_EXT;
            if (104 === a) return d.MAX_EXT;
          }
        }
        if (1020 === a) {
          if (c.isWebGL2) return 34042;
          d = b.get("WEBGL_depth_texture");
          if (null !== d) return d.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function Cj(a, b, c, d) {
    Za.call(this, a, b, d);
    this.stencilBuffer = this.depthBuffer = !1;
    this.numViews = c;
  }
  function Io(a, b) {
    function c(a) {
      if (a.isArrayCamera) return a.cameras;
      n[0] = a;
      return n;
    }
    function d(a) {
      if (void 0 === a.isArrayCamera) return !0;
      a = a.cameras;
      if (a.length > y) return !1;
      for (var b = 1, c = a.length; b < c; b++)
        if (
          a[0].viewport.z !== a[b].viewport.z ||
          a[0].viewport.w !== a[b].viewport.w
        )
          return !1;
      return !0;
    }
    var e = a.extensions,
      f = a.properties,
      h,
      k,
      l,
      m,
      n,
      q,
      t,
      y = 0;
    this.isAvailable = function() {
      if (void 0 === t) {
        var a = e.get("OVR_multiview2");
        if ((t = null !== a && !1 === b.getContextAttributes().antialias))
          for (
            y = b.getParameter(a.MAX_VIEWS_OVR),
              h = new Cj(0, 0, 2),
              q = new E(),
              m = [],
              l = [],
              n = [],
              a = 0;
            a < y;
            a++
          )
            (m[a] = new fa()), (l[a] = new Ya());
      }
      return t;
    };
    this.attachCamera = function(b) {
      if (!1 !== d(b)) {
        (k = a.getRenderTarget())
          ? q.set(k.width, k.height)
          : a.getDrawingBufferSize(q);
        if (b.isArrayCamera) {
          var c = b.cameras[0].viewport;
          h.setSize(c.z, c.w);
          h.setNumViews(b.cameras.length);
        } else h.setSize(q.x, q.y), h.setNumViews(2);
        a.setRenderTarget(h);
      }
    };
    this.detachCamera = function(c) {
      if (h === a.getRenderTarget()) {
        a.setRenderTarget(k);
        var d = h,
          e = d.numViews,
          l = f.get(d).__webglViewFramebuffers,
          m = d.width;
        d = d.height;
        if (c.isArrayCamera)
          for (var n = 0; n < e; n++) {
            var t = c.cameras[n].viewport,
              u = t.x,
              y = t.y,
              r = u + t.z;
            t = y + t.w;
            b.bindFramebuffer(36008, l[n]);
            b.blitFramebuffer(0, 0, m, d, u, y, r, t, 16384, 9728);
          }
        else
          b.bindFramebuffer(36008, l[0]),
            b.blitFramebuffer(0, 0, m, d, 0, 0, q.x, q.y, 16384, 9728);
      }
    };
    this.updateCameraProjectionMatricesUniform = function(a, d) {
      a = c(a);
      for (var e = 0; e < a.length; e++) m[e].copy(a[e].projectionMatrix);
      d.setValue(b, "projectionMatrices", m);
    };
    this.updateCameraViewMatricesUniform = function(a, d) {
      a = c(a);
      for (var e = 0; e < a.length; e++) m[e].copy(a[e].matrixWorldInverse);
      d.setValue(b, "viewMatrices", m);
    };
    this.updateObjectMatricesUniforms = function(a, d, e) {
      d = c(d);
      for (var f = 0; f < d.length; f++)
        m[f].multiplyMatrices(d[f].matrixWorldInverse, a.matrixWorld),
          l[f].getNormalMatrix(m[f]);
      e.setValue(b, "modelViewMatrices", m);
      e.setValue(b, "normalMatrices", l);
    };
  }
  function md() {
    D.call(this);
    this.type = "Group";
  }
  function Ue(a) {
    Ua.call(this);
    this.cameras = a || [];
  }
  function Cl(a, b, c) {
    Dl.setFromMatrixPosition(b.matrixWorld);
    El.setFromMatrixPosition(c.matrixWorld);
    var d = Dl.distanceTo(El),
      e = b.projectionMatrix.elements,
      f = c.projectionMatrix.elements,
      h = e[14] / (e[10] - 1);
    c = e[14] / (e[10] + 1);
    var k = (e[9] + 1) / e[5],
      l = (e[9] - 1) / e[5],
      m = (e[8] - 1) / e[0],
      n = (f[8] + 1) / f[0];
    e = h * m;
    f = h * n;
    n = d / (-m + n);
    m = n * -m;
    b.matrixWorld.decompose(a.position, a.quaternion, a.scale);
    a.translateX(m);
    a.translateZ(n);
    a.matrixWorld.compose(a.position, a.quaternion, a.scale);
    a.matrixWorldInverse.getInverse(a.matrixWorld);
    b = h + n;
    h = c + n;
    a.projectionMatrix.makePerspective(
      e - m,
      f + (d - m),
      ((k * c) / h) * b,
      ((l * c) / h) * b,
      b,
      h
    );
  }
  function ai(a) {
    function b() {
      return null !== k && !0 === k.isPresenting;
    }
    function c() {
      if (b()) {
        var c = k.getEyeParameters("left");
        e = 2 * c.renderWidth * y;
        f = c.renderHeight * y;
        M = a.getPixelRatio();
        a.getSize(B);
        a.setDrawingBufferSize(e, f, 1);
        z.viewport.set(0, 0, e / 2, f);
        H.viewport.set(e / 2, 0, e / 2, f);
        O.start();
        h.dispatchEvent({ type: "sessionstart" });
      } else h.enabled && a.setDrawingBufferSize(B.width, B.height, M), O.stop(), h.dispatchEvent({ type: "sessionend" });
    }
    function d(a, b) {
      null !== b &&
        4 === b.length &&
        a.set(b[0] * e, b[1] * f, b[2] * e, b[3] * f);
    }
    var e,
      f,
      h = this,
      k = null,
      l = null,
      m = null,
      n = [],
      q = new fa(),
      t = new fa(),
      y = 1,
      u = "local-floor";
    "undefined" !== typeof window &&
      "VRFrameData" in window &&
      ((l = new window.VRFrameData()),
      window.addEventListener("vrdisplaypresentchange", c, !1));
    var v = new fa(),
      A = new mb(),
      C = new r(),
      z = new Ua();
    z.viewport = new Ca();
    z.layers.enable(1);
    var H = new Ua();
    H.viewport = new Ca();
    H.layers.enable(2);
    var N = new Ue([z, H]);
    N.layers.enable(1);
    N.layers.enable(2);
    var B = new E(),
      M,
      xa = [];
    this.enabled = !1;
    this.getController = function(a) {
      var b = n[a];
      void 0 === b &&
        ((b = new md()),
        (b.matrixAutoUpdate = !1),
        (b.visible = !1),
        (n[a] = b));
      return b;
    };
    this.getDevice = function() {
      return k;
    };
    this.setDevice = function(a) {
      void 0 !== a && (k = a);
      O.setContext(a);
    };
    this.setFramebufferScaleFactor = function(a) {
      y = a;
    };
    this.setReferenceSpaceType = function(a) {
      u = a;
    };
    this.setPoseTarget = function(a) {
      void 0 !== a && (m = a);
    };
    this.getCamera = function(a) {
      var c = "local-floor" === u ? 1.6 : 0;
      if (!1 === b())
        return a.position.set(0, c, 0), a.rotation.set(0, 0, 0), a;
      k.depthNear = a.near;
      k.depthFar = a.far;
      k.getFrameData(l);
      if ("local-floor" === u) {
        var e = k.stageParameters;
        e
          ? q.fromArray(e.sittingToStandingTransform)
          : q.makeTranslation(0, c, 0);
      }
      c = l.pose;
      e = null !== m ? m : a;
      e.matrix.copy(q);
      e.matrix.decompose(e.position, e.quaternion, e.scale);
      null !== c.orientation &&
        (A.fromArray(c.orientation), e.quaternion.multiply(A));
      null !== c.position &&
        (A.setFromRotationMatrix(q),
        C.fromArray(c.position),
        C.applyQuaternion(A),
        e.position.add(C));
      e.updateMatrixWorld();
      z.near = a.near;
      H.near = a.near;
      z.far = a.far;
      H.far = a.far;
      z.matrixWorldInverse.fromArray(l.leftViewMatrix);
      H.matrixWorldInverse.fromArray(l.rightViewMatrix);
      t.getInverse(q);
      "local-floor" === u &&
        (z.matrixWorldInverse.multiply(t), H.matrixWorldInverse.multiply(t));
      a = e.parent;
      null !== a &&
        (v.getInverse(a.matrixWorld),
        z.matrixWorldInverse.multiply(v),
        H.matrixWorldInverse.multiply(v));
      z.matrixWorld.getInverse(z.matrixWorldInverse);
      H.matrixWorld.getInverse(H.matrixWorldInverse);
      z.projectionMatrix.fromArray(l.leftProjectionMatrix);
      H.projectionMatrix.fromArray(l.rightProjectionMatrix);
      Cl(N, z, H);
      a = k.getLayers();
      a.length &&
        ((a = a[0]), d(z.viewport, a.leftBounds), d(H.viewport, a.rightBounds));
      a: for (a = 0; a < n.length; a++) {
        c = n[a];
        b: {
          e = a;
          for (
            var f = navigator.getGamepads && navigator.getGamepads(),
              h = 0,
              y = 0,
              r = f.length;
            h < r;
            h++
          ) {
            var B = f[h];
            if (
              B &&
              ("Daydream Controller" === B.id ||
                "Gear VR Controller" === B.id ||
                "Oculus Go Controller" === B.id ||
                "OpenVR Gamepad" === B.id ||
                B.id.startsWith("Oculus Touch") ||
                B.id.startsWith("HTC Vive Focus") ||
                B.id.startsWith("Spatial Controller"))
            ) {
              if (y === e) {
                e = B;
                break b;
              }
              y++;
            }
          }
          e = void 0;
        }
        if (void 0 !== e && void 0 !== e.pose) {
          if (null === e.pose) break a;
          f = e.pose;
          !1 === f.hasPosition && c.position.set(0.2, -0.6, -0.05);
          null !== f.position && c.position.fromArray(f.position);
          null !== f.orientation && c.quaternion.fromArray(f.orientation);
          c.matrix.compose(c.position, c.quaternion, c.scale);
          c.matrix.premultiply(q);
          c.matrix.decompose(c.position, c.quaternion, c.scale);
          c.matrixWorldNeedsUpdate = !0;
          c.visible = !0;
          f = "Daydream Controller" === e.id ? 0 : 1;
          void 0 === xa[a] && (xa[a] = !1);
          xa[a] !== e.buttons[f].pressed &&
            ((xa[a] = e.buttons[f].pressed),
            !0 === xa[a]
              ? c.dispatchEvent({ type: "selectstart" })
              : (c.dispatchEvent({ type: "selectend" }),
                c.dispatchEvent({ type: "select" })));
        } else c.visible = !1;
      }
      return N;
    };
    this.getStandingMatrix = function() {
      return q;
    };
    this.isPresenting = b;
    var O = new Gg();
    this.setAnimationLoop = function(a) {
      O.setAnimationLoop(a);
      b() && O.start();
    };
    this.submitFrame = function() {
      b() && k.submitFrame();
    };
    this.dispose = function() {
      "undefined" !== typeof window &&
        window.removeEventListener("vrdisplaypresentchange", c);
    };
    this.setFrameOfReferenceType = function() {
      console.warn(
        "THREE.WebVRManager: setFrameOfReferenceType() has been deprecated."
      );
    };
  }
  function Fl(a, b) {
    function c() {
      return null !== l && null !== m;
    }
    function d(a) {
      for (var b = 0; b < t.length; b++)
        y[b] === a.inputSource && t[b].dispatchEvent({ type: a.type });
    }
    function e() {
      a.setFramebuffer(null);
      a.setRenderTarget(a.getRenderTarget());
      z.stop();
      k.dispatchEvent({ type: "sessionend" });
    }
    function f(a) {
      m = a;
      z.setContext(l);
      z.start();
      k.dispatchEvent({ type: "sessionstart" });
    }
    function h(a, b) {
      null === b
        ? a.matrixWorld.copy(a.matrix)
        : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix);
      a.matrixWorldInverse.getInverse(a.matrixWorld);
    }
    var k = this,
      l = null,
      m = null,
      n = "local-floor",
      q = null,
      t = [],
      y = [],
      u = new Ua();
    u.layers.enable(1);
    u.viewport = new Ca();
    var v = new Ua();
    v.layers.enable(2);
    v.viewport = new Ca();
    var r = new Ue([u, v]);
    r.layers.enable(1);
    r.layers.enable(2);
    this.enabled = !1;
    this.getController = function(a) {
      var b = t[a];
      void 0 === b &&
        ((b = new md()),
        (b.matrixAutoUpdate = !1),
        (b.visible = !1),
        (t[a] = b));
      return b;
    };
    this.setFramebufferScaleFactor = function() {};
    this.setReferenceSpaceType = function(a) {
      n = a;
    };
    this.getSession = function() {
      return l;
    };
    this.setSession = function(a) {
      l = a;
      null !== l &&
        (l.addEventListener("select", d),
        l.addEventListener("selectstart", d),
        l.addEventListener("selectend", d),
        l.addEventListener("end", e),
        l.updateRenderState({ baseLayer: new XRWebGLLayer(l, b) }),
        l.requestReferenceSpace(n).then(f),
        (y = l.inputSources),
        l.addEventListener("inputsourceschange", function() {
          y = l.inputSources;
          for (var a = 0; a < t.length; a++) t[a].userData.inputSource = y[a];
        }));
    };
    this.getCamera = function(a) {
      if (c()) {
        var b = a.parent,
          d = r.cameras;
        h(r, b);
        for (var e = 0; e < d.length; e++) h(d[e], b);
        a.matrixWorld.copy(r.matrixWorld);
        a = a.children;
        e = 0;
        for (b = a.length; e < b; e++) a[e].updateMatrixWorld(!0);
        Cl(r, u, v);
        return r;
      }
      return a;
    };
    this.isPresenting = c;
    var C = null,
      z = new Gg();
    z.setAnimationLoop(function(b, c) {
      q = c.getViewerPose(m);
      if (null !== q) {
        var d = q.views,
          e = l.renderState.baseLayer;
        a.setFramebuffer(e.framebuffer);
        for (var f = 0; f < d.length; f++) {
          var h = d[f],
            k = e.getViewport(h),
            n = r.cameras[f];
          n.matrix.fromArray(h.transform.inverse.matrix).getInverse(n.matrix);
          n.projectionMatrix.fromArray(h.projectionMatrix);
          n.viewport.set(k.x, k.y, k.width, k.height);
          0 === f && r.matrix.copy(n.matrix);
        }
      }
      for (f = 0; f < t.length; f++) {
        d = t[f];
        if ((e = y[f]))
          if (((e = c.getPose(e.targetRaySpace, m)), null !== e)) {
            d.matrix.fromArray(e.transform.matrix);
            d.matrix.decompose(d.position, d.rotation, d.scale);
            d.visible = !0;
            continue;
          }
        d.visible = !1;
      }
      C && C(b);
    });
    this.setAnimationLoop = function(a) {
      C = a;
    };
    this.dispose = function() {};
    this.getStandingMatrix = function() {
      console.warn(
        "THREE.WebXRManager: getStandingMatrix() is no longer needed."
      );
      return new fa();
    };
    this.getDevice = function() {
      console.warn("THREE.WebXRManager: getDevice() has been deprecated.");
    };
    this.setDevice = function() {
      console.warn("THREE.WebXRManager: setDevice() has been deprecated.");
    };
    this.setFrameOfReferenceType = function() {
      console.warn(
        "THREE.WebXRManager: setFrameOfReferenceType() has been deprecated."
      );
    };
    this.submitFrame = function() {};
  }
  function Gl(a) {
    var b;
    function c() {
      La = new xn(Q);
      xb = new vn(Q, La, a);
      !1 === xb.isWebGL2 &&
        (La.get("WEBGL_depth_texture"),
        La.get("OES_texture_float"),
        La.get("OES_texture_half_float"),
        La.get("OES_texture_half_float_linear"),
        La.get("OES_standard_derivatives"),
        La.get("OES_element_index_uint"),
        La.get("ANGLE_instanced_arrays"));
      La.get("OES_texture_float_linear");
      Ma = new Ho(Q, La, xb);
      ka = new Fo(Q, La, Ma, xb);
      ka.scissor(
        S.copy($h)
          .multiplyScalar(U)
          .floor()
      );
      ka.viewport(
        ha
          .copy(sa)
          .multiplyScalar(U)
          .floor()
      );
      da = new An(Q);
      ra = new wo();
      Ba = new Go(Q, La, ka, ra, xb, Ma, da);
      oa = new sn(Q);
      Ta = new yn(Q, oa, da);
      Pa = new Dn(Q, Ta, oa, da);
      Ya = new Cn(Q);
      Ia = new vo(L, La, xb);
      Ua = new zo();
      Aa = new Eo();
      ta = new tn(L, ka, Pa, M);
      Za = new un(Q, La, da, xb);
      cb = new zn(Q, La, da, xb);
      da.programs = Ia.programs;
      L.capabilities = xb;
      L.extensions = La;
      L.properties = ra;
      L.renderLists = Ua;
      L.state = ka;
      L.info = da;
    }
    function d(a) {
      a.preventDefault();
      ib = !0;
    }
    function e() {
      ib = !1;
      c();
    }
    function f(a) {
      a = a.target;
      a.removeEventListener("dispose", f);
      h(a);
      ra.remove(a);
    }
    function h(a) {
      var b = ra.get(a).program;
      a.program = void 0;
      void 0 !== b && Ia.releaseProgram(b);
    }
    function k(a, b) {
      a.render(function(a) {
        L.renderBufferImmediate(a, b);
      });
    }
    function l(a, b, c, d) {
      if (!1 !== a.visible) {
        if (a.layers.test(b.layers))
          if (a.isGroup) c = a.renderOrder;
          else if (a.isLOD) !0 === a.autoUpdate && a.update(b);
          else if (a.isLight) va.pushLight(a), a.castShadow && va.pushShadow(a);
          else if (a.isSprite) {
            if (!a.frustumCulled || ua.intersectsSprite(a)) {
              d && Rf.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bj);
              var e = Pa.update(a),
                f = a.material;
              f.visible && J.push(a, e, f, c, Rf.z, null);
            }
          } else if (a.isImmediateRenderObject)
            d && Rf.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bj),
              J.push(a, null, a.material, c, Rf.z, null);
          else if (a.isMesh || a.isLine || a.isPoints)
            if (
              (a.isSkinnedMesh &&
                a.skeleton.frame !== da.render.frame &&
                (a.skeleton.update(), (a.skeleton.frame = da.render.frame)),
              !a.frustumCulled || ua.intersectsObject(a))
            )
              if (
                (d && Rf.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bj),
                (e = Pa.update(a)),
                (f = a.material),
                Array.isArray(f))
              )
                for (var h = e.groups, k = 0, m = h.length; k < m; k++) {
                  var n = h[k],
                    q = f[n.materialIndex];
                  q && q.visible && J.push(a, e, q, c, Rf.z, n);
                }
              else f.visible && J.push(a, e, f, c, Rf.z, null);
        a = a.children;
        k = 0;
        for (m = a.length; k < m; k++) l(a[k], b, c, d);
      }
    }
    function m(a, b, c, d) {
      for (var e = 0, f = a.length; e < f; e++) {
        var h = a[e],
          k = h.object,
          l = h.geometry,
          m = void 0 === d ? h.material : d;
        h = h.group;
        if (c.isArrayCamera)
          if (((ja = c), jb.enabled && Sa.isAvailable())) n(k, b, c, l, m, h);
          else
            for (var q = c.cameras, t = 0, y = q.length; t < y; t++) {
              var u = q[t];
              k.layers.test(u.layers) &&
                (ka.viewport(ha.copy(u.viewport)),
                va.setupLights(u),
                n(k, b, u, l, m, h));
            }
        else (ja = null), n(k, b, c, l, m, h);
      }
    }
    function n(a, c, d, e, f, h) {
      a.onBeforeRender(L, c, d, e, f, h);
      va = Aa.get(c, ja || d);
      a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, a.matrixWorld);
      a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
      if (a.isImmediateRenderObject) {
        ka.setMaterial(f);
        var l = t(d, c.fog, f, a);
        Kg = b = null;
        P = !1;
        k(a, l);
      } else L.renderBufferDirect(d, c.fog, e, f, a, h);
      a.onAfterRender(L, c, d, e, f, h);
      va = Aa.get(c, ja || d);
    }
    function q(a, b, c) {
      var d = ra.get(a),
        e = va.state.lights,
        k = e.state.version;
      c = Ia.getParameters(
        a,
        e.state,
        va.state.shadowsArray,
        b,
        Da.numPlanes,
        Da.numIntersection,
        c
      );
      var l = Ia.getProgramCode(a, c),
        m = d.program,
        n = !0;
      if (void 0 === m) a.addEventListener("dispose", f);
      else if (m.code !== l) h(a);
      else {
        if (d.lightsStateVersion !== k) d.lightsStateVersion = k;
        else if (void 0 !== c.shaderID) return;
        n = !1;
      }
      n &&
        (c.shaderID
          ? ((l = hb[c.shaderID]),
            (d.shader = {
              name: a.type,
              uniforms: Se(l.uniforms),
              vertexShader: l.vertexShader,
              fragmentShader: l.fragmentShader
            }))
          : (d.shader = {
              name: a.type,
              uniforms: a.uniforms,
              vertexShader: a.vertexShader,
              fragmentShader: a.fragmentShader
            }),
        a.onBeforeCompile(d.shader, L),
        (l = Ia.getProgramCode(a, c)),
        (m = Ia.acquireProgram(a, d.shader, c, l)),
        (d.program = m),
        (a.program = m));
      c = m.getAttributes();
      if (a.morphTargets)
        for (l = a.numSupportedMorphTargets = 0; l < L.maxMorphTargets; l++)
          0 <= c["morphTarget" + l] && a.numSupportedMorphTargets++;
      if (a.morphNormals)
        for (l = a.numSupportedMorphNormals = 0; l < L.maxMorphNormals; l++)
          0 <= c["morphNormal" + l] && a.numSupportedMorphNormals++;
      c = d.shader.uniforms;
      if ((!a.isShaderMaterial && !a.isRawShaderMaterial) || !0 === a.clipping)
        (d.numClippingPlanes = Da.numPlanes),
          (d.numIntersection = Da.numIntersection),
          (c.clippingPlanes = Da.uniform);
      d.fog = b;
      d.needsLights =
        a.isMeshLambertMaterial ||
        a.isMeshPhongMaterial ||
        a.isMeshStandardMaterial ||
        a.isShadowMaterial ||
        (a.isShaderMaterial && !0 === a.lights);
      d.lightsStateVersion = k;
      d.needsLights &&
        ((c.ambientLightColor.value = e.state.ambient),
        (c.lightProbe.value = e.state.probe),
        (c.directionalLights.value = e.state.directional),
        (c.spotLights.value = e.state.spot),
        (c.rectAreaLights.value = e.state.rectArea),
        (c.pointLights.value = e.state.point),
        (c.hemisphereLights.value = e.state.hemi),
        (c.directionalShadowMap.value = e.state.directionalShadowMap),
        (c.directionalShadowMatrix.value = e.state.directionalShadowMatrix),
        (c.spotShadowMap.value = e.state.spotShadowMap),
        (c.spotShadowMatrix.value = e.state.spotShadowMatrix),
        (c.pointShadowMap.value = e.state.pointShadowMap),
        (c.pointShadowMatrix.value = e.state.pointShadowMatrix));
      a = d.program.getUniforms();
      a = Td.seqWithValue(a.seq, c);
      d.uniformsList = a;
    }
    function t(a, b, c, d) {
      Ba.resetTextureUnits();
      var e = ra.get(c),
        f = va.state.lights;
      ok &&
        (qa || a !== ba) &&
        Da.setState(
          c.clippingPlanes,
          c.clipIntersection,
          c.clipShadows,
          a,
          e,
          a === ba && c.id === Ea
        );
      !1 === c.needsUpdate &&
        (void 0 === e.program
          ? (c.needsUpdate = !0)
          : c.fog && e.fog !== b
          ? (c.needsUpdate = !0)
          : e.needsLights && e.lightsStateVersion !== f.state.version
          ? (c.needsUpdate = !0)
          : void 0 === e.numClippingPlanes ||
            (e.numClippingPlanes === Da.numPlanes &&
              e.numIntersection === Da.numIntersection) ||
            (c.needsUpdate = !0));
      c.needsUpdate && (q(c, b, d), (c.needsUpdate = !1));
      var h = !1,
        k = !1,
        l = !1;
      f = e.program;
      var m = f.getUniforms(),
        n = e.shader.uniforms;
      ka.useProgram(f.program) && (l = k = h = !0);
      c.id !== Ea && ((Ea = c.id), (k = !0));
      if (h || ba !== a) {
        0 < f.numMultiviewViews
          ? Sa.updateCameraProjectionMatricesUniform(a, m)
          : m.setValue(Q, "projectionMatrix", a.projectionMatrix);
        xb.logarithmicDepthBuffer &&
          m.setValue(Q, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
        ba !== a && ((ba = a), (l = k = !0));
        if (
          c.isShaderMaterial ||
          c.isMeshPhongMaterial ||
          c.isMeshStandardMaterial ||
          c.envMap
        )
          (h = m.map.cameraPosition),
            void 0 !== h &&
              h.setValue(Q, Rf.setFromMatrixPosition(a.matrixWorld));
        if (
          c.isMeshPhongMaterial ||
          c.isMeshLambertMaterial ||
          c.isMeshBasicMaterial ||
          c.isMeshStandardMaterial ||
          c.isShaderMaterial ||
          c.skinning
        )
          0 < f.numMultiviewViews
            ? Sa.updateCameraViewMatricesUniform(a, m)
            : m.setValue(Q, "viewMatrix", a.matrixWorldInverse);
      }
      if (
        c.skinning &&
        (m.setOptional(Q, d, "bindMatrix"),
        m.setOptional(Q, d, "bindMatrixInverse"),
        (h = d.skeleton))
      ) {
        var t = h.bones;
        if (xb.floatVertexTextures) {
          if (void 0 === h.boneTexture) {
            t = Math.sqrt(4 * t.length);
            t = ca.ceilPowerOfTwo(t);
            t = Math.max(t, 4);
            var r = new Float32Array(t * t * 4);
            r.set(h.boneMatrices);
            var A = new pc(r, t, t, 1023, 1015);
            h.boneMatrices = r;
            h.boneTexture = A;
            h.boneTextureSize = t;
          }
          m.setValue(Q, "boneTexture", h.boneTexture, Ba);
          m.setValue(Q, "boneTextureSize", h.boneTextureSize);
        } else m.setOptional(Q, h, "boneMatrices");
      }
      if (k || e.receiveShadow !== d.receiveShadow)
        (e.receiveShadow = d.receiveShadow),
          m.setValue(Q, "receiveShadow", d.receiveShadow);
      k &&
        (m.setValue(Q, "toneMappingExposure", L.toneMappingExposure),
        m.setValue(Q, "toneMappingWhitePoint", L.toneMappingWhitePoint),
        e.needsLights &&
          ((k = l),
          (n.ambientLightColor.needsUpdate = k),
          (n.lightProbe.needsUpdate = k),
          (n.directionalLights.needsUpdate = k),
          (n.pointLights.needsUpdate = k),
          (n.spotLights.needsUpdate = k),
          (n.rectAreaLights.needsUpdate = k),
          (n.hemisphereLights.needsUpdate = k)),
        b &&
          c.fog &&
          (n.fogColor.value.copy(b.color),
          b.isFog
            ? ((n.fogNear.value = b.near), (n.fogFar.value = b.far))
            : b.isFogExp2 && (n.fogDensity.value = b.density)),
        c.isMeshBasicMaterial
          ? y(n, c)
          : c.isMeshLambertMaterial
          ? (y(n, c), c.emissiveMap && (n.emissiveMap.value = c.emissiveMap))
          : c.isMeshPhongMaterial
          ? (y(n, c),
            c.isMeshToonMaterial
              ? (u(n, c),
                c.gradientMap && (n.gradientMap.value = c.gradientMap))
              : u(n, c))
          : c.isMeshStandardMaterial
          ? (y(n, c),
            c.isMeshPhysicalMaterial
              ? (v(n, c),
                (n.reflectivity.value = c.reflectivity),
                (n.clearcoat.value = c.clearcoat),
                (n.clearcoatRoughness.value = c.clearcoatRoughness),
                c.sheen && n.sheen.value.copy(c.sheen),
                c.clearcoatNormalMap &&
                  (n.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),
                  (n.clearcoatNormalMap.value = c.clearcoatNormalMap),
                  1 === c.side && n.clearcoatNormalScale.value.negate()),
                (n.transparency.value = c.transparency))
              : v(n, c))
          : c.isMeshMatcapMaterial
          ? (y(n, c),
            c.matcap && (n.matcap.value = c.matcap),
            c.bumpMap &&
              ((n.bumpMap.value = c.bumpMap),
              (n.bumpScale.value = c.bumpScale),
              1 === c.side && (n.bumpScale.value *= -1)),
            c.normalMap &&
              ((n.normalMap.value = c.normalMap),
              n.normalScale.value.copy(c.normalScale),
              1 === c.side && n.normalScale.value.negate()),
            c.displacementMap &&
              ((n.displacementMap.value = c.displacementMap),
              (n.displacementScale.value = c.displacementScale),
              (n.displacementBias.value = c.displacementBias)))
          : c.isMeshDepthMaterial
          ? (y(n, c),
            c.displacementMap &&
              ((n.displacementMap.value = c.displacementMap),
              (n.displacementScale.value = c.displacementScale),
              (n.displacementBias.value = c.displacementBias)))
          : c.isMeshDistanceMaterial
          ? (y(n, c),
            c.displacementMap &&
              ((n.displacementMap.value = c.displacementMap),
              (n.displacementScale.value = c.displacementScale),
              (n.displacementBias.value = c.displacementBias)),
            n.referencePosition.value.copy(c.referencePosition),
            (n.nearDistance.value = c.nearDistance),
            (n.farDistance.value = c.farDistance))
          : c.isMeshNormalMaterial
          ? (y(n, c),
            c.bumpMap &&
              ((n.bumpMap.value = c.bumpMap),
              (n.bumpScale.value = c.bumpScale),
              1 === c.side && (n.bumpScale.value *= -1)),
            c.normalMap &&
              ((n.normalMap.value = c.normalMap),
              n.normalScale.value.copy(c.normalScale),
              1 === c.side && n.normalScale.value.negate()),
            c.displacementMap &&
              ((n.displacementMap.value = c.displacementMap),
              (n.displacementScale.value = c.displacementScale),
              (n.displacementBias.value = c.displacementBias)))
          : c.isLineBasicMaterial
          ? (n.diffuse.value.copy(c.color),
            (n.opacity.value = c.opacity),
            c.isLineDashedMaterial &&
              ((n.dashSize.value = c.dashSize),
              (n.totalSize.value = c.dashSize + c.gapSize),
              (n.scale.value = c.scale)))
          : c.isPointsMaterial
          ? (n.diffuse.value.copy(c.color),
            (n.opacity.value = c.opacity),
            (n.size.value = c.size * U),
            (n.scale.value = 0.5 * ma),
            (n.map.value = c.map),
            null !== c.map &&
              (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(),
              n.uvTransform.value.copy(c.map.matrix)))
          : c.isSpriteMaterial
          ? (n.diffuse.value.copy(c.color),
            (n.opacity.value = c.opacity),
            (n.rotation.value = c.rotation),
            (n.map.value = c.map),
            null !== c.map &&
              (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(),
              n.uvTransform.value.copy(c.map.matrix)))
          : c.isShadowMaterial &&
            (n.color.value.copy(c.color), (n.opacity.value = c.opacity)),
        void 0 !== n.ltc_1 && (n.ltc_1.value = I.LTC_1),
        void 0 !== n.ltc_2 && (n.ltc_2.value = I.LTC_2),
        Td.upload(Q, e.uniformsList, n, Ba));
      c.isShaderMaterial &&
        !0 === c.uniformsNeedUpdate &&
        (Td.upload(Q, e.uniformsList, n, Ba), (c.uniformsNeedUpdate = !1));
      c.isSpriteMaterial && m.setValue(Q, "center", d.center);
      0 < f.numMultiviewViews
        ? Sa.updateObjectMatricesUniforms(d, a, m)
        : (m.setValue(Q, "modelViewMatrix", d.modelViewMatrix),
          m.setValue(Q, "normalMatrix", d.normalMatrix));
      m.setValue(Q, "modelMatrix", d.matrixWorld);
      return f;
    }
    function y(a, b) {
      a.opacity.value = b.opacity;
      b.color && a.diffuse.value.copy(b.color);
      b.emissive &&
        a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);
      b.map && (a.map.value = b.map);
      b.alphaMap && (a.alphaMap.value = b.alphaMap);
      b.specularMap && (a.specularMap.value = b.specularMap);
      b.envMap &&
        ((a.envMap.value = b.envMap),
        (a.flipEnvMap.value = b.envMap.isCubeTexture ? -1 : 1),
        (a.reflectivity.value = b.reflectivity),
        (a.refractionRatio.value = b.refractionRatio),
        (a.maxMipLevel.value = ra.get(b.envMap).__maxMipLevel));
      b.lightMap &&
        ((a.lightMap.value = b.lightMap),
        (a.lightMapIntensity.value = b.lightMapIntensity));
      b.aoMap &&
        ((a.aoMap.value = b.aoMap),
        (a.aoMapIntensity.value = b.aoMapIntensity));
      if (b.map) var c = b.map;
      else
        b.specularMap
          ? (c = b.specularMap)
          : b.displacementMap
          ? (c = b.displacementMap)
          : b.normalMap
          ? (c = b.normalMap)
          : b.bumpMap
          ? (c = b.bumpMap)
          : b.roughnessMap
          ? (c = b.roughnessMap)
          : b.metalnessMap
          ? (c = b.metalnessMap)
          : b.alphaMap
          ? (c = b.alphaMap)
          : b.emissiveMap && (c = b.emissiveMap);
      void 0 !== c &&
        (c.isWebGLRenderTarget && (c = c.texture),
        !0 === c.matrixAutoUpdate && c.updateMatrix(),
        a.uvTransform.value.copy(c.matrix));
    }
    function u(a, b) {
      a.specular.value.copy(b.specular);
      a.shininess.value = Math.max(b.shininess, 1e-4);
      b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
      b.bumpMap &&
        ((a.bumpMap.value = b.bumpMap),
        (a.bumpScale.value = b.bumpScale),
        1 === b.side && (a.bumpScale.value *= -1));
      b.normalMap &&
        ((a.normalMap.value = b.normalMap),
        a.normalScale.value.copy(b.normalScale),
        1 === b.side && a.normalScale.value.negate());
      b.displacementMap &&
        ((a.displacementMap.value = b.displacementMap),
        (a.displacementScale.value = b.displacementScale),
        (a.displacementBias.value = b.displacementBias));
    }
    function v(a, b) {
      a.roughness.value = b.roughness;
      a.metalness.value = b.metalness;
      b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
      b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
      b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
      b.bumpMap &&
        ((a.bumpMap.value = b.bumpMap),
        (a.bumpScale.value = b.bumpScale),
        1 === b.side && (a.bumpScale.value *= -1));
      b.normalMap &&
        ((a.normalMap.value = b.normalMap),
        a.normalScale.value.copy(b.normalScale),
        1 === b.side && a.normalScale.value.negate());
      b.displacementMap &&
        ((a.displacementMap.value = b.displacementMap),
        (a.displacementScale.value = b.displacementScale),
        (a.displacementBias.value = b.displacementBias));
      b.envMap && (a.envMapIntensity.value = b.envMapIntensity);
    }
    a = a || {};
    var A =
        void 0 !== a.canvas
          ? a.canvas
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
      C = void 0 !== a.context ? a.context : null,
      z = void 0 !== a.alpha ? a.alpha : !1,
      H = void 0 !== a.depth ? a.depth : !0,
      N = void 0 !== a.stencil ? a.stencil : !0,
      B = void 0 !== a.antialias ? a.antialias : !1,
      M = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
      O = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
      D = void 0 !== a.powerPreference ? a.powerPreference : "default",
      F =
        void 0 !== a.failIfMajorPerformanceCaveat
          ? a.failIfMajorPerformanceCaveat
          : !1,
      J = null,
      va = null;
    this.domElement = A;
    this.debug = { checkShaderErrors: !0 };
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.clippingPlanes = [];
    this.localClippingEnabled = !1;
    this.gammaFactor = 2;
    this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
    this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var L = this,
      ib = !1,
      V = null,
      na = 0,
      wa = 0,
      W = null,
      T = null,
      Ea = -1;
    var Kg = (b = null);
    var P = !1;
    var ba = null,
      ja = null,
      ha = new Ca(),
      S = new Ca(),
      Ik = null,
      X = A.width,
      ma = A.height,
      U = 1,
      sa = new Ca(0, 0, X, ma),
      $h = new Ca(0, 0, X, ma),
      pa = !1,
      ua = new Fg(),
      Da = new wn(),
      ok = !1,
      qa = !1,
      Bj = new fa(),
      Rf = new r();
    try {
      z = {
        alpha: z,
        depth: H,
        stencil: N,
        antialias: B,
        premultipliedAlpha: M,
        preserveDrawingBuffer: O,
        powerPreference: D,
        failIfMajorPerformanceCaveat: F,
        xrCompatible: !0
      };
      A.addEventListener("webglcontextlost", d, !1);
      A.addEventListener("webglcontextrestored", e, !1);
      var Q =
        C || A.getContext("webgl", z) || A.getContext("experimental-webgl", z);
      if (null === Q) {
        if (null !== A.getContext("webgl"))
          throw Error(
            "Error creating WebGL context with your selected attributes."
          );
        throw Error("Error creating WebGL context.");
      }
      void 0 === Q.getShaderPrecisionFormat &&
        (Q.getShaderPrecisionFormat = function() {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (Hl) {
      throw (console.error("THREE.WebGLRenderer: " + Hl.message), Hl);
    }
    var La, xb, ka, da, ra, Ba, oa, Ta, Pa, Ia, Ua, Aa, ta, Ya, Za, cb, Ma;
    c();
    var jb =
      "undefined" !== typeof navigator &&
      "xr" in navigator &&
      "supportsSession" in navigator.xr
        ? new Fl(L, Q)
        : new ai(L);
    this.vr = jb;
    var Sa = new Io(L, Q),
      Wa = new Al(L, Pa, xb.maxTextureSize);
    this.shadowMap = Wa;
    this.getContext = function() {
      return Q;
    };
    this.getContextAttributes = function() {
      return Q.getContextAttributes();
    };
    this.forceContextLoss = function() {
      var a = La.get("WEBGL_lose_context");
      a && a.loseContext();
    };
    this.forceContextRestore = function() {
      var a = La.get("WEBGL_lose_context");
      a && a.restoreContext();
    };
    this.getPixelRatio = function() {
      return U;
    };
    this.setPixelRatio = function(a) {
      void 0 !== a && ((U = a), this.setSize(X, ma, !1));
    };
    this.getSize = function(a) {
      void 0 === a &&
        (console.warn(
          "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
        ),
        (a = new E()));
      return a.set(X, ma);
    };
    this.setSize = function(a, b, c) {
      jb.isPresenting()
        ? console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          )
        : ((X = a),
          (ma = b),
          (A.width = Math.floor(a * U)),
          (A.height = Math.floor(b * U)),
          !1 !== c && ((A.style.width = a + "px"), (A.style.height = b + "px")),
          this.setViewport(0, 0, a, b));
    };
    this.getDrawingBufferSize = function(a) {
      void 0 === a &&
        (console.warn(
          "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
        ),
        (a = new E()));
      return a.set(X * U, ma * U).floor();
    };
    this.setDrawingBufferSize = function(a, b, c) {
      X = a;
      ma = b;
      U = c;
      A.width = Math.floor(a * c);
      A.height = Math.floor(b * c);
      this.setViewport(0, 0, a, b);
    };
    this.getCurrentViewport = function(a) {
      void 0 === a &&
        (console.warn(
          "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
        ),
        (a = new Ca()));
      return a.copy(ha);
    };
    this.getViewport = function(a) {
      return a.copy(sa);
    };
    this.setViewport = function(a, b, c, d) {
      a.isVector4 ? sa.set(a.x, a.y, a.z, a.w) : sa.set(a, b, c, d);
      ka.viewport(
        ha
          .copy(sa)
          .multiplyScalar(U)
          .floor()
      );
    };
    this.getScissor = function(a) {
      return a.copy($h);
    };
    this.setScissor = function(a, b, c, d) {
      a.isVector4 ? $h.set(a.x, a.y, a.z, a.w) : $h.set(a, b, c, d);
      ka.scissor(
        S.copy($h)
          .multiplyScalar(U)
          .floor()
      );
    };
    this.getScissorTest = function() {
      return pa;
    };
    this.setScissorTest = function(a) {
      ka.setScissorTest((pa = a));
    };
    this.getClearColor = function() {
      return ta.getClearColor();
    };
    this.setClearColor = function() {
      ta.setClearColor.apply(ta, arguments);
    };
    this.getClearAlpha = function() {
      return ta.getClearAlpha();
    };
    this.setClearAlpha = function() {
      ta.setClearAlpha.apply(ta, arguments);
    };
    this.clear = function(a, b, c) {
      var d = 0;
      if (void 0 === a || a) d |= 16384;
      if (void 0 === b || b) d |= 256;
      if (void 0 === c || c) d |= 1024;
      Q.clear(d);
    };
    this.clearColor = function() {
      this.clear(!0, !1, !1);
    };
    this.clearDepth = function() {
      this.clear(!1, !0, !1);
    };
    this.clearStencil = function() {
      this.clear(!1, !1, !0);
    };
    this.dispose = function() {
      A.removeEventListener("webglcontextlost", d, !1);
      A.removeEventListener("webglcontextrestored", e, !1);
      Ua.dispose();
      Aa.dispose();
      ra.dispose();
      Pa.dispose();
      jb.dispose();
      $a.stop();
    };
    this.renderBufferImmediate = function(a, b) {
      ka.initAttributes();
      var c = ra.get(a);
      a.hasPositions && !c.position && (c.position = Q.createBuffer());
      a.hasNormals && !c.normal && (c.normal = Q.createBuffer());
      a.hasUvs && !c.uv && (c.uv = Q.createBuffer());
      a.hasColors && !c.color && (c.color = Q.createBuffer());
      b = b.getAttributes();
      a.hasPositions &&
        (Q.bindBuffer(34962, c.position),
        Q.bufferData(34962, a.positionArray, 35048),
        ka.enableAttribute(b.position),
        Q.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0));
      a.hasNormals &&
        (Q.bindBuffer(34962, c.normal),
        Q.bufferData(34962, a.normalArray, 35048),
        ka.enableAttribute(b.normal),
        Q.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0));
      a.hasUvs &&
        (Q.bindBuffer(34962, c.uv),
        Q.bufferData(34962, a.uvArray, 35048),
        ka.enableAttribute(b.uv),
        Q.vertexAttribPointer(b.uv, 2, 5126, !1, 0, 0));
      a.hasColors &&
        (Q.bindBuffer(34962, c.color),
        Q.bufferData(34962, a.colorArray, 35048),
        ka.enableAttribute(b.color),
        Q.vertexAttribPointer(b.color, 3, 5126, !1, 0, 0));
      ka.disableUnusedAttributes();
      Q.drawArrays(4, 0, a.count);
      a.count = 0;
    };
    this.renderBufferDirect = function(a, c, d, e, f, h) {
      var k = f.isMesh && 0 > f.matrixWorld.determinant();
      ka.setMaterial(e, k);
      var l = t(a, c, e, f),
        m = !1;
      if (b !== d.id || Kg !== l.id || P !== (!0 === e.wireframe))
        (b = d.id), (Kg = l.id), (P = !0 === e.wireframe), (m = !0);
      f.morphTargetInfluences && (Ya.update(f, d, e, l), (m = !0));
      k = d.index;
      var n = d.attributes.position;
      c = 1;
      !0 === e.wireframe && ((k = Ta.getWireframeAttribute(d)), (c = 2));
      a = Za;
      if (null !== k) {
        var q = oa.get(k);
        a = cb;
        a.setIndex(q);
      }
      if (m) {
        if (
          !1 !== xb.isWebGL2 ||
          (!f.isInstancedMesh && !d.isInstancedBufferGeometry) ||
          null !== La.get("ANGLE_instanced_arrays")
        ) {
          ka.initAttributes();
          m = d.attributes;
          l = l.getAttributes();
          var y = e.defaultAttributeValues;
          for (N in l) {
            var u = l[N];
            if (0 <= u) {
              var v = m[N];
              if (void 0 !== v) {
                var r = v.normalized,
                  A = v.itemSize,
                  z = oa.get(v);
                if (void 0 !== z) {
                  var B = z.buffer,
                    C = z.type;
                  z = z.bytesPerElement;
                  if (v.isInterleavedBufferAttribute) {
                    var H = v.data,
                      M = H.stride;
                    v = v.offset;
                    H && H.isInstancedInterleavedBuffer
                      ? (ka.enableAttributeAndDivisor(u, H.meshPerAttribute),
                        void 0 === d.maxInstancedCount &&
                          (d.maxInstancedCount = H.meshPerAttribute * H.count))
                      : ka.enableAttribute(u);
                    Q.bindBuffer(34962, B);
                    Q.vertexAttribPointer(u, A, C, r, M * z, v * z);
                  } else
                    v.isInstancedBufferAttribute
                      ? (ka.enableAttributeAndDivisor(u, v.meshPerAttribute),
                        void 0 === d.maxInstancedCount &&
                          (d.maxInstancedCount = v.meshPerAttribute * v.count))
                      : ka.enableAttribute(u),
                      Q.bindBuffer(34962, B),
                      Q.vertexAttribPointer(u, A, C, r, 0, 0);
                }
              } else if ("instanceMatrix" === N)
                (z = oa.get(f.instanceMatrix)),
                  void 0 !== z &&
                    ((B = z.buffer),
                    (C = z.type),
                    ka.enableAttributeAndDivisor(u + 0, 1),
                    ka.enableAttributeAndDivisor(u + 1, 1),
                    ka.enableAttributeAndDivisor(u + 2, 1),
                    ka.enableAttributeAndDivisor(u + 3, 1),
                    Q.bindBuffer(34962, B),
                    Q.vertexAttribPointer(u + 0, 4, C, !1, 64, 0),
                    Q.vertexAttribPointer(u + 1, 4, C, !1, 64, 16),
                    Q.vertexAttribPointer(u + 2, 4, C, !1, 64, 32),
                    Q.vertexAttribPointer(u + 3, 4, C, !1, 64, 48));
              else if (void 0 !== y && ((r = y[N]), void 0 !== r))
                switch (r.length) {
                  case 2:
                    Q.vertexAttrib2fv(u, r);
                    break;
                  case 3:
                    Q.vertexAttrib3fv(u, r);
                    break;
                  case 4:
                    Q.vertexAttrib4fv(u, r);
                    break;
                  default:
                    Q.vertexAttrib1fv(u, r);
                }
            }
          }
          ka.disableUnusedAttributes();
        }
        null !== k && Q.bindBuffer(34963, q.buffer);
      }
      q = Infinity;
      null !== k ? (q = k.count) : void 0 !== n && (q = n.count);
      k = d.drawRange.start * c;
      n = null !== h ? h.start * c : 0;
      var N = Math.max(k, n);
      h = Math.max(
        0,
        Math.min(
          q,
          k + d.drawRange.count * c,
          n + (null !== h ? h.count * c : Infinity)
        ) -
          1 -
          N +
          1
      );
      if (0 !== h) {
        if (f.isMesh)
          if (!0 === e.wireframe)
            ka.setLineWidth(e.wireframeLinewidth * (null === W ? U : 1)),
              a.setMode(1);
          else
            switch (f.drawMode) {
              case 0:
                a.setMode(4);
                break;
              case 1:
                a.setMode(5);
                break;
              case 2:
                a.setMode(6);
            }
        else
          f.isLine
            ? ((e = e.linewidth),
              void 0 === e && (e = 1),
              ka.setLineWidth(e * (null === W ? U : 1)),
              f.isLineSegments
                ? a.setMode(1)
                : f.isLineLoop
                ? a.setMode(2)
                : a.setMode(3))
            : f.isPoints
            ? a.setMode(0)
            : f.isSprite && a.setMode(4);
        f.isInstancedMesh
          ? a.renderInstances(d, N, h, f.count)
          : d.isInstancedBufferGeometry
          ? a.renderInstances(d, N, h, d.maxInstancedCount)
          : a.render(N, h);
      }
    };
    this.compile = function(a, b) {
      va = Aa.get(a, b);
      va.init();
      a.traverse(function(a) {
        a.isLight && (va.pushLight(a), a.castShadow && va.pushShadow(a));
      });
      va.setupLights(b);
      a.traverse(function(b) {
        if (b.material)
          if (Array.isArray(b.material))
            for (var c = 0; c < b.material.length; c++)
              q(b.material[c], a.fog, b);
          else q(b.material, a.fog, b);
      });
    };
    var bb = null,
      $a = new Gg();
    $a.setAnimationLoop(function(a) {
      jb.isPresenting() || (bb && bb(a));
    });
    "undefined" !== typeof window && $a.setContext(window);
    this.setAnimationLoop = function(a) {
      bb = a;
      jb.setAnimationLoop(a);
      $a.start();
    };
    this.render = function(a, c, d, e) {
      if (void 0 !== d) {
        console.warn(
          "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
        );
        var f = d;
      }
      if (void 0 !== e) {
        console.warn(
          "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
        );
        var h = e;
      }
      c && c.isCamera
        ? ib ||
          ((Kg = b = null),
          (P = !1),
          (Ea = -1),
          (ba = null),
          !0 === a.autoUpdate && a.updateMatrixWorld(),
          null === c.parent && c.updateMatrixWorld(),
          jb.enabled && (c = jb.getCamera(c)),
          (va = Aa.get(a, c)),
          va.init(),
          a.onBeforeRender(L, a, c, f || W),
          Bj.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse),
          ua.setFromMatrix(Bj),
          (qa = this.localClippingEnabled),
          (ok = Da.init(this.clippingPlanes, qa, c)),
          (J = Ua.get(a, c)),
          J.init(),
          l(a, c, 0, L.sortObjects),
          !0 === L.sortObjects && J.sort(),
          ok && Da.beginShadows(),
          Wa.render(va.state.shadowsArray, a, c),
          va.setupLights(c),
          ok && Da.endShadows(),
          this.info.autoReset && this.info.reset(),
          void 0 !== f && this.setRenderTarget(f),
          jb.enabled && Sa.isAvailable() && Sa.attachCamera(c),
          ta.render(J, a, c, h),
          (d = J.opaque),
          (e = J.transparent),
          a.overrideMaterial
            ? ((f = a.overrideMaterial),
              d.length && m(d, a, c, f),
              e.length && m(e, a, c, f))
            : (d.length && m(d, a, c), e.length && m(e, a, c)),
          a.onAfterRender(L, a, c),
          null !== W &&
            (Ba.updateRenderTargetMipmap(W),
            Ba.updateMultisampleRenderTarget(W)),
          ka.buffers.depth.setTest(!0),
          ka.buffers.depth.setMask(!0),
          ka.buffers.color.setMask(!0),
          ka.setPolygonOffset(!1),
          jb.enabled &&
            (Sa.isAvailable() && Sa.detachCamera(c), jb.submitFrame()),
          (va = J = null))
        : console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
    };
    this.setFramebuffer = function(a) {
      V !== a && Q.bindFramebuffer(36160, a);
      V = a;
    };
    this.getActiveCubeFace = function() {
      return na;
    };
    this.getActiveMipmapLevel = function() {
      return wa;
    };
    this.getRenderTarget = function() {
      return W;
    };
    this.setRenderTarget = function(a, b, c) {
      W = a;
      na = b;
      wa = c;
      a && void 0 === ra.get(a).__webglFramebuffer && Ba.setupRenderTarget(a);
      var d = V,
        e = !1;
      a
        ? ((d = ra.get(a).__webglFramebuffer),
          a.isWebGLRenderTargetCube
            ? ((d = d[b || 0]), (e = !0))
            : (d = a.isWebGLMultisampleRenderTarget
                ? ra.get(a).__webglMultisampledFramebuffer
                : d),
          ha.copy(a.viewport),
          S.copy(a.scissor),
          (Ik = a.scissorTest))
        : (ha
            .copy(sa)
            .multiplyScalar(U)
            .floor(),
          S.copy($h)
            .multiplyScalar(U)
            .floor(),
          (Ik = pa));
      T !== d && (Q.bindFramebuffer(36160, d), (T = d));
      ka.viewport(ha);
      ka.scissor(S);
      ka.setScissorTest(Ik);
      e &&
        ((a = ra.get(a.texture)),
        Q.framebufferTexture2D(
          36160,
          36064,
          34069 + (b || 0),
          a.__webglTexture,
          c || 0
        ));
    };
    this.readRenderTargetPixels = function(a, b, c, d, e, f, h) {
      if (a && a.isWebGLRenderTarget) {
        var k = ra.get(a).__webglFramebuffer;
        a.isWebGLRenderTargetCube && void 0 !== h && (k = k[h]);
        if (k) {
          h = !1;
          k !== T && (Q.bindFramebuffer(36160, k), (h = !0));
          try {
            var l = a.texture,
              m = l.format,
              n = l.type;
            1023 !== m && Ma.convert(m) !== Q.getParameter(35739)
              ? console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                )
              : 1009 === n ||
                Ma.convert(n) === Q.getParameter(35738) ||
                (1015 === n &&
                  (xb.isWebGL2 ||
                    La.get("OES_texture_float") ||
                    La.get("WEBGL_color_buffer_float"))) ||
                (1016 === n &&
                  (xb.isWebGL2
                    ? La.get("EXT_color_buffer_float")
                    : La.get("EXT_color_buffer_half_float")))
              ? 36053 === Q.checkFramebufferStatus(36160)
                ? 0 <= b &&
                  b <= a.width - d &&
                  0 <= c &&
                  c <= a.height - e &&
                  Q.readPixels(b, c, d, e, Ma.convert(m), Ma.convert(n), f)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  )
              : console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
          } finally {
            h && Q.bindFramebuffer(36160, T);
          }
        }
      } else
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
    };
    this.copyFramebufferToTexture = function(a, b, c) {
      var d = b.image.width,
        e = b.image.height,
        f = Ma.convert(b.format);
      Ba.setTexture2D(b, 0);
      Q.copyTexImage2D(3553, c || 0, f, a.x, a.y, d, e, 0);
    };
    this.copyTextureToTexture = function(a, b, c, d) {
      var e = b.image.width,
        f = b.image.height,
        h = Ma.convert(c.format),
        k = Ma.convert(c.type);
      Ba.setTexture2D(c, 0);
      b.isDataTexture
        ? Q.texSubImage2D(3553, d || 0, a.x, a.y, e, f, h, k, b.image.data)
        : Q.texSubImage2D(3553, d || 0, a.x, a.y, h, k, b.image);
    };
    "undefined" !== typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
  }
  function bi(a, b) {
    this.name = "";
    this.color = new L(a);
    this.density = void 0 !== b ? b : 2.5e-4;
  }
  function ci(a, b, c) {
    this.name = "";
    this.color = new L(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1e3;
  }
  function Fb(a, b) {
    this.array = a;
    this.stride = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.dynamic = !1;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  function Sf(a, b, c, d) {
    this.data = a;
    this.itemSize = b;
    this.offset = c;
    this.normalized = !0 === d;
  }
  function Rb(a) {
    T.call(this);
    this.type = "SpriteMaterial";
    this.color = new L(16777215);
    this.map = null;
    this.rotation = 0;
    this.transparent = this.sizeAttenuation = !0;
    this.setValues(a);
  }
  function di(a) {
    D.call(this);
    this.type = "Sprite";
    if (void 0 === rc) {
      rc = new F();
      var b = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      b = new Fb(b, 5);
      rc.setIndex([0, 1, 2, 0, 2, 3]);
      rc.addAttribute("position", new Sf(b, 3, 0, !1));
      rc.addAttribute("uv", new Sf(b, 2, 3, !1));
    }
    this.geometry = rc;
    this.material = void 0 !== a ? a : new Rb();
    this.center = new E(0.5, 0.5);
  }
  function Lg(a, b, c, d, e, f) {
    sc.subVectors(a, c)
      .addScalar(0.5)
      .multiply(d);
    void 0 !== e
      ? ((Vd.x = f * sc.x - e * sc.y), (Vd.y = e * sc.x + f * sc.y))
      : Vd.copy(sc);
    a.copy(b);
    a.x += Vd.x;
    a.y += Vd.y;
    a.applyMatrix4(Il);
  }
  function Mg() {
    D.call(this);
    this.type = "LOD";
    Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
    this.autoUpdate = !0;
  }
  function Tf(a, b) {
    a &&
      a.isGeometry &&
      console.error(
        "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
      );
    oa.call(this, a, b);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new fa();
    this.bindMatrixInverse = new fa();
  }
  function Ng(a, b) {
    a = a || [];
    this.bones = a.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    this.frame = -1;
    if (void 0 === b) this.calculateInverses();
    else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
    else
      for (
        console.warn("THREE.Skeleton boneInverses is the wrong length."),
          this.boneInverses = [],
          a = 0,
          b = this.bones.length;
        a < b;
        a++
      )
        this.boneInverses.push(new fa());
  }
  function Jl() {
    D.call(this);
    this.type = "Bone";
  }
  function Kl(a, b, c) {
    oa.call(this, a, b);
    this.instanceMatrix = new ba(new Float32Array(16 * c), 16);
    this.count = c;
  }
  function qa(a) {
    T.call(this);
    this.type = "LineBasicMaterial";
    this.color = new L(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.setValues(a);
  }
  function $a(a, b, c) {
    1 === c &&
      console.error(
        "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
      );
    D.call(this);
    this.type = "Line";
    this.geometry = void 0 !== a ? a : new F();
    this.material =
      void 0 !== b ? b : new qa({ color: 16777215 * Math.random() });
  }
  function ra(a, b) {
    $a.call(this, a, b);
    this.type = "LineSegments";
  }
  function ei(a, b) {
    $a.call(this, a, b);
    this.type = "LineLoop";
  }
  function Wd(a) {
    T.call(this);
    this.type = "PointsMaterial";
    this.color = new L(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.morphTargets = !1;
    this.setValues(a);
  }
  function fi(a, b) {
    D.call(this);
    this.type = "Points";
    this.geometry = void 0 !== a ? a : new F();
    this.material =
      void 0 !== b ? b : new Wd({ color: 16777215 * Math.random() });
    this.updateMorphTargets();
  }
  function gi(a, b, c, d, e, f, h) {
    var k = Dj.distanceSqToPoint(a);
    k < c &&
      ((c = new r()),
      Dj.closestPointToPoint(a, c),
      c.applyMatrix4(d),
      (a = e.ray.origin.distanceTo(c)),
      a < e.near ||
        a > e.far ||
        f.push({
          distance: a,
          distanceToRay: Math.sqrt(k),
          point: c,
          index: b,
          face: null,
          object: h
        }));
  }
  function Ll(a, b, c, d, e, f, h, k, l) {
    pa.call(this, a, b, c, d, e, f, h, k, l);
    this.format = void 0 !== h ? h : 1022;
    this.minFilter = void 0 !== f ? f : 1006;
    this.magFilter = void 0 !== e ? e : 1006;
    this.generateMipmaps = !1;
  }
  function Xd(a, b, c, d, e, f, h, k, l, m, n, q) {
    pa.call(this, null, f, h, k, l, m, d, e, n, q);
    this.image = { width: b, height: c };
    this.mipmaps = a;
    this.generateMipmaps = this.flipY = !1;
  }
  function Og(a, b, c, d, e, f, h, k, l) {
    pa.call(this, a, b, c, d, e, f, h, k, l);
    this.needsUpdate = !0;
  }
  function Pg(a, b, c, d, e, f, h, k, l, m) {
    m = void 0 !== m ? m : 1026;
    if (1026 !== m && 1027 !== m)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    void 0 === c && 1026 === m && (c = 1012);
    void 0 === c && 1027 === m && (c = 1020);
    pa.call(this, null, d, e, f, h, k, m, c, l);
    this.image = { width: a, height: b };
    this.magFilter = void 0 !== h ? h : 1003;
    this.minFilter = void 0 !== k ? k : 1003;
    this.generateMipmaps = this.flipY = !1;
  }
  function Uf(a) {
    F.call(this);
    this.type = "WireframeGeometry";
    var b = [],
      c,
      d,
      e,
      f = [0, 0],
      h = {},
      k = ["a", "b", "c"];
    if (a && a.isGeometry) {
      var l = a.faces;
      var m = 0;
      for (d = l.length; m < d; m++) {
        var n = l[m];
        for (c = 0; 3 > c; c++) {
          var q = n[k[c]];
          var t = n[k[(c + 1) % 3]];
          f[0] = Math.min(q, t);
          f[1] = Math.max(q, t);
          q = f[0] + "," + f[1];
          void 0 === h[q] && (h[q] = { index1: f[0], index2: f[1] });
        }
      }
      for (q in h)
        (m = h[q]),
          (k = a.vertices[m.index1]),
          b.push(k.x, k.y, k.z),
          (k = a.vertices[m.index2]),
          b.push(k.x, k.y, k.z);
    } else if (a && a.isBufferGeometry)
      if (((k = new r()), null !== a.index)) {
        l = a.attributes.position;
        n = a.index;
        var y = a.groups;
        0 === y.length &&
          (y = [{ start: 0, count: n.count, materialIndex: 0 }]);
        a = 0;
        for (e = y.length; a < e; ++a)
          for (
            m = y[a], c = m.start, d = m.count, m = c, d = c + d;
            m < d;
            m += 3
          )
            for (c = 0; 3 > c; c++)
              (q = n.getX(m + c)),
                (t = n.getX(m + ((c + 1) % 3))),
                (f[0] = Math.min(q, t)),
                (f[1] = Math.max(q, t)),
                (q = f[0] + "," + f[1]),
                void 0 === h[q] && (h[q] = { index1: f[0], index2: f[1] });
        for (q in h)
          (m = h[q]),
            k.fromBufferAttribute(l, m.index1),
            b.push(k.x, k.y, k.z),
            k.fromBufferAttribute(l, m.index2),
            b.push(k.x, k.y, k.z);
      } else
        for (l = a.attributes.position, m = 0, d = l.count / 3; m < d; m++)
          for (c = 0; 3 > c; c++)
            (h = 3 * m + c),
              k.fromBufferAttribute(l, h),
              b.push(k.x, k.y, k.z),
              (h = 3 * m + ((c + 1) % 3)),
              k.fromBufferAttribute(l, h),
              b.push(k.x, k.y, k.z);
    this.addAttribute("position", new O(b, 3));
  }
  function Vf(a, b, c) {
    W.call(this);
    this.type = "ParametricGeometry";
    this.parameters = { func: a, slices: b, stacks: c };
    this.fromBufferGeometry(new Yd(a, b, c));
    this.mergeVertices();
  }
  function Yd(a, b, c) {
    F.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = { func: a, slices: b, stacks: c };
    var d = [],
      e = [],
      f = [],
      h = [],
      k = new r(),
      l = new r(),
      m = new r(),
      n = new r(),
      q = new r(),
      t,
      y;
    3 > a.length &&
      console.error(
        "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
      );
    var u = b + 1;
    for (t = 0; t <= c; t++) {
      var v = t / c;
      for (y = 0; y <= b; y++) {
        var A = y / b;
        a(A, v, l);
        e.push(l.x, l.y, l.z);
        0 <= A - 1e-5
          ? (a(A - 1e-5, v, m), n.subVectors(l, m))
          : (a(A + 1e-5, v, m), n.subVectors(m, l));
        0 <= v - 1e-5
          ? (a(A, v - 1e-5, m), q.subVectors(l, m))
          : (a(A, v + 1e-5, m), q.subVectors(m, l));
        k.crossVectors(n, q).normalize();
        f.push(k.x, k.y, k.z);
        h.push(A, v);
      }
    }
    for (t = 0; t < c; t++)
      for (y = 0; y < b; y++)
        (a = t * u + y + 1),
          (k = (t + 1) * u + y + 1),
          (l = (t + 1) * u + y),
          d.push(t * u + y, a, l),
          d.push(a, k, l);
    this.setIndex(d);
    this.addAttribute("position", new O(e, 3));
    this.addAttribute("normal", new O(f, 3));
    this.addAttribute("uv", new O(h, 2));
  }
  function Qg(a, b, c, d) {
    W.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = { vertices: a, indices: b, radius: c, detail: d };
    this.fromBufferGeometry(new yb(a, b, c, d));
    this.mergeVertices();
  }
  function yb(a, b, c, d) {
    function e(a) {
      k.push(a.x, a.y, a.z);
    }
    function f(b, c) {
      b *= 3;
      c.x = a[b + 0];
      c.y = a[b + 1];
      c.z = a[b + 2];
    }
    function h(a, b, c, d) {
      0 > d && 1 === a.x && (l[b] = a.x - 1);
      0 === c.x && 0 === c.z && (l[b] = d / 2 / Math.PI + 0.5);
    }
    F.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = { vertices: a, indices: b, radius: c, detail: d };
    c = c || 1;
    d = d || 0;
    var k = [],
      l = [];
    (function(a) {
      for (
        var c = new r(), d = new r(), h = new r(), k = 0;
        k < b.length;
        k += 3
      ) {
        f(b[k + 0], c);
        f(b[k + 1], d);
        f(b[k + 2], h);
        var l,
          m,
          A = c,
          C = d,
          z = h,
          H = Math.pow(2, a),
          N = [];
        for (m = 0; m <= H; m++) {
          N[m] = [];
          var B = A.clone().lerp(z, m / H),
            M = C.clone().lerp(z, m / H),
            E = H - m;
          for (l = 0; l <= E; l++)
            N[m][l] = 0 === l && m === H ? B : B.clone().lerp(M, l / E);
        }
        for (m = 0; m < H; m++)
          for (l = 0; l < 2 * (H - m) - 1; l++)
            (A = Math.floor(l / 2)),
              0 === l % 2
                ? (e(N[m][A + 1]), e(N[m + 1][A]), e(N[m][A]))
                : (e(N[m][A + 1]), e(N[m + 1][A + 1]), e(N[m + 1][A]));
      }
    })(d);
    (function(a) {
      for (var b = new r(), c = 0; c < k.length; c += 3)
        (b.x = k[c + 0]),
          (b.y = k[c + 1]),
          (b.z = k[c + 2]),
          b.normalize().multiplyScalar(a),
          (k[c + 0] = b.x),
          (k[c + 1] = b.y),
          (k[c + 2] = b.z);
    })(c);
    (function() {
      for (var a = new r(), b = 0; b < k.length; b += 3)
        (a.x = k[b + 0]),
          (a.y = k[b + 1]),
          (a.z = k[b + 2]),
          l.push(
            Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5,
            1 -
              (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI +
                0.5)
          );
      a = new r();
      b = new r();
      for (
        var c = new r(),
          d = new r(),
          e = new E(),
          f = new E(),
          v = new E(),
          A = 0,
          C = 0;
        A < k.length;
        A += 9, C += 6
      ) {
        a.set(k[A + 0], k[A + 1], k[A + 2]);
        b.set(k[A + 3], k[A + 4], k[A + 5]);
        c.set(k[A + 6], k[A + 7], k[A + 8]);
        e.set(l[C + 0], l[C + 1]);
        f.set(l[C + 2], l[C + 3]);
        v.set(l[C + 4], l[C + 5]);
        d.copy(a)
          .add(b)
          .add(c)
          .divideScalar(3);
        var z = Math.atan2(d.z, -d.x);
        h(e, C + 0, a, z);
        h(f, C + 2, b, z);
        h(v, C + 4, c, z);
      }
      for (a = 0; a < l.length; a += 6)
        (b = l[a + 0]),
          (c = l[a + 2]),
          (d = l[a + 4]),
          (e = Math.min(b, c, d)),
          0.9 < Math.max(b, c, d) &&
            0.1 > e &&
            (0.2 > b && (l[a + 0] += 1),
            0.2 > c && (l[a + 2] += 1),
            0.2 > d && (l[a + 4] += 1));
    })();
    this.addAttribute("position", new O(k, 3));
    this.addAttribute("normal", new O(k.slice(), 3));
    this.addAttribute("uv", new O(l, 2));
    0 === d ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Ve(a, b) {
    W.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new Zd(a, b));
    this.mergeVertices();
  }
  function Zd(a, b) {
    yb.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      a,
      b
    );
    this.type = "TetrahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function We(a, b) {
    W.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new Sb(a, b));
    this.mergeVertices();
  }
  function Sb(a, b) {
    yb.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      a,
      b
    );
    this.type = "OctahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function Rg(a, b) {
    W.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new nd(a, b));
    this.mergeVertices();
  }
  function nd(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    yb.call(
      this,
      [
        -1,
        c,
        0,
        1,
        c,
        0,
        -1,
        -c,
        0,
        1,
        -c,
        0,
        0,
        -1,
        c,
        0,
        1,
        c,
        0,
        -1,
        -c,
        0,
        1,
        -c,
        c,
        0,
        -1,
        c,
        0,
        1,
        -c,
        0,
        -1,
        -c,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      a,
      b
    );
    this.type = "IcosahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function Sg(a, b) {
    W.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new $d(a, b));
    this.mergeVertices();
  }
  function $d(a, b) {
    var c = (1 + Math.sqrt(5)) / 2,
      d = 1 / c;
    yb.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -d,
        -c,
        0,
        -d,
        c,
        0,
        d,
        -c,
        0,
        d,
        c,
        -d,
        -c,
        0,
        -d,
        c,
        0,
        d,
        -c,
        0,
        d,
        c,
        0,
        -c,
        0,
        -d,
        c,
        0,
        -d,
        -c,
        0,
        d,
        c,
        0,
        d
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      a,
      b
    );
    this.type = "DodecahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function Wf(a, b, c, d, e, f) {
    W.call(this);
    this.type = "TubeGeometry";
    this.parameters = {
      path: a,
      tubularSegments: b,
      radius: c,
      radialSegments: d,
      closed: e
    };
    void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
    a = new tc(a, b, c, d, e);
    this.tangents = a.tangents;
    this.normals = a.normals;
    this.binormals = a.binormals;
    this.fromBufferGeometry(a);
    this.mergeVertices();
  }
  function tc(a, b, c, d, e) {
    function f(e) {
      n = a.getPointAt(e / b, n);
      var f = h.normals[e];
      e = h.binormals[e];
      for (t = 0; t <= d; t++) {
        var m = (t / d) * Math.PI * 2,
          q = Math.sin(m);
        m = -Math.cos(m);
        l.x = m * f.x + q * e.x;
        l.y = m * f.y + q * e.y;
        l.z = m * f.z + q * e.z;
        l.normalize();
        u.push(l.x, l.y, l.z);
        k.x = n.x + c * l.x;
        k.y = n.y + c * l.y;
        k.z = n.z + c * l.z;
        y.push(k.x, k.y, k.z);
      }
    }
    F.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {
      path: a,
      tubularSegments: b,
      radius: c,
      radialSegments: d,
      closed: e
    };
    b = b || 64;
    c = c || 1;
    d = d || 8;
    e = e || !1;
    var h = a.computeFrenetFrames(b, e);
    this.tangents = h.tangents;
    this.normals = h.normals;
    this.binormals = h.binormals;
    var k = new r(),
      l = new r(),
      m = new E(),
      n = new r(),
      q,
      t,
      y = [],
      u = [],
      v = [],
      A = [];
    for (q = 0; q < b; q++) f(q);
    f(!1 === e ? b : 0);
    for (q = 0; q <= b; q++)
      for (t = 0; t <= d; t++) (m.x = q / b), (m.y = t / d), v.push(m.x, m.y);
    (function() {
      for (t = 1; t <= b; t++)
        for (q = 1; q <= d; q++) {
          var a = (d + 1) * t + (q - 1),
            c = (d + 1) * t + q,
            e = (d + 1) * (t - 1) + q;
          A.push((d + 1) * (t - 1) + (q - 1), a, e);
          A.push(a, c, e);
        }
    })();
    this.setIndex(A);
    this.addAttribute("position", new O(y, 3));
    this.addAttribute("normal", new O(u, 3));
    this.addAttribute("uv", new O(v, 2));
  }
  function Xf(a, b, c, d, e, f, h) {
    W.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius: a,
      tube: b,
      tubularSegments: c,
      radialSegments: d,
      p: e,
      q: f
    };
    void 0 !== h &&
      console.warn(
        "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
      );
    this.fromBufferGeometry(new Tg(a, b, c, d, e, f));
    this.mergeVertices();
  }
  function Tg(a, b, c, d, e, f) {
    function h(a, b, c, d, e) {
      var f = Math.sin(a);
      b = (c / b) * a;
      c = Math.cos(b);
      e.x = d * (2 + c) * 0.5 * Math.cos(a);
      e.y = d * (2 + c) * f * 0.5;
      e.z = d * Math.sin(b) * 0.5;
    }
    F.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {
      radius: a,
      tube: b,
      tubularSegments: c,
      radialSegments: d,
      p: e,
      q: f
    };
    a = a || 1;
    b = b || 0.4;
    c = Math.floor(c) || 64;
    d = Math.floor(d) || 8;
    e = e || 2;
    f = f || 3;
    var k = [],
      l = [],
      m = [],
      n = [],
      q,
      t = new r(),
      y = new r(),
      u = new r(),
      v = new r(),
      A = new r(),
      C = new r(),
      z = new r();
    for (q = 0; q <= c; ++q) {
      var H = (q / c) * e * Math.PI * 2;
      h(H, e, f, a, u);
      h(H + 0.01, e, f, a, v);
      C.subVectors(v, u);
      z.addVectors(v, u);
      A.crossVectors(C, z);
      z.crossVectors(A, C);
      A.normalize();
      z.normalize();
      for (H = 0; H <= d; ++H) {
        var N = (H / d) * Math.PI * 2,
          B = -b * Math.cos(N);
        N = b * Math.sin(N);
        t.x = u.x + (B * z.x + N * A.x);
        t.y = u.y + (B * z.y + N * A.y);
        t.z = u.z + (B * z.z + N * A.z);
        l.push(t.x, t.y, t.z);
        y.subVectors(t, u).normalize();
        m.push(y.x, y.y, y.z);
        n.push(q / c);
        n.push(H / d);
      }
    }
    for (H = 1; H <= c; H++)
      for (q = 1; q <= d; q++)
        (a = (d + 1) * H + (q - 1)),
          (b = (d + 1) * H + q),
          (e = (d + 1) * (H - 1) + q),
          k.push((d + 1) * (H - 1) + (q - 1), a, e),
          k.push(a, b, e);
    this.setIndex(k);
    this.addAttribute("position", new O(l, 3));
    this.addAttribute("normal", new O(m, 3));
    this.addAttribute("uv", new O(n, 2));
  }
  function Ug(a, b, c, d, e) {
    W.call(this);
    this.type = "TorusGeometry";
    this.parameters = {
      radius: a,
      tube: b,
      radialSegments: c,
      tubularSegments: d,
      arc: e
    };
    this.fromBufferGeometry(new Vg(a, b, c, d, e));
    this.mergeVertices();
  }
  function Vg(a, b, c, d, e) {
    F.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {
      radius: a,
      tube: b,
      radialSegments: c,
      tubularSegments: d,
      arc: e
    };
    a = a || 1;
    b = b || 0.4;
    c = Math.floor(c) || 8;
    d = Math.floor(d) || 6;
    e = e || 2 * Math.PI;
    var f = [],
      h = [],
      k = [],
      l = [],
      m = new r(),
      n = new r(),
      q = new r(),
      t,
      y;
    for (t = 0; t <= c; t++)
      for (y = 0; y <= d; y++) {
        var u = (y / d) * e,
          v = (t / c) * Math.PI * 2;
        n.x = (a + b * Math.cos(v)) * Math.cos(u);
        n.y = (a + b * Math.cos(v)) * Math.sin(u);
        n.z = b * Math.sin(v);
        h.push(n.x, n.y, n.z);
        m.x = a * Math.cos(u);
        m.y = a * Math.sin(u);
        q.subVectors(n, m).normalize();
        k.push(q.x, q.y, q.z);
        l.push(y / d);
        l.push(t / c);
      }
    for (t = 1; t <= c; t++)
      for (y = 1; y <= d; y++)
        (a = (d + 1) * (t - 1) + y - 1),
          (b = (d + 1) * (t - 1) + y),
          (e = (d + 1) * t + y),
          f.push((d + 1) * t + y - 1, a, e),
          f.push(a, b, e);
    this.setIndex(f);
    this.addAttribute("position", new O(h, 3));
    this.addAttribute("normal", new O(k, 3));
    this.addAttribute("uv", new O(l, 2));
  }
  function Ml(a, b, c, d, e) {
    for (var f, h = 0, k = b, l = c - d; k < c; k += d)
      (h += (a[l] - a[k]) * (a[k + 1] + a[l + 1])), (l = k);
    if (e === 0 < h) for (e = b; e < c; e += d) f = Nl(e, a[e], a[e + 1], f);
    else for (e = c - d; e >= b; e -= d) f = Nl(e, a[e], a[e + 1], f);
    f && od(f, f.next) && (Xe(f), (f = f.next));
    return f;
  }
  function Ye(a, b) {
    if (!a) return a;
    b || (b = a);
    do {
      var c = !1;
      if (a.steiner || (!od(a, a.next) && 0 !== Sa(a.prev, a, a.next)))
        a = a.next;
      else {
        Xe(a);
        a = b = a.prev;
        if (a === a.next) break;
        c = !0;
      }
    } while (c || a !== b);
    return b;
  }
  function Ze(a, b, c, d, e, f, h) {
    if (a) {
      if (!h && f) {
        var k = a,
          l = k;
        do
          null === l.z && (l.z = hi(l.x, l.y, d, e, f)),
            (l.prevZ = l.prev),
            (l = l.nextZ = l.next);
        while (l !== k);
        l.prevZ.nextZ = null;
        l.prevZ = null;
        k = l;
        var m,
          n,
          q,
          t,
          y = 1;
        do {
          l = k;
          var u = (k = null);
          for (n = 0; l; ) {
            n++;
            var v = l;
            for (m = q = 0; m < y && (q++, (v = v.nextZ), v); m++);
            for (t = y; 0 < q || (0 < t && v); )
              0 !== q && (0 === t || !v || l.z <= v.z)
                ? ((m = l), (l = l.nextZ), q--)
                : ((m = v), (v = v.nextZ), t--),
                u ? (u.nextZ = m) : (k = m),
                (m.prevZ = u),
                (u = m);
            l = v;
          }
          u.nextZ = null;
          y *= 2;
        } while (1 < n);
      }
      for (k = a; a.prev !== a.next; ) {
        l = a.prev;
        v = a.next;
        if (f) u = Jo(a, d, e, f);
        else
          a: if (
            ((u = a), (n = u.prev), (q = u), (y = u.next), 0 <= Sa(n, q, y))
          )
            u = !1;
          else {
            for (m = u.next.next; m !== u.prev; ) {
              if (
                uc(n.x, n.y, q.x, q.y, y.x, y.y, m.x, m.y) &&
                0 <= Sa(m.prev, m, m.next)
              ) {
                u = !1;
                break a;
              }
              m = m.next;
            }
            u = !0;
          }
        if (u)
          b.push(l.i / c),
            b.push(a.i / c),
            b.push(v.i / c),
            Xe(a),
            (k = a = v.next);
        else if (((a = v), a === k)) {
          if (!h) Ze(Ye(a), b, c, d, e, f, 1);
          else if (1 === h) {
            h = b;
            k = c;
            l = a;
            do
              (v = l.prev),
                (u = l.next.next),
                !od(v, u) &&
                  Ol(v, l, l.next, u) &&
                  ae(v, u) &&
                  ae(u, v) &&
                  (h.push(v.i / k),
                  h.push(l.i / k),
                  h.push(u.i / k),
                  Xe(l),
                  Xe(l.next),
                  (l = a = u)),
                (l = l.next);
            while (l !== a);
            a = l;
            Ze(a, b, c, d, e, f, 2);
          } else if (2 === h)
            a: {
              h = a;
              do {
                for (k = h.next.next; k !== h.prev; ) {
                  if ((l = h.i !== k.i)) {
                    l = h;
                    v = k;
                    if ((u = l.next.i !== v.i && l.prev.i !== v.i)) {
                      b: {
                        u = l;
                        do {
                          if (
                            u.i !== l.i &&
                            u.next.i !== l.i &&
                            u.i !== v.i &&
                            u.next.i !== v.i &&
                            Ol(u, u.next, l, v)
                          ) {
                            u = !0;
                            break b;
                          }
                          u = u.next;
                        } while (u !== l);
                        u = !1;
                      }
                      u = !u;
                    }
                    if ((u = u && ae(l, v) && ae(v, l))) {
                      u = l;
                      n = !1;
                      q = (l.x + v.x) / 2;
                      v = (l.y + v.y) / 2;
                      do
                        u.y > v !== u.next.y > v &&
                          u.next.y !== u.y &&
                          q <
                            ((u.next.x - u.x) * (v - u.y)) / (u.next.y - u.y) +
                              u.x &&
                          (n = !n),
                          (u = u.next);
                      while (u !== l);
                      u = n;
                    }
                    l = u;
                  }
                  if (l) {
                    a = Pl(h, k);
                    h = Ye(h, h.next);
                    a = Ye(a, a.next);
                    Ze(h, b, c, d, e, f);
                    Ze(a, b, c, d, e, f);
                    break a;
                  }
                  k = k.next;
                }
                h = h.next;
              } while (h !== a);
            }
          break;
        }
      }
    }
  }
  function Jo(a, b, c, d) {
    var e = a.prev,
      f = a.next;
    if (0 <= Sa(e, a, f)) return !1;
    var h = e.x > a.x ? (e.x > f.x ? e.x : f.x) : a.x > f.x ? a.x : f.x,
      k = e.y > a.y ? (e.y > f.y ? e.y : f.y) : a.y > f.y ? a.y : f.y,
      l = hi(
        e.x < a.x ? (e.x < f.x ? e.x : f.x) : a.x < f.x ? a.x : f.x,
        e.y < a.y ? (e.y < f.y ? e.y : f.y) : a.y < f.y ? a.y : f.y,
        b,
        c,
        d
      );
    b = hi(h, k, b, c, d);
    c = a.prevZ;
    for (d = a.nextZ; c && c.z >= l && d && d.z <= b; ) {
      if (
        c !== a.prev &&
        c !== a.next &&
        uc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) &&
        0 <= Sa(c.prev, c, c.next)
      )
        return !1;
      c = c.prevZ;
      if (
        d !== a.prev &&
        d !== a.next &&
        uc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) &&
        0 <= Sa(d.prev, d, d.next)
      )
        return !1;
      d = d.nextZ;
    }
    for (; c && c.z >= l; ) {
      if (
        c !== a.prev &&
        c !== a.next &&
        uc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) &&
        0 <= Sa(c.prev, c, c.next)
      )
        return !1;
      c = c.prevZ;
    }
    for (; d && d.z <= b; ) {
      if (
        d !== a.prev &&
        d !== a.next &&
        uc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) &&
        0 <= Sa(d.prev, d, d.next)
      )
        return !1;
      d = d.nextZ;
    }
    return !0;
  }
  function Ko(a, b) {
    return a.x - b.x;
  }
  function Lo(a, b) {
    var c = b,
      d = a.x,
      e = a.y,
      f = -Infinity;
    do {
      if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
        var h = c.x + ((e - c.y) * (c.next.x - c.x)) / (c.next.y - c.y);
        if (h <= d && h > f) {
          f = h;
          if (h === d) {
            if (e === c.y) return c;
            if (e === c.next.y) return c.next;
          }
          var k = c.x < c.next.x ? c : c.next;
        }
      }
      c = c.next;
    } while (c !== b);
    if (!k) return null;
    if (d === f) return k.prev;
    b = k;
    h = k.x;
    var l = k.y,
      m = Infinity;
    for (c = k.next; c !== b; ) {
      if (
        d >= c.x &&
        c.x >= h &&
        d !== c.x &&
        uc(e < l ? d : f, e, h, l, e < l ? f : d, e, c.x, c.y)
      ) {
        var n = Math.abs(e - c.y) / (d - c.x);
        (n < m || (n === m && c.x > k.x)) && ae(c, a) && ((k = c), (m = n));
      }
      c = c.next;
    }
    return k;
  }
  function hi(a, b, c, d, e) {
    a = 32767 * (a - c) * e;
    b = 32767 * (b - d) * e;
    a = (a | (a << 8)) & 16711935;
    a = (a | (a << 4)) & 252645135;
    a = (a | (a << 2)) & 858993459;
    b = (b | (b << 8)) & 16711935;
    b = (b | (b << 4)) & 252645135;
    b = (b | (b << 2)) & 858993459;
    return ((a | (a << 1)) & 1431655765) | (((b | (b << 1)) & 1431655765) << 1);
  }
  function Mo(a) {
    var b = a,
      c = a;
    do {
      if (b.x < c.x || (b.x === c.x && b.y < c.y)) c = b;
      b = b.next;
    } while (b !== a);
    return c;
  }
  function uc(a, b, c, d, e, f, h, k) {
    return (
      0 <= (e - h) * (b - k) - (a - h) * (f - k) &&
      0 <= (a - h) * (d - k) - (c - h) * (b - k) &&
      0 <= (c - h) * (f - k) - (e - h) * (d - k)
    );
  }
  function Sa(a, b, c) {
    return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
  }
  function od(a, b) {
    return a.x === b.x && a.y === b.y;
  }
  function Ol(a, b, c, d) {
    return (od(a, c) && od(b, d)) || (od(a, d) && od(c, b))
      ? !0
      : 0 < Sa(a, b, c) !== 0 < Sa(a, b, d) &&
          0 < Sa(c, d, a) !== 0 < Sa(c, d, b);
  }
  function ae(a, b) {
    return 0 > Sa(a.prev, a, a.next)
      ? 0 <= Sa(a, b, a.next) && 0 <= Sa(a, a.prev, b)
      : 0 > Sa(a, b, a.prev) || 0 > Sa(a, a.next, b);
  }
  function Pl(a, b) {
    var c = new ii(a.i, a.x, a.y),
      d = new ii(b.i, b.x, b.y),
      e = a.next,
      f = b.prev;
    a.next = b;
    b.prev = a;
    c.next = e;
    e.prev = c;
    d.next = c;
    c.prev = d;
    f.next = d;
    d.prev = f;
    return d;
  }
  function Nl(a, b, c, d) {
    a = new ii(a, b, c);
    d
      ? ((a.next = d.next), (a.prev = d), (d.next.prev = a), (d.next = a))
      : ((a.prev = a), (a.next = a));
    return a;
  }
  function Xe(a) {
    a.next.prev = a.prev;
    a.prev.next = a.next;
    a.prevZ && (a.prevZ.nextZ = a.nextZ);
    a.nextZ && (a.nextZ.prevZ = a.prevZ);
  }
  function ii(a, b, c) {
    this.i = a;
    this.x = b;
    this.y = c;
    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
    this.steiner = !1;
  }
  function Ql(a) {
    var b = a.length;
    2 < b && a[b - 1].equals(a[0]) && a.pop();
  }
  function Rl(a, b) {
    for (var c = 0; c < b.length; c++) a.push(b[c].x), a.push(b[c].y);
  }
  function Tb(a, b) {
    W.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = { shapes: a, options: b };
    this.fromBufferGeometry(new vc(a, b));
    this.mergeVertices();
  }
  function vc(a, b) {
    function c(a) {
      function c(a, b, c) {
        b || console.error("THREE.ExtrudeGeometry: vec does not exist");
        return b
          .clone()
          .multiplyScalar(c)
          .add(a);
      }
      function h(a, b, c) {
        var d = a.x - b.x;
        var e = a.y - b.y;
        var f = c.x - a.x;
        var h = c.y - a.y,
          k = d * d + e * e;
        if (Math.abs(d * h - e * f) > Number.EPSILON) {
          var l = Math.sqrt(k),
            m = Math.sqrt(f * f + h * h);
          k = b.x - e / l;
          b = b.y + d / l;
          h = ((c.x - h / m - k) * h - (c.y + f / m - b) * f) / (d * h - e * f);
          f = k + d * h - a.x;
          d = b + e * h - a.y;
          e = f * f + d * d;
          if (2 >= e) return new E(f, d);
          e = Math.sqrt(e / 2);
        } else (a = !1), d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(h) && (a = !0), a ? ((f = -e), (e = Math.sqrt(k))) : ((f = d), (d = e), (e = Math.sqrt(k / 2)));
        return new E(f / e, d / e);
      }
      function k(a, b) {
        for (X = a.length; 0 <= --X; ) {
          var c = X;
          var f = X - 1;
          0 > f && (f = a.length - 1);
          var h,
            k = z + 2 * O;
          for (h = 0; h < k; h++) {
            var l = fa * h,
              m = fa * (h + 1),
              n = b + f + l,
              q = b + f + m;
            m = b + c + m;
            u(b + c + l);
            u(n);
            u(m);
            u(n);
            u(q);
            u(m);
            l = e.length / 3;
            l = J.generateSideWallUV(d, e, l - 6, l - 3, l - 2, l - 1);
            v(l[0]);
            v(l[1]);
            v(l[3]);
            v(l[1]);
            v(l[2]);
            v(l[3]);
          }
        }
      }
      function l(a, b, c) {
        A.push(a);
        A.push(b);
        A.push(c);
      }
      function y(a, b, c) {
        u(a);
        u(b);
        u(c);
        a = e.length / 3;
        a = J.generateTopUV(d, e, a - 3, a - 2, a - 1);
        v(a[0]);
        v(a[1]);
        v(a[2]);
      }
      function u(a) {
        e.push(A[3 * a]);
        e.push(A[3 * a + 1]);
        e.push(A[3 * a + 2]);
      }
      function v(a) {
        f.push(a.x);
        f.push(a.y);
      }
      var A = [],
        C = void 0 !== b.curveSegments ? b.curveSegments : 12,
        z = void 0 !== b.steps ? b.steps : 1,
        H = void 0 !== b.depth ? b.depth : 100,
        N = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
        B = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
        M = void 0 !== b.bevelSize ? b.bevelSize : B - 2,
        L = void 0 !== b.bevelOffset ? b.bevelOffset : 0,
        O = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
        D = b.extrudePath,
        J = void 0 !== b.UVGenerator ? b.UVGenerator : No;
      void 0 !== b.amount &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
        ),
        (H = b.amount));
      var va = !1;
      if (D) {
        var F = D.getSpacedPoints(z);
        va = !0;
        N = !1;
        var ib = D.computeFrenetFrames(z, !1);
        var I = new r();
        var na = new r();
        var V = new r();
      }
      N || (L = M = B = O = 0);
      var W;
      C = a.extractPoints(C);
      a = C.shape;
      var ba = C.holes;
      if (!be.isClockWise(a)) {
        a = a.reverse();
        var Ea = 0;
        for (W = ba.length; Ea < W; Ea++) {
          var T = ba[Ea];
          be.isClockWise(T) && (ba[Ea] = T.reverse());
        }
      }
      var P = be.triangulateShape(a, ba),
        ha = a;
      Ea = 0;
      for (W = ba.length; Ea < W; Ea++) (T = ba[Ea]), (a = a.concat(T));
      var ca,
        fa = a.length,
        S,
        ja = P.length;
      C = [];
      var X = 0;
      var ma = ha.length;
      var U = ma - 1;
      for (ca = X + 1; X < ma; X++, U++, ca++)
        U === ma && (U = 0),
          ca === ma && (ca = 0),
          (C[X] = h(ha[X], ha[U], ha[ca]));
      D = [];
      var ra = C.concat();
      Ea = 0;
      for (W = ba.length; Ea < W; Ea++) {
        T = ba[Ea];
        var sa = [];
        X = 0;
        ma = T.length;
        U = ma - 1;
        for (ca = X + 1; X < ma; X++, U++, ca++)
          U === ma && (U = 0),
            ca === ma && (ca = 0),
            (sa[X] = h(T[X], T[U], T[ca]));
        D.push(sa);
        ra = ra.concat(sa);
      }
      for (U = 0; U < O; U++) {
        ma = U / O;
        var da = B * Math.cos((ma * Math.PI) / 2);
        ca = M * Math.sin((ma * Math.PI) / 2) + L;
        X = 0;
        for (ma = ha.length; X < ma; X++) {
          var ua = c(ha[X], C[X], ca);
          l(ua.x, ua.y, -da);
        }
        Ea = 0;
        for (W = ba.length; Ea < W; Ea++)
          for (T = ba[Ea], sa = D[Ea], X = 0, ma = T.length; X < ma; X++)
            (ua = c(T[X], sa[X], ca)), l(ua.x, ua.y, -da);
      }
      ca = M + L;
      for (X = 0; X < fa; X++)
        (ua = N ? c(a[X], ra[X], ca) : a[X]),
          va
            ? (na.copy(ib.normals[0]).multiplyScalar(ua.x),
              I.copy(ib.binormals[0]).multiplyScalar(ua.y),
              V.copy(F[0])
                .add(na)
                .add(I),
              l(V.x, V.y, V.z))
            : l(ua.x, ua.y, 0);
      for (ma = 1; ma <= z; ma++)
        for (X = 0; X < fa; X++)
          (ua = N ? c(a[X], ra[X], ca) : a[X]),
            va
              ? (na.copy(ib.normals[ma]).multiplyScalar(ua.x),
                I.copy(ib.binormals[ma]).multiplyScalar(ua.y),
                V.copy(F[ma])
                  .add(na)
                  .add(I),
                l(V.x, V.y, V.z))
              : l(ua.x, ua.y, (H / z) * ma);
      for (U = O - 1; 0 <= U; U--) {
        ma = U / O;
        da = B * Math.cos((ma * Math.PI) / 2);
        ca = M * Math.sin((ma * Math.PI) / 2) + L;
        X = 0;
        for (ma = ha.length; X < ma; X++)
          (ua = c(ha[X], C[X], ca)), l(ua.x, ua.y, H + da);
        Ea = 0;
        for (W = ba.length; Ea < W; Ea++)
          for (T = ba[Ea], sa = D[Ea], X = 0, ma = T.length; X < ma; X++)
            (ua = c(T[X], sa[X], ca)),
              va
                ? l(ua.x, ua.y + F[z - 1].y, F[z - 1].x + da)
                : l(ua.x, ua.y, H + da);
      }
      (function() {
        var a = e.length / 3;
        if (N) {
          var b = 0 * fa;
          for (X = 0; X < ja; X++) (S = P[X]), y(S[2] + b, S[1] + b, S[0] + b);
          b = fa * (z + 2 * O);
          for (X = 0; X < ja; X++) (S = P[X]), y(S[0] + b, S[1] + b, S[2] + b);
        } else {
          for (X = 0; X < ja; X++) (S = P[X]), y(S[2], S[1], S[0]);
          for (X = 0; X < ja; X++)
            (S = P[X]), y(S[0] + fa * z, S[1] + fa * z, S[2] + fa * z);
        }
        d.addGroup(a, e.length / 3 - a, 0);
      })();
      (function() {
        var a = e.length / 3,
          b = 0;
        k(ha, b);
        b += ha.length;
        Ea = 0;
        for (W = ba.length; Ea < W; Ea++)
          (T = ba[Ea]), k(T, b), (b += T.length);
        d.addGroup(a, e.length / 3 - a, 1);
      })();
    }
    F.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = { shapes: a, options: b };
    a = Array.isArray(a) ? a : [a];
    for (var d = this, e = [], f = [], h = 0, k = a.length; h < k; h++) c(a[h]);
    this.addAttribute("position", new O(e, 3));
    this.addAttribute("uv", new O(f, 2));
    this.computeVertexNormals();
  }
  function Sl(a, b, c) {
    c.shapes = [];
    if (Array.isArray(a))
      for (var d = 0, e = a.length; d < e; d++) c.shapes.push(a[d].uuid);
    else c.shapes.push(a.uuid);
    void 0 !== b.extrudePath &&
      (c.options.extrudePath = b.extrudePath.toJSON());
    return c;
  }
  function ji(a, b) {
    W.call(this);
    this.type = "TextGeometry";
    this.parameters = { text: a, parameters: b };
    this.fromBufferGeometry(new ce(a, b));
    this.mergeVertices();
  }
  function ce(a, b) {
    b = b || {};
    var c = b.font;
    if (!c || !c.isFont)
      return (
        console.error(
          "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
        ),
        new W()
      );
    a = c.generateShapes(a, b.size);
    b.depth = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
    vc.call(this, a, b);
    this.type = "TextBufferGeometry";
  }
  function ki(a, b, c, d, e, f, h) {
    W.call(this);
    this.type = "SphereGeometry";
    this.parameters = {
      radius: a,
      widthSegments: b,
      heightSegments: c,
      phiStart: d,
      phiLength: e,
      thetaStart: f,
      thetaLength: h
    };
    this.fromBufferGeometry(new de(a, b, c, d, e, f, h));
    this.mergeVertices();
  }
  function de(a, b, c, d, e, f, h) {
    F.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {
      radius: a,
      widthSegments: b,
      heightSegments: c,
      phiStart: d,
      phiLength: e,
      thetaStart: f,
      thetaLength: h
    };
    a = a || 1;
    b = Math.max(3, Math.floor(b) || 8);
    c = Math.max(2, Math.floor(c) || 6);
    d = void 0 !== d ? d : 0;
    e = void 0 !== e ? e : 2 * Math.PI;
    f = void 0 !== f ? f : 0;
    h = void 0 !== h ? h : Math.PI;
    var k = Math.min(f + h, Math.PI),
      l,
      m,
      n = 0,
      q = [],
      t = new r(),
      y = new r(),
      u = [],
      v = [],
      A = [],
      C = [];
    for (m = 0; m <= c; m++) {
      var z = [],
        H = m / c,
        N = 0;
      0 == m && 0 == f
        ? (N = 0.5 / b)
        : m == c && k == Math.PI && (N = -0.5 / b);
      for (l = 0; l <= b; l++) {
        var B = l / b;
        t.x = -a * Math.cos(d + B * e) * Math.sin(f + H * h);
        t.y = a * Math.cos(f + H * h);
        t.z = a * Math.sin(d + B * e) * Math.sin(f + H * h);
        v.push(t.x, t.y, t.z);
        y.copy(t).normalize();
        A.push(y.x, y.y, y.z);
        C.push(B + N, 1 - H);
        z.push(n++);
      }
      q.push(z);
    }
    for (m = 0; m < c; m++)
      for (l = 0; l < b; l++)
        (a = q[m][l + 1]),
          (d = q[m][l]),
          (e = q[m + 1][l]),
          (h = q[m + 1][l + 1]),
          (0 !== m || 0 < f) && u.push(a, d, h),
          (m !== c - 1 || k < Math.PI) && u.push(d, e, h);
    this.setIndex(u);
    this.addAttribute("position", new O(v, 3));
    this.addAttribute("normal", new O(A, 3));
    this.addAttribute("uv", new O(C, 2));
  }
  function li(a, b, c, d, e, f) {
    W.call(this);
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius: a,
      outerRadius: b,
      thetaSegments: c,
      phiSegments: d,
      thetaStart: e,
      thetaLength: f
    };
    this.fromBufferGeometry(new ee(a, b, c, d, e, f));
    this.mergeVertices();
  }
  function ee(a, b, c, d, e, f) {
    F.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {
      innerRadius: a,
      outerRadius: b,
      thetaSegments: c,
      phiSegments: d,
      thetaStart: e,
      thetaLength: f
    };
    a = a || 0.5;
    b = b || 1;
    e = void 0 !== e ? e : 0;
    f = void 0 !== f ? f : 2 * Math.PI;
    c = void 0 !== c ? Math.max(3, c) : 8;
    d = void 0 !== d ? Math.max(1, d) : 1;
    var h = [],
      k = [],
      l = [],
      m = [],
      n = a,
      q = (b - a) / d,
      t = new r(),
      y = new E(),
      u,
      v;
    for (u = 0; u <= d; u++) {
      for (v = 0; v <= c; v++)
        (a = e + (v / c) * f),
          (t.x = n * Math.cos(a)),
          (t.y = n * Math.sin(a)),
          k.push(t.x, t.y, t.z),
          l.push(0, 0, 1),
          (y.x = (t.x / b + 1) / 2),
          (y.y = (t.y / b + 1) / 2),
          m.push(y.x, y.y);
      n += q;
    }
    for (u = 0; u < d; u++)
      for (b = u * (c + 1), v = 0; v < c; v++)
        (a = v + b),
          (e = a + c + 1),
          (f = a + c + 2),
          (n = a + 1),
          h.push(a, e, n),
          h.push(e, f, n);
    this.setIndex(h);
    this.addAttribute("position", new O(k, 3));
    this.addAttribute("normal", new O(l, 3));
    this.addAttribute("uv", new O(m, 2));
  }
  function $e(a, b, c, d) {
    W.call(this);
    this.type = "LatheGeometry";
    this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
    this.fromBufferGeometry(new af(a, b, c, d));
    this.mergeVertices();
  }
  function af(a, b, c, d) {
    F.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
    b = Math.floor(b) || 12;
    c = c || 0;
    d = d || 2 * Math.PI;
    d = ca.clamp(d, 0, 2 * Math.PI);
    var e = [],
      f = [],
      h = [],
      k = 1 / b,
      l = new r(),
      m = new E(),
      n;
    for (n = 0; n <= b; n++) {
      var q = c + n * k * d;
      var t = Math.sin(q),
        y = Math.cos(q);
      for (q = 0; q <= a.length - 1; q++)
        (l.x = a[q].x * t),
          (l.y = a[q].y),
          (l.z = a[q].x * y),
          f.push(l.x, l.y, l.z),
          (m.x = n / b),
          (m.y = q / (a.length - 1)),
          h.push(m.x, m.y);
    }
    for (n = 0; n < b; n++)
      for (q = 0; q < a.length - 1; q++)
        (c = q + n * a.length),
          (k = c + a.length),
          (l = c + a.length + 1),
          (m = c + 1),
          e.push(c, k, m),
          e.push(k, l, m);
    this.setIndex(e);
    this.addAttribute("position", new O(f, 3));
    this.addAttribute("uv", new O(h, 2));
    this.computeVertexNormals();
    if (d === 2 * Math.PI)
      for (
        d = this.attributes.normal.array,
          e = new r(),
          f = new r(),
          h = new r(),
          c = b * a.length * 3,
          q = n = 0;
        n < a.length;
        n++, q += 3
      )
        (e.x = d[q + 0]),
          (e.y = d[q + 1]),
          (e.z = d[q + 2]),
          (f.x = d[c + q + 0]),
          (f.y = d[c + q + 1]),
          (f.z = d[c + q + 2]),
          h.addVectors(e, f).normalize(),
          (d[q + 0] = d[c + q + 0] = h.x),
          (d[q + 1] = d[c + q + 1] = h.y),
          (d[q + 2] = d[c + q + 2] = h.z);
  }
  function wc(a, b) {
    W.call(this);
    this.type = "ShapeGeometry";
    "object" === ("undefined" === typeof b ? "undefined" : nk(b)) &&
      (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
      (b = b.curveSegments));
    this.parameters = { shapes: a, curveSegments: b };
    this.fromBufferGeometry(new Ub(a, b));
    this.mergeVertices();
  }
  function Ub(a, b) {
    function c(a) {
      var c,
        k = e.length / 3;
      a = a.extractPoints(b);
      var m = a.shape,
        n = a.holes;
      !1 === be.isClockWise(m) && (m = m.reverse());
      a = 0;
      for (c = n.length; a < c; a++) {
        var v = n[a];
        !0 === be.isClockWise(v) && (n[a] = v.reverse());
      }
      var r = be.triangulateShape(m, n);
      a = 0;
      for (c = n.length; a < c; a++) (v = n[a]), (m = m.concat(v));
      a = 0;
      for (c = m.length; a < c; a++)
        (v = m[a]), e.push(v.x, v.y, 0), f.push(0, 0, 1), h.push(v.x, v.y);
      a = 0;
      for (c = r.length; a < c; a++)
        (m = r[a]), d.push(m[0] + k, m[1] + k, m[2] + k), (l += 3);
    }
    F.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = { shapes: a, curveSegments: b };
    b = b || 12;
    var d = [],
      e = [],
      f = [],
      h = [],
      k = 0,
      l = 0;
    if (!1 === Array.isArray(a)) c(a);
    else
      for (var m = 0; m < a.length; m++)
        c(a[m]), this.addGroup(k, l, m), (k += l), (l = 0);
    this.setIndex(d);
    this.addAttribute("position", new O(e, 3));
    this.addAttribute("normal", new O(f, 3));
    this.addAttribute("uv", new O(h, 2));
  }
  function Tl(a, b) {
    b.shapes = [];
    if (Array.isArray(a))
      for (var c = 0, d = a.length; c < d; c++) b.shapes.push(a[c].uuid);
    else b.shapes.push(a.uuid);
    return b;
  }
  function Wg(a, b) {
    F.call(this);
    this.type = "EdgesGeometry";
    this.parameters = { thresholdAngle: b };
    var c = [];
    b = Math.cos(ca.DEG2RAD * (void 0 !== b ? b : 1));
    var d = [0, 0],
      e = {},
      f = ["a", "b", "c"];
    if (a.isBufferGeometry) {
      var h = new W();
      h.fromBufferGeometry(a);
    } else h = a.clone();
    h.mergeVertices();
    h.computeFaceNormals();
    a = h.vertices;
    h = h.faces;
    for (var k = 0, l = h.length; k < l; k++)
      for (var m = h[k], n = 0; 3 > n; n++) {
        var q = m[f[n]];
        var t = m[f[(n + 1) % 3]];
        d[0] = Math.min(q, t);
        d[1] = Math.max(q, t);
        q = d[0] + "," + d[1];
        void 0 === e[q]
          ? (e[q] = { index1: d[0], index2: d[1], face1: k, face2: void 0 })
          : (e[q].face2 = k);
      }
    for (q in e)
      if (
        ((d = e[q]),
        void 0 === d.face2 || h[d.face1].normal.dot(h[d.face2].normal) <= b)
      )
        (f = a[d.index1]),
          c.push(f.x, f.y, f.z),
          (f = a[d.index2]),
          c.push(f.x, f.y, f.z);
    this.addAttribute("position", new O(c, 3));
  }
  function xc(a, b, c, d, e, f, h, k) {
    W.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop: a,
      radiusBottom: b,
      height: c,
      radialSegments: d,
      heightSegments: e,
      openEnded: f,
      thetaStart: h,
      thetaLength: k
    };
    this.fromBufferGeometry(new fe(a, b, c, d, e, f, h, k));
    this.mergeVertices();
  }
  function fe(a, b, c, d, e, f, h, k) {
    function l(c) {
      var e,
        f = new E(),
        l = new r(),
        v = 0,
        z = !0 === c ? a : b,
        L = !0 === c ? 1 : -1;
      var O = u;
      for (e = 1; e <= d; e++)
        q.push(0, A * L, 0), t.push(0, L, 0), y.push(0.5, 0.5), u++;
      var J = u;
      for (e = 0; e <= d; e++) {
        var va = (e / d) * k + h,
          D = Math.cos(va);
        va = Math.sin(va);
        l.x = z * va;
        l.y = A * L;
        l.z = z * D;
        q.push(l.x, l.y, l.z);
        t.push(0, L, 0);
        f.x = 0.5 * D + 0.5;
        f.y = 0.5 * va * L + 0.5;
        y.push(f.x, f.y);
        u++;
      }
      for (e = 0; e < d; e++)
        (f = O + e),
          (l = J + e),
          !0 === c ? n.push(l, l + 1, f) : n.push(l + 1, l, f),
          (v += 3);
      m.addGroup(C, v, !0 === c ? 1 : 2);
      C += v;
    }
    F.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {
      radiusTop: a,
      radiusBottom: b,
      height: c,
      radialSegments: d,
      heightSegments: e,
      openEnded: f,
      thetaStart: h,
      thetaLength: k
    };
    var m = this;
    a = void 0 !== a ? a : 1;
    b = void 0 !== b ? b : 1;
    c = c || 1;
    d = Math.floor(d) || 8;
    e = Math.floor(e) || 1;
    f = void 0 !== f ? f : !1;
    h = void 0 !== h ? h : 0;
    k = void 0 !== k ? k : 2 * Math.PI;
    var n = [],
      q = [],
      t = [],
      y = [],
      u = 0,
      v = [],
      A = c / 2,
      C = 0;
    (function() {
      var f,
        l,
        N = new r(),
        B = new r(),
        M = 0,
        E = (b - a) / c;
      for (l = 0; l <= e; l++) {
        var L = [],
          O = l / e,
          J = O * (b - a) + a;
        for (f = 0; f <= d; f++) {
          var va = f / d,
            D = va * k + h,
            F = Math.sin(D);
          D = Math.cos(D);
          B.x = J * F;
          B.y = -O * c + A;
          B.z = J * D;
          q.push(B.x, B.y, B.z);
          N.set(F, E, D).normalize();
          t.push(N.x, N.y, N.z);
          y.push(va, 1 - O);
          L.push(u++);
        }
        v.push(L);
      }
      for (f = 0; f < d; f++)
        for (l = 0; l < e; l++)
          (N = v[l + 1][f]),
            (B = v[l + 1][f + 1]),
            (E = v[l][f + 1]),
            n.push(v[l][f], N, E),
            n.push(N, B, E),
            (M += 6);
      m.addGroup(C, M, 0);
      C += M;
    })();
    !1 === f && (0 < a && l(!0), 0 < b && l(!1));
    this.setIndex(n);
    this.addAttribute("position", new O(q, 3));
    this.addAttribute("normal", new O(t, 3));
    this.addAttribute("uv", new O(y, 2));
  }
  function Xg(a, b, c, d, e, f, h) {
    xc.call(this, 0, a, b, c, d, e, f, h);
    this.type = "ConeGeometry";
    this.parameters = {
      radius: a,
      height: b,
      radialSegments: c,
      heightSegments: d,
      openEnded: e,
      thetaStart: f,
      thetaLength: h
    };
  }
  function mi(a, b, c, d, e, f, h) {
    fe.call(this, 0, a, b, c, d, e, f, h);
    this.type = "ConeBufferGeometry";
    this.parameters = {
      radius: a,
      height: b,
      radialSegments: c,
      heightSegments: d,
      openEnded: e,
      thetaStart: f,
      thetaLength: h
    };
  }
  function Yg(a, b, c, d) {
    W.call(this);
    this.type = "CircleGeometry";
    this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };
    this.fromBufferGeometry(new Yf(a, b, c, d));
    this.mergeVertices();
  }
  function Yf(a, b, c, d) {
    F.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };
    a = a || 1;
    b = void 0 !== b ? Math.max(3, b) : 8;
    c = void 0 !== c ? c : 0;
    d = void 0 !== d ? d : 2 * Math.PI;
    var e = [],
      f = [],
      h = [],
      k = [],
      l,
      m = new r(),
      n = new E();
    f.push(0, 0, 0);
    h.push(0, 0, 1);
    k.push(0.5, 0.5);
    var q = 0;
    for (l = 3; q <= b; q++, l += 3) {
      var t = c + (q / b) * d;
      m.x = a * Math.cos(t);
      m.y = a * Math.sin(t);
      f.push(m.x, m.y, m.z);
      h.push(0, 0, 1);
      n.x = (f[l] / a + 1) / 2;
      n.y = (f[l + 1] / a + 1) / 2;
      k.push(n.x, n.y);
    }
    for (l = 1; l <= b; l++) e.push(l, l + 1, 0);
    this.setIndex(e);
    this.addAttribute("position", new O(f, 3));
    this.addAttribute("normal", new O(h, 3));
    this.addAttribute("uv", new O(k, 2));
  }
  function yc(a) {
    T.call(this);
    this.type = "ShadowMaterial";
    this.color = new L(0);
    this.transparent = !0;
    this.setValues(a);
  }
  function pd(a) {
    Pa.call(this, a);
    this.type = "RawShaderMaterial";
  }
  function zc(a) {
    T.call(this);
    this.defines = { STANDARD: "" };
    this.type = "MeshStandardMaterial";
    this.color = new L(16777215);
    this.metalness = this.roughness = 0.5;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new L(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new E(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a);
  }
  function Vb(a) {
    zc.call(this);
    this.defines = { STANDARD: "", PHYSICAL: "" };
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = 0.5;
    this.clearcoatRoughness = this.clearcoat = 0;
    this.sheen = null;
    this.clearcoatNormalScale = new E(1, 1);
    this.clearcoatNormalMap = null;
    this.transparency = 0;
    this.setValues(a);
  }
  function Ac(a) {
    T.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new L(16777215);
    this.specular = new L(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new L(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new E(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a);
  }
  function Bc(a) {
    Ac.call(this);
    this.defines = { TOON: "" };
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(a);
  }
  function Wb(a) {
    T.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new E(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.fog = !1;
    this.setValues(a);
  }
  function bf(a) {
    T.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new L(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new L(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a);
  }
  function Cc(a) {
    T.call(this);
    this.defines = { MATCAP: "" };
    this.type = "MeshMatcapMaterial";
    this.color = new L(16777215);
    this.bumpMap = this.map = this.matcap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new E(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a);
  }
  function Dc(a) {
    qa.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(a);
  }
  function Gb(a, b, c, d) {
    this.parameterPositions = a;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
    this.sampleValues = b;
    this.valueSize = c;
  }
  function ni(a, b, c, d) {
    Gb.call(this, a, b, c, d);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function cf(a, b, c, d) {
    Gb.call(this, a, b, c, d);
  }
  function oi(a, b, c, d) {
    Gb.call(this, a, b, c, d);
  }
  function kb(a, b, c, d) {
    if (void 0 === a)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === b || 0 === b.length)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
    this.name = a;
    this.times = Wa.convertArray(b, this.TimeBufferType);
    this.values = Wa.convertArray(c, this.ValueBufferType);
    this.setInterpolation(d || this.DefaultInterpolation);
  }
  function Zg(a, b, c) {
    kb.call(this, a, b, c);
  }
  function Ej(a, b, c, d) {
    kb.call(this, a, b, c, d);
  }
  function qd(a, b, c, d) {
    kb.call(this, a, b, c, d);
  }
  function Fj(a, b, c, d) {
    Gb.call(this, a, b, c, d);
  }
  function pi(a, b, c, d) {
    kb.call(this, a, b, c, d);
  }
  function Gj(a, b, c, d) {
    kb.call(this, a, b, c, d);
  }
  function ge(a, b, c, d) {
    kb.call(this, a, b, c, d);
  }
  function Xb(a, b, c) {
    this.name = a;
    this.tracks = c;
    this.duration = void 0 !== b ? b : -1;
    this.uuid = ca.generateUUID();
    0 > this.duration && this.resetDuration();
  }
  function Oo(a) {
    switch (a.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return qd;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ge;
      case "color":
        return Ej;
      case "quaternion":
        return pi;
      case "bool":
      case "boolean":
        return Zg;
      case "string":
        return Gj;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
  }
  function Po(a) {
    if (void 0 === a.type)
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var b = Oo(a.type);
    if (void 0 === a.times) {
      var c = [],
        d = [];
      Wa.flattenJSON(a.keys, c, d, "value");
      a.times = c;
      a.values = d;
    }
    return void 0 !== b.parse
      ? b.parse(a)
      : new b(a.name, a.times, a.values, a.interpolation);
  }
  function Ul(a, b, c) {
    var d = this,
      e = !1,
      f = 0,
      h = 0,
      k = void 0,
      l = [];
    this.onStart = void 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function(a) {
      h++;
      if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, h);
      e = !0;
    };
    this.itemEnd = function(a) {
      f++;
      if (void 0 !== d.onProgress) d.onProgress(a, f, h);
      if (f === h && ((e = !1), void 0 !== d.onLoad)) d.onLoad();
    };
    this.itemError = function(a) {
      if (void 0 !== d.onError) d.onError(a);
    };
    this.resolveURL = function(a) {
      return k ? k(a) : a;
    };
    this.setURLModifier = function(a) {
      k = a;
      return this;
    };
    this.addHandler = function(a, b) {
      l.push(a, b);
      return this;
    };
    this.removeHandler = function(a) {
      a = l.indexOf(a);
      -1 !== a && l.splice(a, 2);
      return this;
    };
    this.getHandler = function(a) {
      for (var b = 0, c = l.length; b < c; b += 2) {
        var d = l[b + 1];
        if (l[b].test(a)) return d;
      }
      return null;
    };
  }
  function sa(a) {
    this.manager = void 0 !== a ? a : Qo;
    this.crossOrigin = "anonymous";
    this.resourcePath = this.path = "";
  }
  function Ec(a) {
    sa.call(this, a);
  }
  function Vl(a) {
    sa.call(this, a);
  }
  function Wl(a) {
    sa.call(this, a);
  }
  function Xl(a) {
    sa.call(this, a);
  }
  function he(a) {
    sa.call(this, a);
  }
  function qi(a) {
    sa.call(this, a);
  }
  function $g(a) {
    sa.call(this, a);
  }
  function V() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  function Hb(a, b, c, d, e, f, h, k) {
    V.call(this);
    this.type = "EllipseCurve";
    this.aX = a || 0;
    this.aY = b || 0;
    this.xRadius = c || 1;
    this.yRadius = d || 1;
    this.aStartAngle = e || 0;
    this.aEndAngle = f || 2 * Math.PI;
    this.aClockwise = h || !1;
    this.aRotation = k || 0;
  }
  function ie(a, b, c, d, e, f) {
    Hb.call(this, a, b, c, c, d, e, f);
    this.type = "ArcCurve";
  }
  function ah() {
    var a = 0,
      b = 0,
      c = 0,
      d = 0;
    return {
      initCatmullRom: function(e, f, h, k, l) {
        e = l * (h - e);
        k = l * (k - f);
        a = f;
        b = e;
        c = -3 * f + 3 * h - 2 * e - k;
        d = 2 * f - 2 * h + e + k;
      },
      initNonuniformCatmullRom: function(e, f, h, k, l, m, n) {
        e = ((f - e) / l - (h - e) / (l + m) + (h - f) / m) * m;
        k = ((h - f) / m - (k - f) / (m + n) + (k - h) / n) * m;
        a = f;
        b = e;
        c = -3 * f + 3 * h - 2 * e - k;
        d = 2 * f - 2 * h + e + k;
      },
      calc: function(e) {
        var f = e * e;
        return a + b * e + c * f + d * f * e;
      }
    };
  }
  function Yb(a, b, c, d) {
    V.call(this);
    this.type = "CatmullRomCurve3";
    this.points = a || [];
    this.closed = b || !1;
    this.curveType = c || "centripetal";
    this.tension = d || 0.5;
  }
  function Yl(a, b, c, d, e) {
    b = 0.5 * (d - b);
    e = 0.5 * (e - c);
    var f = a * a;
    return (
      (2 * c - 2 * d + b + e) * a * f +
      (-3 * c + 3 * d - 2 * b - e) * f +
      b * a +
      c
    );
  }
  function df(a, b, c, d) {
    var e = 1 - a;
    return e * e * b + 2 * (1 - a) * a * c + a * a * d;
  }
  function je(a, b, c, d, e) {
    var f = 1 - a,
      h = 1 - a;
    return (
      f * f * f * b +
      3 * h * h * a * c +
      3 * (1 - a) * a * a * d +
      a * a * a * e
    );
  }
  function Fc(a, b, c, d) {
    V.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = a || new E();
    this.v1 = b || new E();
    this.v2 = c || new E();
    this.v3 = d || new E();
  }
  function Gc(a, b, c, d) {
    V.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = a || new r();
    this.v1 = b || new r();
    this.v2 = c || new r();
    this.v3 = d || new r();
  }
  function zb(a, b) {
    V.call(this);
    this.type = "LineCurve";
    this.v1 = a || new E();
    this.v2 = b || new E();
  }
  function Hc(a, b) {
    V.call(this);
    this.type = "LineCurve3";
    this.v1 = a || new r();
    this.v2 = b || new r();
  }
  function Ic(a, b, c) {
    V.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = a || new E();
    this.v1 = b || new E();
    this.v2 = c || new E();
  }
  function Ib(a, b, c) {
    V.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = a || new r();
    this.v1 = b || new r();
    this.v2 = c || new r();
  }
  function Jc(a) {
    V.call(this);
    this.type = "SplineCurve";
    this.points = a || [];
  }
  function ke() {
    V.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = !1;
  }
  function Kc(a) {
    ke.call(this);
    this.type = "Path";
    this.currentPoint = new E();
    a && this.setFromPoints(a);
  }
  function rd(a) {
    Kc.call(this, a);
    this.uuid = ca.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  function da(a, b) {
    D.call(this);
    this.type = "Light";
    this.color = new L(a);
    this.intensity = void 0 !== b ? b : 1;
    this.receiveShadow = void 0;
  }
  function bh(a, b, c) {
    da.call(this, a, c);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new L(b);
  }
  function sd(a) {
    this.camera = a;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new E(512, 512);
    this.mapPass = this.map = null;
    this.matrix = new fa();
    this._frustum = new Fg();
    this._frameExtents = new E(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Ca(0, 0, 1, 1)];
  }
  function ch() {
    sd.call(this, new Ua(50, 1, 0.5, 500));
  }
  function dh(a, b, c, d, e, f) {
    da.call(this, a, b);
    this.type = "SpotLight";
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.target = new D();
    Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(a) {
        this.intensity = a / Math.PI;
      }
    });
    this.distance = void 0 !== c ? c : 0;
    this.angle = void 0 !== d ? d : Math.PI / 3;
    this.penumbra = void 0 !== e ? e : 0;
    this.decay = void 0 !== f ? f : 1;
    this.shadow = new ch();
  }
  function eh() {
    sd.call(this, new Ua(90, 1, 0.5, 500));
    this._frameExtents = new E(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Ca(2, 1, 1, 1),
      new Ca(0, 1, 1, 1),
      new Ca(3, 1, 1, 1),
      new Ca(1, 1, 1, 1),
      new Ca(3, 0, 1, 1),
      new Ca(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new r(1, 0, 0),
      new r(-1, 0, 0),
      new r(0, 0, 1),
      new r(0, 0, -1),
      new r(0, 1, 0),
      new r(0, -1, 0)
    ];
    this._cubeUps = [
      new r(0, 1, 0),
      new r(0, 1, 0),
      new r(0, 1, 0),
      new r(0, 1, 0),
      new r(0, 0, 1),
      new r(0, 0, -1)
    ];
  }
  function Hj(a, b, c, d) {
    da.call(this, a, b);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
      get: function() {
        return 4 * this.intensity * Math.PI;
      },
      set: function(a) {
        this.intensity = a / (4 * Math.PI);
      }
    });
    this.distance = void 0 !== c ? c : 0;
    this.decay = void 0 !== d ? d : 1;
    this.shadow = new eh();
  }
  function Zf(a, b, c, d, e, f) {
    oc.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = void 0 !== a ? a : -1;
    this.right = void 0 !== b ? b : 1;
    this.top = void 0 !== c ? c : 1;
    this.bottom = void 0 !== d ? d : -1;
    this.near = void 0 !== e ? e : 0.1;
    this.far = void 0 !== f ? f : 2e3;
    this.updateProjectionMatrix();
  }
  function ri() {
    sd.call(this, new Zf(-5, 5, 5, -5, 0.5, 500));
  }
  function si(a, b) {
    da.call(this, a, b);
    this.type = "DirectionalLight";
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.target = new D();
    this.shadow = new ri();
  }
  function fh(a, b) {
    da.call(this, a, b);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  function ti(a, b, c, d) {
    da.call(this, a, b);
    this.type = "RectAreaLight";
    this.width = void 0 !== c ? c : 10;
    this.height = void 0 !== d ? d : 10;
  }
  function ui(a) {
    sa.call(this, a);
    this.textures = {};
  }
  function vi() {
    F.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  function Ij(a, b, c, d) {
    "number" === typeof c &&
      ((d = c),
      (c = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      ));
    ba.call(this, a, b, c);
    this.meshPerAttribute = d || 1;
  }
  function wi(a) {
    sa.call(this, a);
  }
  function Jj(a) {
    sa.call(this, a);
  }
  function Zl(a) {
    "undefined" === typeof createImageBitmap &&
      console.warn(
        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
      );
    "undefined" === typeof fetch &&
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    sa.call(this, a);
    this.options = void 0;
  }
  function $l() {
    this.type = "ShapePath";
    this.color = new L();
    this.subPaths = [];
    this.currentPath = null;
  }
  function am(a) {
    this.type = "Font";
    this.data = a;
  }
  function bm(a) {
    sa.call(this, a);
  }
  function Kj(a) {
    sa.call(this, a);
  }
  function Lj() {
    this.coefficients = [];
    for (var a = 0; 9 > a; a++) this.coefficients.push(new r());
  }
  function Lc(a, b) {
    da.call(this, void 0, b);
    this.sh = void 0 !== a ? a : new Lj();
  }
  function cm(a, b, c) {
    Lc.call(this, void 0, c);
    a = new L().set(a);
    c = new L().set(b);
    b = new r(a.r, a.g, a.b);
    a = new r(c.r, c.g, c.b);
    c = Math.sqrt(Math.PI);
    var d = c * Math.sqrt(0.75);
    this.sh.coefficients[0]
      .copy(b)
      .add(a)
      .multiplyScalar(c);
    this.sh.coefficients[1]
      .copy(b)
      .sub(a)
      .multiplyScalar(d);
  }
  function dm(a, b) {
    Lc.call(this, void 0, b);
    a = new L().set(a);
    this.sh.coefficients[0]
      .set(a.r, a.g, a.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  function Mj(a) {
    this.autoStart = void 0 !== a ? a : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1;
  }
  function em() {
    D.call(this);
    this.type = "AudioListener";
    this.context = fm.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Mj();
  }
  function td(a) {
    D.call(this);
    this.type = "Audio";
    this.listener = a;
    this.context = a.context;
    this.gain = this.context.createGain();
    this.gain.connect(a.getInput());
    this.autoplay = !1;
    this.buffer = null;
    this.detune = 0;
    this.loop = !1;
    this.offset = this.startTime = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = !1;
    this.hasPlaybackControl = !0;
    this.sourceType = "empty";
    this.filters = [];
  }
  function gm(a) {
    td.call(this, a);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  function hm(a, b) {
    this.analyser = a.context.createAnalyser();
    this.analyser.fftSize = void 0 !== b ? b : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    a.getOutput().connect(this.analyser);
  }
  function im(a, b, c) {
    this.binding = a;
    this.valueSize = c;
    a = Float64Array;
    switch (b) {
      case "quaternion":
        b = this._slerp;
        break;
      case "string":
      case "bool":
        a = Array;
        b = this._select;
        break;
      default:
        b = this._lerp;
    }
    this.buffer = new a(4 * c);
    this._mixBufferRegion = b;
    this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function jm(a, b, c) {
    c = c || Ha.parseTrackName(b);
    this._targetGroup = a;
    this._bindings = a.subscribe_(b, c);
  }
  function Ha(a, b, c) {
    this.path = b;
    this.parsedPath = c || Ha.parseTrackName(b);
    this.node = Ha.findNode(a, this.parsedPath.nodeName) || a;
    this.rootNode = a;
  }
  function km(a, b, c) {
    this._mixer = a;
    this._clip = b;
    this._localRoot = c || null;
    a = b.tracks;
    b = a.length;
    c = Array(b);
    for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) {
      var f = a[e].createInterpolant(null);
      c[e] = f;
      f.settings = d;
    }
    this._interpolantSettings = d;
    this._interpolants = c;
    this._propertyBindings = Array(b);
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = 2201;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = !1;
    this.enabled = !0;
    this.clampWhenFinished = !1;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function lm(a) {
    this._root = a;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1;
  }
  function mm(a, b, c) {
    Fb.call(this, a, b);
    this.meshPerAttribute = c || 1;
  }
  function nm(a, b) {
    return a.distance - b.distance;
  }
  function Nj(a, b, c, d) {
    if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
      a = a.children;
      d = 0;
      for (var e = a.length; d < e; d++) Nj(a[d], b, c, !0);
    }
  }
  function om(a, b) {
    this.min = void 0 !== a ? a : new E(Infinity, Infinity);
    this.max = void 0 !== b ? b : new E(-Infinity, -Infinity);
  }
  function pm(a, b) {
    this.start = void 0 !== a ? a : new r();
    this.end = void 0 !== b ? b : new r();
  }
  function xi(a) {
    D.call(this);
    this.material = a;
    this.render = function() {};
  }
  function gh(a, b, c, d) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16711680;
    d = void 0 !== d ? d : 1;
    b = 0;
    (c = this.object.geometry) && c.isGeometry
      ? (b = 3 * c.faces.length)
      : c && c.isBufferGeometry && (b = c.attributes.normal.count);
    c = new F();
    b = new O(6 * b, 3);
    c.addAttribute("position", b);
    ra.call(this, c, new qa({ color: a, linewidth: d }));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function le(a, b) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    a = new F();
    b = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var c = 0, d = 1; 32 > c; c++, d++) {
      var e = (c / 32) * Math.PI * 2,
        f = (d / 32) * Math.PI * 2;
      b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1);
    }
    a.addAttribute("position", new O(b, 3));
    b = new qa({ fog: !1 });
    this.cone = new ra(a, b);
    this.add(this.cone);
    this.update();
  }
  function qm(a) {
    var b = [];
    a && a.isBone && b.push(a);
    for (var c = 0; c < a.children.length; c++)
      b.push.apply(b, qm(a.children[c]));
    return b;
  }
  function me(a) {
    for (
      var b = qm(a),
        c = new F(),
        d = [],
        e = [],
        f = new L(0, 0, 1),
        h = new L(0, 1, 0),
        k = 0;
      k < b.length;
      k++
    ) {
      var l = b[k];
      l.parent &&
        l.parent.isBone &&
        (d.push(0, 0, 0),
        d.push(0, 0, 0),
        e.push(f.r, f.g, f.b),
        e.push(h.r, h.g, h.b));
    }
    c.addAttribute("position", new O(d, 3));
    c.addAttribute("color", new O(e, 3));
    d = new qa({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    });
    ra.call(this, c, d);
    this.root = a;
    this.bones = b;
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
  }
  function ne(a, b, c) {
    this.light = a;
    this.light.updateMatrixWorld();
    this.color = c;
    a = new de(b, 4, 2);
    b = new vb({ wireframe: !0, fog: !1 });
    oa.call(this, a, b);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function oe(a, b) {
    this.type = "RectAreaLightHelper";
    this.light = a;
    this.color = b;
    a = new F();
    a.addAttribute(
      "position",
      new O([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)
    );
    a.computeBoundingSphere();
    b = new qa({ fog: !1 });
    $a.call(this, a, b);
    a = new F();
    a.addAttribute(
      "position",
      new O([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)
    );
    a.computeBoundingSphere();
    this.add(new oa(a, new vb({ side: 1, fog: !1 })));
    this.update();
  }
  function pe(a, b, c) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = c;
    a = new Sb(b);
    a.rotateY(0.5 * Math.PI);
    this.material = new vb({ wireframe: !0, fog: !1 });
    void 0 === this.color && (this.material.vertexColors = 2);
    b = a.getAttribute("position");
    b = new Float32Array(3 * b.count);
    a.addAttribute("color", new ba(b, 3));
    this.add(new oa(a, this.material));
    this.update();
  }
  function qe(a, b) {
    this.lightProbe = a;
    this.size = b;
    a = new Pa({
      defines: { GAMMA_OUTPUT: "" },
      uniforms: {
        sh: { value: this.lightProbe.sh.coefficients },
        intensity: { value: this.lightProbe.intensity }
      },
      vertexShader:
        "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader:
        "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
    });
    b = new de(1, 32, 16);
    oa.call(this, b, a);
    this.onBeforeRender();
  }
  function Oj(a, b, c, d) {
    a = a || 10;
    b = b || 10;
    c = new L(void 0 !== c ? c : 4473924);
    d = new L(void 0 !== d ? d : 8947848);
    var e = b / 2,
      f = a / b,
      h = a / 2;
    a = [];
    for (var k = [], l = 0, m = 0, n = -h; l <= b; l++, n += f) {
      a.push(-h, 0, n, h, 0, n);
      a.push(n, 0, -h, n, 0, h);
      var q = l === e ? c : d;
      q.toArray(k, m);
      m += 3;
      q.toArray(k, m);
      m += 3;
      q.toArray(k, m);
      m += 3;
      q.toArray(k, m);
      m += 3;
    }
    b = new F();
    b.addAttribute("position", new O(a, 3));
    b.addAttribute("color", new O(k, 3));
    c = new qa({ vertexColors: 2 });
    ra.call(this, b, c);
  }
  function Pj(a, b, c, d, e, f) {
    a = a || 10;
    b = b || 16;
    c = c || 8;
    d = d || 64;
    e = new L(void 0 !== e ? e : 4473924);
    f = new L(void 0 !== f ? f : 8947848);
    var h = [],
      k = [],
      l;
    for (l = 0; l <= b; l++) {
      var m = (l / b) * 2 * Math.PI;
      var n = Math.sin(m) * a;
      m = Math.cos(m) * a;
      h.push(0, 0, 0);
      h.push(n, 0, m);
      var q = l & 1 ? e : f;
      k.push(q.r, q.g, q.b);
      k.push(q.r, q.g, q.b);
    }
    for (l = 0; l <= c; l++) {
      q = l & 1 ? e : f;
      var t = a - (a / c) * l;
      for (b = 0; b < d; b++)
        (m = (b / d) * 2 * Math.PI),
          (n = Math.sin(m) * t),
          (m = Math.cos(m) * t),
          h.push(n, 0, m),
          k.push(q.r, q.g, q.b),
          (m = ((b + 1) / d) * 2 * Math.PI),
          (n = Math.sin(m) * t),
          (m = Math.cos(m) * t),
          h.push(n, 0, m),
          k.push(q.r, q.g, q.b);
    }
    a = new F();
    a.addAttribute("position", new O(h, 3));
    a.addAttribute("color", new O(k, 3));
    h = new qa({ vertexColors: 2 });
    ra.call(this, a, h);
  }
  function re(a, b, c, d) {
    this.audio = a;
    this.range = b || 1;
    this.divisionsInnerAngle = c || 16;
    this.divisionsOuterAngle = d || 2;
    a = new F();
    b = new Float32Array(
      3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)
    );
    a.addAttribute("position", new ba(b, 3));
    b = new qa({ color: 65280 });
    c = new qa({ color: 16776960 });
    $a.call(this, a, [c, b]);
    this.update();
  }
  function hh(a, b, c, d) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16776960;
    d = void 0 !== d ? d : 1;
    b = 0;
    (c = this.object.geometry) && c.isGeometry
      ? (b = c.faces.length)
      : console.warn(
          "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
        );
    c = new F();
    b = new O(6 * b, 3);
    c.addAttribute("position", b);
    ra.call(this, c, new qa({ color: a, linewidth: d }));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function se(a, b, c) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = c;
    void 0 === b && (b = 1);
    a = new F();
    a.addAttribute(
      "position",
      new O([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)
    );
    b = new qa({ fog: !1 });
    this.lightPlane = new $a(a, b);
    this.add(this.lightPlane);
    a = new F();
    a.addAttribute("position", new O([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new $a(a, b);
    this.add(this.targetLine);
    this.update();
  }
  function ih(a) {
    function b(a, b, d) {
      c(a, d);
      c(b, d);
    }
    function c(a, b) {
      f.push(0, 0, 0);
      h.push(b.r, b.g, b.b);
      void 0 === k[a] && (k[a] = []);
      k[a].push(f.length / 3 - 1);
    }
    var d = new F(),
      e = new qa({ color: 16777215, vertexColors: 1 }),
      f = [],
      h = [],
      k = {},
      l = new L(16755200),
      m = new L(16711680),
      n = new L(43775),
      q = new L(16777215),
      t = new L(3355443);
    b("n1", "n2", l);
    b("n2", "n4", l);
    b("n4", "n3", l);
    b("n3", "n1", l);
    b("f1", "f2", l);
    b("f2", "f4", l);
    b("f4", "f3", l);
    b("f3", "f1", l);
    b("n1", "f1", l);
    b("n2", "f2", l);
    b("n3", "f3", l);
    b("n4", "f4", l);
    b("p", "n1", m);
    b("p", "n2", m);
    b("p", "n3", m);
    b("p", "n4", m);
    b("u1", "u2", n);
    b("u2", "u3", n);
    b("u3", "u1", n);
    b("c", "t", q);
    b("p", "c", t);
    b("cn1", "cn2", t);
    b("cn3", "cn4", t);
    b("cf1", "cf2", t);
    b("cf3", "cf4", t);
    d.addAttribute("position", new O(f, 3));
    d.addAttribute("color", new O(h, 3));
    ra.call(this, d, e);
    this.camera = a;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = k;
    this.update();
  }
  function Ia(a, b, c, d, e, f, h) {
    yi.set(e, f, h).unproject(d);
    a = b[a];
    if (void 0 !== a)
      for (c = c.getAttribute("position"), b = 0, d = a.length; b < d; b++)
        c.setXYZ(a[b], yi.x, yi.y, yi.z);
  }
  function Mc(a, b) {
    this.object = a;
    void 0 === b && (b = 16776960);
    a = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var c = new Float32Array(24),
      d = new F();
    d.setIndex(new ba(a, 1));
    d.addAttribute("position", new ba(c, 3));
    ra.call(this, d, new qa({ color: b }));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function zi(a, b) {
    this.type = "Box3Helper";
    this.box = a;
    b = b || 16776960;
    a = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var c = new F();
    c.setIndex(new ba(a, 1));
    c.addAttribute(
      "position",
      new O(
        [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1
        ],
        3
      )
    );
    ra.call(this, c, new qa({ color: b }));
    this.geometry.computeBoundingSphere();
  }
  function ef(a, b, c) {
    this.type = "PlaneHelper";
    this.plane = a;
    this.size = void 0 === b ? 1 : b;
    a = void 0 !== c ? c : 16776960;
    b = new F();
    b.addAttribute(
      "position",
      new O(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    );
    b.computeBoundingSphere();
    $a.call(this, b, new qa({ color: a }));
    b = new F();
    b.addAttribute(
      "position",
      new O([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    );
    b.computeBoundingSphere();
    this.add(
      new oa(
        b,
        new vb({ color: a, opacity: 0.2, transparent: !0, depthWrite: !1 })
      )
    );
  }
  function te(a, b, c, d, e, f) {
    D.call(this);
    void 0 === a && (a = new r(0, 0, 1));
    void 0 === b && (b = new r(0, 0, 0));
    void 0 === c && (c = 1);
    void 0 === d && (d = 16776960);
    void 0 === e && (e = 0.2 * c);
    void 0 === f && (f = 0.2 * e);
    void 0 === ff &&
      ((ff = new F()),
      ff.addAttribute("position", new O([0, 0, 0, 0, 1, 0], 3)),
      (Qj = new fe(0, 0.5, 1, 5, 1)),
      Qj.translate(0, -0.5, 0));
    this.position.copy(b);
    this.line = new $a(ff, new qa({ color: d }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone = new oa(Qj, new vb({ color: d }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, e, f);
  }
  function Rj(a) {
    a = a || 1;
    var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
    a = new F();
    a.addAttribute("position", new O(b, 3));
    a.addAttribute(
      "color",
      new O([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
    );
    b = new qa({ vertexColors: 2 });
    ra.call(this, a, b);
  }
  function rm(a) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    );
    Yb.call(this, a);
    this.type = "catmullrom";
  }
  function Na() {
    this.needsSwap = this.enabled = !0;
    this.renderToScreen = this.clear = !1;
  }
  var sm =
      "undefined" !== typeof globalThis
        ? globalThis
        : "undefined" !== typeof window
        ? window
        : "undefined" !== typeof global
        ? global
        : "undefined" !== typeof self
        ? self
        : {},
    nk =
      "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
        ? function(a) {
            return typeof a;
          }
        : function(a) {
            return a &&
              "function" === typeof Symbol &&
              a.constructor === Symbol &&
              a !== Symbol.prototype
              ? "symbol"
              : typeof a;
          },
    ud = function(a, b) {
      if (!(a instanceof b))
        throw new TypeError("Cannot call a class as a function");
    },
    Nc = (function() {
      function a(a, c) {
        for (var b = 0; b < c.length; b++) {
          var e = c[b];
          e.enumerable = e.enumerable || !1;
          e.configurable = !0;
          "value" in e && (e.writable = !0);
          Object.defineProperty(a, e.key, e);
        }
      }
      return function(b, c, d) {
        c && a(b.prototype, c);
        d && a(b, d);
        return b;
      };
    })(),
    ue = function(a, b) {
      if ("function" !== typeof b && null !== b)
        throw new TypeError(
          "Super expression must either be null or a function, not " + typeof b
        );
      a.prototype = Object.create(b && b.prototype, {
        constructor: {
          value: a,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      b &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(a, b)
          : (a.__proto__ = b));
    },
    ve = function(a, b) {
      if (!a)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return !b || ("object" !== typeof b && "function" !== typeof b) ? a : b;
    },
    tm = function(a) {
      if (Array.isArray(a)) {
        for (var b = 0, c = Array(a.length); b < a.length; b++) c[b] = a[b];
        return c;
      }
      return Array.from(a);
    },
    vm = ad(function(a, b) {
      (function(a, d) {
        d(b);
      })(sm, function(a) {
        function b() {}
        function c(a, b) {
          this.x = a || 0;
          this.y = b || 0;
        }
        function f(a, b, c, d) {
          this._x = a || 0;
          this._y = b || 0;
          this._z = c || 0;
          this._w = void 0 !== d ? d : 1;
        }
        function h(a, b, c) {
          this.x = a || 0;
          this.y = b || 0;
          this.z = c || 0;
        }
        function k() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          0 < arguments.length &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
        }
        function l(a, b, d, x, f, e, h, Y, m, ea) {
          Object.defineProperty(this, "id", { value: ji++ });
          this.uuid = ya.generateUUID();
          this.name = "";
          this.image = void 0 !== a ? a : l.DEFAULT_IMAGE;
          this.mipmaps = [];
          this.mapping = void 0 !== b ? b : l.DEFAULT_MAPPING;
          this.wrapS = void 0 !== d ? d : 1001;
          this.wrapT = void 0 !== x ? x : 1001;
          this.magFilter = void 0 !== f ? f : 1006;
          this.minFilter = void 0 !== e ? e : 1008;
          this.anisotropy = void 0 !== m ? m : 1;
          this.format = void 0 !== h ? h : 1023;
          this.type = void 0 !== Y ? Y : 1009;
          this.offset = new c(0, 0);
          this.repeat = new c(1, 1);
          this.center = new c(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = !0;
          this.matrix = new k();
          this.generateMipmaps = !0;
          this.premultiplyAlpha = !1;
          this.flipY = !0;
          this.unpackAlignment = 4;
          this.encoding = void 0 !== ea ? ea : 3e3;
          this.version = 0;
          this.onUpdate = null;
        }
        function m(a, b, c, d) {
          this.x = a || 0;
          this.y = b || 0;
          this.z = c || 0;
          this.w = void 0 !== d ? d : 1;
        }
        function n(a, b, c) {
          this.width = a;
          this.height = b;
          this.scissor = new m(0, 0, a, b);
          this.scissorTest = !1;
          this.viewport = new m(0, 0, a, b);
          c = c || {};
          this.texture = new l(
            void 0,
            void 0,
            c.wrapS,
            c.wrapT,
            c.magFilter,
            c.minFilter,
            c.format,
            c.type,
            c.anisotropy,
            c.encoding
          );
          this.texture.image = {};
          this.texture.image.width = a;
          this.texture.image.height = b;
          this.texture.generateMipmaps =
            void 0 !== c.generateMipmaps ? c.generateMipmaps : !1;
          this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006;
          this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
          this.stencilBuffer =
            void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
          this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
        }
        function q(a, b, c) {
          n.call(this, a, b, c);
          this.samples = 4;
        }
        function t() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          0 < arguments.length &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
        }
        function y(a, b, c, d) {
          this._x = a || 0;
          this._y = b || 0;
          this._z = c || 0;
          this._order = d || y.DefaultOrder;
        }
        function u() {
          this.mask = 1;
        }
        function v() {
          Object.defineProperty(this, "id", { value: mi++ });
          this.uuid = ya.generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = v.DefaultUp.clone();
          var a = new h(),
            b = new y(),
            c = new f(),
            d = new h(1, 1, 1);
          b._onChange(function() {
            c.setFromEuler(b, !1);
          });
          c._onChange(function() {
            b.setFromQuaternion(c, void 0, !1);
          });
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: a },
            rotation: { configurable: !0, enumerable: !0, value: b },
            quaternion: { configurable: !0, enumerable: !0, value: c },
            scale: { configurable: !0, enumerable: !0, value: d },
            modelViewMatrix: { value: new t() },
            normalMatrix: { value: new k() }
          });
          this.matrix = new t();
          this.matrixWorld = new t();
          this.matrixAutoUpdate = v.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = !1;
          this.layers = new u();
          this.visible = !0;
          this.receiveShadow = this.castShadow = !1;
          this.frustumCulled = !0;
          this.renderOrder = 0;
          this.userData = {};
        }
        function r() {
          v.call(this);
          this.type = "Scene";
          this.overrideMaterial = this.fog = this.background = null;
          this.autoUpdate = !0;
          "undefined" !== typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
        }
        function C(a, b) {
          this.min = void 0 !== a ? a : new h(Infinity, Infinity, Infinity);
          this.max = void 0 !== b ? b : new h(-Infinity, -Infinity, -Infinity);
        }
        function z(a, b, c, d, f) {
          var g;
          var p = 0;
          for (g = a.length - 3; p <= g; p += 3) {
            jh.fromArray(a, p);
            var w =
                f.x * Math.abs(jh.x) +
                f.y * Math.abs(jh.y) +
                f.z * Math.abs(jh.z),
              x = b.dot(jh),
              e = c.dot(jh),
              h = d.dot(jh);
            if (Math.max(-Math.max(x, e, h), Math.min(x, e, h)) > w) return !1;
          }
          return !0;
        }
        function H(a, b) {
          this.center = void 0 !== a ? a : new h();
          this.radius = void 0 !== b ? b : 0;
        }
        function N(a, b) {
          this.origin = void 0 !== a ? a : new h();
          this.direction = void 0 !== b ? b : new h();
        }
        function B(a, b, c) {
          this.a = void 0 !== a ? a : new h();
          this.b = void 0 !== b ? b : new h();
          this.c = void 0 !== c ? c : new h();
        }
        function M(a, b, c) {
          return void 0 === b && void 0 === c
            ? this.set(a)
            : this.setRGB(a, b, c);
        }
        function E(a, b, c) {
          0 > c && (c += 1);
          1 < c && --c;
          return c < 1 / 6
            ? a + 6 * (b - a) * c
            : 0.5 > c
            ? b
            : c < 2 / 3
            ? a + 6 * (b - a) * (2 / 3 - c)
            : a;
        }
        function L(a) {
          return 0.04045 > a
            ? 0.0773993808 * a
            : Math.pow(0.9478672986 * a + 0.0521327014, 2.4);
        }
        function O(a) {
          return 0.0031308 > a
            ? 12.92 * a
            : 1.055 * Math.pow(a, 0.41666) - 0.055;
        }
        function J(a, b, c, d, f, e) {
          this.a = a;
          this.b = b;
          this.c = c;
          this.normal = d && d.isVector3 ? d : new h();
          this.vertexNormals = Array.isArray(d) ? d : [];
          this.color = f && f.isColor ? f : new M();
          this.vertexColors = Array.isArray(f) ? f : [];
          this.materialIndex = void 0 !== e ? e : 0;
        }
        function D() {
          Object.defineProperty(this, "id", { value: sj++ });
          this.uuid = ya.generateUUID();
          this.name = "";
          this.type = "Material";
          this.fog = !0;
          this.blending = 1;
          this.side = 0;
          this.vertexTangents = this.flatShading = !1;
          this.vertexColors = 0;
          this.opacity = 1;
          this.transparent = !1;
          this.blendSrc = 204;
          this.blendDst = 205;
          this.blendEquation = 100;
          this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
          this.depthFunc = 3;
          this.depthWrite = this.depthTest = !0;
          this.stencilWriteMask = 255;
          this.stencilFunc = 519;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
          this.stencilWrite = !1;
          this.clippingPlanes = null;
          this.clipShadows = this.clipIntersection = !1;
          this.shadowSide = null;
          this.colorWrite = !0;
          this.precision = null;
          this.polygonOffset = !1;
          this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
          this.dithering = !1;
          this.alphaTest = 0;
          this.premultipliedAlpha = !1;
          this.toneMapped = this.visible = !0;
          this.userData = {};
          this.needsUpdate = !0;
        }
        function F(a) {
          D.call(this);
          this.type = "MeshBasicMaterial";
          this.color = new M(16777215);
          this.lightMap = this.map = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.envMap = this.alphaMap = this.specularMap = null;
          this.combine = 0;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.wireframeLinejoin = this.wireframeLinecap = "round";
          this.morphTargets = this.skinning = !1;
          this.setValues(a);
        }
        function I(a, b, c) {
          if (Array.isArray(a))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          this.name = "";
          this.array = a;
          this.itemSize = b;
          this.count = void 0 !== a ? a.length / b : 0;
          this.normalized = !0 === c;
          this.dynamic = !1;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
        }
        function V(a, b, c) {
          I.call(this, new Int8Array(a), b, c);
        }
        function W(a, b, c) {
          I.call(this, new Uint8Array(a), b, c);
        }
        function T(a, b, c) {
          I.call(this, new Uint8ClampedArray(a), b, c);
        }
        function ba(a, b, c) {
          I.call(this, new Int16Array(a), b, c);
        }
        function ca(a, b, c) {
          I.call(this, new Uint16Array(a), b, c);
        }
        function ha(a, b, c) {
          I.call(this, new Int32Array(a), b, c);
        }
        function fa(a, b, c) {
          I.call(this, new Uint32Array(a), b, c);
        }
        function P(a, b, c) {
          I.call(this, new Float32Array(a), b, c);
        }
        function ja(a, b, c) {
          I.call(this, new Float64Array(a), b, c);
        }
        function ra() {
          this.vertices = [];
          this.normals = [];
          this.colors = [];
          this.uvs = [];
          this.uvs2 = [];
          this.groups = [];
          this.morphTargets = {};
          this.skinWeights = [];
          this.skinIndices = [];
          this.boundingSphere = this.boundingBox = null;
          this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
        }
        function sa(a) {
          if (0 === a.length) return -Infinity;
          for (var g = a[0], b = 1, c = a.length; b < c; ++b)
            a[b] > g && (g = a[b]);
          return g;
        }
        function S() {
          Object.defineProperty(this, "id", { value: (tj += 2) });
          this.uuid = ya.generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingSphere = this.boundingBox = null;
          this.drawRange = { start: 0, count: Infinity };
          this.userData = {};
        }
        function da(a, b) {
          v.call(this);
          this.type = "Mesh";
          this.geometry = void 0 !== a ? a : new S();
          this.material =
            void 0 !== b ? b : new F({ color: 16777215 * Math.random() });
          this.drawMode = 0;
          this.updateMorphTargets();
        }
        function X(a, b, c, d, f, e, h, k) {
          if (
            null ===
            (1 === b.side
              ? d.intersectTriangle(h, e, f, !0, k)
              : d.intersectTriangle(f, e, h, 2 !== b.side, k))
          )
            return null;
          Hf.copy(k);
          Hf.applyMatrix4(a.matrixWorld);
          b = c.ray.origin.distanceTo(Hf);
          return b < c.near || b > c.far
            ? null
            : { distance: b, point: Hf.clone(), object: a };
        }
        function ma(a, b, d, x, f, e, h, k, l, m, n) {
          kh.fromBufferAttribute(f, l);
          lh.fromBufferAttribute(f, m);
          mh.fromBufferAttribute(f, n);
          f = a.morphTargetInfluences;
          if (b.morphTargets && e && f) {
            yg.set(0, 0, 0);
            Ag.set(0, 0, 0);
            Bg.set(0, 0, 0);
            for (var g = 0, p = e.length; g < p; g++) {
              var w = f[g],
                K = e[g];
              0 !== w &&
                (Ph.fromBufferAttribute(K, l),
                Qh.fromBufferAttribute(K, m),
                Rh.fromBufferAttribute(K, n),
                yg.addScaledVector(Ph.sub(kh), w),
                Ag.addScaledVector(Qh.sub(lh), w),
                Bg.addScaledVector(Rh.sub(mh), w));
            }
            kh.add(yg);
            lh.add(Ag);
            mh.add(Bg);
          }
          if ((a = X(a, b, d, x, kh, lh, mh, Sj)))
            h &&
              (Ai.fromBufferAttribute(h, l),
              Bi.fromBufferAttribute(h, m),
              Ci.fromBufferAttribute(h, n),
              (a.uv = B.getUV(Sj, kh, lh, mh, Ai, Bi, Ci, new c()))),
              k &&
                (Ai.fromBufferAttribute(k, l),
                Bi.fromBufferAttribute(k, m),
                Ci.fromBufferAttribute(k, n),
                (a.uv2 = B.getUV(Sj, kh, lh, mh, Ai, Bi, Ci, new c()))),
              (h = new J(l, m, n)),
              B.getNormal(kh, lh, mh, h.normal),
              (a.face = h);
          return a;
        }
        function U() {
          Object.defineProperty(this, "id", { value: (uj += 2) });
          this.uuid = ya.generateUUID();
          this.name = "";
          this.type = "Geometry";
          this.vertices = [];
          this.colors = [];
          this.faces = [];
          this.faceVertexUvs = [[]];
          this.morphTargets = [];
          this.morphNormals = [];
          this.skinWeights = [];
          this.skinIndices = [];
          this.lineDistances = [];
          this.boundingSphere = this.boundingBox = null;
          this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
        }
        function Ba(a) {
          var g = {},
            b;
          for (b in a) {
            g[b] = {};
            for (var c in a[b]) {
              var d = a[b][c];
              d &&
              (d.isColor ||
                d.isMatrix3 ||
                d.isMatrix4 ||
                d.isVector2 ||
                d.isVector3 ||
                d.isVector4 ||
                d.isTexture)
                ? (g[b][c] = d.clone())
                : Array.isArray(d)
                ? (g[b][c] = d.slice())
                : (g[b][c] = d);
            }
          }
          return g;
        }
        function pa(a) {
          for (var g = {}, b = 0; b < a.length; b++) {
            var c = Ba(a[b]),
              d;
            for (d in c) g[d] = c[d];
          }
          return g;
        }
        function qa(a) {
          D.call(this);
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
          this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
          this.linewidth = 1;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
          this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
          };
          this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = !1;
          void 0 !== a &&
            (void 0 !== a.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(a));
        }
        function ua() {
          v.call(this);
          this.type = "Camera";
          this.matrixWorldInverse = new t();
          this.projectionMatrix = new t();
          this.projectionMatrixInverse = new t();
        }
        function Da(a, b, c, d) {
          ua.call(this);
          this.type = "PerspectiveCamera";
          this.fov = void 0 !== a ? a : 50;
          this.zoom = 1;
          this.near = void 0 !== c ? c : 0.1;
          this.far = void 0 !== d ? d : 2e3;
          this.focus = 10;
          this.aspect = void 0 !== b ? b : 1;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        function Ca(a, b, c, d) {
          v.call(this);
          this.type = "CubeCamera";
          var g = new Da(90, 1, a, b);
          g.up.set(0, -1, 0);
          g.lookAt(new h(1, 0, 0));
          this.add(g);
          var p = new Da(90, 1, a, b);
          p.up.set(0, -1, 0);
          p.lookAt(new h(-1, 0, 0));
          this.add(p);
          var w = new Da(90, 1, a, b);
          w.up.set(0, 0, 1);
          w.lookAt(new h(0, 1, 0));
          this.add(w);
          var x = new Da(90, 1, a, b);
          x.up.set(0, 0, -1);
          x.lookAt(new h(0, -1, 0));
          this.add(x);
          var f = new Da(90, 1, a, b);
          f.up.set(0, -1, 0);
          f.lookAt(new h(0, 0, 1));
          this.add(f);
          var e = new Da(90, 1, a, b);
          e.up.set(0, -1, 0);
          e.lookAt(new h(0, 0, -1));
          this.add(e);
          d = d || { format: 1022, magFilter: 1006, minFilter: 1006 };
          this.renderTarget = new oa(c, c, d);
          this.renderTarget.texture.name = "CubeCamera";
          this.update = function(a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = a.getRenderTarget(),
              d = this.renderTarget,
              h = d.texture.generateMipmaps;
            d.texture.generateMipmaps = !1;
            a.setRenderTarget(d, 0);
            a.render(b, g);
            a.setRenderTarget(d, 1);
            a.render(b, p);
            a.setRenderTarget(d, 2);
            a.render(b, w);
            a.setRenderTarget(d, 3);
            a.render(b, x);
            a.setRenderTarget(d, 4);
            a.render(b, f);
            d.texture.generateMipmaps = h;
            a.setRenderTarget(d, 5);
            a.render(b, e);
            a.setRenderTarget(c);
          };
          this.clear = function(a, g, b, c) {
            for (
              var p = a.getRenderTarget(), d = this.renderTarget, w = 0;
              6 > w;
              w++
            )
              a.setRenderTarget(d, w), a.clear(g, b, c);
            a.setRenderTarget(p);
          };
        }
        function oa(a, b, c) {
          n.call(this, a, b, c);
        }
        function Ia(a, b, c, d, f, e, h, k, m, ea, n, q) {
          l.call(this, null, e, h, k, m, ea, d, f, n, q);
          this.image = { data: a || null, width: b || 1, height: c || 1 };
          this.magFilter = void 0 !== m ? m : 1003;
          this.minFilter = void 0 !== ea ? ea : 1003;
          this.flipY = this.generateMipmaps = !1;
          this.unpackAlignment = 1;
          this.needsUpdate = !0;
        }
        function ta(a, b) {
          this.normal = void 0 !== a ? a : new h(1, 0, 0);
          this.constant = void 0 !== b ? b : 0;
        }
        function Q(a, b, c, d, f, e) {
          this.planes = [
            void 0 !== a ? a : new ta(),
            void 0 !== b ? b : new ta(),
            void 0 !== c ? c : new ta(),
            void 0 !== d ? d : new ta(),
            void 0 !== f ? f : new ta(),
            void 0 !== e ? e : new ta()
          ];
        }
        function Ma() {
          function a(g, p) {
            !1 !== c && (d(g, p), b.requestAnimationFrame(a));
          }
          var b = null,
            c = !1,
            d = null;
          return {
            start: function() {
              !0 !== c && null !== d && (b.requestAnimationFrame(a), (c = !0));
            },
            stop: function() {
              c = !1;
            },
            setAnimationLoop: function(a) {
              d = a;
            },
            setContext: function(a) {
              b = a;
            }
          };
        }
        function Pa(a) {
          function g(g, b) {
            var c = g.array,
              p = g.dynamic ? 35048 : 35044,
              d = a.createBuffer();
            a.bindBuffer(b, d);
            a.bufferData(b, c, p);
            g.onUploadCallback();
            b = 5126;
            c instanceof Float32Array
              ? (b = 5126)
              : c instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : c instanceof Uint16Array
              ? (b = 5123)
              : c instanceof Int16Array
              ? (b = 5122)
              : c instanceof Uint32Array
              ? (b = 5125)
              : c instanceof Int32Array
              ? (b = 5124)
              : c instanceof Int8Array
              ? (b = 5120)
              : c instanceof Uint8Array && (b = 5121);
            return {
              buffer: d,
              type: b,
              bytesPerElement: c.BYTES_PER_ELEMENT,
              version: g.version
            };
          }
          var b = new WeakMap();
          return {
            get: function(a) {
              a.isInterleavedBufferAttribute && (a = a.data);
              return b.get(a);
            },
            remove: function(g) {
              g.isInterleavedBufferAttribute && (g = g.data);
              var c = b.get(g);
              c && (a.deleteBuffer(c.buffer), b.delete(g));
            },
            update: function(c, p) {
              c.isInterleavedBufferAttribute && (c = c.data);
              var d = b.get(c);
              if (void 0 === d) b.set(c, g(c, p));
              else if (d.version < c.version) {
                var w = c,
                  x = w.array,
                  f = w.updateRange;
                a.bindBuffer(p, d.buffer);
                !1 === w.dynamic
                  ? a.bufferData(p, x, 35044)
                  : -1 === f.count
                  ? a.bufferSubData(p, 0, x)
                  : 0 === f.count
                  ? console.error(
                      "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                    )
                  : (a.bufferSubData(
                      p,
                      f.offset * x.BYTES_PER_ELEMENT,
                      x.subarray(f.offset, f.offset + f.count)
                    ),
                    (f.count = -1));
                d.version = c.version;
              }
            }
          };
        }
        function ka(a, b, c, d) {
          U.call(this);
          this.type = "PlaneGeometry";
          this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
          };
          this.fromBufferGeometry(new Aa(a, b, c, d));
          this.mergeVertices();
        }
        function Aa(a, b, c, d) {
          S.call(this);
          this.type = "PlaneBufferGeometry";
          this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
          };
          a = a || 1;
          b = b || 1;
          var g = a / 2,
            p = b / 2;
          c = Math.floor(c) || 1;
          d = Math.floor(d) || 1;
          var w = c + 1,
            x = d + 1,
            f = a / c,
            e = b / d,
            h = [],
            k = [],
            l = [],
            m = [];
          for (a = 0; a < x; a++) {
            var n = a * e - p;
            for (b = 0; b < w; b++)
              k.push(b * f - g, -n, 0),
                l.push(0, 0, 1),
                m.push(b / c),
                m.push(1 - a / d);
          }
          for (a = 0; a < d; a++)
            for (b = 0; b < c; b++)
              (g = b + w * (a + 1)),
                (p = b + 1 + w * (a + 1)),
                (x = b + 1 + w * a),
                h.push(b + w * a, g, x),
                h.push(g, p, x);
          this.setIndex(h);
          this.addAttribute("position", new P(k, 3));
          this.addAttribute("normal", new P(l, 3));
          this.addAttribute("uv", new P(m, 2));
        }
        function Sa(a, b, c, d) {
          function g(a, g) {
            b.buffers.color.setClear(a.r, a.g, a.b, g, d);
          }
          var p = new M(0),
            w = 0,
            x,
            f,
            e = null,
            h = 0;
          return {
            getClearColor: function() {
              return p;
            },
            setClearColor: function(a, b) {
              p.set(a);
              w = void 0 !== b ? b : 1;
              g(p, w);
            },
            getClearAlpha: function() {
              return w;
            },
            setClearAlpha: function(a) {
              w = a;
              g(p, w);
            },
            render: function(b, d, K, k) {
              d = d.background;
              K = a.vr;
              (K = K.getSession && K.getSession()) &&
                "additive" === K.environmentBlendMode &&
                (d = null);
              null === d
                ? (g(p, w), (e = null), (h = 0))
                : d && d.isColor && (g(d, 1), (k = !0), (e = null), (h = 0));
              (a.autoClear || k) &&
                a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
              if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
                void 0 === f &&
                  ((f = new da(
                    new Tj(1, 1, 1),
                    new qa({
                      type: "BackgroundCubeMaterial",
                      uniforms: Ba(we.cube.uniforms),
                      vertexShader: we.cube.vertexShader,
                      fragmentShader: we.cube.fragmentShader,
                      side: 1,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1
                    })
                  )),
                  f.geometry.removeAttribute("normal"),
                  f.geometry.removeAttribute("uv"),
                  (f.onBeforeRender = function(a, g, b) {
                    this.matrixWorld.copyPosition(b.matrixWorld);
                  }),
                  Object.defineProperty(f.material, "map", {
                    get: function() {
                      return this.uniforms.tCube.value;
                    }
                  }),
                  c.update(f));
                k = d.isWebGLRenderTargetCube ? d.texture : d;
                f.material.uniforms.tCube.value = k;
                f.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube
                  ? 1
                  : -1;
                if (e !== d || h !== k.version)
                  (f.material.needsUpdate = !0), (e = d), (h = k.version);
                b.unshift(f, f.geometry, f.material, 0, 0, null);
              } else if (d && d.isTexture) {
                void 0 === x &&
                  ((x = new da(
                    new Aa(2, 2),
                    new qa({
                      type: "BackgroundMaterial",
                      uniforms: Ba(we.background.uniforms),
                      vertexShader: we.background.vertexShader,
                      fragmentShader: we.background.fragmentShader,
                      side: 0,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1
                    })
                  )),
                  x.geometry.removeAttribute("normal"),
                  Object.defineProperty(x.material, "map", {
                    get: function() {
                      return this.uniforms.t2D.value;
                    }
                  }),
                  c.update(x));
                x.material.uniforms.t2D.value = d;
                !0 === d.matrixAutoUpdate && d.updateMatrix();
                x.material.uniforms.uvTransform.value.copy(d.matrix);
                if (e !== d || h !== d.version)
                  (x.material.needsUpdate = !0), (e = d), (h = d.version);
                b.unshift(x, x.geometry, x.material, 0, 0, null);
              }
            }
          };
        }
        function Ta(a, b, c, d) {
          var g;
          this.setMode = function(a) {
            g = a;
          };
          this.render = function(b, p) {
            a.drawArrays(g, b, p);
            c.update(p, g);
          };
          this.renderInstances = function(p, w, x, f) {
            if (0 !== f) {
              if (d.isWebGL2) {
                p = a;
                var e = "drawArraysInstanced";
              } else if (
                ((p = b.get("ANGLE_instanced_arrays")),
                (e = "drawArraysInstancedANGLE"),
                null === p)
              ) {
                console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
                return;
              }
              p[e](g, w, x, f);
              c.update(x, g, f);
            }
          };
        }
        function Ua(a, b, c) {
          function g(g) {
            if ("highp" === g) {
              if (
                0 < a.getShaderPrecisionFormat(35633, 36338).precision &&
                0 < a.getShaderPrecisionFormat(35632, 36338).precision
              )
                return "highp";
              g = "mediump";
            }
            return "mediump" === g &&
              0 < a.getShaderPrecisionFormat(35633, 36337).precision &&
              0 < a.getShaderPrecisionFormat(35632, 36337).precision
              ? "mediump"
              : "lowp";
          }
          var p,
            d =
              "undefined" !== typeof WebGL2RenderingContext &&
              a instanceof WebGL2RenderingContext,
            w = void 0 !== c.precision ? c.precision : "highp",
            f = g(w);
          f !== w &&
            (console.warn(
              "THREE.WebGLRenderer:",
              w,
              "not supported, using",
              f,
              "instead."
            ),
            (w = f));
          c = !0 === c.logarithmicDepthBuffer;
          f = a.getParameter(34930);
          var e = a.getParameter(35660),
            h = a.getParameter(3379),
            k = a.getParameter(34076),
            l = a.getParameter(34921),
            m = a.getParameter(36347),
            n = a.getParameter(36348),
            q = a.getParameter(36349),
            t = 0 < e,
            u = d || !!b.get("OES_texture_float"),
            y = t && u,
            v = d ? a.getParameter(36183) : 0;
          return {
            isWebGL2: d,
            getMaxAnisotropy: function() {
              if (void 0 !== p) return p;
              var g = b.get("EXT_texture_filter_anisotropic");
              return (p =
                null !== g
                  ? a.getParameter(g.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                  : 0);
            },
            getMaxPrecision: g,
            precision: w,
            logarithmicDepthBuffer: c,
            maxTextures: f,
            maxVertexTextures: e,
            maxTextureSize: h,
            maxCubemapSize: k,
            maxAttributes: l,
            maxVertexUniforms: m,
            maxVaryings: n,
            maxFragmentUniforms: q,
            vertexTextures: t,
            floatFragmentTextures: u,
            floatVertexTextures: y,
            maxSamples: v
          };
        }
        function Ya() {
          function a() {
            ea.value !== d && ((ea.value = d), (ea.needsUpdate = 0 < f));
            c.numPlanes = f;
            c.numIntersection = 0;
          }
          function b(a, g, b, p) {
            var d = null !== a ? a.length : 0,
              w = null;
            if (0 !== d) {
              w = ea.value;
              if (!0 !== p || null === w) {
                p = b + 4 * d;
                g = g.matrixWorldInverse;
                m.getNormalMatrix(g);
                if (null === w || w.length < p) w = new Float32Array(p);
                for (p = 0; p !== d; ++p, b += 4)
                  l.copy(a[p]).applyMatrix4(g, m),
                    l.normal.toArray(w, b),
                    (w[b + 3] = l.constant);
              }
              ea.value = w;
              ea.needsUpdate = !0;
            }
            c.numPlanes = d;
            return w;
          }
          var c = this,
            d = null,
            f = 0,
            e = !1,
            h = !1,
            l = new ta(),
            m = new k(),
            ea = { value: null, needsUpdate: !1 };
          this.uniform = ea;
          this.numIntersection = this.numPlanes = 0;
          this.init = function(a, g, c) {
            var p = 0 !== a.length || g || 0 !== f || e;
            e = g;
            d = b(a, c, 0);
            f = a.length;
            return p;
          };
          this.beginShadows = function() {
            h = !0;
            b(null);
          };
          this.endShadows = function() {
            h = !1;
            a();
          };
          this.setState = function(g, c, p, w, x, K) {
            if (!e || null === g || 0 === g.length || (h && !p))
              h ? b(null) : a();
            else {
              p = h ? 0 : f;
              var k = 4 * p,
                G = x.clippingState || null;
              ea.value = G;
              G = b(g, w, k, K);
              for (g = 0; g !== k; ++g) G[g] = d[g];
              x.clippingState = G;
              this.numIntersection = c ? this.numPlanes : 0;
              this.numPlanes += p;
            }
          };
        }
        function Za(a) {
          var g = {};
          return {
            get: function(b) {
              if (void 0 !== g[b]) return g[b];
              switch (b) {
                case "WEBGL_depth_texture":
                  var c =
                    a.getExtension("WEBGL_depth_texture") ||
                    a.getExtension("MOZ_WEBGL_depth_texture") ||
                    a.getExtension("WEBKIT_WEBGL_depth_texture");
                  break;
                case "EXT_texture_filter_anisotropic":
                  c =
                    a.getExtension("EXT_texture_filter_anisotropic") ||
                    a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                  break;
                case "WEBGL_compressed_texture_s3tc":
                  c =
                    a.getExtension("WEBGL_compressed_texture_s3tc") ||
                    a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                    a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                  break;
                case "WEBGL_compressed_texture_pvrtc":
                  c =
                    a.getExtension("WEBGL_compressed_texture_pvrtc") ||
                    a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                  break;
                default:
                  c = a.getExtension(b);
              }
              null === c &&
                console.warn(
                  "THREE.WebGLRenderer: " + b + " extension not supported."
                );
              return (g[b] = c);
            }
          };
        }
        function $a(a, b, c) {
          function g(a) {
            var p = a.target;
            a = d.get(p);
            null !== a.index && b.remove(a.index);
            for (var x in a.attributes) b.remove(a.attributes[x]);
            p.removeEventListener("dispose", g);
            d.delete(p);
            if ((x = w.get(a))) b.remove(x), w.delete(a);
            c.memory.geometries--;
          }
          function p(a) {
            var g = [],
              c = a.index,
              p = a.attributes.position;
            if (null !== c) {
              var d = c.array;
              c = c.version;
              p = 0;
              for (var x = d.length; p < x; p += 3) {
                var f = d[p + 0],
                  e = d[p + 1],
                  h = d[p + 2];
                g.push(f, e, e, h, h, f);
              }
            } else for (d = p.array, c = p.version, p = 0, x = d.length / 3 - 1; p < x; p += 3) (f = p + 0), (e = p + 1), (h = p + 2), g.push(f, e, e, h, h, f);
            g = new (65535 < sa(g) ? fa : ca)(g, 1);
            g.version = c;
            b.update(g, 34963);
            (d = w.get(a)) && b.remove(d);
            w.set(a, g);
          }
          var d = new WeakMap(),
            w = new WeakMap();
          return {
            get: function(a, b) {
              var p = d.get(b);
              if (p) return p;
              b.addEventListener("dispose", g);
              b.isBufferGeometry
                ? (p = b)
                : b.isGeometry &&
                  (void 0 === b._bufferGeometry &&
                    (b._bufferGeometry = new S().setFromObject(a)),
                  (p = b._bufferGeometry));
              d.set(b, p);
              c.memory.geometries++;
              return p;
            },
            update: function(a) {
              var g = a.index,
                c = a.attributes;
              null !== g && b.update(g, 34963);
              for (var p in c) b.update(c[p], 34962);
              a = a.morphAttributes;
              for (p in a) {
                g = a[p];
                c = 0;
                for (var d = g.length; c < d; c++) b.update(g[c], 34962);
              }
            },
            getWireframeAttribute: function(a) {
              var g = w.get(a);
              if (g) {
                var b = a.index;
                null !== b && g.version < b.version && p(a);
              } else p(a);
              return w.get(a);
            }
          };
        }
        function bb(a, b, c, d) {
          var g, p, w;
          this.setMode = function(a) {
            g = a;
          };
          this.setIndex = function(a) {
            p = a.type;
            w = a.bytesPerElement;
          };
          this.render = function(b, d) {
            a.drawElements(g, d, p, b * w);
            c.update(d, g);
          };
          this.renderInstances = function(x, f, e, h) {
            if (0 !== h) {
              if (d.isWebGL2) {
                x = a;
                var K = "drawElementsInstanced";
              } else if (
                ((x = b.get("ANGLE_instanced_arrays")),
                (K = "drawElementsInstancedANGLE"),
                null === x)
              ) {
                console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
                return;
              }
              x[K](g, e, p, f * w, h);
              c.update(e, g, h);
            }
          };
        }
        function cb(a) {
          var g = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: g,
            programs: null,
            autoReset: !0,
            reset: function() {
              g.frame++;
              g.calls = 0;
              g.triangles = 0;
              g.points = 0;
              g.lines = 0;
            },
            update: function(a, b, c) {
              c = c || 1;
              g.calls++;
              switch (b) {
                case 4:
                  g.triangles += (a / 3) * c;
                  break;
                case 5:
                case 6:
                  g.triangles += c * (a - 2);
                  break;
                case 1:
                  g.lines += (a / 2) * c;
                  break;
                case 3:
                  g.lines += c * (a - 1);
                  break;
                case 2:
                  g.lines += c * a;
                  break;
                case 0:
                  g.points += c * a;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", b);
              }
            }
          };
        }
        function Wa(a, b) {
          return Math.abs(b[1]) - Math.abs(a[1]);
        }
        function kb(a) {
          var g = {},
            b = new Float32Array(8);
          return {
            update: function(c, p, d, w) {
              var x = c.morphTargetInfluences,
                f = x.length;
              c = g[p.id];
              if (void 0 === c) {
                c = [];
                for (var e = 0; e < f; e++) c[e] = [e, 0];
                g[p.id] = c;
              }
              var h = d.morphTargets && p.morphAttributes.position;
              d = d.morphNormals && p.morphAttributes.normal;
              for (e = 0; e < f; e++) {
                var K = c[e];
                0 !== K[1] &&
                  (h && p.removeAttribute("morphTarget" + e),
                  d && p.removeAttribute("morphNormal" + e));
              }
              for (e = 0; e < f; e++) (K = c[e]), (K[0] = e), (K[1] = x[e]);
              c.sort(Wa);
              for (e = 0; 8 > e; e++) {
                if ((K = c[e]))
                  if (((x = K[0]), (f = K[1]))) {
                    h && p.addAttribute("morphTarget" + e, h[x]);
                    d && p.addAttribute("morphNormal" + e, d[x]);
                    b[e] = f;
                    continue;
                  }
                b[e] = 0;
              }
              w.getUniforms().setValue(a, "morphTargetInfluences", b);
            }
          };
        }
        function mb(a, b, c, d) {
          var g = {};
          return {
            update: function(a) {
              var p = d.render.frame,
                w = a.geometry,
                x = b.get(a, w);
              g[x.id] !== p &&
                (w.isGeometry && x.updateFromObject(a),
                b.update(x),
                (g[x.id] = p));
              a.isInstancedMesh && c.update(a.instanceMatrix, 34962);
              return x;
            },
            dispose: function() {
              g = {};
            }
          };
        }
        function Ha(a, b, c, d, f, e, h, k, m, ea) {
          a = void 0 !== a ? a : [];
          l.call(
            this,
            a,
            void 0 !== b ? b : 301,
            c,
            d,
            f,
            e,
            void 0 !== h ? h : 1022,
            k,
            m,
            ea
          );
          this.flipY = !1;
        }
        function db(a, b, c, d) {
          l.call(this, null);
          this.image = {
            data: a || null,
            width: b || 1,
            height: c || 1,
            depth: d || 1
          };
          this.minFilter = this.magFilter = 1003;
          this.wrapR = 1001;
          this.flipY = this.generateMipmaps = !1;
          this.needsUpdate = !0;
        }
        function jb(a, b, c, d) {
          l.call(this, null);
          this.image = {
            data: a || null,
            width: b || 1,
            height: c || 1,
            depth: d || 1
          };
          this.minFilter = this.magFilter = 1003;
          this.wrapR = 1001;
          this.flipY = this.generateMipmaps = !1;
          this.needsUpdate = !0;
        }
        function eb(a, b, c) {
          var g = a[0];
          if (0 >= g || 0 < g) return a;
          var p = b * c,
            d = Uh[p];
          void 0 === d && ((d = new Float32Array(p)), (Uh[p] = d));
          if (0 !== b)
            for (g.toArray(d, 0), g = 1, p = 0; g !== b; ++g)
              (p += c), a[g].toArray(d, p);
          return d;
        }
        function Oa(a, b) {
          if (a.length !== b.length) return !1;
          for (var g = 0, c = a.length; g < c; g++)
            if (a[g] !== b[g]) return !1;
          return !0;
        }
        function Na(a, b) {
          for (var g = 0, c = b.length; g < c; g++) a[g] = b[g];
        }
        function rb(a, b) {
          var g = Vh[b];
          void 0 === g && ((g = new Int32Array(b)), (Vh[b] = g));
          for (var c = 0; c !== b; ++c) g[c] = a.allocateTextureUnit();
          return g;
        }
        function ub(a, b) {
          var g = this.cache;
          g[0] !== b && (a.uniform1f(this.addr, b), (g[0] = b));
        }
        function vb(a, b) {
          var g = this.cache;
          if (void 0 !== b.x) {
            if (g[0] !== b.x || g[1] !== b.y)
              a.uniform2f(this.addr, b.x, b.y), (g[0] = b.x), (g[1] = b.y);
          } else Oa(g, b) || (a.uniform2fv(this.addr, b), Na(g, b));
        }
        function wb(a, b) {
          var g = this.cache;
          if (void 0 !== b.x) {
            if (g[0] !== b.x || g[1] !== b.y || g[2] !== b.z)
              a.uniform3f(this.addr, b.x, b.y, b.z),
                (g[0] = b.x),
                (g[1] = b.y),
                (g[2] = b.z);
          } else if (void 0 !== b.r) {
            if (g[0] !== b.r || g[1] !== b.g || g[2] !== b.b)
              a.uniform3f(this.addr, b.r, b.g, b.b),
                (g[0] = b.r),
                (g[1] = b.g),
                (g[2] = b.b);
          } else Oa(g, b) || (a.uniform3fv(this.addr, b), Na(g, b));
        }
        function yb(a, b) {
          var g = this.cache;
          if (void 0 !== b.x) {
            if (g[0] !== b.x || g[1] !== b.y || g[2] !== b.z || g[3] !== b.w)
              a.uniform4f(this.addr, b.x, b.y, b.z, b.w),
                (g[0] = b.x),
                (g[1] = b.y),
                (g[2] = b.z),
                (g[3] = b.w);
          } else Oa(g, b) || (a.uniform4fv(this.addr, b), Na(g, b));
        }
        function zb(a, b) {
          var g = this.cache,
            c = b.elements;
          void 0 === c
            ? Oa(g, b) || (a.uniformMatrix2fv(this.addr, !1, b), Na(g, b))
            : Oa(g, c) ||
              (Yh.set(c), a.uniformMatrix2fv(this.addr, !1, Yh), Na(g, c));
        }
        function Cb(a, b) {
          var g = this.cache,
            c = b.elements;
          void 0 === c
            ? Oa(g, b) || (a.uniformMatrix3fv(this.addr, !1, b), Na(g, b))
            : Oa(g, c) ||
              (Xh.set(c), a.uniformMatrix3fv(this.addr, !1, Xh), Na(g, c));
        }
        function Eb(a, b) {
          var g = this.cache,
            c = b.elements;
          void 0 === c
            ? Oa(g, b) || (a.uniformMatrix4fv(this.addr, !1, b), Na(g, b))
            : Oa(g, c) ||
              (Wh.set(c), a.uniformMatrix4fv(this.addr, !1, Wh), Na(g, c));
        }
        function Gb(a, b, c) {
          var g = this.cache,
            p = c.allocateTextureUnit();
          g[0] !== p && (a.uniform1i(this.addr, p), (g[0] = p));
          c.safeSetTexture2D(b || Sh, p);
        }
        function Hb(a, b, c) {
          var g = this.cache,
            p = c.allocateTextureUnit();
          g[0] !== p && (a.uniform1i(this.addr, p), (g[0] = p));
          c.setTexture2DArray(b || yj, p);
        }
        function Nb(a, b, c) {
          var g = this.cache,
            p = c.allocateTextureUnit();
          g[0] !== p && (a.uniform1i(this.addr, p), (g[0] = p));
          c.setTexture3D(b || zj, p);
        }
        function Xb(a, b, c) {
          var g = this.cache,
            p = c.allocateTextureUnit();
          g[0] !== p && (a.uniform1i(this.addr, p), (g[0] = p));
          c.safeSetTextureCube(b || Th, p);
        }
        function Yb(a, b) {
          var g = this.cache;
          g[0] !== b && (a.uniform1i(this.addr, b), (g[0] = b));
        }
        function bc(a, b) {
          var g = this.cache;
          Oa(g, b) || (a.uniform2iv(this.addr, b), Na(g, b));
        }
        function gc(a, b) {
          var g = this.cache;
          Oa(g, b) || (a.uniform3iv(this.addr, b), Na(g, b));
        }
        function ic(a, b) {
          var g = this.cache;
          Oa(g, b) || (a.uniform4iv(this.addr, b), Na(g, b));
        }
        function jc(a) {
          switch (a) {
            case 5126:
              return ub;
            case 35664:
              return vb;
            case 35665:
              return wb;
            case 35666:
              return yb;
            case 35674:
              return zb;
            case 35675:
              return Cb;
            case 35676:
              return Eb;
            case 35678:
            case 36198:
              return Gb;
            case 35679:
              return Nb;
            case 35680:
              return Xb;
            case 36289:
              return Hb;
            case 5124:
            case 35670:
              return Yb;
            case 35667:
            case 35671:
              return bc;
            case 35668:
            case 35672:
              return gc;
            case 35669:
            case 35673:
              return ic;
          }
        }
        function lc(a, b) {
          a.uniform1fv(this.addr, b);
        }
        function Ac(a, b) {
          a.uniform1iv(this.addr, b);
        }
        function Ec(a, b) {
          a.uniform2iv(this.addr, b);
        }
        function Fc(a, b) {
          a.uniform3iv(this.addr, b);
        }
        function Hc(a, b) {
          a.uniform4iv(this.addr, b);
        }
        function Ic(a, b) {
          b = eb(b, this.size, 2);
          a.uniform2fv(this.addr, b);
        }
        function Jc(a, b) {
          b = eb(b, this.size, 3);
          a.uniform3fv(this.addr, b);
        }
        function Kc(a, b) {
          b = eb(b, this.size, 4);
          a.uniform4fv(this.addr, b);
        }
        function Lc(a, b) {
          b = eb(b, this.size, 4);
          a.uniformMatrix2fv(this.addr, !1, b);
        }
        function Rc(a, b) {
          b = eb(b, this.size, 9);
          a.uniformMatrix3fv(this.addr, !1, b);
        }
        function Vc(a, b) {
          b = eb(b, this.size, 16);
          a.uniformMatrix4fv(this.addr, !1, b);
        }
        function Xc(a, b, c) {
          var g = b.length,
            p = rb(c, g);
          a.uniform1iv(this.addr, p);
          for (a = 0; a !== g; ++a) c.safeSetTexture2D(b[a] || Sh, p[a]);
        }
        function $c(a, b, c) {
          var g = b.length,
            p = rb(c, g);
          a.uniform1iv(this.addr, p);
          for (a = 0; a !== g; ++a) c.safeSetTextureCube(b[a] || Th, p[a]);
        }
        function bd(a) {
          switch (a) {
            case 5126:
              return lc;
            case 35664:
              return Ic;
            case 35665:
              return Jc;
            case 35666:
              return Kc;
            case 35674:
              return Lc;
            case 35675:
              return Rc;
            case 35676:
              return Vc;
            case 35678:
              return Xc;
            case 35680:
              return $c;
            case 5124:
            case 35670:
              return Ac;
            case 35667:
            case 35671:
              return Ec;
            case 35668:
            case 35672:
              return Fc;
            case 35669:
            case 35673:
              return Hc;
          }
        }
        function dd(a, b, c) {
          this.id = a;
          this.addr = c;
          this.cache = [];
          this.setValue = jc(b.type);
        }
        function oc(a, b, c) {
          this.id = a;
          this.addr = c;
          this.cache = [];
          this.size = b.size;
          this.setValue = bd(b.type);
        }
        function qc(a) {
          this.id = a;
          this.seq = [];
          this.map = {};
        }
        function hb(a, b) {
          this.seq = [];
          this.map = {};
          for (var g = a.getProgramParameter(b, 35718), c = 0; c < g; ++c) {
            var p = a.getActiveUniform(b, c),
              d = a.getUniformLocation(b, p.name),
              f = this,
              e = p.name,
              h = e.length;
            for (Gg.lastIndex = 0; ; ) {
              var k = Gg.exec(e),
                l = Gg.lastIndex,
                m = k[1],
                n = k[3];
              "]" === k[2] && (m |= 0);
              if (void 0 === n || ("[" === n && l + 2 === h)) {
                e = f;
                p = void 0 === n ? new dd(m, p, d) : new oc(m, p, d);
                e.seq.push(p);
                e.map[p.id] = p;
                break;
              } else
                (n = f.map[m]),
                  void 0 === n &&
                    ((n = new qc(m)),
                    (m = f),
                    (f = n),
                    m.seq.push(f),
                    (m.map[f.id] = f)),
                  (f = n);
            }
          }
        }
        function vc(a, b, c) {
          b = a.createShader(b);
          a.shaderSource(b, c);
          a.compileShader(b);
          return b;
        }
        function zc(a) {
          switch (a) {
            case 3e3:
              return ["Linear", "( value )"];
            case 3001:
              return ["sRGB", "( value )"];
            case 3002:
              return ["RGBE", "( value )"];
            case 3004:
              return ["RGBM", "( value, 7.0 )"];
            case 3005:
              return ["RGBM", "( value, 16.0 )"];
            case 3006:
              return ["RGBD", "( value, 256.0 )"];
            case 3007:
              return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
              return ["LogLuv", "( value )"];
            default:
              throw Error("unsupported encoding: " + a);
          }
        }
        function Gc(a, b, c) {
          var g = a.getShaderParameter(b, 35713),
            p = a.getShaderInfoLog(b).trim();
          if (g && "" === p) return "";
          a = a.getShaderSource(b).split("\n");
          for (b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
          a = a.join("\n");
          return "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + p + a;
        }
        function Ib(a, b) {
          b = zc(b);
          return (
            "vec4 " +
            a +
            "( vec4 value ) { return " +
            b[0] +
            "ToLinear" +
            b[1] +
            "; }"
          );
        }
        function sd(a, b) {
          b = zc(b);
          return (
            "vec4 " +
            a +
            "( vec4 value ) { return LinearTo" +
            b[0] +
            b[1] +
            "; }"
          );
        }
        function ud(a, b) {
          switch (b) {
            case 1:
              b = "Linear";
              break;
            case 2:
              b = "Reinhard";
              break;
            case 3:
              b = "Uncharted2";
              break;
            case 4:
              b = "OptimizedCineon";
              break;
            case 5:
              b = "ACESFilmic";
              break;
            default:
              throw Error("unsupported toneMapping: " + b);
          }
          return (
            "vec3 " +
            a +
            "( vec3 color ) { return " +
            b +
            "ToneMapping( color ); }"
          );
        }
        function Id(a, b, c) {
          a = a || {};
          return [
            a.derivatives ||
            b.envMapCubeUV ||
            b.bumpMap ||
            b.tangentSpaceNormalMap ||
            b.clearcoatNormalMap ||
            b.flatShading
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth")
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            a.drawBuffers && c.get("WEBGL_draw_buffers")
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod")
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : ""
          ]
            .filter(Db)
            .join("\n");
        }
        function Jd(a) {
          var g = [],
            b;
          for (b in a) {
            var c = a[b];
            !1 !== c && g.push("#define " + b + " " + c);
          }
          return g.join("\n");
        }
        function Db(a) {
          return "" !== a;
        }
        function Sc(a, b) {
          return a
            .replace(/NUM_DIR_LIGHTS/g, b.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, b.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows);
        }
        function Tc(a, b) {
          return a
            .replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              b.numClippingPlanes - b.numClipIntersection
            );
        }
        function kc(a, b) {
          a = za[b];
          if (void 0 === a) throw Error("Can not resolve #include <" + b + ">");
          return a.replace(Jg, kc);
        }
        function ed(a, b, c, d) {
          a = "";
          for (b = parseInt(b); b < parseInt(c); b++)
            a += d
              .replace(/\[ i \]/g, "[ " + b + " ]")
              .replace(/UNROLLED_LOOP_INDEX/g, b);
          return a;
        }
        function id(a) {
          var g =
            "precision " +
            a.precision +
            " float;\nprecision " +
            a.precision +
            " int;";
          "highp" === a.precision
            ? (g += "\n#define HIGH_PRECISION")
            : "mediump" === a.precision
            ? (g += "\n#define MEDIUM_PRECISION")
            : "lowp" === a.precision && (g += "\n#define LOW_PRECISION");
          return g;
        }
        function Sd(a) {
          var g = "SHADOWMAP_TYPE_BASIC";
          1 === a.shadowMapType
            ? (g = "SHADOWMAP_TYPE_PCF")
            : 2 === a.shadowMapType
            ? (g = "SHADOWMAP_TYPE_PCF_SOFT")
            : 3 === a.shadowMapType && (g = "SHADOWMAP_TYPE_VSM");
          return g;
        }
        function Td(a, b) {
          var g = "ENVMAP_TYPE_CUBE";
          if (a.envMap)
            switch (b.envMap.mapping) {
              case 301:
              case 302:
                g = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                g = "ENVMAP_TYPE_CUBE_UV";
                break;
              case 303:
              case 304:
                g = "ENVMAP_TYPE_EQUIREC";
                break;
              case 305:
                g = "ENVMAP_TYPE_SPHERE";
            }
          return g;
        }
        function be(a, b) {
          var g = "ENVMAP_MODE_REFLECTION";
          if (a.envMap)
            switch (b.envMap.mapping) {
              case 302:
              case 304:
                g = "ENVMAP_MODE_REFRACTION";
            }
          return g;
        }
        function fe(a, b) {
          var g = "ENVMAP_BLENDING_MULTIPLY";
          if (a.envMap)
            switch (b.combine) {
              case 0:
                g = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                g = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                g = "ENVMAP_BLENDING_ADD";
            }
          return g;
        }
        function ke(a, b, c, d, f, e) {
          var g = a.getContext(),
            p = d.defines,
            w = f.vertexShader,
            x = f.fragmentShader,
            h = Sd(e),
            K = Td(e, d),
            k = be(e, d),
            G = fe(e, d),
            l = 0 < a.gammaFactor ? a.gammaFactor : 1,
            m = e.isWebGL2 ? "" : Id(d.extensions, e, b),
            n = Jd(p),
            q = g.createProgram(),
            t =
              (p = a.getRenderTarget()) && p.isWebGLMultiviewRenderTarget
                ? p.numViews
                : 0;
          d.isRawShaderMaterial
            ? ((p = [n].filter(Db).join("\n")),
              0 < p.length && (p += "\n"),
              (b = [m, n].filter(Db).join("\n")),
              0 < b.length && (b += "\n"))
            : ((p = [
                id(e),
                "#define SHADER_NAME " + f.name,
                n,
                e.instancing ? "#define USE_INSTANCING" : "",
                e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                "#define GAMMA_FACTOR " + l,
                "#define MAX_BONES " + e.maxBones,
                e.useFog && e.fog ? "#define USE_FOG" : "",
                e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
                e.map ? "#define USE_MAP" : "",
                e.envMap ? "#define USE_ENVMAP" : "",
                e.envMap ? "#define " + k : "",
                e.lightMap ? "#define USE_LIGHTMAP" : "",
                e.aoMap ? "#define USE_AOMAP" : "",
                e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                e.bumpMap ? "#define USE_BUMPMAP" : "",
                e.normalMap ? "#define USE_NORMALMAP" : "",
                e.normalMap && e.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                e.normalMap && e.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                e.displacementMap && e.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
                e.specularMap ? "#define USE_SPECULARMAP" : "",
                e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                e.metalnessMap ? "#define USE_METALNESSMAP" : "",
                e.alphaMap ? "#define USE_ALPHAMAP" : "",
                e.vertexTangents ? "#define USE_TANGENT" : "",
                e.vertexColors ? "#define USE_COLOR" : "",
                e.vertexUvs ? "#define USE_UV" : "",
                e.flatShading ? "#define FLAT_SHADED" : "",
                e.skinning ? "#define USE_SKINNING" : "",
                e.useVertexTexture ? "#define BONE_TEXTURE" : "",
                e.morphTargets ? "#define USE_MORPHTARGETS" : "",
                e.morphNormals && !1 === e.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                e.doubleSided ? "#define DOUBLE_SIDED" : "",
                e.flipSided ? "#define FLIP_SIDED" : "",
                e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                e.shadowMapEnabled ? "#define " + h : "",
                e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                e.logarithmicDepthBuffer &&
                (e.isWebGL2 || b.get("EXT_frag_depth"))
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "#ifdef USE_INSTANCING",
                " attribute mat4 instanceMatrix;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#ifdef USE_COLOR",
                "\tattribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n"
              ]
                .filter(Db)
                .join("\n")),
              (b = [
                m,
                id(e),
                "#define SHADER_NAME " + f.name,
                n,
                e.alphaTest
                  ? "#define ALPHATEST " +
                    e.alphaTest +
                    (e.alphaTest % 1 ? "" : ".0")
                  : "",
                "#define GAMMA_FACTOR " + l,
                e.useFog && e.fog ? "#define USE_FOG" : "",
                e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
                e.map ? "#define USE_MAP" : "",
                e.matcap ? "#define USE_MATCAP" : "",
                e.envMap ? "#define USE_ENVMAP" : "",
                e.envMap ? "#define " + K : "",
                e.envMap ? "#define " + k : "",
                e.envMap ? "#define " + G : "",
                e.lightMap ? "#define USE_LIGHTMAP" : "",
                e.aoMap ? "#define USE_AOMAP" : "",
                e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                e.bumpMap ? "#define USE_BUMPMAP" : "",
                e.normalMap ? "#define USE_NORMALMAP" : "",
                e.normalMap && e.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                e.normalMap && e.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                e.specularMap ? "#define USE_SPECULARMAP" : "",
                e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                e.metalnessMap ? "#define USE_METALNESSMAP" : "",
                e.alphaMap ? "#define USE_ALPHAMAP" : "",
                e.sheen ? "#define USE_SHEEN" : "",
                e.vertexTangents ? "#define USE_TANGENT" : "",
                e.vertexColors ? "#define USE_COLOR" : "",
                e.vertexUvs ? "#define USE_UV" : "",
                e.gradientMap ? "#define USE_GRADIENTMAP" : "",
                e.flatShading ? "#define FLAT_SHADED" : "",
                e.doubleSided ? "#define DOUBLE_SIDED" : "",
                e.flipSided ? "#define FLIP_SIDED" : "",
                e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                e.shadowMapEnabled ? "#define " + h : "",
                e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                e.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
                e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                e.logarithmicDepthBuffer &&
                (e.isWebGL2 || b.get("EXT_frag_depth"))
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                ((d.extensions && d.extensions.shaderTextureLOD) || e.envMap) &&
                (e.isWebGL2 || b.get("EXT_shader_texture_lod"))
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                0 !== e.toneMapping ? "#define TONE_MAPPING" : "",
                0 !== e.toneMapping ? za.tonemapping_pars_fragment : "",
                0 !== e.toneMapping ? ud("toneMapping", e.toneMapping) : "",
                e.dithering ? "#define DITHERING" : "",
                e.outputEncoding ||
                e.mapEncoding ||
                e.matcapEncoding ||
                e.envMapEncoding ||
                e.emissiveMapEncoding
                  ? za.encodings_pars_fragment
                  : "",
                e.mapEncoding ? Ib("mapTexelToLinear", e.mapEncoding) : "",
                e.matcapEncoding
                  ? Ib("matcapTexelToLinear", e.matcapEncoding)
                  : "",
                e.envMapEncoding
                  ? Ib("envMapTexelToLinear", e.envMapEncoding)
                  : "",
                e.emissiveMapEncoding
                  ? Ib("emissiveMapTexelToLinear", e.emissiveMapEncoding)
                  : "",
                e.outputEncoding
                  ? sd("linearToOutputTexel", e.outputEncoding)
                  : "",
                e.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "",
                "\n"
              ]
                .filter(Db)
                .join("\n")));
          w = w.replace(Jg, kc);
          w = Sc(w, e);
          w = Tc(w, e);
          x = x.replace(Jg, kc);
          x = Sc(x, e);
          x = Tc(x, e);
          w = w.replace(Zh, ed);
          x = x.replace(Zh, ed);
          e.isWebGL2 &&
            !d.isRawShaderMaterial &&
            ((h = !1),
            (K = /^\s*#version\s+300\s+es\s*\n/),
            d.isShaderMaterial &&
              null !== w.match(K) &&
              null !== x.match(K) &&
              ((h = !0), (w = w.replace(K, "")), (x = x.replace(K, ""))),
            (p =
              "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
              p),
            (b =
              [
                "#version 300 es\n\n#define varying in",
                h ? "" : "out highp vec4 pc_fragColor;",
                h ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"
              ].join("\n") +
              "\n" +
              b),
            0 < t &&
              ((p = p.replace(
                "#version 300 es\n",
                [
                  "#version 300 es\n\n#extension GL_OVR_multiview2 : require",
                  "layout(num_views = " + t + ") in;",
                  "#define VIEW_ID gl_ViewID_OVR"
                ].join("\n")
              )),
              (p = p.replace(
                "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;",
                [
                  "uniform mat4 modelViewMatrices[" + t + "];",
                  "uniform mat4 projectionMatrices[" + t + "];",
                  "uniform mat4 viewMatrices[" + t + "];",
                  "uniform mat3 normalMatrices[" + t + "];",
                  "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"
                ].join("\n")
              )),
              (b = b.replace(
                "#version 300 es\n",
                "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"
              )),
              (b = b.replace(
                "uniform mat4 viewMatrix;",
                [
                  "uniform mat4 viewMatrices[" + t + "];",
                  "#define viewMatrix viewMatrices[VIEW_ID]"
                ].join("\n")
              ))));
          x = b + x;
          w = vc(g, 35633, p + w);
          x = vc(g, 35632, x);
          g.attachShader(q, w);
          g.attachShader(q, x);
          void 0 !== d.index0AttributeName
            ? g.bindAttribLocation(q, 0, d.index0AttributeName)
            : !0 === e.morphTargets && g.bindAttribLocation(q, 0, "position");
          g.linkProgram(q);
          if (a.debug.checkShaderErrors) {
            a = g.getProgramInfoLog(q).trim();
            e = g.getShaderInfoLog(w).trim();
            h = g.getShaderInfoLog(x).trim();
            k = K = !0;
            if (!1 === g.getProgramParameter(q, 35714))
              (K = !1),
                (G = Gc(g, w, "vertex")),
                (l = Gc(g, x, "fragment")),
                console.error(
                  "THREE.WebGLProgram: shader error: ",
                  g.getError(),
                  "35715",
                  g.getProgramParameter(q, 35715),
                  "gl.getProgramInfoLog",
                  a,
                  G,
                  l
                );
            else if ("" !== a)
              console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a);
            else if ("" === e || "" === h) k = !1;
            k &&
              (this.diagnostics = {
                runnable: K,
                material: d,
                programLog: a,
                vertexShader: { log: e, prefix: p },
                fragmentShader: { log: h, prefix: b }
              });
          }
          g.deleteShader(w);
          g.deleteShader(x);
          var u;
          this.getUniforms = function() {
            void 0 === u && (u = new hb(g, q));
            return u;
          };
          var y;
          this.getAttributes = function() {
            if (void 0 === y) {
              for (
                var a = {}, b = g.getProgramParameter(q, 35721), c = 0;
                c < b;
                c++
              ) {
                var p = g.getActiveAttrib(q, c).name;
                a[p] = g.getAttribLocation(q, p);
              }
              y = a;
            }
            return y;
          };
          this.destroy = function() {
            g.deleteProgram(q);
            this.program = void 0;
          };
          this.name = f.name;
          this.id = Aj++;
          this.code = c;
          this.usedTimes = 1;
          this.program = q;
          this.vertexShader = w;
          this.fragmentShader = x;
          this.numMultiviewViews = t;
          return this;
        }
        function te(a, b, c) {
          function g(a, g) {
            if (a)
              a.isTexture
                ? (b = a.encoding)
                : a.isWebGLRenderTarget &&
                  (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (b = a.texture.encoding));
            else var b = 3e3;
            3e3 === b && g && (b = 3007);
            return b;
          }
          var p = [],
            d = {
              MeshDepthMaterial: "depth",
              MeshDistanceMaterial: "distanceRGBA",
              MeshNormalMaterial: "normal",
              MeshBasicMaterial: "basic",
              MeshLambertMaterial: "lambert",
              MeshPhongMaterial: "phong",
              MeshToonMaterial: "phong",
              MeshStandardMaterial: "physical",
              MeshPhysicalMaterial: "physical",
              MeshMatcapMaterial: "matcap",
              LineBasicMaterial: "basic",
              LineDashedMaterial: "dashed",
              PointsMaterial: "points",
              ShadowMaterial: "shadow",
              SpriteMaterial: "sprite"
            },
            w = "precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(
              " "
            );
          this.getParameters = function(b, p, w, e, x, f, h) {
            var K = d[b.type];
            if (h.isSkinnedMesh) {
              var k = h.skeleton.bones;
              if (c.floatVertexTextures) k = 1024;
              else {
                var G = Math.min(
                  Math.floor((c.maxVertexUniforms - 20) / 4),
                  k.length
                );
                G < k.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        k.length +
                        " bones. This GPU supports " +
                        G +
                        "."
                    ),
                    (k = 0))
                  : (k = G);
              }
            } else k = 0;
            G = c.precision;
            null !== b.precision &&
              ((G = c.getMaxPrecision(b.precision)),
              G !== b.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  b.precision,
                  "not supported, using",
                  G,
                  "instead."
                ));
            var l = a.getRenderTarget();
            return {
              isWebGL2: c.isWebGL2,
              shaderID: K,
              precision: G,
              instancing: !0 === h.isInstancedMesh,
              supportsVertexTextures: c.vertexTextures,
              outputEncoding: g(l ? l.texture : null, a.gammaOutput),
              map: !!b.map,
              mapEncoding: g(b.map, a.gammaInput),
              matcap: !!b.matcap,
              matcapEncoding: g(b.matcap, a.gammaInput),
              envMap: !!b.envMap,
              envMapMode: b.envMap && b.envMap.mapping,
              envMapEncoding: g(b.envMap, a.gammaInput),
              envMapCubeUV:
                !!b.envMap &&
                (306 === b.envMap.mapping || 307 === b.envMap.mapping),
              lightMap: !!b.lightMap,
              aoMap: !!b.aoMap,
              emissiveMap: !!b.emissiveMap,
              emissiveMapEncoding: g(b.emissiveMap, a.gammaInput),
              bumpMap: !!b.bumpMap,
              normalMap: !!b.normalMap,
              objectSpaceNormalMap: 1 === b.normalMapType,
              tangentSpaceNormalMap: 0 === b.normalMapType,
              clearcoatNormalMap: !!b.clearcoatNormalMap,
              displacementMap: !!b.displacementMap,
              roughnessMap: !!b.roughnessMap,
              metalnessMap: !!b.metalnessMap,
              specularMap: !!b.specularMap,
              alphaMap: !!b.alphaMap,
              gradientMap: !!b.gradientMap,
              sheen: !!b.sheen,
              combine: b.combine,
              vertexTangents: b.normalMap && b.vertexTangents,
              vertexColors: b.vertexColors,
              vertexUvs:
                !!b.map ||
                !!b.bumpMap ||
                !!b.normalMap ||
                !!b.specularMap ||
                !!b.alphaMap ||
                !!b.emissiveMap ||
                !!b.roughnessMap ||
                !!b.metalnessMap ||
                !!b.clearcoatNormalMap,
              fog: !!e,
              useFog: b.fog,
              fogExp2: e && e.isFogExp2,
              flatShading: b.flatShading,
              sizeAttenuation: b.sizeAttenuation,
              logarithmicDepthBuffer: c.logarithmicDepthBuffer,
              skinning: b.skinning && 0 < k,
              maxBones: k,
              useVertexTexture: c.floatVertexTextures,
              morphTargets: b.morphTargets,
              morphNormals: b.morphNormals,
              maxMorphTargets: a.maxMorphTargets,
              maxMorphNormals: a.maxMorphNormals,
              numDirLights: p.directional.length,
              numPointLights: p.point.length,
              numSpotLights: p.spot.length,
              numRectAreaLights: p.rectArea.length,
              numHemiLights: p.hemi.length,
              numDirLightShadows: p.directionalShadowMap.length,
              numPointLightShadows: p.pointShadowMap.length,
              numSpotLightShadows: p.spotShadowMap.length,
              numClippingPlanes: x,
              numClipIntersection: f,
              dithering: b.dithering,
              shadowMapEnabled: a.shadowMap.enabled && 0 < w.length,
              shadowMapType: a.shadowMap.type,
              toneMapping: b.toneMapped ? a.toneMapping : 0,
              physicallyCorrectLights: a.physicallyCorrectLights,
              premultipliedAlpha: b.premultipliedAlpha,
              alphaTest: b.alphaTest,
              doubleSided: 2 === b.side,
              flipSided: 1 === b.side,
              depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
            };
          };
          this.getProgramCode = function(g, b) {
            var c = [];
            b.shaderID
              ? c.push(b.shaderID)
              : (c.push(g.fragmentShader), c.push(g.vertexShader));
            if (void 0 !== g.defines)
              for (var p in g.defines) c.push(p), c.push(g.defines[p]);
            for (p = 0; p < w.length; p++) c.push(b[w[p]]);
            c.push(g.onBeforeCompile.toString());
            c.push(a.gammaOutput);
            c.push(a.gammaFactor);
            return c.join();
          };
          this.acquireProgram = function(g, c, d, w) {
            for (var e, x = 0, f = p.length; x < f; x++) {
              var h = p[x];
              if (h.code === w) {
                e = h;
                ++e.usedTimes;
                break;
              }
            }
            void 0 === e && ((e = new ke(a, b, w, g, c, d)), p.push(e));
            return e;
          };
          this.releaseProgram = function(a) {
            if (0 === --a.usedTimes) {
              var g = p.indexOf(a);
              p[g] = p[p.length - 1];
              p.pop();
              a.destroy();
            }
          };
          this.programs = p;
        }
        function ue() {
          var a = new WeakMap();
          return {
            get: function(g) {
              var b = a.get(g);
              void 0 === b && ((b = {}), a.set(g, b));
              return b;
            },
            remove: function(g) {
              a.delete(g);
            },
            update: function(g, b, c) {
              a.get(g)[b] = c;
            },
            dispose: function() {
              a = new WeakMap();
            }
          };
        }
        function ve(a, b) {
          return a.groupOrder !== b.groupOrder
            ? a.groupOrder - b.groupOrder
            : a.renderOrder !== b.renderOrder
            ? a.renderOrder - b.renderOrder
            : a.program !== b.program
            ? a.program.id - b.program.id
            : a.material.id !== b.material.id
            ? a.material.id - b.material.id
            : a.z !== b.z
            ? a.z - b.z
            : a.id - b.id;
        }
        function He(a, b) {
          return a.groupOrder !== b.groupOrder
            ? a.groupOrder - b.groupOrder
            : a.renderOrder !== b.renderOrder
            ? a.renderOrder - b.renderOrder
            : a.z !== b.z
            ? b.z - a.z
            : a.id - b.id;
        }
        function Kd() {
          function a(a, g, p, d, w, e) {
            var x = b[c];
            void 0 === x
              ? ((x = {
                  id: a.id,
                  object: a,
                  geometry: g,
                  material: p,
                  program: p.program || f,
                  groupOrder: d,
                  renderOrder: a.renderOrder,
                  z: w,
                  group: e
                }),
                (b[c] = x))
              : ((x.id = a.id),
                (x.object = a),
                (x.geometry = g),
                (x.material = p),
                (x.program = p.program || f),
                (x.groupOrder = d),
                (x.renderOrder = a.renderOrder),
                (x.z = w),
                (x.group = e));
            c++;
            return x;
          }
          var b = [],
            c = 0,
            d = [],
            e = [],
            f = { id: -1 };
          return {
            opaque: d,
            transparent: e,
            init: function() {
              c = 0;
              d.length = 0;
              e.length = 0;
            },
            push: function(g, b, c, p, w, x) {
              g = a(g, b, c, p, w, x);
              (!0 === c.transparent ? e : d).push(g);
            },
            unshift: function(g, b, c, p, w, x) {
              g = a(g, b, c, p, w, x);
              (!0 === c.transparent ? e : d).unshift(g);
            },
            sort: function() {
              1 < d.length && d.sort(ve);
              1 < e.length && e.sort(He);
            }
          };
        }
        function Je() {
          function a(g) {
            g = g.target;
            g.removeEventListener("dispose", a);
            b.delete(g);
          }
          var b = new WeakMap();
          return {
            get: function(g, c) {
              var p = b.get(g);
              if (void 0 === p) {
                var d = new Kd();
                b.set(g, new WeakMap());
                b.get(g).set(c, d);
                g.addEventListener("dispose", a);
              } else
                (d = p.get(c)), void 0 === d && ((d = new Kd()), p.set(c, d));
              return d;
            },
            dispose: function() {
              b = new WeakMap();
            }
          };
        }
        function Ke() {
          var a = {};
          return {
            get: function(g) {
              if (void 0 !== a[g.id]) return a[g.id];
              switch (g.type) {
                case "DirectionalLight":
                  var b = {
                    direction: new h(),
                    color: new M(),
                    shadow: !1,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new c()
                  };
                  break;
                case "SpotLight":
                  b = {
                    position: new h(),
                    direction: new h(),
                    color: new M(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                    shadow: !1,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new c()
                  };
                  break;
                case "PointLight":
                  b = {
                    position: new h(),
                    color: new M(),
                    distance: 0,
                    decay: 0,
                    shadow: !1,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new c(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                  };
                  break;
                case "HemisphereLight":
                  b = {
                    direction: new h(),
                    skyColor: new M(),
                    groundColor: new M()
                  };
                  break;
                case "RectAreaLight":
                  b = {
                    color: new M(),
                    position: new h(),
                    halfWidth: new h(),
                    halfHeight: new h()
                  };
              }
              return (a[g.id] = b);
            }
          };
        }
        function Oe(a, b) {
          return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
        }
        function Pe() {
          for (
            var a = new Ke(),
              b = {
                version: 0,
                hash: {
                  directionalLength: -1,
                  pointLength: -1,
                  spotLength: -1,
                  rectAreaLength: -1,
                  hemiLength: -1,
                  numDirectionalShadows: -1,
                  numPointShadows: -1,
                  numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
              },
              c = 0;
            9 > c;
            c++
          )
            b.probe.push(new h());
          var d = new h(),
            e = new t(),
            f = new t();
          return {
            setup: function(g, c, p) {
              for (var w = 0, x = 0, h = 0, k = 0; 9 > k; k++)
                b.probe[k].set(0, 0, 0);
              var K = (c = 0),
                G = 0,
                l = 0,
                Z = 0,
                m = 0,
                Y = 0,
                R = 0;
              p = p.matrixWorldInverse;
              g.sort(Oe);
              k = 0;
              for (var n = g.length; k < n; k++) {
                var q = g[k],
                  t = q.color,
                  u = q.intensity,
                  y = q.distance,
                  v = q.shadow && q.shadow.map ? q.shadow.map.texture : null;
                if (q.isAmbientLight)
                  (w += t.r * u), (x += t.g * u), (h += t.b * u);
                else if (q.isLightProbe)
                  for (v = 0; 9 > v; v++)
                    b.probe[v].addScaledVector(q.sh.coefficients[v], u);
                else if (q.isDirectionalLight) {
                  var r = a.get(q);
                  r.color.copy(q.color).multiplyScalar(q.intensity);
                  r.direction.setFromMatrixPosition(q.matrixWorld);
                  d.setFromMatrixPosition(q.target.matrixWorld);
                  r.direction.sub(d);
                  r.direction.transformDirection(p);
                  if ((r.shadow = q.castShadow))
                    (u = q.shadow),
                      (r.shadowBias = u.bias),
                      (r.shadowRadius = u.radius),
                      (r.shadowMapSize = u.mapSize),
                      (b.directionalShadowMap[c] = v),
                      (b.directionalShadowMatrix[c] = q.shadow.matrix),
                      m++;
                  b.directional[c] = r;
                  c++;
                } else if (q.isSpotLight) {
                  r = a.get(q);
                  r.position.setFromMatrixPosition(q.matrixWorld);
                  r.position.applyMatrix4(p);
                  r.color.copy(t).multiplyScalar(u);
                  r.distance = y;
                  r.direction.setFromMatrixPosition(q.matrixWorld);
                  d.setFromMatrixPosition(q.target.matrixWorld);
                  r.direction.sub(d);
                  r.direction.transformDirection(p);
                  r.coneCos = Math.cos(q.angle);
                  r.penumbraCos = Math.cos(q.angle * (1 - q.penumbra));
                  r.decay = q.decay;
                  if ((r.shadow = q.castShadow))
                    (u = q.shadow),
                      (r.shadowBias = u.bias),
                      (r.shadowRadius = u.radius),
                      (r.shadowMapSize = u.mapSize),
                      (b.spotShadowMap[G] = v),
                      (b.spotShadowMatrix[G] = q.shadow.matrix),
                      R++;
                  b.spot[G] = r;
                  G++;
                } else if (q.isRectAreaLight)
                  (r = a.get(q)),
                    r.color.copy(t).multiplyScalar(u),
                    r.position.setFromMatrixPosition(q.matrixWorld),
                    r.position.applyMatrix4(p),
                    f.identity(),
                    e.copy(q.matrixWorld),
                    e.premultiply(p),
                    f.extractRotation(e),
                    r.halfWidth.set(0.5 * q.width, 0, 0),
                    r.halfHeight.set(0, 0.5 * q.height, 0),
                    r.halfWidth.applyMatrix4(f),
                    r.halfHeight.applyMatrix4(f),
                    (b.rectArea[l] = r),
                    l++;
                else if (q.isPointLight) {
                  r = a.get(q);
                  r.position.setFromMatrixPosition(q.matrixWorld);
                  r.position.applyMatrix4(p);
                  r.color.copy(q.color).multiplyScalar(q.intensity);
                  r.distance = q.distance;
                  r.decay = q.decay;
                  if ((r.shadow = q.castShadow))
                    (u = q.shadow),
                      (r.shadowBias = u.bias),
                      (r.shadowRadius = u.radius),
                      (r.shadowMapSize = u.mapSize),
                      (r.shadowCameraNear = u.camera.near),
                      (r.shadowCameraFar = u.camera.far),
                      (b.pointShadowMap[K] = v),
                      (b.pointShadowMatrix[K] = q.shadow.matrix),
                      Y++;
                  b.point[K] = r;
                  K++;
                } else
                  q.isHemisphereLight &&
                    ((r = a.get(q)),
                    r.direction.setFromMatrixPosition(q.matrixWorld),
                    r.direction.transformDirection(p),
                    r.direction.normalize(),
                    r.skyColor.copy(q.color).multiplyScalar(u),
                    r.groundColor.copy(q.groundColor).multiplyScalar(u),
                    (b.hemi[Z] = r),
                    Z++);
              }
              b.ambient[0] = w;
              b.ambient[1] = x;
              b.ambient[2] = h;
              g = b.hash;
              if (
                g.directionalLength !== c ||
                g.pointLength !== K ||
                g.spotLength !== G ||
                g.rectAreaLength !== l ||
                g.hemiLength !== Z ||
                g.numDirectionalShadows !== m ||
                g.numPointShadows !== Y ||
                g.numSpotShadows !== R
              )
                (b.directional.length = c),
                  (b.spot.length = G),
                  (b.rectArea.length = l),
                  (b.point.length = K),
                  (b.hemi.length = Z),
                  (b.directionalShadowMap.length = m),
                  (b.pointShadowMap.length = Y),
                  (b.spotShadowMap.length = R),
                  (b.directionalShadowMatrix.length = m),
                  (b.pointShadowMatrix.length = Y),
                  (b.spotShadowMatrix.length = R),
                  (g.directionalLength = c),
                  (g.pointLength = K),
                  (g.spotLength = G),
                  (g.rectAreaLength = l),
                  (g.hemiLength = Z),
                  (g.numDirectionalShadows = m),
                  (g.numPointShadows = Y),
                  (g.numSpotShadows = R),
                  (b.version = Cj++);
            },
            state: b
          };
        }
        function Pd() {
          var a = new Pe(),
            b = [],
            c = [];
          return {
            init: function() {
              b.length = 0;
              c.length = 0;
            },
            state: { lightsArray: b, shadowsArray: c, lights: a },
            setupLights: function(g) {
              a.setup(b, c, g);
            },
            pushLight: function(a) {
              b.push(a);
            },
            pushShadow: function(a) {
              c.push(a);
            }
          };
        }
        function Qe() {
          function a(g) {
            g = g.target;
            g.removeEventListener("dispose", a);
            b.delete(g);
          }
          var b = new WeakMap();
          return {
            get: function(g, c) {
              if (!1 === b.has(g)) {
                var p = new Pd();
                b.set(g, new WeakMap());
                b.get(g).set(c, p);
                g.addEventListener("dispose", a);
              } else
                !1 === b.get(g).has(c)
                  ? ((p = new Pd()), b.get(g).set(c, p))
                  : (p = b.get(g).get(c));
              return p;
            },
            dispose: function() {
              b = new WeakMap();
            }
          };
        }
        function $f(a) {
          D.call(this);
          this.type = "MeshDepthMaterial";
          this.depthPacking = 3200;
          this.morphTargets = this.skinning = !1;
          this.displacementMap = this.alphaMap = this.map = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.fog = !1;
          this.setValues(a);
        }
        function ag(a) {
          D.call(this);
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new h();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.morphTargets = this.skinning = !1;
          this.displacementMap = this.alphaMap = this.map = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = !1;
          this.setValues(a);
        }
        function Qd(a, b, d) {
          function g(g, b, c, p, d, w) {
            var e = g.geometry;
            var f = k;
            var x = g.customDepthMaterial;
            c.isPointLight && ((f = l), (x = g.customDistanceMaterial));
            x
              ? (f = x)
              : ((x = !1),
                b.morphTargets &&
                  (e && e.isBufferGeometry
                    ? (x =
                        e.morphAttributes &&
                        e.morphAttributes.position &&
                        0 < e.morphAttributes.position.length)
                    : e &&
                      e.isGeometry &&
                      (x = e.morphTargets && 0 < e.morphTargets.length)),
                g.isSkinnedMesh &&
                  !1 === b.skinning &&
                  console.warn(
                    "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                    g
                  ),
                (g = g.isSkinnedMesh && b.skinning),
                (e = 0),
                x && (e |= 1),
                g && (e |= 2),
                (f = f[e]));
            a.localClippingEnabled &&
              !0 === b.clipShadows &&
              0 !== b.clippingPlanes.length &&
              ((e = f.uuid),
              (x = b.uuid),
              (g = q[e]),
              void 0 === g && ((g = {}), (q[e] = g)),
              (e = g[x]),
              void 0 === e && ((e = f.clone()), (g[x] = e)),
              (f = e));
            f.visible = b.visible;
            f.wireframe = b.wireframe;
            f.side =
              3 === w
                ? null != b.shadowSide
                  ? b.shadowSide
                  : b.side
                : null != b.shadowSide
                ? b.shadowSide
                : t[b.side];
            f.clipShadows = b.clipShadows;
            f.clippingPlanes = b.clippingPlanes;
            f.clipIntersection = b.clipIntersection;
            f.wireframeLinewidth = b.wireframeLinewidth;
            f.linewidth = b.linewidth;
            c.isPointLight &&
              f.isMeshDistanceMaterial &&
              (f.referencePosition.setFromMatrixPosition(c.matrixWorld),
              (f.nearDistance = p),
              (f.farDistance = d));
            return f;
          }
          function p(c, d, e, f, x) {
            if (!1 !== c.visible) {
              if (
                c.layers.test(d.layers) &&
                (c.isMesh || c.isLine || c.isPoints) &&
                (c.castShadow || (c.receiveShadow && 3 === x)) &&
                (!c.frustumCulled || w.intersectsObject(c))
              ) {
                c.modelViewMatrix.multiplyMatrices(
                  e.matrixWorldInverse,
                  c.matrixWorld
                );
                var h = b.update(c),
                  k = c.material;
                if (Array.isArray(k))
                  for (var K = h.groups, l = 0, G = K.length; l < G; l++) {
                    var Z = K[l],
                      m = k[Z.materialIndex];
                    m &&
                      m.visible &&
                      ((m = g(c, m, f, e.near, e.far, x)),
                      a.renderBufferDirect(e, null, h, m, c, Z));
                  }
                else
                  k.visible &&
                    ((m = g(c, k, f, e.near, e.far, x)),
                    a.renderBufferDirect(e, null, h, m, c, null));
              }
              c = c.children;
              h = 0;
              for (k = c.length; h < k; h++) p(c[h], d, e, f, x);
            }
          }
          var w = new Q(),
            e = new c(),
            f = new c(),
            h = new m(),
            k = Array(4),
            l = Array(4),
            q = {},
            t = { 0: 1, 1: 0, 2: 2 },
            u = new qa({
              defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 0.125 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new c() },
                radius: { value: 4 }
              },
              vertexShader:
                "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}"
            }),
            r = u.clone();
          r.defines.HORIZONAL_PASS = 1;
          var y = new S();
          y.addAttribute(
            "position",
            new I(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          var v = new da(y, u);
          for (y = 0; 4 !== y; ++y) {
            var A = 0 !== (y & 1),
              z = 0 !== (y & 2),
              C = new $f({ depthPacking: 3201, morphTargets: A, skinning: z });
            k[y] = C;
            A = new ag({ morphTargets: A, skinning: z });
            l[y] = A;
          }
          var B = this;
          this.enabled = !1;
          this.autoUpdate = !0;
          this.needsUpdate = !1;
          this.type = 1;
          this.render = function(g, c, x) {
            if (
              !1 !== B.enabled &&
              (!1 !== B.autoUpdate || !1 !== B.needsUpdate) &&
              0 !== g.length
            ) {
              var k = a.getRenderTarget(),
                K = a.getActiveCubeFace(),
                l = a.getActiveMipmapLevel(),
                G = a.state;
              G.setBlending(0);
              G.buffers.color.setClear(1, 1, 1, 1);
              G.buffers.depth.setTest(!0);
              G.setScissorTest(!1);
              for (var Z = 0, m = g.length; Z < m; Z++) {
                var Y = g[Z],
                  R = Y.shadow;
                if (void 0 === R)
                  console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
                else {
                  e.copy(R.mapSize);
                  var ea = R.getFrameExtents();
                  e.multiply(ea);
                  f.copy(R.mapSize);
                  if (e.x > d || e.y > d)
                    console.warn(
                      "THREE.WebGLShadowMap:",
                      Y,
                      "has shadow exceeding max texture size, reducing"
                    ),
                      e.x > d &&
                        ((f.x = Math.floor(d / ea.x)),
                        (e.x = f.x * ea.x),
                        (R.mapSize.x = f.x)),
                      e.y > d &&
                        ((f.y = Math.floor(d / ea.y)),
                        (e.y = f.y * ea.y),
                        (R.mapSize.y = f.y));
                  null !== R.map ||
                    R.isPointLightShadow ||
                    3 !== this.type ||
                    ((ea = { minFilter: 1006, magFilter: 1006, format: 1023 }),
                    (R.map = new n(e.x, e.y, ea)),
                    (R.map.texture.name = Y.name + ".shadowMap"),
                    (R.mapPass = new n(e.x, e.y, ea)),
                    R.camera.updateProjectionMatrix());
                  null === R.map &&
                    ((ea = { minFilter: 1003, magFilter: 1003, format: 1023 }),
                    (R.map = new n(e.x, e.y, ea)),
                    (R.map.texture.name = Y.name + ".shadowMap"),
                    R.camera.updateProjectionMatrix());
                  a.setRenderTarget(R.map);
                  a.clear();
                  ea = R.getViewportCount();
                  for (var q = 0; q < ea; q++) {
                    var t = R.getViewport(q);
                    h.set(f.x * t.x, f.y * t.y, f.x * t.z, f.y * t.w);
                    G.viewport(h);
                    R.updateMatrices(Y, x, q);
                    w = R.getFrustum();
                    p(c, x, R.camera, Y, this.type);
                  }
                  R.isPointLightShadow ||
                    3 !== this.type ||
                    ((Y = R),
                    (R = x),
                    (ea = b.update(v)),
                    (u.uniforms.shadow_pass.value = Y.map.texture),
                    (u.uniforms.resolution.value = Y.mapSize),
                    (u.uniforms.radius.value = Y.radius),
                    a.setRenderTarget(Y.mapPass),
                    a.clear(),
                    a.renderBufferDirect(R, null, ea, u, v, null),
                    (r.uniforms.shadow_pass.value = Y.mapPass.texture),
                    (r.uniforms.resolution.value = Y.mapSize),
                    (r.uniforms.radius.value = Y.radius),
                    a.setRenderTarget(Y.map),
                    a.clear(),
                    a.renderBufferDirect(R, null, ea, r, v, null));
                }
              }
              B.needsUpdate = !1;
              a.setRenderTarget(k, K, l);
            }
          };
        }
        function Re(a, b, c, d) {
          function g(g, b, c) {
            var p = new Uint8Array(4),
              d = a.createTexture();
            a.bindTexture(g, d);
            a.texParameteri(g, 10241, 9728);
            a.texParameteri(g, 10240, 9728);
            for (g = 0; g < c; g++)
              a.texImage2D(b + g, 0, 6408, 1, 1, 0, 6408, 5121, p);
            return d;
          }
          function p(g, c) {
            r[g] = 1;
            0 === y[g] && (a.enableVertexAttribArray(g), (y[g] = 1));
            v[g] !== c &&
              ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[
                d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](g, c),
              (v[g] = c));
          }
          function w(g) {
            !0 !== A[g] && (a.enable(g), (A[g] = !0));
          }
          function e(g) {
            !1 !== A[g] && (a.disable(g), (A[g] = !1));
          }
          function f(g, b, p, d, f, x, h, k) {
            if (0 === g) C && (e(3042), (C = !1));
            else if ((C || (w(3042), (C = !0)), 5 !== g)) {
              if (g !== H || k !== Jk) {
                if (100 !== M || 100 !== N)
                  a.blendEquation(32774), (N = M = 100);
                if (k)
                  switch (g) {
                    case 1:
                      a.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case 2:
                      a.blendFunc(1, 1);
                      break;
                    case 3:
                      a.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case 4:
                      a.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", g);
                  }
                else
                  switch (g) {
                    case 1:
                      a.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case 2:
                      a.blendFunc(770, 1);
                      break;
                    case 3:
                      a.blendFunc(0, 769);
                      break;
                    case 4:
                      a.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", g);
                  }
                L = I = E = D = null;
                H = g;
                Jk = k;
              }
            } else {
              f = f || b;
              x = x || p;
              h = h || d;
              if (b !== M || f !== N)
                a.blendEquationSeparate(c.convert(b), c.convert(f)),
                  (M = b),
                  (N = f);
              if (p !== D || d !== E || x !== I || h !== L)
                a.blendFuncSeparate(
                  c.convert(p),
                  c.convert(d),
                  c.convert(x),
                  c.convert(h)
                ),
                  (D = p),
                  (E = d),
                  (I = x),
                  (L = h);
              H = g;
              Jk = null;
            }
          }
          function x(g) {
            Kk !== g && (g ? a.frontFace(2304) : a.frontFace(2305), (Kk = g));
          }
          function h(g) {
            0 !== g
              ? (w(2884),
                g !== Lk &&
                  (1 === g
                    ? a.cullFace(1029)
                    : 2 === g
                    ? a.cullFace(1028)
                    : a.cullFace(1032)))
              : e(2884);
            Lk = g;
          }
          function k(g, b, c) {
            if (g) {
              if ((w(32823), J !== b || P !== c))
                a.polygonOffset(b, c), (J = b), (P = c);
            } else e(32823);
          }
          function l(g) {
            void 0 === g && (g = 33984 + F - 1);
            Q !== g && (a.activeTexture(g), (Q = g));
          }
          var n = new (function() {
              var g = !1,
                b = new m(),
                c = null,
                p = new m(0, 0, 0, 0);
              return {
                setMask: function(b) {
                  c === b || g || (a.colorMask(b, b, b, b), (c = b));
                },
                setLocked: function(a) {
                  g = a;
                },
                setClear: function(g, c, d, w, e) {
                  !0 === e && ((g *= w), (c *= w), (d *= w));
                  b.set(g, c, d, w);
                  !1 === p.equals(b) && (a.clearColor(g, c, d, w), p.copy(b));
                },
                reset: function() {
                  g = !1;
                  c = null;
                  p.set(-1, 0, 0, 0);
                }
              };
            })(),
            q = new (function() {
              var g = !1,
                b = null,
                c = null,
                p = null;
              return {
                setTest: function(a) {
                  a ? w(2929) : e(2929);
                },
                setMask: function(c) {
                  b === c || g || (a.depthMask(c), (b = c));
                },
                setFunc: function(g) {
                  if (c !== g) {
                    if (g)
                      switch (g) {
                        case 0:
                          a.depthFunc(512);
                          break;
                        case 1:
                          a.depthFunc(519);
                          break;
                        case 2:
                          a.depthFunc(513);
                          break;
                        case 3:
                          a.depthFunc(515);
                          break;
                        case 4:
                          a.depthFunc(514);
                          break;
                        case 5:
                          a.depthFunc(518);
                          break;
                        case 6:
                          a.depthFunc(516);
                          break;
                        case 7:
                          a.depthFunc(517);
                          break;
                        default:
                          a.depthFunc(515);
                      }
                    else a.depthFunc(515);
                    c = g;
                  }
                },
                setLocked: function(a) {
                  g = a;
                },
                setClear: function(g) {
                  p !== g && (a.clearDepth(g), (p = g));
                },
                reset: function() {
                  g = !1;
                  p = c = b = null;
                }
              };
            })(),
            t = new (function() {
              var g = !1,
                b = null,
                c = null,
                p = null,
                d = null,
                f = null,
                x = null,
                h = null,
                k = null;
              return {
                setTest: function(a) {
                  g || (a ? w(2960) : e(2960));
                },
                setMask: function(c) {
                  b === c || g || (a.stencilMask(c), (b = c));
                },
                setFunc: function(g, b, w) {
                  if (c !== g || p !== b || d !== w)
                    a.stencilFunc(g, b, w), (c = g), (p = b), (d = w);
                },
                setOp: function(g, b, c) {
                  if (f !== g || x !== b || h !== c)
                    a.stencilOp(g, b, c), (f = g), (x = b), (h = c);
                },
                setLocked: function(a) {
                  g = a;
                },
                setClear: function(g) {
                  k !== g && (a.clearStencil(g), (k = g));
                },
                reset: function() {
                  g = !1;
                  k = h = x = f = d = p = c = b = null;
                }
              };
            })(),
            u = a.getParameter(34921),
            r = new Uint8Array(u),
            y = new Uint8Array(u),
            v = new Uint8Array(u),
            A = {},
            z = null,
            B = null,
            C = null,
            H = null,
            M = null,
            D = null,
            E = null,
            N = null,
            I = null,
            L = null,
            Jk = !1,
            Kk = null,
            Lk = null,
            O = null,
            J = null,
            P = null,
            F = a.getParameter(35661),
            S = !1;
          u = 0;
          u = a.getParameter(7938);
          -1 !== u.indexOf("WebGL")
            ? ((u = parseFloat(/^WebGL ([0-9])/.exec(u)[1])), (S = 1 <= u))
            : -1 !== u.indexOf("OpenGL ES") &&
              ((u = parseFloat(/^OpenGL ES ([0-9])/.exec(u)[1])), (S = 2 <= u));
          var Q = null,
            U = {},
            X = new m(),
            V = new m(),
            wd = {};
          wd[3553] = g(3553, 3553, 1);
          wd[34067] = g(34067, 34069, 6);
          n.setClear(0, 0, 0, 1);
          q.setClear(1);
          t.setClear(0);
          w(2929);
          q.setFunc(3);
          x(!1);
          h(1);
          w(2884);
          f(0);
          return {
            buffers: { color: n, depth: q, stencil: t },
            initAttributes: function() {
              for (var a = 0, g = r.length; a < g; a++) r[a] = 0;
            },
            enableAttribute: function(a) {
              p(a, 0);
            },
            enableAttributeAndDivisor: p,
            disableUnusedAttributes: function() {
              for (var g = 0, b = y.length; g !== b; ++g)
                y[g] !== r[g] && (a.disableVertexAttribArray(g), (y[g] = 0));
            },
            enable: w,
            disable: e,
            getCompressedTextureFormats: function() {
              if (
                null === z &&
                ((z = []),
                b.get("WEBGL_compressed_texture_pvrtc") ||
                  b.get("WEBGL_compressed_texture_s3tc") ||
                  b.get("WEBGL_compressed_texture_etc1") ||
                  b.get("WEBGL_compressed_texture_astc"))
              )
                for (var g = a.getParameter(34467), c = 0; c < g.length; c++)
                  z.push(g[c]);
              return z;
            },
            useProgram: function(g) {
              return B !== g ? (a.useProgram(g), (B = g), !0) : !1;
            },
            setBlending: f,
            setMaterial: function(a, g) {
              2 === a.side ? e(2884) : w(2884);
              var b = 1 === a.side;
              g && (b = !b);
              x(b);
              1 === a.blending && !1 === a.transparent
                ? f(0)
                : f(
                    a.blending,
                    a.blendEquation,
                    a.blendSrc,
                    a.blendDst,
                    a.blendEquationAlpha,
                    a.blendSrcAlpha,
                    a.blendDstAlpha,
                    a.premultipliedAlpha
                  );
              q.setFunc(a.depthFunc);
              q.setTest(a.depthTest);
              q.setMask(a.depthWrite);
              n.setMask(a.colorWrite);
              g = a.stencilWrite;
              t.setTest(g);
              g &&
                (t.setMask(a.stencilWriteMask),
                t.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask),
                t.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass));
              k(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
            },
            setFlipSided: x,
            setCullFace: h,
            setLineWidth: function(g) {
              g !== O && (S && a.lineWidth(g), (O = g));
            },
            setPolygonOffset: k,
            setScissorTest: function(a) {
              a ? w(3089) : e(3089);
            },
            activeTexture: l,
            bindTexture: function(g, b) {
              null === Q && l();
              var c = U[Q];
              void 0 === c &&
                ((c = { type: void 0, texture: void 0 }), (U[Q] = c));
              if (c.type !== g || c.texture !== b)
                a.bindTexture(g, b || wd[g]), (c.type = g), (c.texture = b);
            },
            compressedTexImage2D: function() {
              try {
                a.compressedTexImage2D.apply(a, arguments);
              } catch (Uj) {
                console.error("THREE.WebGLState:", Uj);
              }
            },
            texImage2D: function() {
              try {
                a.texImage2D.apply(a, arguments);
              } catch (Uj) {
                console.error("THREE.WebGLState:", Uj);
              }
            },
            texImage3D: function() {
              try {
                a.texImage3D.apply(a, arguments);
              } catch (Uj) {
                console.error("THREE.WebGLState:", Uj);
              }
            },
            scissor: function(g) {
              !1 === X.equals(g) && (a.scissor(g.x, g.y, g.z, g.w), X.copy(g));
            },
            viewport: function(g) {
              !1 === V.equals(g) && (a.viewport(g.x, g.y, g.z, g.w), V.copy(g));
            },
            reset: function() {
              for (var g = 0; g < y.length; g++)
                1 === y[g] && (a.disableVertexAttribArray(g), (y[g] = 0));
              A = {};
              Q = z = null;
              U = {};
              Lk = Kk = H = B = null;
              n.reset();
              q.reset();
              t.reset();
            }
          };
        }
        function Se(a, b, c, d, e, f, h) {
          function g(a, g) {
            return C
              ? new OffscreenCanvas(a, g)
              : document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                );
          }
          function p(a, b, c, p) {
            var d = 1;
            if (a.width > p || a.height > p)
              d = p / Math.max(a.width, a.height);
            if (1 > d || !0 === b) {
              if (
                ("undefined" !== typeof HTMLImageElement &&
                  a instanceof HTMLImageElement) ||
                ("undefined" !== typeof HTMLCanvasElement &&
                  a instanceof HTMLCanvasElement) ||
                ("undefined" !== typeof ImageBitmap && a instanceof ImageBitmap)
              )
                return (
                  (p = b ? ya.floorPowerOfTwo : Math.floor),
                  (b = p(d * a.width)),
                  (d = p(d * a.height)),
                  void 0 === B && (B = g(b, d)),
                  (c = c ? g(b, d) : B),
                  (c.width = b),
                  (c.height = d),
                  c.getContext("2d").drawImage(a, 0, 0, b, d),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      a.width +
                      "x" +
                      a.height +
                      ") to (" +
                      b +
                      "x" +
                      d +
                      ")."
                  ),
                  c
                );
              "data" in a &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    a.width +
                    "x" +
                    a.height +
                    ")."
                );
            }
            return a;
          }
          function w(a) {
            return ya.isPowerOfTwo(a.width) && ya.isPowerOfTwo(a.height);
          }
          function x(a, g) {
            return (
              a.generateMipmaps &&
              g &&
              1003 !== a.minFilter &&
              1006 !== a.minFilter
            );
          }
          function k(g, b, c, p) {
            a.generateMipmap(g);
            d.get(b).__maxMipLevel = Math.log(Math.max(c, p)) * Math.LOG2E;
          }
          function K(a, g) {
            if (!e.isWebGL2) return a;
            var c = a;
            6403 === a &&
              (5126 === g && (c = 33326),
              5131 === g && (c = 33325),
              5121 === g && (c = 33321));
            6407 === a &&
              (5126 === g && (c = 34837),
              5131 === g && (c = 34843),
              5121 === g && (c = 32849));
            6408 === a &&
              (5126 === g && (c = 34836),
              5131 === g && (c = 34842),
              5121 === g && (c = 32856));
            33325 === c || 33326 === c || 34842 === c || 34836 === c
              ? b.get("EXT_color_buffer_float")
              : (34843 === c || 34837 === c) &&
                console.warn(
                  "THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."
                );
            return c;
          }
          function l(a) {
            return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729;
          }
          function G(g) {
            g = g.target;
            g.removeEventListener("dispose", G);
            var b = d.get(g);
            void 0 !== b.__webglInit &&
              (a.deleteTexture(b.__webglTexture), d.remove(g));
            g.isVideoTexture && z.delete(g);
            h.memory.textures--;
          }
          function Z(g) {
            g = g.target;
            g.removeEventListener("dispose", Z);
            var b = d.get(g),
              c = d.get(g.texture);
            if (g) {
              void 0 !== c.__webglTexture && a.deleteTexture(c.__webglTexture);
              g.depthTexture && g.depthTexture.dispose();
              if (g.isWebGLRenderTargetCube)
                for (c = 0; 6 > c; c++)
                  a.deleteFramebuffer(b.__webglFramebuffer[c]),
                    b.__webglDepthbuffer &&
                      a.deleteRenderbuffer(b.__webglDepthbuffer[c]);
              else
                a.deleteFramebuffer(b.__webglFramebuffer),
                  b.__webglDepthbuffer &&
                    a.deleteRenderbuffer(b.__webglDepthbuffer);
              if (g.isWebGLMultiviewRenderTarget) {
                a.deleteTexture(b.__webglColorTexture);
                a.deleteTexture(b.__webglDepthStencilTexture);
                h.memory.textures -= 2;
                c = 0;
                for (var p = b.__webglViewFramebuffers.length; c < p; c++)
                  a.deleteFramebuffer(b.__webglViewFramebuffers[c]);
              }
              d.remove(g.texture);
              d.remove(g);
            }
            h.memory.textures--;
          }
          function m(a, g) {
            var b = d.get(a);
            if (a.isVideoTexture) {
              var p = h.render.frame;
              z.get(a) !== p && (z.set(a, p), a.update());
            }
            if (0 < a.version && b.__version !== a.version)
              if (((p = a.image), void 0 === p))
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                );
              else if (!1 === p.complete)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              else {
                r(b, a, g);
                return;
              }
            c.activeTexture(33984 + g);
            c.bindTexture(3553, b.__webglTexture);
          }
          function n(g, b) {
            if (6 === g.image.length) {
              var h = d.get(g);
              if (0 < g.version && h.__version !== g.version) {
                u(h, g);
                c.activeTexture(33984 + b);
                c.bindTexture(34067, h.__webglTexture);
                a.pixelStorei(37440, g.flipY);
                var l = g && g.isCompressedTexture;
                b = g.image[0] && g.image[0].isDataTexture;
                for (var G = [], Z = 0; 6 > Z; Z++)
                  G[Z] =
                    l || b
                      ? b
                        ? g.image[Z].image
                        : g.image[Z]
                      : p(g.image[Z], !1, !0, e.maxCubemapSize);
                var m = G[0],
                  Y = w(m) || e.isWebGL2,
                  R = f.convert(g.format),
                  n = f.convert(g.type),
                  ea = K(R, n);
                t(34067, g, Y);
                if (l) {
                  for (Z = 0; 6 > Z; Z++) {
                    var q = G[Z].mipmaps;
                    for (l = 0; l < q.length; l++) {
                      var ab = q[l];
                      1023 !== g.format && 1022 !== g.format
                        ? -1 < c.getCompressedTextureFormats().indexOf(R)
                          ? c.compressedTexImage2D(
                              34069 + Z,
                              l,
                              ea,
                              ab.width,
                              ab.height,
                              0,
                              ab.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : c.texImage2D(
                            34069 + Z,
                            l,
                            ea,
                            ab.width,
                            ab.height,
                            0,
                            R,
                            n,
                            ab.data
                          );
                    }
                  }
                  h.__maxMipLevel = q.length - 1;
                } else {
                  q = g.mipmaps;
                  for (Z = 0; 6 > Z; Z++)
                    if (b)
                      for (
                        c.texImage2D(
                          34069 + Z,
                          0,
                          ea,
                          G[Z].width,
                          G[Z].height,
                          0,
                          R,
                          n,
                          G[Z].data
                        ),
                          l = 0;
                        l < q.length;
                        l++
                      )
                        (ab = q[l]),
                          (ab = ab.image[Z].image),
                          c.texImage2D(
                            34069 + Z,
                            l + 1,
                            ea,
                            ab.width,
                            ab.height,
                            0,
                            R,
                            n,
                            ab.data
                          );
                    else
                      for (
                        c.texImage2D(34069 + Z, 0, ea, R, n, G[Z]), l = 0;
                        l < q.length;
                        l++
                      )
                        (ab = q[l]),
                          c.texImage2D(34069 + Z, l + 1, ea, R, n, ab.image[Z]);
                  h.__maxMipLevel = q.length;
                }
                x(g, Y) && k(34067, g, m.width, m.height);
                h.__version = g.version;
                if (g.onUpdate) g.onUpdate(g);
              } else
                c.activeTexture(33984 + b),
                  c.bindTexture(34067, h.__webglTexture);
            }
          }
          function q(a, g) {
            c.activeTexture(33984 + g);
            c.bindTexture(34067, d.get(a).__webglTexture);
          }
          function t(g, c, p) {
            p
              ? (a.texParameteri(g, 10242, f.convert(c.wrapS)),
                a.texParameteri(g, 10243, f.convert(c.wrapT)),
                (32879 !== g && 35866 !== g) ||
                  a.texParameteri(g, 32882, f.convert(c.wrapR)),
                a.texParameteri(g, 10240, f.convert(c.magFilter)),
                a.texParameteri(g, 10241, f.convert(c.minFilter)))
              : (a.texParameteri(g, 10242, 33071),
                a.texParameteri(g, 10243, 33071),
                (32879 !== g && 35866 !== g) ||
                  a.texParameteri(g, 32882, 33071),
                (1001 === c.wrapS && 1001 === c.wrapT) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                a.texParameteri(g, 10240, l(c.magFilter)),
                a.texParameteri(g, 10241, l(c.minFilter)),
                1003 !== c.minFilter &&
                  1006 !== c.minFilter &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  ));
            !(p = b.get("EXT_texture_filter_anisotropic")) ||
              (1015 === c.type && null === b.get("OES_texture_float_linear")) ||
              (1016 === c.type &&
                null ===
                  (e.isWebGL2 || b.get("OES_texture_half_float_linear"))) ||
              !(1 < c.anisotropy || d.get(c).__currentAnisotropy) ||
              (a.texParameterf(
                g,
                p.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(c.anisotropy, e.getMaxAnisotropy())
              ),
              (d.get(c).__currentAnisotropy = c.anisotropy));
          }
          function u(g, b) {
            void 0 === g.__webglInit &&
              ((g.__webglInit = !0),
              b.addEventListener("dispose", G),
              (g.__webglTexture = a.createTexture()),
              h.memory.textures++);
          }
          function r(g, b, d) {
            var h = 3553;
            b.isDataTexture2DArray && (h = 35866);
            b.isDataTexture3D && (h = 32879);
            u(g, b);
            c.activeTexture(33984 + d);
            c.bindTexture(h, g.__webglTexture);
            a.pixelStorei(37440, b.flipY);
            a.pixelStorei(37441, b.premultiplyAlpha);
            a.pixelStorei(3317, b.unpackAlignment);
            d = e.isWebGL2
              ? !1
              : 1001 !== b.wrapS ||
                1001 !== b.wrapT ||
                (1003 !== b.minFilter && 1006 !== b.minFilter);
            d = d && !1 === w(b.image);
            d = p(b.image, d, !1, e.maxTextureSize);
            var l = w(d) || e.isWebGL2,
              G = f.convert(b.format),
              Z = f.convert(b.type),
              m = K(G, Z);
            t(h, b, l);
            var Y = b.mipmaps;
            if (b.isDepthTexture) {
              m = 6402;
              if (1015 === b.type) {
                if (!e.isWebGL2)
                  throw Error("Float Depth Texture only supported in WebGL2.0");
                m = 36012;
              } else e.isWebGL2 && (m = 33189);
              1026 === b.format &&
                6402 === m &&
                1012 !== b.type &&
                1014 !== b.type &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (b.type = 1012),
                (Z = f.convert(b.type)));
              1027 === b.format &&
                ((m = 34041),
                1020 !== b.type &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (b.type = 1020),
                  (Z = f.convert(b.type))));
              c.texImage2D(3553, 0, m, d.width, d.height, 0, G, Z, null);
            } else if (b.isDataTexture)
              if (0 < Y.length && l) {
                for (var R = 0, n = Y.length; R < n; R++)
                  (h = Y[R]),
                    c.texImage2D(
                      3553,
                      R,
                      m,
                      h.width,
                      h.height,
                      0,
                      G,
                      Z,
                      h.data
                    );
                b.generateMipmaps = !1;
                g.__maxMipLevel = Y.length - 1;
              } else
                c.texImage2D(3553, 0, m, d.width, d.height, 0, G, Z, d.data),
                  (g.__maxMipLevel = 0);
            else if (b.isCompressedTexture) {
              R = 0;
              for (n = Y.length; R < n; R++)
                (h = Y[R]),
                  1023 !== b.format && 1022 !== b.format
                    ? -1 < c.getCompressedTextureFormats().indexOf(G)
                      ? c.compressedTexImage2D(
                          3553,
                          R,
                          m,
                          h.width,
                          h.height,
                          0,
                          h.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : c.texImage2D(
                        3553,
                        R,
                        m,
                        h.width,
                        h.height,
                        0,
                        G,
                        Z,
                        h.data
                      );
              g.__maxMipLevel = Y.length - 1;
            } else if (b.isDataTexture2DArray)
              c.texImage3D(
                35866,
                0,
                m,
                d.width,
                d.height,
                d.depth,
                0,
                G,
                Z,
                d.data
              ),
                (g.__maxMipLevel = 0);
            else if (b.isDataTexture3D)
              c.texImage3D(
                32879,
                0,
                m,
                d.width,
                d.height,
                d.depth,
                0,
                G,
                Z,
                d.data
              ),
                (g.__maxMipLevel = 0);
            else if (0 < Y.length && l) {
              R = 0;
              for (n = Y.length; R < n; R++)
                (h = Y[R]), c.texImage2D(3553, R, m, G, Z, h);
              b.generateMipmaps = !1;
              g.__maxMipLevel = Y.length - 1;
            } else c.texImage2D(3553, 0, m, G, Z, d), (g.__maxMipLevel = 0);
            x(b, l) && k(3553, b, d.width, d.height);
            g.__version = b.version;
            if (b.onUpdate) b.onUpdate(b);
          }
          function y(g, b, p, w) {
            var e = f.convert(b.texture.format),
              x = f.convert(b.texture.type),
              h = K(e, x);
            c.texImage2D(w, 0, h, b.width, b.height, 0, e, x, null);
            a.bindFramebuffer(36160, g);
            a.framebufferTexture2D(
              36160,
              p,
              w,
              d.get(b.texture).__webglTexture,
              0
            );
            a.bindFramebuffer(36160, null);
          }
          function v(g, b, c) {
            a.bindRenderbuffer(36161, g);
            if (b.depthBuffer && !b.stencilBuffer)
              c
                ? ((c = A(b)),
                  a.renderbufferStorageMultisample(
                    36161,
                    c,
                    33189,
                    b.width,
                    b.height
                  ))
                : a.renderbufferStorage(36161, 33189, b.width, b.height),
                a.framebufferRenderbuffer(36160, 36096, 36161, g);
            else if (b.depthBuffer && b.stencilBuffer)
              c
                ? ((c = A(b)),
                  a.renderbufferStorageMultisample(
                    36161,
                    c,
                    35056,
                    b.width,
                    b.height
                  ))
                : a.renderbufferStorage(36161, 34041, b.width, b.height),
                a.framebufferRenderbuffer(36160, 33306, 36161, g);
            else {
              g = f.convert(b.texture.format);
              var p = f.convert(b.texture.type);
              g = K(g, p);
              c
                ? ((c = A(b)),
                  a.renderbufferStorageMultisample(
                    36161,
                    c,
                    g,
                    b.width,
                    b.height
                  ))
                : a.renderbufferStorage(36161, g, b.width, b.height);
            }
            a.bindRenderbuffer(36161, null);
          }
          function A(a) {
            return e.isWebGL2 && a.isWebGLMultisampleRenderTarget
              ? Math.min(e.maxSamples, a.samples)
              : 0;
          }
          var z = new WeakMap(),
            B,
            C =
              "undefined" !== typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d"),
            H = 0,
            M = !1,
            D = !1;
          this.allocateTextureUnit = function() {
            var a = H;
            a >= e.maxTextures &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  a +
                  " texture units while this GPU supports only " +
                  e.maxTextures
              );
            H += 1;
            return a;
          };
          this.resetTextureUnits = function() {
            H = 0;
          };
          this.setTexture2D = m;
          this.setTexture2DArray = function(a, g) {
            var b = d.get(a);
            0 < a.version && b.__version !== a.version
              ? r(b, a, g)
              : (c.activeTexture(33984 + g),
                c.bindTexture(35866, b.__webglTexture));
          };
          this.setTexture3D = function(a, g) {
            var b = d.get(a);
            0 < a.version && b.__version !== a.version
              ? r(b, a, g)
              : (c.activeTexture(33984 + g),
                c.bindTexture(32879, b.__webglTexture));
          };
          this.setTextureCube = n;
          this.setTextureCubeDynamic = q;
          this.setupRenderTarget = function(g) {
            var p = d.get(g),
              l = d.get(g.texture);
            g.addEventListener("dispose", Z);
            l.__webglTexture = a.createTexture();
            h.memory.textures++;
            var G = !0 === g.isWebGLRenderTargetCube,
              Y = !0 === g.isWebGLMultisampleRenderTarget,
              R = !0 === g.isWebGLMultiviewRenderTarget,
              n = w(g) || e.isWebGL2;
            if (G) {
              p.__webglFramebuffer = [];
              for (var ea = 0; 6 > ea; ea++)
                p.__webglFramebuffer[ea] = a.createFramebuffer();
            } else if (((p.__webglFramebuffer = a.createFramebuffer()), Y))
              if (e.isWebGL2) {
                p.__webglMultisampledFramebuffer = a.createFramebuffer();
                p.__webglColorRenderbuffer = a.createRenderbuffer();
                a.bindRenderbuffer(36161, p.__webglColorRenderbuffer);
                Y = f.convert(g.texture.format);
                var q = f.convert(g.texture.type);
                Y = K(Y, q);
                q = A(g);
                a.renderbufferStorageMultisample(
                  36161,
                  q,
                  Y,
                  g.width,
                  g.height
                );
                a.bindFramebuffer(36160, p.__webglMultisampledFramebuffer);
                a.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  p.__webglColorRenderbuffer
                );
                a.bindRenderbuffer(36161, null);
                g.depthBuffer &&
                  ((p.__webglDepthRenderbuffer = a.createRenderbuffer()),
                  v(p.__webglDepthRenderbuffer, g, !0));
                a.bindFramebuffer(36160, null);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
            else if (R) {
              ea = g.width;
              var u = g.height;
              Y = g.numViews;
              a.bindFramebuffer(36160, p.__webglFramebuffer);
              var ab = b.get("OVR_multiview2");
              h.memory.textures += 2;
              q = a.createTexture();
              a.bindTexture(35866, q);
              a.texParameteri(35866, 10240, 9728);
              a.texParameteri(35866, 10241, 9728);
              a.texImage3D(35866, 0, 32856, ea, u, Y, 0, 6408, 5121, null);
              ab.framebufferTextureMultiviewOVR(36160, 36064, q, 0, 0, Y);
              var r = a.createTexture();
              a.bindTexture(35866, r);
              a.texParameteri(35866, 10240, 9728);
              a.texParameteri(35866, 10241, 9728);
              a.texImage3D(35866, 0, 35056, ea, u, Y, 0, 34041, 34042, null);
              ab.framebufferTextureMultiviewOVR(36160, 33306, r, 0, 0, Y);
              u = Array(Y);
              for (ea = 0; ea < Y; ++ea)
                (u[ea] = a.createFramebuffer()),
                  a.bindFramebuffer(36160, u[ea]),
                  a.framebufferTextureLayer(36160, 36064, q, 0, ea);
              p.__webglColorTexture = q;
              p.__webglDepthStencilTexture = r;
              p.__webglViewFramebuffers = u;
              a.bindFramebuffer(36160, null);
              a.bindTexture(35866, null);
            }
            if (G) {
              c.bindTexture(34067, l.__webglTexture);
              t(34067, g.texture, n);
              for (ea = 0; 6 > ea; ea++)
                y(p.__webglFramebuffer[ea], g, 36064, 34069 + ea);
              x(g.texture, n) && k(34067, g.texture, g.width, g.height);
              c.bindTexture(34067, null);
            } else
              R ||
                (c.bindTexture(3553, l.__webglTexture),
                t(3553, g.texture, n),
                y(p.__webglFramebuffer, g, 36064, 3553),
                x(g.texture, n) && k(3553, g.texture, g.width, g.height),
                c.bindTexture(3553, null));
            if (g.depthBuffer) {
              p = d.get(g);
              l = !0 === g.isWebGLRenderTargetCube;
              if (g.depthTexture) {
                if (l)
                  throw Error(
                    "target.depthTexture not supported in Cube render targets"
                  );
                if (g && g.isWebGLRenderTargetCube)
                  throw Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                a.bindFramebuffer(36160, p.__webglFramebuffer);
                if (!g.depthTexture || !g.depthTexture.isDepthTexture)
                  throw Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (d.get(g.depthTexture).__webglTexture &&
                  g.depthTexture.image.width === g.width &&
                  g.depthTexture.image.height === g.height) ||
                  ((g.depthTexture.image.width = g.width),
                  (g.depthTexture.image.height = g.height),
                  (g.depthTexture.needsUpdate = !0));
                m(g.depthTexture, 0);
                p = d.get(g.depthTexture).__webglTexture;
                if (1026 === g.depthTexture.format)
                  a.framebufferTexture2D(36160, 36096, 3553, p, 0);
                else if (1027 === g.depthTexture.format)
                  a.framebufferTexture2D(36160, 33306, 3553, p, 0);
                else throw Error("Unknown depthTexture format");
              } else if (l)
                for (p.__webglDepthbuffer = [], l = 0; 6 > l; l++)
                  a.bindFramebuffer(36160, p.__webglFramebuffer[l]),
                    (p.__webglDepthbuffer[l] = a.createRenderbuffer()),
                    v(p.__webglDepthbuffer[l], g);
              else
                a.bindFramebuffer(36160, p.__webglFramebuffer),
                  (p.__webglDepthbuffer = a.createRenderbuffer()),
                  v(p.__webglDepthbuffer, g);
              a.bindFramebuffer(36160, null);
            }
          };
          this.updateRenderTargetMipmap = function(a) {
            var g = a.texture,
              b = w(a) || e.isWebGL2;
            if (x(g, b)) {
              b = a.isWebGLRenderTargetCube ? 34067 : 3553;
              var p = d.get(g).__webglTexture;
              c.bindTexture(b, p);
              k(b, g, a.width, a.height);
              c.bindTexture(b, null);
            }
          };
          this.updateMultisampleRenderTarget = function(g) {
            if (g.isWebGLMultisampleRenderTarget)
              if (e.isWebGL2) {
                var b = d.get(g);
                a.bindFramebuffer(36008, b.__webglMultisampledFramebuffer);
                a.bindFramebuffer(36009, b.__webglFramebuffer);
                b = g.width;
                var c = g.height,
                  p = 16384;
                g.depthBuffer && (p |= 256);
                g.stencilBuffer && (p |= 1024);
                a.blitFramebuffer(0, 0, b, c, 0, 0, b, c, p, 9728);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
          };
          this.safeSetTexture2D = function(a, g) {
            a &&
              a.isWebGLRenderTarget &&
              (!1 === M &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (M = !0)),
              (a = a.texture));
            m(a, g);
          };
          this.safeSetTextureCube = function(a, g) {
            a &&
              a.isWebGLRenderTargetCube &&
              (!1 === D &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (D = !0)),
              (a = a.texture));
            (a && a.isCubeTexture) ||
            (Array.isArray(a.image) && 6 === a.image.length)
              ? n(a, g)
              : q(a, g);
          };
        }
        function Rd(a, b, c) {
          return {
            convert: function(a) {
              if (1e3 === a) return 10497;
              if (1001 === a) return 33071;
              if (1002 === a) return 33648;
              if (1003 === a) return 9728;
              if (1004 === a) return 9984;
              if (1005 === a) return 9986;
              if (1006 === a) return 9729;
              if (1007 === a) return 9985;
              if (1008 === a) return 9987;
              if (1009 === a) return 5121;
              if (1017 === a) return 32819;
              if (1018 === a) return 32820;
              if (1019 === a) return 33635;
              if (1010 === a) return 5120;
              if (1011 === a) return 5122;
              if (1012 === a) return 5123;
              if (1013 === a) return 5124;
              if (1014 === a) return 5125;
              if (1015 === a) return 5126;
              if (1016 === a) {
                if (c.isWebGL2) return 5131;
                var g = b.get("OES_texture_half_float");
                if (null !== g) return g.HALF_FLOAT_OES;
              }
              if (1021 === a) return 6406;
              if (1022 === a) return 6407;
              if (1023 === a) return 6408;
              if (1024 === a) return 6409;
              if (1025 === a) return 6410;
              if (1026 === a) return 6402;
              if (1027 === a) return 34041;
              if (1028 === a) return 6403;
              if (100 === a) return 32774;
              if (101 === a) return 32778;
              if (102 === a) return 32779;
              if (200 === a) return 0;
              if (201 === a) return 1;
              if (202 === a) return 768;
              if (203 === a) return 769;
              if (204 === a) return 770;
              if (205 === a) return 771;
              if (206 === a) return 772;
              if (207 === a) return 773;
              if (208 === a) return 774;
              if (209 === a) return 775;
              if (210 === a) return 776;
              if (33776 === a || 33777 === a || 33778 === a || 33779 === a)
                if (
                  ((g = b.get("WEBGL_compressed_texture_s3tc")), null !== g)
                ) {
                  if (33776 === a) return g.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (33777 === a) return g.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (33778 === a) return g.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (33779 === a) return g.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              if (35840 === a || 35841 === a || 35842 === a || 35843 === a)
                if (
                  ((g = b.get("WEBGL_compressed_texture_pvrtc")), null !== g)
                ) {
                  if (35840 === a) return g.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (35841 === a) return g.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (35842 === a) return g.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (35843 === a) return g.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
              if (
                36196 === a &&
                ((g = b.get("WEBGL_compressed_texture_etc1")), null !== g)
              )
                return g.COMPRESSED_RGB_ETC1_WEBGL;
              if (
                37808 === a ||
                37809 === a ||
                37810 === a ||
                37811 === a ||
                37812 === a ||
                37813 === a ||
                37814 === a ||
                37815 === a ||
                37816 === a ||
                37817 === a ||
                37818 === a ||
                37819 === a ||
                37820 === a ||
                37821 === a
              )
                if (((g = b.get("WEBGL_compressed_texture_astc")), null !== g))
                  return a;
              if (103 === a || 104 === a) {
                if (c.isWebGL2) {
                  if (103 === a) return 32775;
                  if (104 === a) return 32776;
                }
                g = b.get("EXT_blend_minmax");
                if (null !== g) {
                  if (103 === a) return g.MIN_EXT;
                  if (104 === a) return g.MAX_EXT;
                }
              }
              if (1020 === a) {
                if (c.isWebGL2) return 34042;
                g = b.get("WEBGL_depth_texture");
                if (null !== g) return g.UNSIGNED_INT_24_8_WEBGL;
              }
              return 0;
            }
          };
        }
        function ld(a, b, c, d) {
          n.call(this, a, b, d);
          this.stencilBuffer = this.depthBuffer = !1;
          this.numViews = c;
        }
        function Te(a, b) {
          function g(a) {
            if (a.isArrayCamera) return a.cameras;
            n[0] = a;
            return n;
          }
          function p(a) {
            if (void 0 === a.isArrayCamera) return !0;
            a = a.cameras;
            if (a.length > r) return !1;
            for (var g = 1, b = a.length; g < b; g++)
              if (
                a[0].viewport.z !== a[g].viewport.z ||
                a[0].viewport.w !== a[g].viewport.w
              )
                return !1;
            return !0;
          }
          var d = a.extensions,
            e = a.properties,
            f,
            h,
            l,
            m,
            n,
            q,
            u,
            r = 0;
          this.isAvailable = function() {
            if (void 0 === u) {
              var a = d.get("OVR_multiview2");
              if ((u = null !== a && !1 === b.getContextAttributes().antialias))
                for (
                  r = b.getParameter(a.MAX_VIEWS_OVR),
                    f = new ld(0, 0, 2),
                    q = new c(),
                    m = [],
                    l = [],
                    n = [],
                    a = 0;
                  a < r;
                  a++
                )
                  (m[a] = new t()), (l[a] = new k());
            }
            return u;
          };
          this.attachCamera = function(g) {
            if (!1 !== p(g)) {
              (h = a.getRenderTarget())
                ? q.set(h.width, h.height)
                : a.getDrawingBufferSize(q);
              if (g.isArrayCamera) {
                var b = g.cameras[0].viewport;
                f.setSize(b.z, b.w);
                f.setNumViews(g.cameras.length);
              } else f.setSize(q.x, q.y), f.setNumViews(2);
              a.setRenderTarget(f);
            }
          };
          this.detachCamera = function(g) {
            if (f === a.getRenderTarget()) {
              a.setRenderTarget(h);
              var c = f,
                p = c.numViews,
                d = e.get(c).__webglViewFramebuffers,
                w = c.width;
              c = c.height;
              if (g.isArrayCamera)
                for (var x = 0; x < p; x++) {
                  var k = g.cameras[x].viewport,
                    K = k.x,
                    l = k.y,
                    G = K + k.z;
                  k = l + k.w;
                  b.bindFramebuffer(36008, d[x]);
                  b.blitFramebuffer(0, 0, w, c, K, l, G, k, 16384, 9728);
                }
              else
                b.bindFramebuffer(36008, d[0]),
                  b.blitFramebuffer(0, 0, w, c, 0, 0, q.x, q.y, 16384, 9728);
            }
          };
          this.updateCameraProjectionMatricesUniform = function(a, c) {
            a = g(a);
            for (var p = 0; p < a.length; p++) m[p].copy(a[p].projectionMatrix);
            c.setValue(b, "projectionMatrices", m);
          };
          this.updateCameraViewMatricesUniform = function(a, c) {
            a = g(a);
            for (var p = 0; p < a.length; p++)
              m[p].copy(a[p].matrixWorldInverse);
            c.setValue(b, "viewMatrices", m);
          };
          this.updateObjectMatricesUniforms = function(a, c, p) {
            c = g(c);
            for (var d = 0; d < c.length; d++)
              m[d].multiplyMatrices(c[d].matrixWorldInverse, a.matrixWorld),
                l[d].getNormalMatrix(m[d]);
            p.setValue(b, "modelViewMatrices", m);
            p.setValue(b, "normalMatrices", l);
          };
        }
        function Fb() {
          v.call(this);
          this.type = "Group";
        }
        function Rb(a) {
          Da.call(this);
          this.cameras = a || [];
        }
        function Wd(a, b, c) {
          ai.setFromMatrixPosition(b.matrixWorld);
          bi.setFromMatrixPosition(c.matrixWorld);
          var g = ai.distanceTo(bi),
            p = b.projectionMatrix.elements,
            d = c.projectionMatrix.elements,
            w = p[14] / (p[10] - 1);
          c = p[14] / (p[10] + 1);
          var e = (p[9] + 1) / p[5],
            f = (p[9] - 1) / p[5],
            h = (p[8] - 1) / p[0],
            k = (d[8] + 1) / d[0];
          p = w * h;
          d = w * k;
          k = g / (-h + k);
          h = k * -h;
          b.matrixWorld.decompose(a.position, a.quaternion, a.scale);
          a.translateX(h);
          a.translateZ(k);
          a.matrixWorld.compose(a.position, a.quaternion, a.scale);
          a.matrixWorldInverse.getInverse(a.matrixWorld);
          b = w + k;
          w = c + k;
          a.projectionMatrix.makePerspective(
            p - h,
            d + (g - h),
            ((e * c) / w) * b,
            ((f * c) / w) * b,
            b,
            w
          );
        }
        function od(a) {
          function g() {
            return null !== Y && !0 === Y.isPresenting;
          }
          function b() {
            if (g()) {
              var b = Y.getEyeParameters("left");
              e = 2 * b.renderWidth * y;
              k = b.renderHeight * y;
              E = a.getPixelRatio();
              a.getSize(D);
              a.setDrawingBufferSize(e, k, 1);
              C.viewport.set(0, 0, e / 2, k);
              H.viewport.set(e / 2, 0, e / 2, k);
              I.start();
              l.dispatchEvent({ type: "sessionstart" });
            } else l.enabled && a.setDrawingBufferSize(D.width, D.height, E), I.stop(), l.dispatchEvent({ type: "sessionend" });
          }
          function d(a, g) {
            null !== g &&
              4 === g.length &&
              a.set(g[0] * e, g[1] * k, g[2] * e, g[3] * k);
          }
          var e,
            k,
            l = this,
            Y = null,
            R = null,
            n = null,
            q = [],
            u = new t(),
            r = new t(),
            y = 1,
            v = "local-floor";
          "undefined" !== typeof window &&
            "VRFrameData" in window &&
            ((R = new window.VRFrameData()),
            window.addEventListener("vrdisplaypresentchange", b, !1));
          var A = new t(),
            z = new f(),
            B = new h(),
            C = new Da();
          C.viewport = new m();
          C.layers.enable(1);
          var H = new Da();
          H.viewport = new m();
          H.layers.enable(2);
          var M = new Rb([C, H]);
          M.layers.enable(1);
          M.layers.enable(2);
          var D = new c(),
            E,
            N = [];
          this.enabled = !1;
          this.getController = function(a) {
            var g = q[a];
            void 0 === g &&
              ((g = new Fb()),
              (g.matrixAutoUpdate = !1),
              (g.visible = !1),
              (q[a] = g));
            return g;
          };
          this.getDevice = function() {
            return Y;
          };
          this.setDevice = function(a) {
            void 0 !== a && (Y = a);
            I.setContext(a);
          };
          this.setFramebufferScaleFactor = function(a) {
            y = a;
          };
          this.setReferenceSpaceType = function(a) {
            v = a;
          };
          this.setPoseTarget = function(a) {
            void 0 !== a && (n = a);
          };
          this.getCamera = function(a) {
            var b = "local-floor" === v ? 1.6 : 0;
            if (!1 === g())
              return a.position.set(0, b, 0), a.rotation.set(0, 0, 0), a;
            Y.depthNear = a.near;
            Y.depthFar = a.far;
            Y.getFrameData(R);
            if ("local-floor" === v) {
              var c = Y.stageParameters;
              c
                ? u.fromArray(c.sittingToStandingTransform)
                : u.makeTranslation(0, b, 0);
            }
            b = R.pose;
            c = null !== n ? n : a;
            c.matrix.copy(u);
            c.matrix.decompose(c.position, c.quaternion, c.scale);
            null !== b.orientation &&
              (z.fromArray(b.orientation), c.quaternion.multiply(z));
            null !== b.position &&
              (z.setFromRotationMatrix(u),
              B.fromArray(b.position),
              B.applyQuaternion(z),
              c.position.add(B));
            c.updateMatrixWorld();
            C.near = a.near;
            H.near = a.near;
            C.far = a.far;
            H.far = a.far;
            C.matrixWorldInverse.fromArray(R.leftViewMatrix);
            H.matrixWorldInverse.fromArray(R.rightViewMatrix);
            r.getInverse(u);
            "local-floor" === v &&
              (C.matrixWorldInverse.multiply(r),
              H.matrixWorldInverse.multiply(r));
            a = c.parent;
            null !== a &&
              (A.getInverse(a.matrixWorld),
              C.matrixWorldInverse.multiply(A),
              H.matrixWorldInverse.multiply(A));
            C.matrixWorld.getInverse(C.matrixWorldInverse);
            H.matrixWorld.getInverse(H.matrixWorldInverse);
            C.projectionMatrix.fromArray(R.leftProjectionMatrix);
            H.projectionMatrix.fromArray(R.rightProjectionMatrix);
            Wd(M, C, H);
            a = Y.getLayers();
            a.length &&
              ((a = a[0]),
              d(C.viewport, a.leftBounds),
              d(H.viewport, a.rightBounds));
            a: for (a = 0; a < q.length; a++) {
              b = q[a];
              b: {
                c = a;
                for (
                  var p = navigator.getGamepads && navigator.getGamepads(),
                    w = 0,
                    e = 0,
                    f = p.length;
                  w < f;
                  w++
                ) {
                  var h = p[w];
                  if (
                    h &&
                    ("Daydream Controller" === h.id ||
                      "Gear VR Controller" === h.id ||
                      "Oculus Go Controller" === h.id ||
                      "OpenVR Gamepad" === h.id ||
                      h.id.startsWith("Oculus Touch") ||
                      h.id.startsWith("HTC Vive Focus") ||
                      h.id.startsWith("Spatial Controller"))
                  ) {
                    if (e === c) {
                      c = h;
                      break b;
                    }
                    e++;
                  }
                }
                c = void 0;
              }
              if (void 0 !== c && void 0 !== c.pose) {
                if (null === c.pose) break a;
                p = c.pose;
                !1 === p.hasPosition && b.position.set(0.2, -0.6, -0.05);
                null !== p.position && b.position.fromArray(p.position);
                null !== p.orientation && b.quaternion.fromArray(p.orientation);
                b.matrix.compose(b.position, b.quaternion, b.scale);
                b.matrix.premultiply(u);
                b.matrix.decompose(b.position, b.quaternion, b.scale);
                b.matrixWorldNeedsUpdate = !0;
                b.visible = !0;
                p = "Daydream Controller" === c.id ? 0 : 1;
                void 0 === N[a] && (N[a] = !1);
                N[a] !== c.buttons[p].pressed &&
                  ((N[a] = c.buttons[p].pressed),
                  !0 === N[a]
                    ? b.dispatchEvent({ type: "selectstart" })
                    : (b.dispatchEvent({ type: "selectend" }),
                      b.dispatchEvent({ type: "select" })));
              } else b.visible = !1;
            }
            return M;
          };
          this.getStandingMatrix = function() {
            return u;
          };
          this.isPresenting = g;
          var I = new Ma();
          this.setAnimationLoop = function(a) {
            I.setAnimationLoop(a);
            g() && I.start();
          };
          this.submitFrame = function() {
            g() && Y.submitFrame();
          };
          this.dispose = function() {
            "undefined" !== typeof window &&
              window.removeEventListener("vrdisplaypresentchange", b);
          };
          this.setFrameOfReferenceType = function() {
            console.warn(
              "THREE.WebVRManager: setFrameOfReferenceType() has been deprecated."
            );
          };
        }
        function de(a, b) {
          function g() {
            return null !== h && null !== k;
          }
          function c(a) {
            for (var g = 0; g < q.length; g++)
              u[g] === a.inputSource && q[g].dispatchEvent({ type: a.type });
          }
          function p() {
            a.setFramebuffer(null);
            a.setRenderTarget(a.getRenderTarget());
            z.stop();
            f.dispatchEvent({ type: "sessionend" });
          }
          function d(a) {
            k = a;
            z.setContext(h);
            z.start();
            f.dispatchEvent({ type: "sessionstart" });
          }
          function e(a, g) {
            null === g
              ? a.matrixWorld.copy(a.matrix)
              : a.matrixWorld.multiplyMatrices(g.matrixWorld, a.matrix);
            a.matrixWorldInverse.getInverse(a.matrixWorld);
          }
          var f = this,
            h = null,
            k = null,
            l = "local-floor",
            n = null,
            q = [],
            u = [],
            r = new Da();
          r.layers.enable(1);
          r.viewport = new m();
          var y = new Da();
          y.layers.enable(2);
          y.viewport = new m();
          var v = new Rb([r, y]);
          v.layers.enable(1);
          v.layers.enable(2);
          this.enabled = !1;
          this.getController = function(a) {
            var g = q[a];
            void 0 === g &&
              ((g = new Fb()),
              (g.matrixAutoUpdate = !1),
              (g.visible = !1),
              (q[a] = g));
            return g;
          };
          this.setFramebufferScaleFactor = function() {};
          this.setReferenceSpaceType = function(a) {
            l = a;
          };
          this.getSession = function() {
            return h;
          };
          this.setSession = function(a) {
            h = a;
            null !== h &&
              (h.addEventListener("select", c),
              h.addEventListener("selectstart", c),
              h.addEventListener("selectend", c),
              h.addEventListener("end", p),
              h.updateRenderState({ baseLayer: new XRWebGLLayer(h, b) }),
              h.requestReferenceSpace(l).then(d),
              (u = h.inputSources),
              h.addEventListener("inputsourceschange", function() {
                u = h.inputSources;
                for (var a = 0; a < q.length; a++)
                  q[a].userData.inputSource = u[a];
              }));
          };
          this.getCamera = function(a) {
            if (g()) {
              var b = a.parent,
                c = v.cameras;
              e(v, b);
              for (var p = 0; p < c.length; p++) e(c[p], b);
              a.matrixWorld.copy(v.matrixWorld);
              a = a.children;
              p = 0;
              for (b = a.length; p < b; p++) a[p].updateMatrixWorld(!0);
              Wd(v, r, y);
              return v;
            }
            return a;
          };
          this.isPresenting = g;
          var A = null,
            z = new Ma();
          z.setAnimationLoop(function(g, b) {
            n = b.getViewerPose(k);
            if (null !== n) {
              var c = n.views,
                p = h.renderState.baseLayer;
              a.setFramebuffer(p.framebuffer);
              for (var d = 0; d < c.length; d++) {
                var w = c[d],
                  e = p.getViewport(w),
                  f = v.cameras[d];
                f.matrix
                  .fromArray(w.transform.inverse.matrix)
                  .getInverse(f.matrix);
                f.projectionMatrix.fromArray(w.projectionMatrix);
                f.viewport.set(e.x, e.y, e.width, e.height);
                0 === d && v.matrix.copy(f.matrix);
              }
            }
            for (d = 0; d < q.length; d++) {
              c = q[d];
              if ((p = u[d]))
                if (((p = b.getPose(p.targetRaySpace, k)), null !== p)) {
                  c.matrix.fromArray(p.transform.matrix);
                  c.matrix.decompose(c.position, c.rotation, c.scale);
                  c.visible = !0;
                  continue;
                }
              c.visible = !1;
            }
            A && A(g);
          });
          this.setAnimationLoop = function(a) {
            A = a;
          };
          this.dispose = function() {};
          this.getStandingMatrix = function() {
            console.warn(
              "THREE.WebXRManager: getStandingMatrix() is no longer needed."
            );
            return new t();
          };
          this.getDevice = function() {
            console.warn(
              "THREE.WebXRManager: getDevice() has been deprecated."
            );
          };
          this.setDevice = function() {
            console.warn(
              "THREE.WebXRManager: setDevice() has been deprecated."
            );
          };
          this.setFrameOfReferenceType = function() {
            console.warn(
              "THREE.WebXRManager: setFrameOfReferenceType() has been deprecated."
            );
          };
          this.submitFrame = function() {};
        }
        function rd(a) {
          var g;
          function b() {
            Xa = new Za(aa);
            ka = new Ua(aa, Xa, a);
            !1 === ka.isWebGL2 &&
              (Xa.get("WEBGL_depth_texture"),
              Xa.get("OES_texture_float"),
              Xa.get("OES_texture_half_float"),
              Xa.get("OES_texture_half_float_linear"),
              Xa.get("OES_standard_derivatives"),
              Xa.get("OES_element_index_uint"),
              Xa.get("ANGLE_instanced_arrays"));
            Xa.get("OES_texture_float_linear");
            Ka = new Rd(aa, Xa, ka);
            Fa = new Re(aa, Xa, Ka, ka);
            Fa.scissor(
              na
                .copy(va)
                .multiplyScalar(xa)
                .floor()
            );
            Fa.viewport(
              fa
                .copy(ma)
                .multiplyScalar(xa)
                .floor()
            );
            ta = new cb(aa);
            oa = new ue();
            ua = new Se(aa, Xa, Fa, oa, ka, Ka, ta);
            Ra = new Pa(aa);
            Ca = new $a(aa, Ra, ta);
            za = new mb(aa, Ca, Ra, ta);
            Na = new kb(aa);
            Aa = new te(P, Xa, ka);
            Da = new Je();
            Ja = new Qe();
            Ga = new Sa(P, Fa, za, N);
            Oa = new Ta(aa, Xa, ta, ka);
            Qa = new bb(aa, Xa, ta, ka);
            ta.programs = Aa.programs;
            P.capabilities = ka;
            P.extensions = Xa;
            P.properties = oa;
            P.renderLists = Da;
            P.state = Fa;
            P.info = ta;
          }
          function d(a) {
            a.preventDefault();
            S = !0;
          }
          function e() {
            S = !1;
            b();
          }
          function f(a) {
            a = a.target;
            a.removeEventListener("dispose", f);
            k(a);
            oa.remove(a);
          }
          function k(a) {
            var g = oa.get(a).program;
            a.program = void 0;
            void 0 !== g && Aa.releaseProgram(g);
          }
          function l(a, g) {
            a.render(function(a) {
              P.renderBufferImmediate(a, g);
            });
          }
          function R(a, g, b, c) {
            if (!1 !== a.visible) {
              if (a.layers.test(g.layers))
                if (a.isGroup) b = a.renderOrder;
                else if (a.isLOD) !0 === a.autoUpdate && a.update(g);
                else if (a.isLight)
                  J.pushLight(a), a.castShadow && J.pushShadow(a);
                else if (a.isSprite) {
                  if (!a.frustumCulled || Ea.intersectsSprite(a)) {
                    c &&
                      wa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(pa);
                    var p = za.update(a),
                      d = a.material;
                    d.visible && O.push(a, p, d, b, wa.z, null);
                  }
                } else if (a.isImmediateRenderObject)
                  c && wa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(pa),
                    O.push(a, null, a.material, b, wa.z, null);
                else if (a.isMesh || a.isLine || a.isPoints)
                  if (
                    (a.isSkinnedMesh &&
                      a.skeleton.frame !== ta.render.frame &&
                      (a.skeleton.update(),
                      (a.skeleton.frame = ta.render.frame)),
                    !a.frustumCulled || Ea.intersectsObject(a))
                  )
                    if (
                      (c &&
                        wa
                          .setFromMatrixPosition(a.matrixWorld)
                          .applyMatrix4(pa),
                      (p = za.update(a)),
                      (d = a.material),
                      Array.isArray(d))
                    )
                      for (var w = p.groups, e = 0, f = w.length; e < f; e++) {
                        var h = w[e],
                          x = d[h.materialIndex];
                        x && x.visible && O.push(a, p, x, b, wa.z, h);
                      }
                    else d.visible && O.push(a, p, d, b, wa.z, null);
              a = a.children;
              e = 0;
              for (f = a.length; e < f; e++) R(a[e], g, b, c);
            }
          }
          function n(a, g, b, c) {
            for (var p = 0, d = a.length; p < d; p++) {
              var w = a[p],
                e = w.object,
                f = w.geometry,
                h = void 0 === c ? w.material : c;
              w = w.group;
              if (b.isArrayCamera)
                if (((ha = b), Ha.enabled && La.isAvailable()))
                  q(e, g, b, f, h, w);
                else
                  for (var x = b.cameras, k = 0, K = x.length; k < K; k++) {
                    var l = x[k];
                    e.layers.test(l.layers) &&
                      (Fa.viewport(fa.copy(l.viewport)),
                      J.setupLights(l),
                      q(e, g, l, f, h, w));
                  }
              else (ha = null), q(e, g, b, f, h, w);
            }
          }
          function q(a, b, c, p, d, w) {
            a.onBeforeRender(P, b, c, p, d, w);
            J = Ja.get(b, ha || c);
            a.modelViewMatrix.multiplyMatrices(
              c.matrixWorldInverse,
              a.matrixWorld
            );
            a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
            if (a.isImmediateRenderObject) {
              Fa.setMaterial(d);
              var e = r(c, b.fog, d, a);
              ba = g = null;
              ca = !1;
              l(a, e);
            } else P.renderBufferDirect(c, b.fog, p, d, a, w);
            a.onAfterRender(P, b, c, p, d, w);
            J = Ja.get(b, ha || c);
          }
          function u(a, g, b) {
            var c = oa.get(a),
              p = J.state.lights,
              d = p.state.version;
            b = Aa.getParameters(
              a,
              p.state,
              J.state.shadowsArray,
              g,
              vd.numPlanes,
              vd.numIntersection,
              b
            );
            var w = Aa.getProgramCode(a, b),
              e = c.program,
              h = !0;
            if (void 0 === e) a.addEventListener("dispose", f);
            else if (e.code !== w) k(a);
            else {
              if (c.lightsStateVersion !== d) c.lightsStateVersion = d;
              else if (void 0 !== b.shaderID) return;
              h = !1;
            }
            h &&
              (b.shaderID
                ? ((w = we[b.shaderID]),
                  (c.shader = {
                    name: a.type,
                    uniforms: Ba(w.uniforms),
                    vertexShader: w.vertexShader,
                    fragmentShader: w.fragmentShader
                  }))
                : (c.shader = {
                    name: a.type,
                    uniforms: a.uniforms,
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader
                  }),
              a.onBeforeCompile(c.shader, P),
              (w = Aa.getProgramCode(a, b)),
              (e = Aa.acquireProgram(a, c.shader, b, w)),
              (c.program = e),
              (a.program = e));
            b = e.getAttributes();
            if (a.morphTargets)
              for (
                w = a.numSupportedMorphTargets = 0;
                w < P.maxMorphTargets;
                w++
              )
                0 <= b["morphTarget" + w] && a.numSupportedMorphTargets++;
            if (a.morphNormals)
              for (
                w = a.numSupportedMorphNormals = 0;
                w < P.maxMorphNormals;
                w++
              )
                0 <= b["morphNormal" + w] && a.numSupportedMorphNormals++;
            b = c.shader.uniforms;
            if (
              (!a.isShaderMaterial && !a.isRawShaderMaterial) ||
              !0 === a.clipping
            )
              (c.numClippingPlanes = vd.numPlanes),
                (c.numIntersection = vd.numIntersection),
                (b.clippingPlanes = vd.uniform);
            c.fog = g;
            c.needsLights =
              a.isMeshLambertMaterial ||
              a.isMeshPhongMaterial ||
              a.isMeshStandardMaterial ||
              a.isShadowMaterial ||
              (a.isShaderMaterial && !0 === a.lights);
            c.lightsStateVersion = d;
            c.needsLights &&
              ((b.ambientLightColor.value = p.state.ambient),
              (b.lightProbe.value = p.state.probe),
              (b.directionalLights.value = p.state.directional),
              (b.spotLights.value = p.state.spot),
              (b.rectAreaLights.value = p.state.rectArea),
              (b.pointLights.value = p.state.point),
              (b.hemisphereLights.value = p.state.hemi),
              (b.directionalShadowMap.value = p.state.directionalShadowMap),
              (b.directionalShadowMatrix.value =
                p.state.directionalShadowMatrix),
              (b.spotShadowMap.value = p.state.spotShadowMap),
              (b.spotShadowMatrix.value = p.state.spotShadowMatrix),
              (b.pointShadowMap.value = p.state.pointShadowMap),
              (b.pointShadowMatrix.value = p.state.pointShadowMatrix));
            a = c.program.getUniforms();
            a = hb.seqWithValue(a.seq, b);
            c.uniformsList = a;
          }
          function r(a, g, b, c) {
            ua.resetTextureUnits();
            var p = oa.get(b),
              d = J.state.lights;
            qa &&
              (sa || a !== da) &&
              vd.setState(
                b.clippingPlanes,
                b.clipIntersection,
                b.clipShadows,
                a,
                p,
                a === da && b.id === T
              );
            !1 === b.needsUpdate &&
              (void 0 === p.program
                ? (b.needsUpdate = !0)
                : b.fog && p.fog !== g
                ? (b.needsUpdate = !0)
                : p.needsLights && p.lightsStateVersion !== d.state.version
                ? (b.needsUpdate = !0)
                : void 0 === p.numClippingPlanes ||
                  (p.numClippingPlanes === vd.numPlanes &&
                    p.numIntersection === vd.numIntersection) ||
                  (b.needsUpdate = !0));
            b.needsUpdate && (u(b, g, c), (b.needsUpdate = !1));
            var w = !1,
              e = !1,
              f = !1;
            d = p.program;
            var h = d.getUniforms(),
              x = p.shader.uniforms;
            Fa.useProgram(d.program) && (f = e = w = !0);
            b.id !== T && ((T = b.id), (e = !0));
            if (w || da !== a) {
              0 < d.numMultiviewViews
                ? La.updateCameraProjectionMatricesUniform(a, h)
                : h.setValue(aa, "projectionMatrix", a.projectionMatrix);
              ka.logarithmicDepthBuffer &&
                h.setValue(
                  aa,
                  "logDepthBufFC",
                  2 / (Math.log(a.far + 1) / Math.LN2)
                );
              da !== a && ((da = a), (f = e = !0));
              if (
                b.isShaderMaterial ||
                b.isMeshPhongMaterial ||
                b.isMeshStandardMaterial ||
                b.envMap
              )
                (w = h.map.cameraPosition),
                  void 0 !== w &&
                    w.setValue(aa, wa.setFromMatrixPosition(a.matrixWorld));
              if (
                b.isMeshPhongMaterial ||
                b.isMeshLambertMaterial ||
                b.isMeshBasicMaterial ||
                b.isMeshStandardMaterial ||
                b.isShaderMaterial ||
                b.skinning
              )
                0 < d.numMultiviewViews
                  ? La.updateCameraViewMatricesUniform(a, h)
                  : h.setValue(aa, "viewMatrix", a.matrixWorldInverse);
            }
            if (
              b.skinning &&
              (h.setOptional(aa, c, "bindMatrix"),
              h.setOptional(aa, c, "bindMatrixInverse"),
              (w = c.skeleton))
            ) {
              var k = w.bones;
              if (ka.floatVertexTextures) {
                if (void 0 === w.boneTexture) {
                  k = Math.sqrt(4 * k.length);
                  k = ya.ceilPowerOfTwo(k);
                  k = Math.max(k, 4);
                  var K = new Float32Array(k * k * 4);
                  K.set(w.boneMatrices);
                  var l = new Ia(K, k, k, 1023, 1015);
                  w.boneMatrices = K;
                  w.boneTexture = l;
                  w.boneTextureSize = k;
                }
                h.setValue(aa, "boneTexture", w.boneTexture, ua);
                h.setValue(aa, "boneTextureSize", w.boneTextureSize);
              } else h.setOptional(aa, w, "boneMatrices");
            }
            if (e || p.receiveShadow !== c.receiveShadow)
              (p.receiveShadow = c.receiveShadow),
                h.setValue(aa, "receiveShadow", c.receiveShadow);
            e &&
              (h.setValue(aa, "toneMappingExposure", P.toneMappingExposure),
              h.setValue(aa, "toneMappingWhitePoint", P.toneMappingWhitePoint),
              p.needsLights &&
                ((e = f),
                (x.ambientLightColor.needsUpdate = e),
                (x.lightProbe.needsUpdate = e),
                (x.directionalLights.needsUpdate = e),
                (x.pointLights.needsUpdate = e),
                (x.spotLights.needsUpdate = e),
                (x.rectAreaLights.needsUpdate = e),
                (x.hemisphereLights.needsUpdate = e)),
              g &&
                b.fog &&
                (x.fogColor.value.copy(g.color),
                g.isFog
                  ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
                  : g.isFogExp2 && (x.fogDensity.value = g.density)),
              b.isMeshBasicMaterial
                ? y(x, b)
                : b.isMeshLambertMaterial
                ? (y(x, b),
                  b.emissiveMap && (x.emissiveMap.value = b.emissiveMap))
                : b.isMeshPhongMaterial
                ? (y(x, b),
                  b.isMeshToonMaterial
                    ? (v(x, b),
                      b.gradientMap && (x.gradientMap.value = b.gradientMap))
                    : v(x, b))
                : b.isMeshStandardMaterial
                ? (y(x, b),
                  b.isMeshPhysicalMaterial
                    ? (A(x, b),
                      (x.reflectivity.value = b.reflectivity),
                      (x.clearcoat.value = b.clearcoat),
                      (x.clearcoatRoughness.value = b.clearcoatRoughness),
                      b.sheen && x.sheen.value.copy(b.sheen),
                      b.clearcoatNormalMap &&
                        (x.clearcoatNormalScale.value.copy(
                          b.clearcoatNormalScale
                        ),
                        (x.clearcoatNormalMap.value = b.clearcoatNormalMap),
                        1 === b.side && x.clearcoatNormalScale.value.negate()),
                      (x.transparency.value = b.transparency))
                    : A(x, b))
                : b.isMeshMatcapMaterial
                ? (y(x, b),
                  b.matcap && (x.matcap.value = b.matcap),
                  b.bumpMap &&
                    ((x.bumpMap.value = b.bumpMap),
                    (x.bumpScale.value = b.bumpScale),
                    1 === b.side && (x.bumpScale.value *= -1)),
                  b.normalMap &&
                    ((x.normalMap.value = b.normalMap),
                    x.normalScale.value.copy(b.normalScale),
                    1 === b.side && x.normalScale.value.negate()),
                  b.displacementMap &&
                    ((x.displacementMap.value = b.displacementMap),
                    (x.displacementScale.value = b.displacementScale),
                    (x.displacementBias.value = b.displacementBias)))
                : b.isMeshDepthMaterial
                ? (y(x, b),
                  b.displacementMap &&
                    ((x.displacementMap.value = b.displacementMap),
                    (x.displacementScale.value = b.displacementScale),
                    (x.displacementBias.value = b.displacementBias)))
                : b.isMeshDistanceMaterial
                ? (y(x, b),
                  b.displacementMap &&
                    ((x.displacementMap.value = b.displacementMap),
                    (x.displacementScale.value = b.displacementScale),
                    (x.displacementBias.value = b.displacementBias)),
                  x.referencePosition.value.copy(b.referencePosition),
                  (x.nearDistance.value = b.nearDistance),
                  (x.farDistance.value = b.farDistance))
                : b.isMeshNormalMaterial
                ? (y(x, b),
                  b.bumpMap &&
                    ((x.bumpMap.value = b.bumpMap),
                    (x.bumpScale.value = b.bumpScale),
                    1 === b.side && (x.bumpScale.value *= -1)),
                  b.normalMap &&
                    ((x.normalMap.value = b.normalMap),
                    x.normalScale.value.copy(b.normalScale),
                    1 === b.side && x.normalScale.value.negate()),
                  b.displacementMap &&
                    ((x.displacementMap.value = b.displacementMap),
                    (x.displacementScale.value = b.displacementScale),
                    (x.displacementBias.value = b.displacementBias)))
                : b.isLineBasicMaterial
                ? (x.diffuse.value.copy(b.color),
                  (x.opacity.value = b.opacity),
                  b.isLineDashedMaterial &&
                    ((x.dashSize.value = b.dashSize),
                    (x.totalSize.value = b.dashSize + b.gapSize),
                    (x.scale.value = b.scale)))
                : b.isPointsMaterial
                ? (x.diffuse.value.copy(b.color),
                  (x.opacity.value = b.opacity),
                  (x.size.value = b.size * xa),
                  (x.scale.value = 0.5 * ja),
                  (x.map.value = b.map),
                  null !== b.map &&
                    (!0 === b.map.matrixAutoUpdate && b.map.updateMatrix(),
                    x.uvTransform.value.copy(b.map.matrix)))
                : b.isSpriteMaterial
                ? (x.diffuse.value.copy(b.color),
                  (x.opacity.value = b.opacity),
                  (x.rotation.value = b.rotation),
                  (x.map.value = b.map),
                  null !== b.map &&
                    (!0 === b.map.matrixAutoUpdate && b.map.updateMatrix(),
                    x.uvTransform.value.copy(b.map.matrix)))
                : b.isShadowMaterial &&
                  (x.color.value.copy(b.color), (x.opacity.value = b.opacity)),
              void 0 !== x.ltc_1 && (x.ltc_1.value = ia.LTC_1),
              void 0 !== x.ltc_2 && (x.ltc_2.value = ia.LTC_2),
              hb.upload(aa, p.uniformsList, x, ua));
            b.isShaderMaterial &&
              !0 === b.uniformsNeedUpdate &&
              (hb.upload(aa, p.uniformsList, x, ua),
              (b.uniformsNeedUpdate = !1));
            b.isSpriteMaterial && h.setValue(aa, "center", c.center);
            0 < d.numMultiviewViews
              ? La.updateObjectMatricesUniforms(c, a, h)
              : (h.setValue(aa, "modelViewMatrix", c.modelViewMatrix),
                h.setValue(aa, "normalMatrix", c.normalMatrix));
            h.setValue(aa, "modelMatrix", c.matrixWorld);
            return d;
          }
          function y(a, g) {
            a.opacity.value = g.opacity;
            g.color && a.diffuse.value.copy(g.color);
            g.emissive &&
              a.emissive.value
                .copy(g.emissive)
                .multiplyScalar(g.emissiveIntensity);
            g.map && (a.map.value = g.map);
            g.alphaMap && (a.alphaMap.value = g.alphaMap);
            g.specularMap && (a.specularMap.value = g.specularMap);
            g.envMap &&
              ((a.envMap.value = g.envMap),
              (a.flipEnvMap.value = g.envMap.isCubeTexture ? -1 : 1),
              (a.reflectivity.value = g.reflectivity),
              (a.refractionRatio.value = g.refractionRatio),
              (a.maxMipLevel.value = oa.get(g.envMap).__maxMipLevel));
            g.lightMap &&
              ((a.lightMap.value = g.lightMap),
              (a.lightMapIntensity.value = g.lightMapIntensity));
            g.aoMap &&
              ((a.aoMap.value = g.aoMap),
              (a.aoMapIntensity.value = g.aoMapIntensity));
            if (g.map) var b = g.map;
            else
              g.specularMap
                ? (b = g.specularMap)
                : g.displacementMap
                ? (b = g.displacementMap)
                : g.normalMap
                ? (b = g.normalMap)
                : g.bumpMap
                ? (b = g.bumpMap)
                : g.roughnessMap
                ? (b = g.roughnessMap)
                : g.metalnessMap
                ? (b = g.metalnessMap)
                : g.alphaMap
                ? (b = g.alphaMap)
                : g.emissiveMap && (b = g.emissiveMap);
            void 0 !== b &&
              (b.isWebGLRenderTarget && (b = b.texture),
              !0 === b.matrixAutoUpdate && b.updateMatrix(),
              a.uvTransform.value.copy(b.matrix));
          }
          function v(a, g) {
            a.specular.value.copy(g.specular);
            a.shininess.value = Math.max(g.shininess, 1e-4);
            g.emissiveMap && (a.emissiveMap.value = g.emissiveMap);
            g.bumpMap &&
              ((a.bumpMap.value = g.bumpMap),
              (a.bumpScale.value = g.bumpScale),
              1 === g.side && (a.bumpScale.value *= -1));
            g.normalMap &&
              ((a.normalMap.value = g.normalMap),
              a.normalScale.value.copy(g.normalScale),
              1 === g.side && a.normalScale.value.negate());
            g.displacementMap &&
              ((a.displacementMap.value = g.displacementMap),
              (a.displacementScale.value = g.displacementScale),
              (a.displacementBias.value = g.displacementBias));
          }
          function A(a, g) {
            a.roughness.value = g.roughness;
            a.metalness.value = g.metalness;
            g.roughnessMap && (a.roughnessMap.value = g.roughnessMap);
            g.metalnessMap && (a.metalnessMap.value = g.metalnessMap);
            g.emissiveMap && (a.emissiveMap.value = g.emissiveMap);
            g.bumpMap &&
              ((a.bumpMap.value = g.bumpMap),
              (a.bumpScale.value = g.bumpScale),
              1 === g.side && (a.bumpScale.value *= -1));
            g.normalMap &&
              ((a.normalMap.value = g.normalMap),
              a.normalScale.value.copy(g.normalScale),
              1 === g.side && a.normalScale.value.negate());
            g.displacementMap &&
              ((a.displacementMap.value = g.displacementMap),
              (a.displacementScale.value = g.displacementScale),
              (a.displacementBias.value = g.displacementBias));
            g.envMap && (a.envMapIntensity.value = g.envMapIntensity);
          }
          a = a || {};
          var z =
              void 0 !== a.canvas
                ? a.canvas
                : document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "canvas"
                  ),
            C = void 0 !== a.context ? a.context : null,
            B = void 0 !== a.alpha ? a.alpha : !1,
            H = void 0 !== a.depth ? a.depth : !0,
            M = void 0 !== a.stencil ? a.stencil : !0,
            D = void 0 !== a.antialias ? a.antialias : !1,
            N = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
            E =
              void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
            I = void 0 !== a.powerPreference ? a.powerPreference : "default",
            L =
              void 0 !== a.failIfMajorPerformanceCaveat
                ? a.failIfMajorPerformanceCaveat
                : !1,
            O = null,
            J = null;
          this.domElement = z;
          this.debug = { checkShaderErrors: !0 };
          this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
          this.clippingPlanes = [];
          this.localClippingEnabled = !1;
          this.gammaFactor = 2;
          this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
          this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
          this.maxMorphTargets = 8;
          this.maxMorphNormals = 4;
          var P = this,
            S = !1,
            F = null,
            U = 0,
            X = 0,
            V = null,
            W = null,
            T = -1;
          var ba = (g = null);
          var ca = !1;
          var da = null,
            ha = null,
            fa = new m(),
            na = new m(),
            la = null,
            wd = z.width,
            ja = z.height,
            xa = 1,
            ma = new m(0, 0, wd, ja),
            va = new m(0, 0, wd, ja),
            ra = !1,
            Ea = new Q(),
            vd = new Ya(),
            qa = !1,
            sa = !1,
            pa = new t(),
            wa = new h();
          try {
            B = {
              alpha: B,
              depth: H,
              stencil: M,
              antialias: D,
              premultipliedAlpha: N,
              preserveDrawingBuffer: E,
              powerPreference: I,
              failIfMajorPerformanceCaveat: L,
              xrCompatible: !0
            };
            z.addEventListener("webglcontextlost", d, !1);
            z.addEventListener("webglcontextrestored", e, !1);
            var aa =
              C ||
              z.getContext("webgl", B) ||
              z.getContext("experimental-webgl", B);
            if (null === aa) {
              if (null !== z.getContext("webgl"))
                throw Error(
                  "Error creating WebGL context with your selected attributes."
                );
              throw Error("Error creating WebGL context.");
            }
            void 0 === aa.getShaderPrecisionFormat &&
              (aa.getShaderPrecisionFormat = function() {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
              });
          } catch (um) {
            throw (console.error("THREE.WebGLRenderer: " + um.message), um);
          }
          var Xa,
            ka,
            Fa,
            ta,
            oa,
            ua,
            Ra,
            Ca,
            za,
            Aa,
            Da,
            Ja,
            Ga,
            Na,
            Oa,
            Qa,
            Ka;
          b();
          var Ha =
            "undefined" !== typeof navigator &&
            "xr" in navigator &&
            "supportsSession" in navigator.xr
              ? new de(P, aa)
              : new od(P);
          this.vr = Ha;
          var La = new Te(P, aa),
            ib = new Qd(P, za, ka.maxTextureSize);
          this.shadowMap = ib;
          this.getContext = function() {
            return aa;
          };
          this.getContextAttributes = function() {
            return aa.getContextAttributes();
          };
          this.forceContextLoss = function() {
            var a = Xa.get("WEBGL_lose_context");
            a && a.loseContext();
          };
          this.forceContextRestore = function() {
            var a = Xa.get("WEBGL_lose_context");
            a && a.restoreContext();
          };
          this.getPixelRatio = function() {
            return xa;
          };
          this.setPixelRatio = function(a) {
            void 0 !== a && ((xa = a), this.setSize(wd, ja, !1));
          };
          this.getSize = function(a) {
            void 0 === a &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
              ),
              (a = new c()));
            return a.set(wd, ja);
          };
          this.setSize = function(a, g, b) {
            Ha.isPresenting()
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((wd = a),
                (ja = g),
                (z.width = Math.floor(a * xa)),
                (z.height = Math.floor(g * xa)),
                !1 !== b &&
                  ((z.style.width = a + "px"), (z.style.height = g + "px")),
                this.setViewport(0, 0, a, g));
          };
          this.getDrawingBufferSize = function(a) {
            void 0 === a &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
              ),
              (a = new c()));
            return a.set(wd * xa, ja * xa).floor();
          };
          this.setDrawingBufferSize = function(a, g, b) {
            wd = a;
            ja = g;
            xa = b;
            z.width = Math.floor(a * b);
            z.height = Math.floor(g * b);
            this.setViewport(0, 0, a, g);
          };
          this.getCurrentViewport = function(a) {
            void 0 === a &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
              ),
              (a = new m()));
            return a.copy(fa);
          };
          this.getViewport = function(a) {
            return a.copy(ma);
          };
          this.setViewport = function(a, g, b, c) {
            a.isVector4 ? ma.set(a.x, a.y, a.z, a.w) : ma.set(a, g, b, c);
            Fa.viewport(
              fa
                .copy(ma)
                .multiplyScalar(xa)
                .floor()
            );
          };
          this.getScissor = function(a) {
            return a.copy(va);
          };
          this.setScissor = function(a, g, b, c) {
            a.isVector4 ? va.set(a.x, a.y, a.z, a.w) : va.set(a, g, b, c);
            Fa.scissor(
              na
                .copy(va)
                .multiplyScalar(xa)
                .floor()
            );
          };
          this.getScissorTest = function() {
            return ra;
          };
          this.setScissorTest = function(a) {
            Fa.setScissorTest((ra = a));
          };
          this.getClearColor = function() {
            return Ga.getClearColor();
          };
          this.setClearColor = function() {
            Ga.setClearColor.apply(Ga, arguments);
          };
          this.getClearAlpha = function() {
            return Ga.getClearAlpha();
          };
          this.setClearAlpha = function() {
            Ga.setClearAlpha.apply(Ga, arguments);
          };
          this.clear = function(a, g, b) {
            var c = 0;
            if (void 0 === a || a) c |= 16384;
            if (void 0 === g || g) c |= 256;
            if (void 0 === b || b) c |= 1024;
            aa.clear(c);
          };
          this.clearColor = function() {
            this.clear(!0, !1, !1);
          };
          this.clearDepth = function() {
            this.clear(!1, !0, !1);
          };
          this.clearStencil = function() {
            this.clear(!1, !1, !0);
          };
          this.dispose = function() {
            z.removeEventListener("webglcontextlost", d, !1);
            z.removeEventListener("webglcontextrestored", e, !1);
            Da.dispose();
            Ja.dispose();
            oa.dispose();
            za.dispose();
            Ha.dispose();
            Va.stop();
          };
          this.renderBufferImmediate = function(a, g) {
            Fa.initAttributes();
            var b = oa.get(a);
            a.hasPositions && !b.position && (b.position = aa.createBuffer());
            a.hasNormals && !b.normal && (b.normal = aa.createBuffer());
            a.hasUvs && !b.uv && (b.uv = aa.createBuffer());
            a.hasColors && !b.color && (b.color = aa.createBuffer());
            g = g.getAttributes();
            a.hasPositions &&
              (aa.bindBuffer(34962, b.position),
              aa.bufferData(34962, a.positionArray, 35048),
              Fa.enableAttribute(g.position),
              aa.vertexAttribPointer(g.position, 3, 5126, !1, 0, 0));
            a.hasNormals &&
              (aa.bindBuffer(34962, b.normal),
              aa.bufferData(34962, a.normalArray, 35048),
              Fa.enableAttribute(g.normal),
              aa.vertexAttribPointer(g.normal, 3, 5126, !1, 0, 0));
            a.hasUvs &&
              (aa.bindBuffer(34962, b.uv),
              aa.bufferData(34962, a.uvArray, 35048),
              Fa.enableAttribute(g.uv),
              aa.vertexAttribPointer(g.uv, 2, 5126, !1, 0, 0));
            a.hasColors &&
              (aa.bindBuffer(34962, b.color),
              aa.bufferData(34962, a.colorArray, 35048),
              Fa.enableAttribute(g.color),
              aa.vertexAttribPointer(g.color, 3, 5126, !1, 0, 0));
            Fa.disableUnusedAttributes();
            aa.drawArrays(4, 0, a.count);
            a.count = 0;
          };
          this.renderBufferDirect = function(a, b, c, p, d, w) {
            var e = d.isMesh && 0 > d.matrixWorld.determinant();
            Fa.setMaterial(p, e);
            var f = r(a, b, p, d),
              x = !1;
            if (g !== c.id || ba !== f.id || ca !== (!0 === p.wireframe))
              (g = c.id), (ba = f.id), (ca = !0 === p.wireframe), (x = !0);
            d.morphTargetInfluences && (Na.update(d, c, p, f), (x = !0));
            e = c.index;
            var h = c.attributes.position;
            b = 1;
            !0 === p.wireframe && ((e = Ca.getWireframeAttribute(c)), (b = 2));
            a = Oa;
            if (null !== e) {
              var k = Ra.get(e);
              a = Qa;
              a.setIndex(k);
            }
            if (x) {
              if (
                !1 !== ka.isWebGL2 ||
                (!d.isInstancedMesh && !c.isInstancedBufferGeometry) ||
                null !== Xa.get("ANGLE_instanced_arrays")
              ) {
                Fa.initAttributes();
                x = c.attributes;
                f = f.getAttributes();
                var K = p.defaultAttributeValues;
                for (t in f) {
                  var l = f[t];
                  if (0 <= l) {
                    var G = x[t];
                    if (void 0 !== G) {
                      var Z = G.normalized,
                        m = G.itemSize,
                        Y = Ra.get(G);
                      if (void 0 !== Y) {
                        var R = Y.buffer,
                          n = Y.type;
                        Y = Y.bytesPerElement;
                        if (G.isInterleavedBufferAttribute) {
                          var ea = G.data,
                            q = ea.stride;
                          G = G.offset;
                          ea && ea.isInstancedInterleavedBuffer
                            ? (Fa.enableAttributeAndDivisor(
                                l,
                                ea.meshPerAttribute
                              ),
                              void 0 === c.maxInstancedCount &&
                                (c.maxInstancedCount =
                                  ea.meshPerAttribute * ea.count))
                            : Fa.enableAttribute(l);
                          aa.bindBuffer(34962, R);
                          aa.vertexAttribPointer(l, m, n, Z, q * Y, G * Y);
                        } else
                          G.isInstancedBufferAttribute
                            ? (Fa.enableAttributeAndDivisor(
                                l,
                                G.meshPerAttribute
                              ),
                              void 0 === c.maxInstancedCount &&
                                (c.maxInstancedCount =
                                  G.meshPerAttribute * G.count))
                            : Fa.enableAttribute(l),
                            aa.bindBuffer(34962, R),
                            aa.vertexAttribPointer(l, m, n, Z, 0, 0);
                      }
                    } else if ("instanceMatrix" === t)
                      (Y = Ra.get(d.instanceMatrix)),
                        void 0 !== Y &&
                          ((R = Y.buffer),
                          (n = Y.type),
                          Fa.enableAttributeAndDivisor(l + 0, 1),
                          Fa.enableAttributeAndDivisor(l + 1, 1),
                          Fa.enableAttributeAndDivisor(l + 2, 1),
                          Fa.enableAttributeAndDivisor(l + 3, 1),
                          aa.bindBuffer(34962, R),
                          aa.vertexAttribPointer(l + 0, 4, n, !1, 64, 0),
                          aa.vertexAttribPointer(l + 1, 4, n, !1, 64, 16),
                          aa.vertexAttribPointer(l + 2, 4, n, !1, 64, 32),
                          aa.vertexAttribPointer(l + 3, 4, n, !1, 64, 48));
                    else if (void 0 !== K && ((Z = K[t]), void 0 !== Z))
                      switch (Z.length) {
                        case 2:
                          aa.vertexAttrib2fv(l, Z);
                          break;
                        case 3:
                          aa.vertexAttrib3fv(l, Z);
                          break;
                        case 4:
                          aa.vertexAttrib4fv(l, Z);
                          break;
                        default:
                          aa.vertexAttrib1fv(l, Z);
                      }
                  }
                }
                Fa.disableUnusedAttributes();
              }
              null !== e && aa.bindBuffer(34963, k.buffer);
            }
            k = Infinity;
            null !== e ? (k = e.count) : void 0 !== h && (k = h.count);
            e = c.drawRange.start * b;
            h = null !== w ? w.start * b : 0;
            var t = Math.max(e, h);
            w = Math.max(
              0,
              Math.min(
                k,
                e + c.drawRange.count * b,
                h + (null !== w ? w.count * b : Infinity)
              ) -
                1 -
                t +
                1
            );
            if (0 !== w) {
              if (d.isMesh)
                if (!0 === p.wireframe)
                  Fa.setLineWidth(p.wireframeLinewidth * (null === V ? xa : 1)),
                    a.setMode(1);
                else
                  switch (d.drawMode) {
                    case 0:
                      a.setMode(4);
                      break;
                    case 1:
                      a.setMode(5);
                      break;
                    case 2:
                      a.setMode(6);
                  }
              else
                d.isLine
                  ? ((p = p.linewidth),
                    void 0 === p && (p = 1),
                    Fa.setLineWidth(p * (null === V ? xa : 1)),
                    d.isLineSegments
                      ? a.setMode(1)
                      : d.isLineLoop
                      ? a.setMode(2)
                      : a.setMode(3))
                  : d.isPoints
                  ? a.setMode(0)
                  : d.isSprite && a.setMode(4);
              d.isInstancedMesh
                ? a.renderInstances(c, t, w, d.count)
                : c.isInstancedBufferGeometry
                ? a.renderInstances(c, t, w, c.maxInstancedCount)
                : a.render(t, w);
            }
          };
          this.compile = function(a, g) {
            J = Ja.get(a, g);
            J.init();
            a.traverse(function(a) {
              a.isLight && (J.pushLight(a), a.castShadow && J.pushShadow(a));
            });
            J.setupLights(g);
            a.traverse(function(g) {
              if (g.material)
                if (Array.isArray(g.material))
                  for (var b = 0; b < g.material.length; b++)
                    u(g.material[b], a.fog, g);
                else u(g.material, a.fog, g);
            });
          };
          var Wa = null,
            Va = new Ma();
          Va.setAnimationLoop(function(a) {
            Ha.isPresenting() || (Wa && Wa(a));
          });
          "undefined" !== typeof window && Va.setContext(window);
          this.setAnimationLoop = function(a) {
            Wa = a;
            Ha.setAnimationLoop(a);
            Va.start();
          };
          this.render = function(a, b, c, p) {
            if (void 0 !== c) {
              console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              );
              var d = c;
            }
            if (void 0 !== p) {
              console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
              );
              var w = p;
            }
            b && b.isCamera
              ? S ||
                ((ba = g = null),
                (ca = !1),
                (T = -1),
                (da = null),
                !0 === a.autoUpdate && a.updateMatrixWorld(),
                null === b.parent && b.updateMatrixWorld(),
                Ha.enabled && (b = Ha.getCamera(b)),
                (J = Ja.get(a, b)),
                J.init(),
                a.onBeforeRender(P, a, b, d || V),
                pa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
                Ea.setFromMatrix(pa),
                (sa = this.localClippingEnabled),
                (qa = vd.init(this.clippingPlanes, sa, b)),
                (O = Da.get(a, b)),
                O.init(),
                R(a, b, 0, P.sortObjects),
                !0 === P.sortObjects && O.sort(),
                qa && vd.beginShadows(),
                ib.render(J.state.shadowsArray, a, b),
                J.setupLights(b),
                qa && vd.endShadows(),
                this.info.autoReset && this.info.reset(),
                void 0 !== d && this.setRenderTarget(d),
                Ha.enabled && La.isAvailable() && La.attachCamera(b),
                Ga.render(O, a, b, w),
                (c = O.opaque),
                (p = O.transparent),
                a.overrideMaterial
                  ? ((d = a.overrideMaterial),
                    c.length && n(c, a, b, d),
                    p.length && n(p, a, b, d))
                  : (c.length && n(c, a, b), p.length && n(p, a, b)),
                a.onAfterRender(P, a, b),
                null !== V &&
                  (ua.updateRenderTargetMipmap(V),
                  ua.updateMultisampleRenderTarget(V)),
                Fa.buffers.depth.setTest(!0),
                Fa.buffers.depth.setMask(!0),
                Fa.buffers.color.setMask(!0),
                Fa.setPolygonOffset(!1),
                Ha.enabled &&
                  (La.isAvailable() && La.detachCamera(b), Ha.submitFrame()),
                (J = O = null))
              : console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
          };
          this.setFramebuffer = function(a) {
            F !== a && aa.bindFramebuffer(36160, a);
            F = a;
          };
          this.getActiveCubeFace = function() {
            return U;
          };
          this.getActiveMipmapLevel = function() {
            return X;
          };
          this.getRenderTarget = function() {
            return V;
          };
          this.setRenderTarget = function(a, g, b) {
            V = a;
            U = g;
            X = b;
            a &&
              void 0 === oa.get(a).__webglFramebuffer &&
              ua.setupRenderTarget(a);
            var c = F,
              p = !1;
            a
              ? ((c = oa.get(a).__webglFramebuffer),
                a.isWebGLRenderTargetCube
                  ? ((c = c[g || 0]), (p = !0))
                  : (c = a.isWebGLMultisampleRenderTarget
                      ? oa.get(a).__webglMultisampledFramebuffer
                      : c),
                fa.copy(a.viewport),
                na.copy(a.scissor),
                (la = a.scissorTest))
              : (fa
                  .copy(ma)
                  .multiplyScalar(xa)
                  .floor(),
                na
                  .copy(va)
                  .multiplyScalar(xa)
                  .floor(),
                (la = ra));
            W !== c && (aa.bindFramebuffer(36160, c), (W = c));
            Fa.viewport(fa);
            Fa.scissor(na);
            Fa.setScissorTest(la);
            p &&
              ((a = oa.get(a.texture)),
              aa.framebufferTexture2D(
                36160,
                36064,
                34069 + (g || 0),
                a.__webglTexture,
                b || 0
              ));
          };
          this.readRenderTargetPixels = function(a, g, b, c, p, d, w) {
            if (a && a.isWebGLRenderTarget) {
              var e = oa.get(a).__webglFramebuffer;
              a.isWebGLRenderTargetCube && void 0 !== w && (e = e[w]);
              if (e) {
                w = !1;
                e !== W && (aa.bindFramebuffer(36160, e), (w = !0));
                try {
                  var f = a.texture,
                    x = f.format,
                    h = f.type;
                  1023 !== x && Ka.convert(x) !== aa.getParameter(35739)
                    ? console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                      )
                    : 1009 === h ||
                      Ka.convert(h) === aa.getParameter(35738) ||
                      (1015 === h &&
                        (ka.isWebGL2 ||
                          Xa.get("OES_texture_float") ||
                          Xa.get("WEBGL_color_buffer_float"))) ||
                      (1016 === h &&
                        (ka.isWebGL2
                          ? Xa.get("EXT_color_buffer_float")
                          : Xa.get("EXT_color_buffer_half_float")))
                    ? 36053 === aa.checkFramebufferStatus(36160)
                      ? 0 <= g &&
                        g <= a.width - c &&
                        0 <= b &&
                        b <= a.height - p &&
                        aa.readPixels(
                          g,
                          b,
                          c,
                          p,
                          Ka.convert(x),
                          Ka.convert(h),
                          d
                        )
                      : console.error(
                          "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                        )
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                      );
                } finally {
                  w && aa.bindFramebuffer(36160, W);
                }
              }
            } else
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
          };
          this.copyFramebufferToTexture = function(a, g, b) {
            var c = g.image.width,
              p = g.image.height,
              d = Ka.convert(g.format);
            ua.setTexture2D(g, 0);
            aa.copyTexImage2D(3553, b || 0, d, a.x, a.y, c, p, 0);
          };
          this.copyTextureToTexture = function(a, g, b, c) {
            var p = g.image.width,
              d = g.image.height,
              w = Ka.convert(b.format),
              e = Ka.convert(b.type);
            ua.setTexture2D(b, 0);
            g.isDataTexture
              ? aa.texSubImage2D(
                  3553,
                  c || 0,
                  a.x,
                  a.y,
                  p,
                  d,
                  w,
                  e,
                  g.image.data
                )
              : aa.texSubImage2D(3553, c || 0, a.x, a.y, w, e, g.image);
          };
          "undefined" !== typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
        }
        function Mc(a, b) {
          this.name = "";
          this.color = new M(a);
          this.density = void 0 !== b ? b : 2.5e-4;
        }
        function Nc(a, b, c) {
          this.name = "";
          this.color = new M(a);
          this.near = void 0 !== b ? b : 1;
          this.far = void 0 !== c ? c : 1e3;
        }
        function bg(a, b) {
          this.array = a;
          this.stride = b;
          this.count = void 0 !== a ? a.length / b : 0;
          this.dynamic = !1;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
        }
        function cc(a, b, c, d) {
          this.data = a;
          this.itemSize = b;
          this.offset = c;
          this.normalized = !0 === d;
        }
        function cg(a) {
          D.call(this);
          this.type = "SpriteMaterial";
          this.color = new M(16777215);
          this.map = null;
          this.rotation = 0;
          this.transparent = this.sizeAttenuation = !0;
          this.setValues(a);
        }
        function dc(a) {
          v.call(this);
          this.type = "Sprite";
          if (void 0 === Di) {
            Di = new S();
            var g = new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1
            ]);
            g = new bg(g, 5);
            Di.setIndex([0, 1, 2, 0, 2, 3]);
            Di.addAttribute("position", new cc(g, 3, 0, !1));
            Di.addAttribute("uv", new cc(g, 2, 3, !1));
          }
          this.geometry = Di;
          this.material = void 0 !== a ? a : new cg();
          this.center = new c(0.5, 0.5);
        }
        function Qc(a, b, c, d, e, f) {
          Ei.subVectors(a, c)
            .addScalar(0.5)
            .multiply(d);
          void 0 !== e
            ? ((Vj.x = f * Ei.x - e * Ei.y), (Vj.y = e * Ei.x + f * Ei.y))
            : Vj.copy(Ei);
          a.copy(b);
          a.x += Vj.x;
          a.y += Vj.y;
          a.applyMatrix4(ci);
        }
        function fc() {
          v.call(this);
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: { enumerable: !0, value: [] }
          });
          this.autoUpdate = !0;
        }
        function hc(a, b) {
          a &&
            a.isGeometry &&
            console.error(
              "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
          da.call(this, a, b);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new t();
          this.bindMatrixInverse = new t();
        }
        function Wc(a, b) {
          a = a || [];
          this.bones = a.slice(0);
          this.boneMatrices = new Float32Array(16 * this.bones.length);
          this.frame = -1;
          if (void 0 === b) this.calculateInverses();
          else if (this.bones.length === b.length)
            this.boneInverses = b.slice(0);
          else
            for (
              console.warn("THREE.Skeleton boneInverses is the wrong length."),
                this.boneInverses = [],
                a = 0,
                b = this.bones.length;
              a < b;
              a++
            )
              this.boneInverses.push(new t());
        }
        function Ld() {
          v.call(this);
          this.type = "Bone";
        }
        function Md(a, b, c) {
          da.call(this, a, b);
          this.instanceMatrix = new I(new Float32Array(16 * c), 16);
          this.count = c;
        }
        function Ga(a) {
          D.call(this);
          this.type = "LineBasicMaterial";
          this.color = new M(16777215);
          this.linewidth = 1;
          this.linejoin = this.linecap = "round";
          this.setValues(a);
        }
        function nb(a, b, c) {
          1 === c &&
            console.error(
              "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
            );
          v.call(this);
          this.type = "Line";
          this.geometry = void 0 !== a ? a : new S();
          this.material =
            void 0 !== b ? b : new Ga({ color: 16777215 * Math.random() });
        }
        function Qa(a, b) {
          nb.call(this, a, b);
          this.type = "LineSegments";
        }
        function Zc(a, b) {
          nb.call(this, a, b);
          this.type = "LineLoop";
        }
        function xd(a) {
          D.call(this);
          this.type = "PointsMaterial";
          this.color = new M(16777215);
          this.map = null;
          this.size = 1;
          this.sizeAttenuation = !0;
          this.morphTargets = !1;
          this.setValues(a);
        }
        function Mb(a, b) {
          v.call(this);
          this.type = "Points";
          this.geometry = void 0 !== a ? a : new S();
          this.material =
            void 0 !== b ? b : new xd({ color: 16777215 * Math.random() });
          this.updateMorphTargets();
        }
        function Nd(a, b, c, d, e, f, k) {
          var g = Zg.distanceSqToPoint(a);
          g < c &&
            ((c = new h()),
            Zg.closestPointToPoint(a, c),
            c.applyMatrix4(d),
            (a = e.ray.origin.distanceTo(c)),
            a < e.near ||
              a > e.far ||
              f.push({
                distance: a,
                distanceToRay: Math.sqrt(g),
                point: c,
                index: b,
                face: null,
                object: k
              }));
        }
        function Od(a, b, c, d, e, f, h, k, m) {
          l.call(this, a, b, c, d, e, f, h, k, m);
          this.format = void 0 !== h ? h : 1022;
          this.minFilter = void 0 !== f ? f : 1006;
          this.magFilter = void 0 !== e ? e : 1006;
          this.generateMipmaps = !1;
        }
        function Ob(a, b, c, d, e, f, h, k, m, n, q, t) {
          l.call(this, null, f, h, k, m, n, d, e, q, t);
          this.image = { width: b, height: c };
          this.mipmaps = a;
          this.generateMipmaps = this.flipY = !1;
        }
        function mc(a, b, c, d, e, f, h, k, m) {
          l.call(this, a, b, c, d, e, f, h, k, m);
          this.needsUpdate = !0;
        }
        function nc(a, b, c, d, e, f, h, k, m, n) {
          n = void 0 !== n ? n : 1026;
          if (1026 !== n && 1027 !== n)
            throw Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === c && 1026 === n && (c = 1012);
          void 0 === c && 1027 === n && (c = 1020);
          l.call(this, null, d, e, f, h, k, n, c, m);
          this.image = { width: a, height: b };
          this.magFilter = void 0 !== h ? h : 1003;
          this.minFilter = void 0 !== k ? k : 1003;
          this.generateMipmaps = this.flipY = !1;
        }
        function Pb(a) {
          S.call(this);
          this.type = "WireframeGeometry";
          var g = [],
            b,
            c,
            d,
            e = [0, 0],
            f = {},
            k = ["a", "b", "c"];
          if (a && a.isGeometry) {
            var l = a.faces;
            var m = 0;
            for (c = l.length; m < c; m++) {
              var n = l[m];
              for (b = 0; 3 > b; b++) {
                var q = n[k[b]];
                var t = n[k[(b + 1) % 3]];
                e[0] = Math.min(q, t);
                e[1] = Math.max(q, t);
                q = e[0] + "," + e[1];
                void 0 === f[q] && (f[q] = { index1: e[0], index2: e[1] });
              }
            }
            for (q in f)
              (m = f[q]),
                (k = a.vertices[m.index1]),
                g.push(k.x, k.y, k.z),
                (k = a.vertices[m.index2]),
                g.push(k.x, k.y, k.z);
          } else if (a && a.isBufferGeometry)
            if (((k = new h()), null !== a.index)) {
              l = a.attributes.position;
              n = a.index;
              var u = a.groups;
              0 === u.length &&
                (u = [{ start: 0, count: n.count, materialIndex: 0 }]);
              a = 0;
              for (d = u.length; a < d; ++a)
                for (
                  m = u[a], b = m.start, c = m.count, m = b, c = b + c;
                  m < c;
                  m += 3
                )
                  for (b = 0; 3 > b; b++)
                    (q = n.getX(m + b)),
                      (t = n.getX(m + ((b + 1) % 3))),
                      (e[0] = Math.min(q, t)),
                      (e[1] = Math.max(q, t)),
                      (q = e[0] + "," + e[1]),
                      void 0 === f[q] &&
                        (f[q] = { index1: e[0], index2: e[1] });
              for (q in f)
                (m = f[q]),
                  k.fromBufferAttribute(l, m.index1),
                  g.push(k.x, k.y, k.z),
                  k.fromBufferAttribute(l, m.index2),
                  g.push(k.x, k.y, k.z);
            } else
              for (
                l = a.attributes.position, m = 0, c = l.count / 3;
                m < c;
                m++
              )
                for (b = 0; 3 > b; b++)
                  (f = 3 * m + b),
                    k.fromBufferAttribute(l, f),
                    g.push(k.x, k.y, k.z),
                    (f = 3 * m + ((b + 1) % 3)),
                    k.fromBufferAttribute(l, f),
                    g.push(k.x, k.y, k.z);
          this.addAttribute("position", new P(g, 3));
        }
        function pc(a, b, c) {
          U.call(this);
          this.type = "ParametricGeometry";
          this.parameters = { func: a, slices: b, stacks: c };
          this.fromBufferGeometry(new Qb(a, b, c));
          this.mergeVertices();
        }
        function Qb(a, b, c) {
          S.call(this);
          this.type = "ParametricBufferGeometry";
          this.parameters = { func: a, slices: b, stacks: c };
          var g = [],
            p = [],
            d = [],
            w = [],
            e = new h(),
            f = new h(),
            k = new h(),
            l = new h(),
            m = new h(),
            n,
            q;
          3 > a.length &&
            console.error(
              "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
            );
          var t = b + 1;
          for (n = 0; n <= c; n++) {
            var u = n / c;
            for (q = 0; q <= b; q++) {
              var r = q / b;
              a(r, u, f);
              p.push(f.x, f.y, f.z);
              0 <= r - 1e-5
                ? (a(r - 1e-5, u, k), l.subVectors(f, k))
                : (a(r + 1e-5, u, k), l.subVectors(k, f));
              0 <= u - 1e-5
                ? (a(r, u - 1e-5, k), m.subVectors(f, k))
                : (a(r, u + 1e-5, k), m.subVectors(k, f));
              e.crossVectors(l, m).normalize();
              d.push(e.x, e.y, e.z);
              w.push(r, u);
            }
          }
          for (n = 0; n < c; n++)
            for (q = 0; q < b; q++)
              (a = n * t + q + 1),
                (e = (n + 1) * t + q + 1),
                (f = (n + 1) * t + q),
                g.push(n * t + q, a, f),
                g.push(a, e, f);
          this.setIndex(g);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("normal", new P(d, 3));
          this.addAttribute("uv", new P(w, 2));
        }
        function rc(a, b, c, d) {
          U.call(this);
          this.type = "PolyhedronGeometry";
          this.parameters = { vertices: a, indices: b, radius: c, detail: d };
          this.fromBufferGeometry(new Jb(a, b, c, d));
          this.mergeVertices();
        }
        function Jb(a, b, d, e) {
          function g(a) {
            f.push(a.x, a.y, a.z);
          }
          function p(g, b) {
            g *= 3;
            b.x = a[g + 0];
            b.y = a[g + 1];
            b.z = a[g + 2];
          }
          function w(a, g, b, c) {
            0 > c && 1 === a.x && (x[g] = a.x - 1);
            0 === b.x && 0 === b.z && (x[g] = c / 2 / Math.PI + 0.5);
          }
          S.call(this);
          this.type = "PolyhedronBufferGeometry";
          this.parameters = { vertices: a, indices: b, radius: d, detail: e };
          d = d || 1;
          e = e || 0;
          var f = [],
            x = [];
          (function(a) {
            for (
              var c = new h(), d = new h(), w = new h(), e = 0;
              e < b.length;
              e += 3
            ) {
              p(b[e + 0], c);
              p(b[e + 1], d);
              p(b[e + 2], w);
              var f,
                x,
                k = c,
                K = d,
                l = w,
                G = Math.pow(2, a),
                m = [];
              for (x = 0; x <= G; x++) {
                m[x] = [];
                var Z = k.clone().lerp(l, x / G),
                  Y = K.clone().lerp(l, x / G),
                  n = G - x;
                for (f = 0; f <= n; f++)
                  m[x][f] = 0 === f && x === G ? Z : Z.clone().lerp(Y, f / n);
              }
              for (x = 0; x < G; x++)
                for (f = 0; f < 2 * (G - x) - 1; f++)
                  (k = Math.floor(f / 2)),
                    0 === f % 2
                      ? (g(m[x][k + 1]), g(m[x + 1][k]), g(m[x][k]))
                      : (g(m[x][k + 1]), g(m[x + 1][k + 1]), g(m[x + 1][k]));
            }
          })(e);
          (function(a) {
            for (var g = new h(), b = 0; b < f.length; b += 3)
              (g.x = f[b + 0]),
                (g.y = f[b + 1]),
                (g.z = f[b + 2]),
                g.normalize().multiplyScalar(a),
                (f[b + 0] = g.x),
                (f[b + 1] = g.y),
                (f[b + 2] = g.z);
          })(d);
          (function() {
            for (var a = new h(), g = 0; g < f.length; g += 3)
              (a.x = f[g + 0]),
                (a.y = f[g + 1]),
                (a.z = f[g + 2]),
                x.push(
                  Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5,
                  1 -
                    (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) /
                      Math.PI +
                      0.5)
                );
            a = new h();
            g = new h();
            for (
              var b = new h(),
                p = new h(),
                d = new c(),
                e = new c(),
                k = new c(),
                K = 0,
                l = 0;
              K < f.length;
              K += 9, l += 6
            ) {
              a.set(f[K + 0], f[K + 1], f[K + 2]);
              g.set(f[K + 3], f[K + 4], f[K + 5]);
              b.set(f[K + 6], f[K + 7], f[K + 8]);
              d.set(x[l + 0], x[l + 1]);
              e.set(x[l + 2], x[l + 3]);
              k.set(x[l + 4], x[l + 5]);
              p.copy(a)
                .add(g)
                .add(b)
                .divideScalar(3);
              var G = Math.atan2(p.z, -p.x);
              w(d, l + 0, a, G);
              w(e, l + 2, g, G);
              w(k, l + 4, b, G);
            }
            for (a = 0; a < x.length; a += 6)
              (g = x[a + 0]),
                (b = x[a + 2]),
                (p = x[a + 4]),
                (d = Math.min(g, b, p)),
                0.9 < Math.max(g, b, p) &&
                  0.1 > d &&
                  (0.2 > g && (x[a + 0] += 1),
                  0.2 > b && (x[a + 2] += 1),
                  0.2 > p && (x[a + 4] += 1));
          })();
          this.addAttribute("position", new P(f, 3));
          this.addAttribute("normal", new P(f.slice(), 3));
          this.addAttribute("uv", new P(x, 2));
          0 === e ? this.computeVertexNormals() : this.normalizeNormals();
        }
        function sc(a, b) {
          U.call(this);
          this.type = "TetrahedronGeometry";
          this.parameters = { radius: a, detail: b };
          this.fromBufferGeometry(new Sb(a, b));
          this.mergeVertices();
        }
        function Sb(a, b) {
          Jb.call(
            this,
            [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
            a,
            b
          );
          this.type = "TetrahedronBufferGeometry";
          this.parameters = { radius: a, detail: b };
        }
        function tc(a, b) {
          U.call(this);
          this.type = "OctahedronGeometry";
          this.parameters = { radius: a, detail: b };
          this.fromBufferGeometry(new nh(a, b));
          this.mergeVertices();
        }
        function nh(a, b) {
          Jb.call(
            this,
            [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            [
              0,
              2,
              4,
              0,
              4,
              3,
              0,
              3,
              5,
              0,
              5,
              2,
              1,
              2,
              5,
              1,
              5,
              3,
              1,
              3,
              4,
              1,
              4,
              2
            ],
            a,
            b
          );
          this.type = "OctahedronBufferGeometry";
          this.parameters = { radius: a, detail: b };
        }
        function uc(a, b) {
          U.call(this);
          this.type = "IcosahedronGeometry";
          this.parameters = { radius: a, detail: b };
          this.fromBufferGeometry(new Tb(a, b));
          this.mergeVertices();
        }
        function Tb(a, b) {
          var g = (1 + Math.sqrt(5)) / 2;
          Jb.call(
            this,
            [
              -1,
              g,
              0,
              1,
              g,
              0,
              -1,
              -g,
              0,
              1,
              -g,
              0,
              0,
              -1,
              g,
              0,
              1,
              g,
              0,
              -1,
              -g,
              0,
              1,
              -g,
              g,
              0,
              -1,
              g,
              0,
              1,
              -g,
              0,
              -1,
              -g,
              0,
              1
            ],
            [
              0,
              11,
              5,
              0,
              5,
              1,
              0,
              1,
              7,
              0,
              7,
              10,
              0,
              10,
              11,
              1,
              5,
              9,
              5,
              11,
              4,
              11,
              10,
              2,
              10,
              7,
              6,
              7,
              1,
              8,
              3,
              9,
              4,
              3,
              4,
              2,
              3,
              2,
              6,
              3,
              6,
              8,
              3,
              8,
              9,
              4,
              9,
              5,
              2,
              4,
              11,
              6,
              2,
              10,
              8,
              6,
              7,
              9,
              8,
              1
            ],
            a,
            b
          );
          this.type = "IcosahedronBufferGeometry";
          this.parameters = { radius: a, detail: b };
        }
        function wc(a, b) {
          U.call(this);
          this.type = "DodecahedronGeometry";
          this.parameters = { radius: a, detail: b };
          this.fromBufferGeometry(new Ub(a, b));
          this.mergeVertices();
        }
        function Ub(a, b) {
          var g = (1 + Math.sqrt(5)) / 2,
            c = 1 / g;
          Jb.call(
            this,
            [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -c,
              -g,
              0,
              -c,
              g,
              0,
              c,
              -g,
              0,
              c,
              g,
              -c,
              -g,
              0,
              -c,
              g,
              0,
              c,
              -g,
              0,
              c,
              g,
              0,
              -g,
              0,
              -c,
              g,
              0,
              -c,
              -g,
              0,
              c,
              g,
              0,
              c
            ],
            [
              3,
              11,
              7,
              3,
              7,
              15,
              3,
              15,
              13,
              7,
              19,
              17,
              7,
              17,
              6,
              7,
              6,
              15,
              17,
              4,
              8,
              17,
              8,
              10,
              17,
              10,
              6,
              8,
              0,
              16,
              8,
              16,
              2,
              8,
              2,
              10,
              0,
              12,
              1,
              0,
              1,
              18,
              0,
              18,
              16,
              6,
              10,
              2,
              6,
              2,
              13,
              6,
              13,
              15,
              2,
              16,
              18,
              2,
              18,
              3,
              2,
              3,
              13,
              18,
              1,
              9,
              18,
              9,
              11,
              18,
              11,
              3,
              4,
              14,
              12,
              4,
              12,
              0,
              4,
              0,
              8,
              11,
              9,
              5,
              11,
              5,
              19,
              11,
              19,
              7,
              19,
              5,
              14,
              19,
              14,
              4,
              19,
              4,
              17,
              1,
              12,
              14,
              1,
              14,
              5,
              1,
              5,
              9
            ],
            a,
            b
          );
          this.type = "DodecahedronBufferGeometry";
          this.parameters = { radius: a, detail: b };
        }
        function xc(a, b, c, d, e, f) {
          U.call(this);
          this.type = "TubeGeometry";
          this.parameters = {
            path: a,
            tubularSegments: b,
            radius: c,
            radialSegments: d,
            closed: e
          };
          void 0 !== f &&
            console.warn("THREE.TubeGeometry: taper has been removed.");
          a = new oh(a, b, c, d, e);
          this.tangents = a.tangents;
          this.normals = a.normals;
          this.binormals = a.binormals;
          this.fromBufferGeometry(a);
          this.mergeVertices();
        }
        function oh(a, b, d, e, f) {
          function g(g) {
            K = a.getPointAt(g / b, K);
            var c = p.normals[g];
            g = p.binormals[g];
            for (m = 0; m <= e; m++) {
              var f = (m / e) * Math.PI * 2,
                h = Math.sin(f);
              f = -Math.cos(f);
              x.x = f * c.x + h * g.x;
              x.y = f * c.y + h * g.y;
              x.z = f * c.z + h * g.z;
              x.normalize();
              q.push(x.x, x.y, x.z);
              w.x = K.x + d * x.x;
              w.y = K.y + d * x.y;
              w.z = K.z + d * x.z;
              n.push(w.x, w.y, w.z);
            }
          }
          S.call(this);
          this.type = "TubeBufferGeometry";
          this.parameters = {
            path: a,
            tubularSegments: b,
            radius: d,
            radialSegments: e,
            closed: f
          };
          b = b || 64;
          d = d || 1;
          e = e || 8;
          f = f || !1;
          var p = a.computeFrenetFrames(b, f);
          this.tangents = p.tangents;
          this.normals = p.normals;
          this.binormals = p.binormals;
          var w = new h(),
            x = new h(),
            k = new c(),
            K = new h(),
            l,
            m,
            n = [],
            q = [],
            t = [],
            u = [];
          for (l = 0; l < b; l++) g(l);
          g(!1 === f ? b : 0);
          for (l = 0; l <= b; l++)
            for (m = 0; m <= e; m++)
              (k.x = l / b), (k.y = m / e), t.push(k.x, k.y);
          (function() {
            for (m = 1; m <= b; m++)
              for (l = 1; l <= e; l++) {
                var a = (e + 1) * m + (l - 1),
                  g = (e + 1) * m + l,
                  c = (e + 1) * (m - 1) + l;
                u.push((e + 1) * (m - 1) + (l - 1), a, c);
                u.push(a, g, c);
              }
          })();
          this.setIndex(u);
          this.addAttribute("position", new P(n, 3));
          this.addAttribute("normal", new P(q, 3));
          this.addAttribute("uv", new P(t, 2));
        }
        function yc(a, b, c, d, e, f, h) {
          U.call(this);
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
          };
          void 0 !== h &&
            console.warn(
              "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
            );
          this.fromBufferGeometry(new Vb(a, b, c, d, e, f));
          this.mergeVertices();
        }
        function Vb(a, b, c, d, e, f) {
          function g(a, g, b, c, p) {
            var d = Math.sin(a);
            g = (b / g) * a;
            b = Math.cos(g);
            p.x = c * (2 + b) * 0.5 * Math.cos(a);
            p.y = c * (2 + b) * d * 0.5;
            p.z = c * Math.sin(g) * 0.5;
          }
          S.call(this);
          this.type = "TorusKnotBufferGeometry";
          this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
          };
          a = a || 1;
          b = b || 0.4;
          c = Math.floor(c) || 64;
          d = Math.floor(d) || 8;
          e = e || 2;
          f = f || 3;
          var p = [],
            w = [],
            x = [],
            k = [],
            l,
            K = new h(),
            G = new h(),
            m = new h(),
            n = new h(),
            q = new h(),
            t = new h(),
            u = new h();
          for (l = 0; l <= c; ++l) {
            var r = (l / c) * e * Math.PI * 2;
            g(r, e, f, a, m);
            g(r + 0.01, e, f, a, n);
            t.subVectors(n, m);
            u.addVectors(n, m);
            q.crossVectors(t, u);
            u.crossVectors(q, t);
            q.normalize();
            u.normalize();
            for (r = 0; r <= d; ++r) {
              var y = (r / d) * Math.PI * 2,
                v = -b * Math.cos(y);
              y = b * Math.sin(y);
              K.x = m.x + (v * u.x + y * q.x);
              K.y = m.y + (v * u.y + y * q.y);
              K.z = m.z + (v * u.z + y * q.z);
              w.push(K.x, K.y, K.z);
              G.subVectors(K, m).normalize();
              x.push(G.x, G.y, G.z);
              k.push(l / c);
              k.push(r / d);
            }
          }
          for (r = 1; r <= c; r++)
            for (l = 1; l <= d; l++)
              (a = (d + 1) * r + (l - 1)),
                (b = (d + 1) * r + l),
                (e = (d + 1) * (r - 1) + l),
                p.push((d + 1) * (r - 1) + (l - 1), a, e),
                p.push(a, b, e);
          this.setIndex(p);
          this.addAttribute("position", new P(w, 3));
          this.addAttribute("normal", new P(x, 3));
          this.addAttribute("uv", new P(k, 2));
        }
        function Bc(a, b, c, d, e) {
          U.call(this);
          this.type = "TorusGeometry";
          this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
          };
          this.fromBufferGeometry(new Wb(a, b, c, d, e));
          this.mergeVertices();
        }
        function Wb(a, b, c, d, e) {
          S.call(this);
          this.type = "TorusBufferGeometry";
          this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
          };
          a = a || 1;
          b = b || 0.4;
          c = Math.floor(c) || 8;
          d = Math.floor(d) || 6;
          e = e || 2 * Math.PI;
          var g = [],
            p = [],
            w = [],
            f = [],
            x = new h(),
            k = new h(),
            l = new h(),
            K,
            m;
          for (K = 0; K <= c; K++)
            for (m = 0; m <= d; m++) {
              var n = (m / d) * e,
                q = (K / c) * Math.PI * 2;
              k.x = (a + b * Math.cos(q)) * Math.cos(n);
              k.y = (a + b * Math.cos(q)) * Math.sin(n);
              k.z = b * Math.sin(q);
              p.push(k.x, k.y, k.z);
              x.x = a * Math.cos(n);
              x.y = a * Math.sin(n);
              l.subVectors(k, x).normalize();
              w.push(l.x, l.y, l.z);
              f.push(m / d);
              f.push(K / c);
            }
          for (K = 1; K <= c; K++)
            for (m = 1; m <= d; m++)
              (a = (d + 1) * (K - 1) + m - 1),
                (b = (d + 1) * (K - 1) + m),
                (e = (d + 1) * K + m),
                g.push((d + 1) * K + m - 1, a, e),
                g.push(a, b, e);
          this.setIndex(g);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("normal", new P(w, 3));
          this.addAttribute("uv", new P(f, 2));
        }
        function bf(a, b, c, d, e) {
          for (var g, p = 0, w = b, f = c - d; w < c; w += d)
            (p += (a[f] - a[w]) * (a[w + 1] + a[f + 1])), (f = w);
          if (e === 0 < p)
            for (e = b; e < c; e += d) g = zf(e, a[e], a[e + 1], g);
          else for (e = c - d; e >= b; e -= d) g = zf(e, a[e], a[e + 1], g);
          g && ph(g, g.next) && (Yc(g), (g = g.next));
          return g;
        }
        function Cc(a, b) {
          if (!a) return a;
          b || (b = a);
          do {
            var g = !1;
            if (a.steiner || (!ph(a, a.next) && 0 !== ob(a.prev, a, a.next)))
              a = a.next;
            else {
              Yc(a);
              a = b = a.prev;
              if (a === a.next) break;
              g = !0;
            }
          } while (g || a !== b);
          return b;
        }
        function Dc(a, b, c, d, e, f, h) {
          if (a) {
            if (!h && f) {
              var g = a,
                p = g;
              do
                null === p.z && (p.z = Ie(p.x, p.y, d, e, f)),
                  (p.prevZ = p.prev),
                  (p = p.nextZ = p.next);
              while (p !== g);
              p.prevZ.nextZ = null;
              p.prevZ = null;
              g = p;
              var w,
                x,
                k,
                l,
                K = 1;
              do {
                p = g;
                var G = (g = null);
                for (x = 0; p; ) {
                  x++;
                  var m = p;
                  for (w = k = 0; w < K && (k++, (m = m.nextZ), m); w++);
                  for (l = K; 0 < k || (0 < l && m); )
                    0 !== k && (0 === l || !m || p.z <= m.z)
                      ? ((w = p), (p = p.nextZ), k--)
                      : ((w = m), (m = m.nextZ), l--),
                      G ? (G.nextZ = w) : (g = w),
                      (w.prevZ = G),
                      (G = w);
                  p = m;
                }
                G.nextZ = null;
                K *= 2;
              } while (1 < x);
            }
            for (g = a; a.prev !== a.next; ) {
              p = a.prev;
              m = a.next;
              if (f) G = Zf(a, d, e, f);
              else
                a: if (
                  ((G = a),
                  (x = G.prev),
                  (k = G),
                  (K = G.next),
                  0 <= ob(x, k, K))
                )
                  G = !1;
                else {
                  for (w = G.next.next; w !== G.prev; ) {
                    if (
                      ec(x.x, x.y, k.x, k.y, K.x, K.y, w.x, w.y) &&
                      0 <= ob(w.prev, w, w.next)
                    ) {
                      G = !1;
                      break a;
                    }
                    w = w.next;
                  }
                  G = !0;
                }
              if (G)
                b.push(p.i / c),
                  b.push(a.i / c),
                  b.push(m.i / c),
                  Yc(a),
                  (g = a = m.next);
              else if (((a = m), a === g)) {
                if (!h) Dc(Cc(a), b, c, d, e, f, 1);
                else if (1 === h) {
                  h = b;
                  g = c;
                  p = a;
                  do
                    (m = p.prev),
                      (G = p.next.next),
                      !ph(m, G) &&
                        uf(m, p, p.next, G) &&
                        Uc(m, G) &&
                        Uc(G, m) &&
                        (h.push(m.i / g),
                        h.push(p.i / g),
                        h.push(G.i / g),
                        Yc(p),
                        Yc(p.next),
                        (p = a = G)),
                      (p = p.next);
                  while (p !== a);
                  a = p;
                  Dc(a, b, c, d, e, f, 2);
                } else if (2 === h)
                  a: {
                    h = a;
                    do {
                      for (g = h.next.next; g !== h.prev; ) {
                        if ((p = h.i !== g.i)) {
                          p = h;
                          m = g;
                          if ((G = p.next.i !== m.i && p.prev.i !== m.i)) {
                            b: {
                              G = p;
                              do {
                                if (
                                  G.i !== p.i &&
                                  G.next.i !== p.i &&
                                  G.i !== m.i &&
                                  G.next.i !== m.i &&
                                  uf(G, G.next, p, m)
                                ) {
                                  G = !0;
                                  break b;
                                }
                                G = G.next;
                              } while (G !== p);
                              G = !1;
                            }
                            G = !G;
                          }
                          if ((G = G && Uc(p, m) && Uc(m, p))) {
                            G = p;
                            x = !1;
                            k = (p.x + m.x) / 2;
                            m = (p.y + m.y) / 2;
                            do
                              G.y > m !== G.next.y > m &&
                                G.next.y !== G.y &&
                                k <
                                  ((G.next.x - G.x) * (m - G.y)) /
                                    (G.next.y - G.y) +
                                    G.x &&
                                (x = !x),
                                (G = G.next);
                            while (G !== p);
                            G = x;
                          }
                          p = G;
                        }
                        if (p) {
                          a = yf(h, g);
                          h = Cc(h, h.next);
                          a = Cc(a, a.next);
                          Dc(h, b, c, d, e, f);
                          Dc(a, b, c, d, e, f);
                          break a;
                        }
                        g = g.next;
                      }
                      h = h.next;
                    } while (h !== a);
                  }
                break;
              }
            }
          }
        }
        function Zf(a, b, c, d) {
          var g = a.prev,
            p = a.next;
          if (0 <= ob(g, a, p)) return !1;
          var e = g.x > a.x ? (g.x > p.x ? g.x : p.x) : a.x > p.x ? a.x : p.x,
            w = g.y > a.y ? (g.y > p.y ? g.y : p.y) : a.y > p.y ? a.y : p.y,
            f = Ie(
              g.x < a.x ? (g.x < p.x ? g.x : p.x) : a.x < p.x ? a.x : p.x,
              g.y < a.y ? (g.y < p.y ? g.y : p.y) : a.y < p.y ? a.y : p.y,
              b,
              c,
              d
            );
          b = Ie(e, w, b, c, d);
          c = a.prevZ;
          for (d = a.nextZ; c && c.z >= f && d && d.z <= b; ) {
            if (
              c !== a.prev &&
              c !== a.next &&
              ec(g.x, g.y, a.x, a.y, p.x, p.y, c.x, c.y) &&
              0 <= ob(c.prev, c, c.next)
            )
              return !1;
            c = c.prevZ;
            if (
              d !== a.prev &&
              d !== a.next &&
              ec(g.x, g.y, a.x, a.y, p.x, p.y, d.x, d.y) &&
              0 <= ob(d.prev, d, d.next)
            )
              return !1;
            d = d.nextZ;
          }
          for (; c && c.z >= f; ) {
            if (
              c !== a.prev &&
              c !== a.next &&
              ec(g.x, g.y, a.x, a.y, p.x, p.y, c.x, c.y) &&
              0 <= ob(c.prev, c, c.next)
            )
              return !1;
            c = c.prevZ;
          }
          for (; d && d.z <= b; ) {
            if (
              d !== a.prev &&
              d !== a.next &&
              ec(g.x, g.y, a.x, a.y, p.x, p.y, d.x, d.y) &&
              0 <= ob(d.prev, d, d.next)
            )
              return !1;
            d = d.nextZ;
          }
          return !0;
        }
        function lg(a, b) {
          return a.x - b.x;
        }
        function mg(a, b) {
          var g = b,
            c = a.x,
            p = a.y,
            d = -Infinity;
          do {
            if (p <= g.y && p >= g.next.y && g.next.y !== g.y) {
              var e = g.x + ((p - g.y) * (g.next.x - g.x)) / (g.next.y - g.y);
              if (e <= c && e > d) {
                d = e;
                if (e === c) {
                  if (p === g.y) return g;
                  if (p === g.next.y) return g.next;
                }
                var f = g.x < g.next.x ? g : g.next;
              }
            }
            g = g.next;
          } while (g !== b);
          if (!f) return null;
          if (c === d) return f.prev;
          b = f;
          e = f.x;
          var h = f.y,
            k = Infinity;
          for (g = f.next; g !== b; ) {
            if (
              c >= g.x &&
              g.x >= e &&
              c !== g.x &&
              ec(p < h ? c : d, p, e, h, p < h ? d : c, p, g.x, g.y)
            ) {
              var l = Math.abs(p - g.y) / (c - g.x);
              (l < k || (l === k && g.x > f.x)) &&
                Uc(g, a) &&
                ((f = g), (k = l));
            }
            g = g.next;
          }
          return f;
        }
        function Ie(a, b, c, d, e) {
          a = 32767 * (a - c) * e;
          b = 32767 * (b - d) * e;
          a = (a | (a << 8)) & 16711935;
          a = (a | (a << 4)) & 252645135;
          a = (a | (a << 2)) & 858993459;
          b = (b | (b << 8)) & 16711935;
          b = (b | (b << 4)) & 252645135;
          b = (b | (b << 2)) & 858993459;
          return (
            ((a | (a << 1)) & 1431655765) | (((b | (b << 1)) & 1431655765) << 1)
          );
        }
        function og(a) {
          var g = a,
            b = a;
          do {
            if (g.x < b.x || (g.x === b.x && g.y < b.y)) b = g;
            g = g.next;
          } while (g !== a);
          return b;
        }
        function ec(a, b, c, d, e, f, h, k) {
          return (
            0 <= (e - h) * (b - k) - (a - h) * (f - k) &&
            0 <= (a - h) * (d - k) - (c - h) * (b - k) &&
            0 <= (c - h) * (f - k) - (e - h) * (d - k)
          );
        }
        function ob(a, b, c) {
          return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
        }
        function ph(a, b) {
          return a.x === b.x && a.y === b.y;
        }
        function uf(a, b, c, d) {
          return (ph(a, c) && ph(b, d)) || (ph(a, d) && ph(c, b))
            ? !0
            : 0 < ob(a, b, c) !== 0 < ob(a, b, d) &&
                0 < ob(c, d, a) !== 0 < ob(c, d, b);
        }
        function Uc(a, b) {
          return 0 > ob(a.prev, a, a.next)
            ? 0 <= ob(a, b, a.next) && 0 <= ob(a, a.prev, b)
            : 0 > ob(a, b, a.prev) || 0 > ob(a, a.next, b);
        }
        function yf(a, b) {
          var g = new Le(a.i, a.x, a.y),
            c = new Le(b.i, b.x, b.y),
            p = a.next,
            d = b.prev;
          a.next = b;
          b.prev = a;
          g.next = p;
          p.prev = g;
          c.next = g;
          g.prev = c;
          d.next = c;
          c.prev = d;
          return c;
        }
        function zf(a, b, c, d) {
          a = new Le(a, b, c);
          d
            ? ((a.next = d.next), (a.prev = d), (d.next.prev = a), (d.next = a))
            : ((a.prev = a), (a.next = a));
          return a;
        }
        function Yc(a) {
          a.next.prev = a.prev;
          a.prev.next = a.next;
          a.prevZ && (a.prevZ.nextZ = a.nextZ);
          a.nextZ && (a.nextZ.prevZ = a.prevZ);
        }
        function Le(a, b, c) {
          this.i = a;
          this.x = b;
          this.y = c;
          this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
          this.steiner = !1;
        }
        function Ef(a) {
          var g = a.length;
          2 < g && a[g - 1].equals(a[0]) && a.pop();
        }
        function Gf(a, b) {
          for (var g = 0; g < b.length; g++) a.push(b[g].x), a.push(b[g].y);
        }
        function qh(a, b) {
          U.call(this);
          this.type = "ExtrudeGeometry";
          this.parameters = { shapes: a, options: b };
          this.fromBufferGeometry(new xe(a, b));
          this.mergeVertices();
        }
        function xe(a, b) {
          function g(a) {
            function g(a, g, b) {
              g || console.error("THREE.ExtrudeGeometry: vec does not exist");
              return g
                .clone()
                .multiplyScalar(b)
                .add(a);
            }
            function f(a, g, b) {
              var p = a.x - g.x;
              var d = a.y - g.y;
              var e = b.x - a.x;
              var f = b.y - a.y,
                w = p * p + d * d;
              if (Math.abs(p * f - d * e) > Number.EPSILON) {
                var h = Math.sqrt(w),
                  x = Math.sqrt(e * e + f * f);
                w = g.x - d / h;
                g = g.y + p / h;
                f =
                  ((b.x - f / x - w) * f - (b.y + e / x - g) * e) /
                  (p * f - d * e);
                e = w + p * f - a.x;
                p = g + d * f - a.y;
                d = e * e + p * p;
                if (2 >= d) return new c(e, p);
                d = Math.sqrt(d / 2);
              } else (a = !1), p > Number.EPSILON ? e > Number.EPSILON && (a = !0) : p < -Number.EPSILON ? e < -Number.EPSILON && (a = !0) : Math.sign(d) === Math.sign(f) && (a = !0), a ? ((e = -d), (d = Math.sqrt(w))) : ((e = p), (p = d), (d = Math.sqrt(w / 2)));
              return new c(e / d, p / d);
            }
            function w(a, g) {
              for (F = a.length; 0 <= --F; ) {
                var b = F;
                var c = F - 1;
                0 > c && (c = a.length - 1);
                var e,
                  f = Z + 2 * u;
                for (e = 0; e < f; e++) {
                  var w = O * e,
                    h = O * (e + 1),
                    x = g + c + w,
                    k = g + c + h;
                  h = g + b + h;
                  l(g + b + w);
                  l(x);
                  l(h);
                  l(x);
                  l(k);
                  l(h);
                  w = d.length / 3;
                  w = y.generateSideWallUV(p, d, w - 6, w - 3, w - 2, w - 1);
                  K(w[0]);
                  K(w[1]);
                  K(w[3]);
                  K(w[1]);
                  K(w[2]);
                  K(w[3]);
                }
              }
            }
            function x(a, g, b) {
              G.push(a);
              G.push(g);
              G.push(b);
            }
            function k(a, g, b) {
              l(a);
              l(g);
              l(b);
              a = d.length / 3;
              a = y.generateTopUV(p, d, a - 3, a - 2, a - 1);
              K(a[0]);
              K(a[1]);
              K(a[2]);
            }
            function l(a) {
              d.push(G[3 * a]);
              d.push(G[3 * a + 1]);
              d.push(G[3 * a + 2]);
            }
            function K(a) {
              e.push(a.x);
              e.push(a.y);
            }
            var G = [],
              m = void 0 !== b.curveSegments ? b.curveSegments : 12,
              Z = void 0 !== b.steps ? b.steps : 1,
              n = void 0 !== b.depth ? b.depth : 100,
              Y = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
              q = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
              R = void 0 !== b.bevelSize ? b.bevelSize : q - 2,
              t = void 0 !== b.bevelOffset ? b.bevelOffset : 0,
              u = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
              r = b.extrudePath,
              y = void 0 !== b.UVGenerator ? b.UVGenerator : Fj;
            void 0 !== b.amount &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (n = b.amount));
            var v = !1;
            if (r) {
              var A = r.getSpacedPoints(Z);
              v = !0;
              Y = !1;
              var z = r.computeFrenetFrames(Z, !1);
              var C = new h();
              var B = new h();
              var H = new h();
            }
            Y || (t = R = q = u = 0);
            var M;
            m = a.extractPoints(m);
            a = m.shape;
            var D = m.holes;
            if (!gf.isClockWise(a)) {
              a = a.reverse();
              var N = 0;
              for (M = D.length; N < M; N++) {
                var E = D[N];
                gf.isClockWise(E) && (D[N] = E.reverse());
              }
            }
            var P = gf.triangulateShape(a, D),
              I = a;
            N = 0;
            for (M = D.length; N < M; N++) (E = D[N]), (a = a.concat(E));
            var J,
              O = a.length,
              L,
              S = P.length;
            m = [];
            var F = 0;
            var Q = I.length;
            var U = Q - 1;
            for (J = F + 1; F < Q; F++, U++, J++)
              U === Q && (U = 0),
                J === Q && (J = 0),
                (m[F] = f(I[F], I[U], I[J]));
            r = [];
            var V = m.concat();
            N = 0;
            for (M = D.length; N < M; N++) {
              E = D[N];
              var X = [];
              F = 0;
              Q = E.length;
              U = Q - 1;
              for (J = F + 1; F < Q; F++, U++, J++)
                U === Q && (U = 0),
                  J === Q && (J = 0),
                  (X[F] = f(E[F], E[U], E[J]));
              r.push(X);
              V = V.concat(X);
            }
            for (U = 0; U < u; U++) {
              Q = U / u;
              var W = q * Math.cos((Q * Math.PI) / 2);
              J = R * Math.sin((Q * Math.PI) / 2) + t;
              F = 0;
              for (Q = I.length; F < Q; F++) {
                var T = g(I[F], m[F], J);
                x(T.x, T.y, -W);
              }
              N = 0;
              for (M = D.length; N < M; N++)
                for (E = D[N], X = r[N], F = 0, Q = E.length; F < Q; F++)
                  (T = g(E[F], X[F], J)), x(T.x, T.y, -W);
            }
            J = R + t;
            for (F = 0; F < O; F++)
              (T = Y ? g(a[F], V[F], J) : a[F]),
                v
                  ? (B.copy(z.normals[0]).multiplyScalar(T.x),
                    C.copy(z.binormals[0]).multiplyScalar(T.y),
                    H.copy(A[0])
                      .add(B)
                      .add(C),
                    x(H.x, H.y, H.z))
                  : x(T.x, T.y, 0);
            for (Q = 1; Q <= Z; Q++)
              for (F = 0; F < O; F++)
                (T = Y ? g(a[F], V[F], J) : a[F]),
                  v
                    ? (B.copy(z.normals[Q]).multiplyScalar(T.x),
                      C.copy(z.binormals[Q]).multiplyScalar(T.y),
                      H.copy(A[Q])
                        .add(B)
                        .add(C),
                      x(H.x, H.y, H.z))
                    : x(T.x, T.y, (n / Z) * Q);
            for (U = u - 1; 0 <= U; U--) {
              Q = U / u;
              W = q * Math.cos((Q * Math.PI) / 2);
              J = R * Math.sin((Q * Math.PI) / 2) + t;
              F = 0;
              for (Q = I.length; F < Q; F++)
                (T = g(I[F], m[F], J)), x(T.x, T.y, n + W);
              N = 0;
              for (M = D.length; N < M; N++)
                for (E = D[N], X = r[N], F = 0, Q = E.length; F < Q; F++)
                  (T = g(E[F], X[F], J)),
                    v
                      ? x(T.x, T.y + A[Z - 1].y, A[Z - 1].x + W)
                      : x(T.x, T.y, n + W);
            }
            (function() {
              var a = d.length / 3;
              if (Y) {
                var g = 0 * O;
                for (F = 0; F < S; F++)
                  (L = P[F]), k(L[2] + g, L[1] + g, L[0] + g);
                g = O * (Z + 2 * u);
                for (F = 0; F < S; F++)
                  (L = P[F]), k(L[0] + g, L[1] + g, L[2] + g);
              } else {
                for (F = 0; F < S; F++) (L = P[F]), k(L[2], L[1], L[0]);
                for (F = 0; F < S; F++)
                  (L = P[F]), k(L[0] + O * Z, L[1] + O * Z, L[2] + O * Z);
              }
              p.addGroup(a, d.length / 3 - a, 0);
            })();
            (function() {
              var a = d.length / 3,
                g = 0;
              w(I, g);
              g += I.length;
              N = 0;
              for (M = D.length; N < M; N++)
                (E = D[N]), w(E, g), (g += E.length);
              p.addGroup(a, d.length / 3 - a, 1);
            })();
          }
          S.call(this);
          this.type = "ExtrudeBufferGeometry";
          this.parameters = { shapes: a, options: b };
          a = Array.isArray(a) ? a : [a];
          for (var p = this, d = [], e = [], f = 0, k = a.length; f < k; f++)
            g(a[f]);
          this.addAttribute("position", new P(d, 3));
          this.addAttribute("uv", new P(e, 2));
          this.computeVertexNormals();
        }
        function If(a, b, c) {
          c.shapes = [];
          if (Array.isArray(a))
            for (var g = 0, p = a.length; g < p; g++) c.shapes.push(a[g].uuid);
          else c.shapes.push(a.uuid);
          void 0 !== b.extrudePath &&
            (c.options.extrudePath = b.extrudePath.toJSON());
          return c;
        }
        function ad(a, b) {
          U.call(this);
          this.type = "TextGeometry";
          this.parameters = { text: a, parameters: b };
          this.fromBufferGeometry(new Fi(a, b));
          this.mergeVertices();
        }
        function Fi(a, b) {
          b = b || {};
          var g = b.font;
          if (!g || !g.isFont)
            return (
              console.error(
                "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
              ),
              new U()
            );
          a = g.generateShapes(a, b.size);
          b.depth = void 0 !== b.height ? b.height : 50;
          void 0 === b.bevelThickness && (b.bevelThickness = 10);
          void 0 === b.bevelSize && (b.bevelSize = 8);
          void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
          xe.call(this, a, b);
          this.type = "TextBufferGeometry";
        }
        function cd(a, b, c, d, e, f, h) {
          U.call(this);
          this.type = "SphereGeometry";
          this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: h
          };
          this.fromBufferGeometry(new dg(a, b, c, d, e, f, h));
          this.mergeVertices();
        }
        function dg(a, b, c, d, e, f, k) {
          S.call(this);
          this.type = "SphereBufferGeometry";
          this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: k
          };
          a = a || 1;
          b = Math.max(3, Math.floor(b) || 8);
          c = Math.max(2, Math.floor(c) || 6);
          d = void 0 !== d ? d : 0;
          e = void 0 !== e ? e : 2 * Math.PI;
          f = void 0 !== f ? f : 0;
          k = void 0 !== k ? k : Math.PI;
          var g = Math.min(f + k, Math.PI),
            p,
            w,
            x = 0,
            l = [],
            K = new h(),
            G = new h(),
            m = [],
            Z = [],
            n = [],
            q = [];
          for (w = 0; w <= c; w++) {
            var t = [],
              u = w / c,
              r = 0;
            0 == w && 0 == f
              ? (r = 0.5 / b)
              : w == c && g == Math.PI && (r = -0.5 / b);
            for (p = 0; p <= b; p++) {
              var y = p / b;
              K.x = -a * Math.cos(d + y * e) * Math.sin(f + u * k);
              K.y = a * Math.cos(f + u * k);
              K.z = a * Math.sin(d + y * e) * Math.sin(f + u * k);
              Z.push(K.x, K.y, K.z);
              G.copy(K).normalize();
              n.push(G.x, G.y, G.z);
              q.push(y + r, 1 - u);
              t.push(x++);
            }
            l.push(t);
          }
          for (w = 0; w < c; w++)
            for (p = 0; p < b; p++)
              (a = l[w][p + 1]),
                (d = l[w][p]),
                (e = l[w + 1][p]),
                (k = l[w + 1][p + 1]),
                (0 !== w || 0 < f) && m.push(a, d, k),
                (w !== c - 1 || g < Math.PI) && m.push(d, e, k);
          this.setIndex(m);
          this.addAttribute("position", new P(Z, 3));
          this.addAttribute("normal", new P(n, 3));
          this.addAttribute("uv", new P(q, 2));
        }
        function fd(a, b, c, d, e, f) {
          U.call(this);
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
          };
          this.fromBufferGeometry(new Gi(a, b, c, d, e, f));
          this.mergeVertices();
        }
        function Gi(a, b, d, e, f, k) {
          S.call(this);
          this.type = "RingBufferGeometry";
          this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: d,
            phiSegments: e,
            thetaStart: f,
            thetaLength: k
          };
          a = a || 0.5;
          b = b || 1;
          f = void 0 !== f ? f : 0;
          k = void 0 !== k ? k : 2 * Math.PI;
          d = void 0 !== d ? Math.max(3, d) : 8;
          e = void 0 !== e ? Math.max(1, e) : 1;
          var g = [],
            p = [],
            w = [],
            x = [],
            l = a,
            K = (b - a) / e,
            G = new h(),
            m = new c(),
            n,
            q;
          for (n = 0; n <= e; n++) {
            for (q = 0; q <= d; q++)
              (a = f + (q / d) * k),
                (G.x = l * Math.cos(a)),
                (G.y = l * Math.sin(a)),
                p.push(G.x, G.y, G.z),
                w.push(0, 0, 1),
                (m.x = (G.x / b + 1) / 2),
                (m.y = (G.y / b + 1) / 2),
                x.push(m.x, m.y);
            l += K;
          }
          for (n = 0; n < e; n++)
            for (b = n * (d + 1), q = 0; q < d; q++)
              (a = q + b),
                (f = a + d + 1),
                (k = a + d + 2),
                (l = a + 1),
                g.push(a, f, l),
                g.push(f, k, l);
          this.setIndex(g);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("normal", new P(w, 3));
          this.addAttribute("uv", new P(x, 2));
        }
        function gd(a, b, c, d) {
          U.call(this);
          this.type = "LatheGeometry";
          this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
          };
          this.fromBufferGeometry(new Hi(a, b, c, d));
          this.mergeVertices();
        }
        function Hi(a, b, d, e) {
          S.call(this);
          this.type = "LatheBufferGeometry";
          this.parameters = {
            points: a,
            segments: b,
            phiStart: d,
            phiLength: e
          };
          b = Math.floor(b) || 12;
          d = d || 0;
          e = e || 2 * Math.PI;
          e = ya.clamp(e, 0, 2 * Math.PI);
          var g = [],
            p = [],
            f = [],
            w = 1 / b,
            x = new h(),
            k = new c(),
            l;
          for (l = 0; l <= b; l++) {
            var m = d + l * w * e;
            var n = Math.sin(m),
              q = Math.cos(m);
            for (m = 0; m <= a.length - 1; m++)
              (x.x = a[m].x * n),
                (x.y = a[m].y),
                (x.z = a[m].x * q),
                p.push(x.x, x.y, x.z),
                (k.x = l / b),
                (k.y = m / (a.length - 1)),
                f.push(k.x, k.y);
          }
          for (l = 0; l < b; l++)
            for (m = 0; m < a.length - 1; m++)
              (d = m + l * a.length),
                (w = d + a.length),
                (x = d + a.length + 1),
                (k = d + 1),
                g.push(d, w, k),
                g.push(w, x, k);
          this.setIndex(g);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("uv", new P(f, 2));
          this.computeVertexNormals();
          if (e === 2 * Math.PI)
            for (
              e = this.attributes.normal.array,
                g = new h(),
                p = new h(),
                f = new h(),
                d = b * a.length * 3,
                m = l = 0;
              l < a.length;
              l++, m += 3
            )
              (g.x = e[m + 0]),
                (g.y = e[m + 1]),
                (g.z = e[m + 2]),
                (p.x = e[d + m + 0]),
                (p.y = e[d + m + 1]),
                (p.z = e[d + m + 2]),
                f.addVectors(g, p).normalize(),
                (e[m + 0] = e[d + m + 0] = f.x),
                (e[m + 1] = e[d + m + 1] = f.y),
                (e[m + 2] = e[d + m + 2] = f.z);
        }
        function rh(a, b) {
          U.call(this);
          this.type = "ShapeGeometry";
          "object" === ("undefined" === typeof b ? "undefined" : nk(b)) &&
            (console.warn(
              "THREE.ShapeGeometry: Options parameter has been removed."
            ),
            (b = b.curveSegments));
          this.parameters = { shapes: a, curveSegments: b };
          this.fromBufferGeometry(new sh(a, b));
          this.mergeVertices();
        }
        function sh(a, b) {
          function g(a) {
            var g,
              f = p.length / 3;
            a = a.extractPoints(b);
            var w = a.shape,
              x = a.holes;
            !1 === gf.isClockWise(w) && (w = w.reverse());
            a = 0;
            for (g = x.length; a < g; a++) {
              var k = x[a];
              !0 === gf.isClockWise(k) && (x[a] = k.reverse());
            }
            var l = gf.triangulateShape(w, x);
            a = 0;
            for (g = x.length; a < g; a++) (k = x[a]), (w = w.concat(k));
            a = 0;
            for (g = w.length; a < g; a++)
              (k = w[a]),
                p.push(k.x, k.y, 0),
                d.push(0, 0, 1),
                e.push(k.x, k.y);
            a = 0;
            for (g = l.length; a < g; a++)
              (w = l[a]), c.push(w[0] + f, w[1] + f, w[2] + f), (h += 3);
          }
          S.call(this);
          this.type = "ShapeBufferGeometry";
          this.parameters = { shapes: a, curveSegments: b };
          b = b || 12;
          var c = [],
            p = [],
            d = [],
            e = [],
            f = 0,
            h = 0;
          if (!1 === Array.isArray(a)) g(a);
          else
            for (var k = 0; k < a.length; k++)
              g(a[k]), this.addGroup(f, h, k), (f += h), (h = 0);
          this.setIndex(c);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("normal", new P(d, 3));
          this.addAttribute("uv", new P(e, 2));
        }
        function Of(a, b) {
          b.shapes = [];
          if (Array.isArray(a))
            for (var g = 0, c = a.length; g < c; g++) b.shapes.push(a[g].uuid);
          else b.shapes.push(a.uuid);
          return b;
        }
        function Ii(a, b) {
          S.call(this);
          this.type = "EdgesGeometry";
          this.parameters = { thresholdAngle: b };
          var g = [];
          b = Math.cos(ya.DEG2RAD * (void 0 !== b ? b : 1));
          var c = [0, 0],
            p = {},
            d = ["a", "b", "c"];
          if (a.isBufferGeometry) {
            var e = new U();
            e.fromBufferGeometry(a);
          } else e = a.clone();
          e.mergeVertices();
          e.computeFaceNormals();
          a = e.vertices;
          e = e.faces;
          for (var f = 0, h = e.length; f < h; f++)
            for (var k = e[f], l = 0; 3 > l; l++) {
              var m = k[d[l]];
              var n = k[d[(l + 1) % 3]];
              c[0] = Math.min(m, n);
              c[1] = Math.max(m, n);
              m = c[0] + "," + c[1];
              void 0 === p[m]
                ? (p[m] = {
                    index1: c[0],
                    index2: c[1],
                    face1: f,
                    face2: void 0
                  })
                : (p[m].face2 = f);
            }
          for (m in p)
            if (
              ((c = p[m]),
              void 0 === c.face2 ||
                e[c.face1].normal.dot(e[c.face2].normal) <= b)
            )
              (d = a[c.index1]),
                g.push(d.x, d.y, d.z),
                (d = a[c.index2]),
                g.push(d.x, d.y, d.z);
          this.addAttribute("position", new P(g, 3));
        }
        function th(a, b, c, d, e, f, h, k) {
          U.call(this);
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: h,
            thetaLength: k
          };
          this.fromBufferGeometry(new hf(a, b, c, d, e, f, h, k));
          this.mergeVertices();
        }
        function hf(a, b, d, e, f, k, l, m) {
          function g(g) {
            var d,
              f = new c(),
              k = new h(),
              n = 0,
              R = !0 === g ? a : b,
              t = !0 === g ? 1 : -1;
            var ea = Z;
            for (d = 1; d <= e; d++)
              x.push(0, q * t, 0), K.push(0, t, 0), G.push(0.5, 0.5), Z++;
            var u = Z;
            for (d = 0; d <= e; d++) {
              var r = (d / e) * m + l,
                y = Math.cos(r);
              r = Math.sin(r);
              k.x = R * r;
              k.y = q * t;
              k.z = R * y;
              x.push(k.x, k.y, k.z);
              K.push(0, t, 0);
              f.x = 0.5 * y + 0.5;
              f.y = 0.5 * r * t + 0.5;
              G.push(f.x, f.y);
              Z++;
            }
            for (d = 0; d < e; d++)
              (f = ea + d),
                (k = u + d),
                !0 === g ? w.push(k, k + 1, f) : w.push(k + 1, k, f),
                (n += 3);
            p.addGroup(Y, n, !0 === g ? 1 : 2);
            Y += n;
          }
          S.call(this);
          this.type = "CylinderBufferGeometry";
          this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: d,
            radialSegments: e,
            heightSegments: f,
            openEnded: k,
            thetaStart: l,
            thetaLength: m
          };
          var p = this;
          a = void 0 !== a ? a : 1;
          b = void 0 !== b ? b : 1;
          d = d || 1;
          e = Math.floor(e) || 8;
          f = Math.floor(f) || 1;
          k = void 0 !== k ? k : !1;
          l = void 0 !== l ? l : 0;
          m = void 0 !== m ? m : 2 * Math.PI;
          var w = [],
            x = [],
            K = [],
            G = [],
            Z = 0,
            n = [],
            q = d / 2,
            Y = 0;
          (function() {
            var g,
              c,
              k = new h(),
              R = new h(),
              t = 0,
              ea = (b - a) / d;
            for (c = 0; c <= f; c++) {
              var u = [],
                r = c / f,
                y = r * (b - a) + a;
              for (g = 0; g <= e; g++) {
                var v = g / e,
                  ab = v * m + l,
                  A = Math.sin(ab);
                ab = Math.cos(ab);
                R.x = y * A;
                R.y = -r * d + q;
                R.z = y * ab;
                x.push(R.x, R.y, R.z);
                k.set(A, ea, ab).normalize();
                K.push(k.x, k.y, k.z);
                G.push(v, 1 - r);
                u.push(Z++);
              }
              n.push(u);
            }
            for (g = 0; g < e; g++)
              for (c = 0; c < f; c++)
                (k = n[c + 1][g]),
                  (R = n[c + 1][g + 1]),
                  (ea = n[c][g + 1]),
                  w.push(n[c][g], k, ea),
                  w.push(k, R, ea),
                  (t += 6);
            p.addGroup(Y, t, 0);
            Y += t;
          })();
          !1 === k && (0 < a && g(!0), 0 < b && g(!1));
          this.setIndex(w);
          this.addAttribute("position", new P(x, 3));
          this.addAttribute("normal", new P(K, 3));
          this.addAttribute("uv", new P(G, 2));
        }
        function hd(a, b, c, d, e, f, h) {
          th.call(this, 0, a, b, c, d, e, f, h);
          this.type = "ConeGeometry";
          this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: h
          };
        }
        function jd(a, b, c, d, e, f, h) {
          hf.call(this, 0, a, b, c, d, e, f, h);
          this.type = "ConeBufferGeometry";
          this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: h
          };
        }
        function kd(a, b, c, d) {
          U.call(this);
          this.type = "CircleGeometry";
          this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
          };
          this.fromBufferGeometry(new Ji(a, b, c, d));
          this.mergeVertices();
        }
        function Ji(a, b, d, e) {
          S.call(this);
          this.type = "CircleBufferGeometry";
          this.parameters = {
            radius: a,
            segments: b,
            thetaStart: d,
            thetaLength: e
          };
          a = a || 1;
          b = void 0 !== b ? Math.max(3, b) : 8;
          d = void 0 !== d ? d : 0;
          e = void 0 !== e ? e : 2 * Math.PI;
          var g = [],
            p = [],
            f = [],
            w = [],
            x,
            k = new h(),
            l = new c();
          p.push(0, 0, 0);
          f.push(0, 0, 1);
          w.push(0.5, 0.5);
          var m = 0;
          for (x = 3; m <= b; m++, x += 3) {
            var n = d + (m / b) * e;
            k.x = a * Math.cos(n);
            k.y = a * Math.sin(n);
            p.push(k.x, k.y, k.z);
            f.push(0, 0, 1);
            l.x = (p[x] / a + 1) / 2;
            l.y = (p[x + 1] / a + 1) / 2;
            w.push(l.x, l.y);
          }
          for (x = 1; x <= b; x++) g.push(x, x + 1, 0);
          this.setIndex(g);
          this.addAttribute("position", new P(p, 3));
          this.addAttribute("normal", new P(f, 3));
          this.addAttribute("uv", new P(w, 2));
        }
        function uh(a) {
          D.call(this);
          this.type = "ShadowMaterial";
          this.color = new M(0);
          this.transparent = !0;
          this.setValues(a);
        }
        function Ki(a) {
          qa.call(this, a);
          this.type = "RawShaderMaterial";
        }
        function ye(a) {
          D.call(this);
          this.defines = { STANDARD: "" };
          this.type = "MeshStandardMaterial";
          this.color = new M(16777215);
          this.metalness = this.roughness = 0.5;
          this.lightMap = this.map = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new M(0);
          this.emissiveIntensity = 1;
          this.bumpMap = this.emissiveMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = 0;
          this.normalScale = new c(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.wireframeLinejoin = this.wireframeLinecap = "round";
          this.morphNormals = this.morphTargets = this.skinning = !1;
          this.setValues(a);
        }
        function vh(a) {
          ye.call(this);
          this.defines = { STANDARD: "", PHYSICAL: "" };
          this.type = "MeshPhysicalMaterial";
          this.reflectivity = 0.5;
          this.clearcoatRoughness = this.clearcoat = 0;
          this.sheen = null;
          this.clearcoatNormalScale = new c(1, 1);
          this.clearcoatNormalMap = null;
          this.transparency = 0;
          this.setValues(a);
        }
        function yd(a) {
          D.call(this);
          this.type = "MeshPhongMaterial";
          this.color = new M(16777215);
          this.specular = new M(1118481);
          this.shininess = 30;
          this.lightMap = this.map = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new M(0);
          this.emissiveIntensity = 1;
          this.bumpMap = this.emissiveMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = 0;
          this.normalScale = new c(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.envMap = this.alphaMap = this.specularMap = null;
          this.combine = 0;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.wireframeLinejoin = this.wireframeLinecap = "round";
          this.morphNormals = this.morphTargets = this.skinning = !1;
          this.setValues(a);
        }
        function wh(a) {
          yd.call(this);
          this.defines = { TOON: "" };
          this.type = "MeshToonMaterial";
          this.gradientMap = null;
          this.setValues(a);
        }
        function xh(a) {
          D.call(this);
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = 0;
          this.normalScale = new c(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.morphNormals = this.morphTargets = this.skinning = this.fog = !1;
          this.setValues(a);
        }
        function yh(a) {
          D.call(this);
          this.type = "MeshLambertMaterial";
          this.color = new M(16777215);
          this.lightMap = this.map = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new M(0);
          this.emissiveIntensity = 1;
          this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
          this.combine = 0;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = !1;
          this.wireframeLinewidth = 1;
          this.wireframeLinejoin = this.wireframeLinecap = "round";
          this.morphNormals = this.morphTargets = this.skinning = !1;
          this.setValues(a);
        }
        function zh(a) {
          D.call(this);
          this.defines = { MATCAP: "" };
          this.type = "MeshMatcapMaterial";
          this.color = new M(16777215);
          this.bumpMap = this.map = this.matcap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = 0;
          this.normalScale = new c(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.morphNormals = this.morphTargets = this.skinning = !1;
          this.setValues(a);
        }
        function Ah(a) {
          Ga.call(this);
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(a);
        }
        function Zb(a, b, c, d) {
          this.parameterPositions = a;
          this._cachedIndex = 0;
          this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
          this.sampleValues = b;
          this.valueSize = c;
        }
        function Ud(a, b, c, d) {
          Zb.call(this, a, b, c, d);
          this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
        }
        function md(a, b, c, d) {
          Zb.call(this, a, b, c, d);
        }
        function Vd(a, b, c, d) {
          Zb.call(this, a, b, c, d);
        }
        function pb(a, b, c, d) {
          if (void 0 === a)
            throw Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === b || 0 === b.length)
            throw Error(
              "THREE.KeyframeTrack: no keyframes in track named " + a
            );
          this.name = a;
          this.times = lb.convertArray(b, this.TimeBufferType);
          this.values = lb.convertArray(c, this.ValueBufferType);
          this.setInterpolation(d || this.DefaultInterpolation);
        }
        function Xd(a, b, c) {
          pb.call(this, a, b, c);
        }
        function Yd(a, b, c, d) {
          pb.call(this, a, b, c, d);
        }
        function Li(a, b, c, d) {
          pb.call(this, a, b, c, d);
        }
        function Zd(a, b, c, d) {
          Zb.call(this, a, b, c, d);
        }
        function nd(a, b, c, d) {
          pb.call(this, a, b, c, d);
        }
        function $d(a, b, c, d) {
          pb.call(this, a, b, c, d);
        }
        function Mi(a, b, c, d) {
          pb.call(this, a, b, c, d);
        }
        function Oc(a, b, c) {
          this.name = a;
          this.tracks = c;
          this.duration = void 0 !== b ? b : -1;
          this.uuid = ya.generateUUID();
          0 > this.duration && this.resetDuration();
        }
        function Tg(a) {
          switch (a.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Li;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Mi;
            case "color":
              return Yd;
            case "quaternion":
              return nd;
            case "bool":
            case "boolean":
              return Xd;
            case "string":
              return $d;
          }
          throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
        }
        function Vg(a) {
          if (void 0 === a.type)
            throw Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          var g = Tg(a.type);
          if (void 0 === a.times) {
            var b = [],
              c = [];
            lb.flattenJSON(a.keys, b, c, "value");
            a.times = b;
            a.values = c;
          }
          return void 0 !== g.parse
            ? g.parse(a)
            : new g(a.name, a.times, a.values, a.interpolation);
        }
        function Xe(a, b, c) {
          var g = this,
            p = !1,
            d = 0,
            e = 0,
            f = void 0,
            w = [];
          this.onStart = void 0;
          this.onLoad = a;
          this.onProgress = b;
          this.onError = c;
          this.itemStart = function(a) {
            e++;
            if (!1 === p && void 0 !== g.onStart) g.onStart(a, d, e);
            p = !0;
          };
          this.itemEnd = function(a) {
            d++;
            if (void 0 !== g.onProgress) g.onProgress(a, d, e);
            if (d === e && ((p = !1), void 0 !== g.onLoad)) g.onLoad();
          };
          this.itemError = function(a) {
            if (void 0 !== g.onError) g.onError(a);
          };
          this.resolveURL = function(a) {
            return f ? f(a) : a;
          };
          this.setURLModifier = function(a) {
            f = a;
            return this;
          };
          this.addHandler = function(a, g) {
            w.push(a, g);
            return this;
          };
          this.removeHandler = function(a) {
            a = w.indexOf(a);
            -1 !== a && w.splice(a, 2);
            return this;
          };
          this.getHandler = function(a) {
            for (var g = 0, b = w.length; g < b; g += 2) {
              var c = w[g + 1];
              if (w[g].test(a)) return c;
            }
            return null;
          };
        }
        function Ja(a) {
          this.manager = void 0 !== a ? a : qi;
          this.crossOrigin = "anonymous";
          this.resourcePath = this.path = "";
        }
        function Pc(a) {
          Ja.call(this, a);
        }
        function Ye(a) {
          Ja.call(this, a);
        }
        function Ze(a) {
          Ja.call(this, a);
        }
        function ae(a) {
          Ja.call(this, a);
        }
        function Ni(a) {
          Ja.call(this, a);
        }
        function ce(a) {
          Ja.call(this, a);
        }
        function ee(a) {
          Ja.call(this, a);
        }
        function la() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        function $b(a, b, c, d, e, f, h, k) {
          la.call(this);
          this.type = "EllipseCurve";
          this.aX = a || 0;
          this.aY = b || 0;
          this.xRadius = c || 1;
          this.yRadius = d || 1;
          this.aStartAngle = e || 0;
          this.aEndAngle = f || 2 * Math.PI;
          this.aClockwise = h || !1;
          this.aRotation = k || 0;
        }
        function Oi(a, b, c, d, e, f) {
          $b.call(this, a, b, c, c, d, e, f);
          this.type = "ArcCurve";
        }
        function af() {
          var a = 0,
            b = 0,
            c = 0,
            d = 0;
          return {
            initCatmullRom: function(g, p, e, f, w) {
              g = w * (e - g);
              f = w * (f - p);
              a = p;
              b = g;
              c = -3 * p + 3 * e - 2 * g - f;
              d = 2 * p - 2 * e + g + f;
            },
            initNonuniformCatmullRom: function(g, p, e, f, w, h, x) {
              g = ((p - g) / w - (e - g) / (w + h) + (e - p) / h) * h;
              f = ((e - p) / h - (f - p) / (h + x) + (f - e) / x) * h;
              a = p;
              b = g;
              c = -3 * p + 3 * e - 2 * g - f;
              d = 2 * p - 2 * e + g + f;
            },
            calc: function(g) {
              var p = g * g;
              return a + b * g + c * p + d * p * g;
            }
          };
        }
        function sb(a, b, c, d) {
          la.call(this);
          this.type = "CatmullRomCurve3";
          this.points = a || [];
          this.closed = b || !1;
          this.curveType = c || "centripetal";
          this.tension = d || 0.5;
        }
        function Yf(a, b, c, d, e) {
          b = 0.5 * (d - b);
          e = 0.5 * (e - c);
          var g = a * a;
          return (
            (2 * c - 2 * d + b + e) * a * g +
            (-3 * c + 3 * d - 2 * b - e) * g +
            b * a +
            c
          );
        }
        function pd(a, b, c, d) {
          var g = 1 - a;
          return g * g * b + 2 * (1 - a) * a * c + a * a * d;
        }
        function qd(a, b, c, d, e) {
          var g = 1 - a,
            p = 1 - a;
          return (
            g * g * g * b +
            3 * p * p * a * c +
            3 * (1 - a) * a * a * d +
            a * a * a * e
          );
        }
        function zd(a, b, d, e) {
          la.call(this);
          this.type = "CubicBezierCurve";
          this.v0 = a || new c();
          this.v1 = b || new c();
          this.v2 = d || new c();
          this.v3 = e || new c();
        }
        function ze(a, b, c, d) {
          la.call(this);
          this.type = "CubicBezierCurve3";
          this.v0 = a || new h();
          this.v1 = b || new h();
          this.v2 = c || new h();
          this.v3 = d || new h();
        }
        function Kb(a, b) {
          la.call(this);
          this.type = "LineCurve";
          this.v1 = a || new c();
          this.v2 = b || new c();
        }
        function Ad(a, b) {
          la.call(this);
          this.type = "LineCurve3";
          this.v1 = a || new h();
          this.v2 = b || new h();
        }
        function Bd(a, b, d) {
          la.call(this);
          this.type = "QuadraticBezierCurve";
          this.v0 = a || new c();
          this.v1 = b || new c();
          this.v2 = d || new c();
        }
        function Ae(a, b, c) {
          la.call(this);
          this.type = "QuadraticBezierCurve3";
          this.v0 = a || new h();
          this.v1 = b || new h();
          this.v2 = c || new h();
        }
        function Cd(a) {
          la.call(this);
          this.type = "SplineCurve";
          this.points = a || [];
        }
        function jf() {
          la.call(this);
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = !1;
        }
        function Dd(a) {
          jf.call(this);
          this.type = "Path";
          this.currentPoint = new c();
          a && this.setFromPoints(a);
        }
        function eg(a) {
          Dd.call(this, a);
          this.uuid = ya.generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        function Ka(a, b) {
          v.call(this);
          this.type = "Light";
          this.color = new M(a);
          this.intensity = void 0 !== b ? b : 1;
          this.receiveShadow = void 0;
        }
        function ge(a, b, c) {
          Ka.call(this, a, c);
          this.type = "HemisphereLight";
          this.castShadow = void 0;
          this.position.copy(v.DefaultUp);
          this.updateMatrix();
          this.groundColor = new M(b);
        }
        function Be(a) {
          this.camera = a;
          this.bias = 0;
          this.radius = 1;
          this.mapSize = new c(512, 512);
          this.mapPass = this.map = null;
          this.matrix = new t();
          this._frustum = new Q();
          this._frameExtents = new c(1, 1);
          this._viewportCount = 1;
          this._viewports = [new m(0, 0, 1, 1)];
        }
        function he() {
          Be.call(this, new Da(50, 1, 0.5, 500));
        }
        function ie(a, b, c, d, e, f) {
          Ka.call(this, a, b);
          this.type = "SpotLight";
          this.position.copy(v.DefaultUp);
          this.updateMatrix();
          this.target = new v();
          Object.defineProperty(this, "power", {
            get: function() {
              return this.intensity * Math.PI;
            },
            set: function(a) {
              this.intensity = a / Math.PI;
            }
          });
          this.distance = void 0 !== c ? c : 0;
          this.angle = void 0 !== d ? d : Math.PI / 3;
          this.penumbra = void 0 !== e ? e : 0;
          this.decay = void 0 !== f ? f : 1;
          this.shadow = new he();
        }
        function df() {
          Be.call(this, new Da(90, 1, 0.5, 500));
          this._frameExtents = new c(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new m(2, 1, 1, 1),
            new m(0, 1, 1, 1),
            new m(3, 1, 1, 1),
            new m(1, 1, 1, 1),
            new m(3, 0, 1, 1),
            new m(1, 0, 1, 1)
          ];
          this._cubeDirections = [
            new h(1, 0, 0),
            new h(-1, 0, 0),
            new h(0, 0, 1),
            new h(0, 0, -1),
            new h(0, 1, 0),
            new h(0, -1, 0)
          ];
          this._cubeUps = [
            new h(0, 1, 0),
            new h(0, 1, 0),
            new h(0, 1, 0),
            new h(0, 1, 0),
            new h(0, 0, 1),
            new h(0, 0, -1)
          ];
        }
        function je(a, b, c, d) {
          Ka.call(this, a, b);
          this.type = "PointLight";
          Object.defineProperty(this, "power", {
            get: function() {
              return 4 * this.intensity * Math.PI;
            },
            set: function(a) {
              this.intensity = a / (4 * Math.PI);
            }
          });
          this.distance = void 0 !== c ? c : 0;
          this.decay = void 0 !== d ? d : 1;
          this.shadow = new df();
        }
        function td(a, b, c, d, e, f) {
          ua.call(this);
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = void 0 !== a ? a : -1;
          this.right = void 0 !== b ? b : 1;
          this.top = void 0 !== c ? c : 1;
          this.bottom = void 0 !== d ? d : -1;
          this.near = void 0 !== e ? e : 0.1;
          this.far = void 0 !== f ? f : 2e3;
          this.updateProjectionMatrix();
        }
        function le() {
          Be.call(this, new td(-5, 5, 5, -5, 0.5, 500));
        }
        function me(a, b) {
          Ka.call(this, a, b);
          this.type = "DirectionalLight";
          this.position.copy(v.DefaultUp);
          this.updateMatrix();
          this.target = new v();
          this.shadow = new le();
        }
        function ne(a, b) {
          Ka.call(this, a, b);
          this.type = "AmbientLight";
          this.castShadow = void 0;
        }
        function oe(a, b, c, d) {
          Ka.call(this, a, b);
          this.type = "RectAreaLight";
          this.width = void 0 !== c ? c : 10;
          this.height = void 0 !== d ? d : 10;
        }
        function pe(a) {
          Ja.call(this, a);
          this.textures = {};
        }
        function qe() {
          S.call(this);
          this.type = "InstancedBufferGeometry";
          this.maxInstancedCount = void 0;
        }
        function re(a, b, c, d) {
          "number" === typeof c &&
            ((d = c),
            (c = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            ));
          I.call(this, a, b, c);
          this.meshPerAttribute = d || 1;
        }
        function se(a) {
          Ja.call(this, a);
        }
        function Ge(a) {
          Ja.call(this, a);
        }
        function sf(a) {
          "undefined" === typeof createImageBitmap &&
            console.warn(
              "THREE.ImageBitmapLoader: createImageBitmap() not supported."
            );
          "undefined" === typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          Ja.call(this, a);
          this.options = void 0;
        }
        function tf() {
          this.type = "ShapePath";
          this.color = new M();
          this.subPaths = [];
          this.currentPath = null;
        }
        function vf(a) {
          this.type = "Font";
          this.data = a;
        }
        function Af(a) {
          Ja.call(this, a);
        }
        function Me(a) {
          Ja.call(this, a);
        }
        function Ne() {
          this.coefficients = [];
          for (var a = 0; 9 > a; a++) this.coefficients.push(new h());
        }
        function Ed(a, b) {
          Ka.call(this, void 0, b);
          this.sh = void 0 !== a ? a : new Ne();
        }
        function Cf(a, b, c) {
          Ed.call(this, void 0, c);
          a = new M().set(a);
          c = new M().set(b);
          b = new h(a.r, a.g, a.b);
          a = new h(c.r, c.g, c.b);
          c = Math.sqrt(Math.PI);
          var g = c * Math.sqrt(0.75);
          this.sh.coefficients[0]
            .copy(b)
            .add(a)
            .multiplyScalar(c);
          this.sh.coefficients[1]
            .copy(b)
            .sub(a)
            .multiplyScalar(g);
        }
        function Ff(a, b) {
          Ed.call(this, void 0, b);
          a = new M().set(a);
          this.sh.coefficients[0]
            .set(a.r, a.g, a.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
        function zg() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new Da();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = !1;
          this.cameraR = new Da();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = !1;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        function Jf(a) {
          this.autoStart = void 0 !== a ? a : !0;
          this.elapsedTime = this.oldTime = this.startTime = 0;
          this.running = !1;
        }
        function Kf() {
          v.call(this);
          this.type = "AudioListener";
          this.context = fh.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Jf();
        }
        function Pi(a) {
          v.call(this);
          this.type = "Audio";
          this.listener = a;
          this.context = a.context;
          this.gain = this.context.createGain();
          this.gain.connect(a.getInput());
          this.autoplay = !1;
          this.buffer = null;
          this.detune = 0;
          this.loop = !1;
          this.offset = this.startTime = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = !1;
          this.hasPlaybackControl = !0;
          this.sourceType = "empty";
          this.filters = [];
        }
        function Lf(a) {
          Pi.call(this, a);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        function Mf(a, b) {
          this.analyser = a.context.createAnalyser();
          this.analyser.fftSize = void 0 !== b ? b : 2048;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          a.getOutput().connect(this.analyser);
        }
        function Nf(a, b, c) {
          this.binding = a;
          this.valueSize = c;
          a = Float64Array;
          switch (b) {
            case "quaternion":
              b = this._slerp;
              break;
            case "string":
            case "bool":
              a = Array;
              b = this._select;
              break;
            default:
              b = this._lerp;
          }
          this.buffer = new a(4 * c);
          this._mixBufferRegion = b;
          this.referenceCount = this.useCount = this.cumulativeWeight = 0;
        }
        function Fg(a, b, c) {
          c = c || tb.parseTrackName(b);
          this._targetGroup = a;
          this._bindings = a.subscribe_(b, c);
        }
        function tb(a, b, c) {
          this.path = b;
          this.parsedPath = c || tb.parseTrackName(b);
          this.node = tb.findNode(a, this.parsedPath.nodeName) || a;
          this.rootNode = a;
        }
        function Hg() {
          this.uuid = ya.generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          var a = {};
          this._indicesByUUID = a;
          for (var b = 0, c = arguments.length; b !== c; ++b)
            a[arguments[b].uuid] = b;
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          var d = this;
          this.stats = {
            objects: {
              get total() {
                return d._objects.length;
              },
              get inUse() {
                return this.total - d.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return d._bindings.length;
            }
          };
        }
        function Ig(a, b, c) {
          this._mixer = a;
          this._clip = b;
          this._localRoot = c || null;
          a = b.tracks;
          b = a.length;
          c = Array(b);
          for (
            var g = { endingStart: 2400, endingEnd: 2400 }, d = 0;
            d !== b;
            ++d
          ) {
            var p = a[d].createInterpolant(null);
            c[d] = p;
            p.settings = g;
          }
          this._interpolantSettings = g;
          this._interpolants = c;
          this._propertyBindings = Array(b);
          this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
          this.loop = 2201;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
          this.repetitions = Infinity;
          this.paused = !1;
          this.enabled = !0;
          this.clampWhenFinished = !1;
          this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
        }
        function Pf(a) {
          this._root = a;
          this._initMemoryManager();
          this.time = this._accuIndex = 0;
          this.timeScale = 1;
        }
        function Ue(a, b) {
          "string" === typeof a &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (a = b));
          this.value = a;
        }
        function Sf(a, b, c) {
          bg.call(this, a, b);
          this.meshPerAttribute = c || 1;
        }
        function Lg(a, b, c, d) {
          this.ray = new N(a, b);
          this.near = c || 0;
          this.far = d || Infinity;
          this.camera = null;
          this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
          };
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function() {
                console.warn(
                  "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                );
                return this.Points;
              }
            }
          });
        }
        function Mg(a, b) {
          return a.distance - b.distance;
        }
        function Tf(a, b, c, d) {
          if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
            a = a.children;
            d = 0;
            for (var g = a.length; d < g; d++) Tf(a[d], b, c, !0);
          }
        }
        function Og(a, b, c) {
          this.radius = void 0 !== a ? a : 1;
          this.phi = void 0 !== b ? b : 0;
          this.theta = void 0 !== c ? c : 0;
          return this;
        }
        function Pg(a, b, c) {
          this.radius = void 0 !== a ? a : 1;
          this.theta = void 0 !== b ? b : 0;
          this.y = void 0 !== c ? c : 0;
          return this;
        }
        function Uf(a, b) {
          this.min = void 0 !== a ? a : new c(Infinity, Infinity);
          this.max = void 0 !== b ? b : new c(-Infinity, -Infinity);
        }
        function Vf(a, b) {
          this.start = void 0 !== a ? a : new h();
          this.end = void 0 !== b ? b : new h();
        }
        function Wj(a) {
          v.call(this);
          this.material = a;
          this.render = function() {};
        }
        function Xj(a, b, c, d) {
          this.object = a;
          this.size = void 0 !== b ? b : 1;
          a = void 0 !== c ? c : 16711680;
          d = void 0 !== d ? d : 1;
          b = 0;
          (c = this.object.geometry) && c.isGeometry
            ? (b = 3 * c.faces.length)
            : c && c.isBufferGeometry && (b = c.attributes.normal.count);
          c = new S();
          b = new P(6 * b, 3);
          c.addAttribute("position", b);
          Qa.call(this, c, new Ga({ color: a, linewidth: d }));
          this.matrixAutoUpdate = !1;
          this.update();
        }
        function Qi(a, b) {
          v.call(this);
          this.light = a;
          this.light.updateMatrixWorld();
          this.matrix = a.matrixWorld;
          this.matrixAutoUpdate = !1;
          this.color = b;
          a = new S();
          b = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
          ];
          for (var g = 0, c = 1; 32 > g; g++, c++) {
            var d = (g / 32) * Math.PI * 2,
              p = (c / 32) * Math.PI * 2;
            b.push(Math.cos(d), Math.sin(d), 1, Math.cos(p), Math.sin(p), 1);
          }
          a.addAttribute("position", new P(b, 3));
          b = new Ga({ fog: !1 });
          this.cone = new Qa(a, b);
          this.add(this.cone);
          this.update();
        }
        function Qg(a) {
          var b = [];
          a && a.isBone && b.push(a);
          for (var g = 0; g < a.children.length; g++)
            b.push.apply(b, Qg(a.children[g]));
          return b;
        }
        function Ri(a) {
          for (
            var b = Qg(a),
              g = new S(),
              c = [],
              d = [],
              e = new M(0, 0, 1),
              f = new M(0, 1, 0),
              h = 0;
            h < b.length;
            h++
          ) {
            var k = b[h];
            k.parent &&
              k.parent.isBone &&
              (c.push(0, 0, 0),
              c.push(0, 0, 0),
              d.push(e.r, e.g, e.b),
              d.push(f.r, f.g, f.b));
          }
          g.addAttribute("position", new P(c, 3));
          g.addAttribute("color", new P(d, 3));
          c = new Ga({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
          });
          Qa.call(this, g, c);
          this.root = a;
          this.bones = b;
          this.matrix = a.matrixWorld;
          this.matrixAutoUpdate = !1;
        }
        function Si(a, b, c) {
          this.light = a;
          this.light.updateMatrixWorld();
          this.color = c;
          a = new dg(b, 4, 2);
          b = new F({ wireframe: !0, fog: !1 });
          da.call(this, a, b);
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = !1;
          this.update();
        }
        function Ti(a, b) {
          this.type = "RectAreaLightHelper";
          this.light = a;
          this.color = b;
          a = new S();
          a.addAttribute(
            "position",
            new P([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)
          );
          a.computeBoundingSphere();
          b = new Ga({ fog: !1 });
          nb.call(this, a, b);
          a = new S();
          a.addAttribute(
            "position",
            new P(
              [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
              3
            )
          );
          a.computeBoundingSphere();
          this.add(new da(a, new F({ side: 1, fog: !1 })));
          this.update();
        }
        function Ui(a, b, c) {
          v.call(this);
          this.light = a;
          this.light.updateMatrixWorld();
          this.matrix = a.matrixWorld;
          this.matrixAutoUpdate = !1;
          this.color = c;
          a = new nh(b);
          a.rotateY(0.5 * Math.PI);
          this.material = new F({ wireframe: !0, fog: !1 });
          void 0 === this.color && (this.material.vertexColors = 2);
          b = a.getAttribute("position");
          b = new Float32Array(3 * b.count);
          a.addAttribute("color", new I(b, 3));
          this.add(new da(a, this.material));
          this.update();
        }
        function Vi(a, b) {
          this.lightProbe = a;
          this.size = b;
          a = new qa({
            defines: { GAMMA_OUTPUT: "" },
            uniforms: {
              sh: { value: this.lightProbe.sh.coefficients },
              intensity: { value: this.lightProbe.intensity }
            },
            vertexShader:
              "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader:
              "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
          });
          b = new dg(1, 32, 16);
          da.call(this, b, a);
          this.onBeforeRender();
        }
        function Ve(a, b, c, d) {
          a = a || 10;
          b = b || 10;
          c = new M(void 0 !== c ? c : 4473924);
          d = new M(void 0 !== d ? d : 8947848);
          var g = b / 2,
            p = a / b,
            e = a / 2;
          a = [];
          for (var f = [], h = 0, w = 0, x = -e; h <= b; h++, x += p) {
            a.push(-e, 0, x, e, 0, x);
            a.push(x, 0, -e, x, 0, e);
            var k = h === g ? c : d;
            k.toArray(f, w);
            w += 3;
            k.toArray(f, w);
            w += 3;
            k.toArray(f, w);
            w += 3;
            k.toArray(f, w);
            w += 3;
          }
          b = new S();
          b.addAttribute("position", new P(a, 3));
          b.addAttribute("color", new P(f, 3));
          c = new Ga({ vertexColors: 2 });
          Qa.call(this, b, c);
        }
        function We(a, b, c, d, e, f) {
          a = a || 10;
          b = b || 16;
          c = c || 8;
          d = d || 64;
          e = new M(void 0 !== e ? e : 4473924);
          f = new M(void 0 !== f ? f : 8947848);
          var g = [],
            p = [],
            h;
          for (h = 0; h <= b; h++) {
            var w = (h / b) * 2 * Math.PI;
            var x = Math.sin(w) * a;
            w = Math.cos(w) * a;
            g.push(0, 0, 0);
            g.push(x, 0, w);
            var k = h & 1 ? e : f;
            p.push(k.r, k.g, k.b);
            p.push(k.r, k.g, k.b);
          }
          for (h = 0; h <= c; h++) {
            k = h & 1 ? e : f;
            var l = a - (a / c) * h;
            for (b = 0; b < d; b++)
              (w = (b / d) * 2 * Math.PI),
                (x = Math.sin(w) * l),
                (w = Math.cos(w) * l),
                g.push(x, 0, w),
                p.push(k.r, k.g, k.b),
                (w = ((b + 1) / d) * 2 * Math.PI),
                (x = Math.sin(w) * l),
                (w = Math.cos(w) * l),
                g.push(x, 0, w),
                p.push(k.r, k.g, k.b);
          }
          a = new S();
          a.addAttribute("position", new P(g, 3));
          a.addAttribute("color", new P(p, 3));
          g = new Ga({ vertexColors: 2 });
          Qa.call(this, a, g);
        }
        function Wi(a, b, c, d) {
          this.audio = a;
          this.range = b || 1;
          this.divisionsInnerAngle = c || 16;
          this.divisionsOuterAngle = d || 2;
          a = new S();
          b = new Float32Array(
            3 *
              (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) +
                3)
          );
          a.addAttribute("position", new I(b, 3));
          b = new Ga({ color: 65280 });
          c = new Ga({ color: 16776960 });
          nb.call(this, a, [c, b]);
          this.update();
        }
        function Yj(a, b, c, d) {
          this.object = a;
          this.size = void 0 !== b ? b : 1;
          a = void 0 !== c ? c : 16776960;
          d = void 0 !== d ? d : 1;
          b = 0;
          (c = this.object.geometry) && c.isGeometry
            ? (b = c.faces.length)
            : console.warn(
                "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
              );
          c = new S();
          b = new P(6 * b, 3);
          c.addAttribute("position", b);
          Qa.call(this, c, new Ga({ color: a, linewidth: d }));
          this.matrixAutoUpdate = !1;
          this.update();
        }
        function Xi(a, b, c) {
          v.call(this);
          this.light = a;
          this.light.updateMatrixWorld();
          this.matrix = a.matrixWorld;
          this.matrixAutoUpdate = !1;
          this.color = c;
          void 0 === b && (b = 1);
          a = new S();
          a.addAttribute(
            "position",
            new P([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)
          );
          b = new Ga({ fog: !1 });
          this.lightPlane = new nb(a, b);
          this.add(this.lightPlane);
          a = new S();
          a.addAttribute("position", new P([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new nb(a, b);
          this.add(this.targetLine);
          this.update();
        }
        function Zj(a) {
          function b(a, b, c) {
            g(a, c);
            g(b, c);
          }
          function g(a, b) {
            e.push(0, 0, 0);
            f.push(b.r, b.g, b.b);
            void 0 === h[a] && (h[a] = []);
            h[a].push(e.length / 3 - 1);
          }
          var c = new S(),
            d = new Ga({ color: 16777215, vertexColors: 1 }),
            e = [],
            f = [],
            h = {},
            k = new M(16755200),
            l = new M(16711680),
            m = new M(43775),
            n = new M(16777215),
            q = new M(3355443);
          b("n1", "n2", k);
          b("n2", "n4", k);
          b("n4", "n3", k);
          b("n3", "n1", k);
          b("f1", "f2", k);
          b("f2", "f4", k);
          b("f4", "f3", k);
          b("f3", "f1", k);
          b("n1", "f1", k);
          b("n2", "f2", k);
          b("n3", "f3", k);
          b("n4", "f4", k);
          b("p", "n1", l);
          b("p", "n2", l);
          b("p", "n3", l);
          b("p", "n4", l);
          b("u1", "u2", m);
          b("u2", "u3", m);
          b("u3", "u1", m);
          b("c", "t", n);
          b("p", "c", q);
          b("cn1", "cn2", q);
          b("cn3", "cn4", q);
          b("cf1", "cf2", q);
          b("cf3", "cf4", q);
          c.addAttribute("position", new P(e, 3));
          c.addAttribute("color", new P(f, 3));
          Qa.call(this, c, d);
          this.camera = a;
          this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix();
          this.matrix = a.matrixWorld;
          this.matrixAutoUpdate = !1;
          this.pointMap = h;
          this.update();
        }
        function fb(a, b, c, d, e, f, h) {
          pk.set(e, f, h).unproject(d);
          a = b[a];
          if (void 0 !== a)
            for (
              c = c.getAttribute("position"), b = 0, d = a.length;
              b < d;
              b++
            )
              c.setXYZ(a[b], pk.x, pk.y, pk.z);
        }
        function kf(a, b) {
          this.object = a;
          void 0 === b && (b = 16776960);
          a = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
          ]);
          var g = new Float32Array(24),
            c = new S();
          c.setIndex(new I(a, 1));
          c.addAttribute("position", new I(g, 3));
          Qa.call(this, c, new Ga({ color: b }));
          this.matrixAutoUpdate = !1;
          this.update();
        }
        function ak(a, b) {
          this.type = "Box3Helper";
          this.box = a;
          b = b || 16776960;
          a = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
          ]);
          var g = new S();
          g.setIndex(new I(a, 1));
          g.addAttribute(
            "position",
            new P(
              [
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                -1
              ],
              3
            )
          );
          Qa.call(this, g, new Ga({ color: b }));
          this.geometry.computeBoundingSphere();
        }
        function bk(a, b, c) {
          this.type = "PlaneHelper";
          this.plane = a;
          this.size = void 0 === b ? 1 : b;
          a = void 0 !== c ? c : 16776960;
          b = new S();
          b.addAttribute(
            "position",
            new P(
              [
                1,
                -1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                1,
                0,
                0,
                1,
                0,
                0,
                0
              ],
              3
            )
          );
          b.computeBoundingSphere();
          nb.call(this, b, new Ga({ color: a }));
          b = new S();
          b.addAttribute(
            "position",
            new P(
              [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
              3
            )
          );
          b.computeBoundingSphere();
          this.add(
            new da(
              b,
              new F({ color: a, opacity: 0.2, transparent: !0, depthWrite: !1 })
            )
          );
        }
        function lf(a, b, c, d, e, f) {
          v.call(this);
          void 0 === a && (a = new h(0, 0, 1));
          void 0 === b && (b = new h(0, 0, 0));
          void 0 === c && (c = 1);
          void 0 === d && (d = 16776960);
          void 0 === e && (e = 0.2 * c);
          void 0 === f && (f = 0.2 * e);
          void 0 === qk &&
            ((qk = new S()),
            qk.addAttribute("position", new P([0, 0, 0, 0, 1, 0], 3)),
            (Nh = new hf(0, 0.5, 1, 5, 1)),
            Nh.translate(0, -0.5, 0));
          this.position.copy(b);
          this.line = new nb(qk, new Ga({ color: d }));
          this.line.matrixAutoUpdate = !1;
          this.add(this.line);
          this.cone = new da(Nh, new F({ color: d }));
          this.cone.matrixAutoUpdate = !1;
          this.add(this.cone);
          this.setDirection(a);
          this.setLength(c, e, f);
        }
        function ck(a) {
          a = a || 1;
          var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
          a = new S();
          a.addAttribute("position", new P(b, 3));
          a.addAttribute(
            "color",
            new P(
              [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
              3
            )
          );
          b = new Ga({ vertexColors: 2 });
          Qa.call(this, a, b);
        }
        function Rg(a) {
          console.warn(
            "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
          );
          sb.call(this, a);
          this.type = "catmullrom";
          this.closed = !0;
        }
        function Sg(a) {
          console.warn(
            "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
          );
          sb.call(this, a);
          this.type = "catmullrom";
        }
        function Wf(a) {
          console.warn(
            "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
          );
          sb.call(this, a);
          this.type = "catmullrom";
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
        void 0 === Number.isInteger &&
          (Number.isInteger = function(a) {
            return "number" === typeof a && isFinite(a) && Math.floor(a) === a;
          });
        void 0 === Math.sign &&
          (Math.sign = function(a) {
            return 0 > a ? -1 : 0 < a ? 1 : +a;
          });
        !1 === "name" in Function.prototype &&
          Object.defineProperty(Function.prototype, "name", {
            get: function() {
              return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }
          });
        void 0 === Object.assign &&
          (Object.assign = function(a) {
            if (void 0 === a || null === a)
              throw new TypeError("Cannot convert undefined or null to object");
            for (var b = Object(a), g = 1; g < arguments.length; g++) {
              var c = arguments[g];
              if (void 0 !== c && null !== c)
                for (var d in c)
                  Object.prototype.hasOwnProperty.call(c, d) && (b[d] = c[d]);
            }
            return b;
          });
        Object.assign(b.prototype, {
          addEventListener: function(a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var g = this._listeners;
            void 0 === g[a] && (g[a] = []);
            -1 === g[a].indexOf(b) && g[a].push(b);
          },
          hasEventListener: function(a, b) {
            if (void 0 === this._listeners) return !1;
            var g = this._listeners;
            return void 0 !== g[a] && -1 !== g[a].indexOf(b);
          },
          removeEventListener: function(a, b) {
            void 0 !== this._listeners &&
              ((a = this._listeners[a]),
              void 0 !== a && ((b = a.indexOf(b)), -1 !== b && a.splice(b, 1)));
          },
          dispatchEvent: function(a) {
            if (void 0 !== this._listeners) {
              var b = this._listeners[a.type];
              if (void 0 !== b) {
                a.target = this;
                b = b.slice(0);
                for (var g = 0, c = b.length; g < c; g++) b[g].call(this, a);
              }
            }
          }
        });
        for (var qb = [], dk = 0; 256 > dk; dk++)
          qb[dk] = (16 > dk ? "0" : "") + dk.toString(16);
        var ya = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: function() {
            var a = (4294967295 * Math.random()) | 0,
              b = (4294967295 * Math.random()) | 0,
              c = (4294967295 * Math.random()) | 0,
              d = (4294967295 * Math.random()) | 0;
            return (
              qb[a & 255] +
              qb[(a >> 8) & 255] +
              qb[(a >> 16) & 255] +
              qb[(a >> 24) & 255] +
              "-" +
              qb[b & 255] +
              qb[(b >> 8) & 255] +
              "-" +
              qb[((b >> 16) & 15) | 64] +
              qb[(b >> 24) & 255] +
              "-" +
              qb[(c & 63) | 128] +
              qb[(c >> 8) & 255] +
              "-" +
              qb[(c >> 16) & 255] +
              qb[(c >> 24) & 255] +
              qb[d & 255] +
              qb[(d >> 8) & 255] +
              qb[(d >> 16) & 255] +
              qb[(d >> 24) & 255]
            ).toUpperCase();
          },
          clamp: function(a, b, c) {
            return Math.max(b, Math.min(c, a));
          },
          euclideanModulo: function(a, b) {
            return ((a % b) + b) % b;
          },
          mapLinear: function(a, b, c, d, e) {
            return d + ((a - b) * (e - d)) / (c - b);
          },
          lerp: function(a, b, c) {
            return (1 - c) * a + c * b;
          },
          smoothstep: function(a, b, c) {
            if (a <= b) return 0;
            if (a >= c) return 1;
            a = (a - b) / (c - b);
            return a * a * (3 - 2 * a);
          },
          smootherstep: function(a, b, c) {
            if (a <= b) return 0;
            if (a >= c) return 1;
            a = (a - b) / (c - b);
            return a * a * a * (a * (6 * a - 15) + 10);
          },
          randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1));
          },
          randFloat: function(a, b) {
            return a + Math.random() * (b - a);
          },
          randFloatSpread: function(a) {
            return a * (0.5 - Math.random());
          },
          degToRad: function(a) {
            return a * ya.DEG2RAD;
          },
          radToDeg: function(a) {
            return a * ya.RAD2DEG;
          },
          isPowerOfTwo: function(a) {
            return 0 === (a & (a - 1)) && 0 !== a;
          },
          ceilPowerOfTwo: function(a) {
            return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
          },
          floorPowerOfTwo: function(a) {
            return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
          }
        };
        Object.defineProperties(c.prototype, {
          width: {
            get: function() {
              return this.x;
            },
            set: function(a) {
              this.x = a;
            }
          },
          height: {
            get: function() {
              return this.y;
            },
            set: function(a) {
              this.y = a;
            }
          }
        });
        Object.assign(c.prototype, {
          isVector2: !0,
          set: function(a, b) {
            this.x = a;
            this.y = b;
            return this;
          },
          setScalar: function(a) {
            this.y = this.x = a;
            return this;
          },
          setX: function(a) {
            this.x = a;
            return this;
          },
          setY: function(a) {
            this.y = a;
            return this;
          },
          setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;
              case 1:
                this.y = b;
                break;
              default:
                throw Error("index is out of range: " + a);
            }
            return this;
          },
          getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw Error("index is out of range: " + a);
            }
          },
          clone: function() {
            return new this.constructor(this.x, this.y);
          },
          copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            return this;
          },
          add: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(a, b)
              );
            this.x += a.x;
            this.y += a.y;
            return this;
          },
          addScalar: function(a) {
            this.x += a;
            this.y += a;
            return this;
          },
          addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
          },
          addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            return this;
          },
          sub: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(a, b)
              );
            this.x -= a.x;
            this.y -= a.y;
            return this;
          },
          subScalar: function(a) {
            this.x -= a;
            this.y -= a;
            return this;
          },
          subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
          },
          multiply: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            return this;
          },
          multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            return this;
          },
          divide: function(a) {
            this.x /= a.x;
            this.y /= a.y;
            return this;
          },
          divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
          },
          applyMatrix3: function(a) {
            var b = this.x,
              g = this.y;
            a = a.elements;
            this.x = a[0] * b + a[3] * g + a[6];
            this.y = a[1] * b + a[4] * g + a[7];
            return this;
          },
          min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            return this;
          },
          max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            return this;
          },
          clamp: function(a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            return this;
          },
          clampScalar: function(a, b) {
            this.x = Math.max(a, Math.min(b, this.x));
            this.y = Math.max(a, Math.min(b, this.y));
            return this;
          },
          clampLength: function(a, b) {
            var g = this.length();
            return this.divideScalar(g || 1).multiplyScalar(
              Math.max(a, Math.min(b, g))
            );
          },
          floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
          },
          dot: function(a) {
            return this.x * a.x + this.y * a.y;
          },
          cross: function(a) {
            return this.x * a.y - this.y * a.x;
          },
          lengthSq: function() {
            return this.x * this.x + this.y * this.y;
          },
          length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y);
          },
          normalize: function() {
            return this.divideScalar(this.length() || 1);
          },
          angle: function() {
            var a = Math.atan2(this.y, this.x);
            0 > a && (a += 2 * Math.PI);
            return a;
          },
          distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a));
          },
          distanceToSquared: function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return b * b + a * a;
          },
          manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
          },
          setLength: function(a) {
            return this.normalize().multiplyScalar(a);
          },
          lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            return this;
          },
          lerpVectors: function(a, b, c) {
            return this.subVectors(b, a)
              .multiplyScalar(c)
              .add(a);
          },
          equals: function(a) {
            return a.x === this.x && a.y === this.y;
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            return a;
          },
          fromBufferAttribute: function(a, b, c) {
            void 0 !== c &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              );
            this.x = a.getX(b);
            this.y = a.getY(b);
            return this;
          },
          rotateAround: function(a, b) {
            var g = Math.cos(b);
            b = Math.sin(b);
            var c = this.x - a.x,
              d = this.y - a.y;
            this.x = c * g - d * b + a.x;
            this.y = c * b + d * g + a.y;
            return this;
          }
        });
        Object.assign(f, {
          slerp: function(a, b, c, d) {
            return c.copy(a).slerp(b, d);
          },
          slerpFlat: function(a, b, c, d, e, f, h) {
            var g = c[d + 0],
              p = c[d + 1],
              w = c[d + 2];
            c = c[d + 3];
            d = e[f + 0];
            var x = e[f + 1],
              k = e[f + 2];
            e = e[f + 3];
            if (c !== e || g !== d || p !== x || w !== k) {
              f = 1 - h;
              var l = g * d + p * x + w * k + c * e,
                K = 0 <= l ? 1 : -1,
                m = 1 - l * l;
              m > Number.EPSILON &&
                ((m = Math.sqrt(m)),
                (l = Math.atan2(m, l * K)),
                (f = Math.sin(f * l) / m),
                (h = Math.sin(h * l) / m));
              K *= h;
              g = g * f + d * K;
              p = p * f + x * K;
              w = w * f + k * K;
              c = c * f + e * K;
              f === 1 - h &&
                ((h = 1 / Math.sqrt(g * g + p * p + w * w + c * c)),
                (g *= h),
                (p *= h),
                (w *= h),
                (c *= h));
            }
            a[b] = g;
            a[b + 1] = p;
            a[b + 2] = w;
            a[b + 3] = c;
          }
        });
        Object.defineProperties(f.prototype, {
          x: {
            get: function() {
              return this._x;
            },
            set: function(a) {
              this._x = a;
              this._onChangeCallback();
            }
          },
          y: {
            get: function() {
              return this._y;
            },
            set: function(a) {
              this._y = a;
              this._onChangeCallback();
            }
          },
          z: {
            get: function() {
              return this._z;
            },
            set: function(a) {
              this._z = a;
              this._onChangeCallback();
            }
          },
          w: {
            get: function() {
              return this._w;
            },
            set: function(a) {
              this._w = a;
              this._onChangeCallback();
            }
          }
        });
        Object.assign(f.prototype, {
          isQuaternion: !0,
          set: function(a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z = c;
            this._w = d;
            this._onChangeCallback();
            return this;
          },
          clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          },
          copy: function(a) {
            this._x = a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = a.w;
            this._onChangeCallback();
            return this;
          },
          setFromEuler: function(a, b) {
            if (!a || !a.isEuler)
              throw Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            var g = a._x,
              c = a._y,
              d = a._z;
            a = a.order;
            var p = Math.cos,
              e = Math.sin,
              f = p(g / 2),
              h = p(c / 2);
            p = p(d / 2);
            g = e(g / 2);
            c = e(c / 2);
            d = e(d / 2);
            "XYZ" === a
              ? ((this._x = g * h * p + f * c * d),
                (this._y = f * c * p - g * h * d),
                (this._z = f * h * d + g * c * p),
                (this._w = f * h * p - g * c * d))
              : "YXZ" === a
              ? ((this._x = g * h * p + f * c * d),
                (this._y = f * c * p - g * h * d),
                (this._z = f * h * d - g * c * p),
                (this._w = f * h * p + g * c * d))
              : "ZXY" === a
              ? ((this._x = g * h * p - f * c * d),
                (this._y = f * c * p + g * h * d),
                (this._z = f * h * d + g * c * p),
                (this._w = f * h * p - g * c * d))
              : "ZYX" === a
              ? ((this._x = g * h * p - f * c * d),
                (this._y = f * c * p + g * h * d),
                (this._z = f * h * d - g * c * p),
                (this._w = f * h * p + g * c * d))
              : "YZX" === a
              ? ((this._x = g * h * p + f * c * d),
                (this._y = f * c * p + g * h * d),
                (this._z = f * h * d - g * c * p),
                (this._w = f * h * p - g * c * d))
              : "XZY" === a &&
                ((this._x = g * h * p - f * c * d),
                (this._y = f * c * p - g * h * d),
                (this._z = f * h * d + g * c * p),
                (this._w = f * h * p + g * c * d));
            !1 !== b && this._onChangeCallback();
            return this;
          },
          setFromAxisAngle: function(a, b) {
            b /= 2;
            var g = Math.sin(b);
            this._x = a.x * g;
            this._y = a.y * g;
            this._z = a.z * g;
            this._w = Math.cos(b);
            this._onChangeCallback();
            return this;
          },
          setFromRotationMatrix: function(a) {
            var b = a.elements,
              g = b[0];
            a = b[4];
            var c = b[8],
              d = b[1],
              e = b[5],
              f = b[9],
              h = b[2],
              k = b[6];
            b = b[10];
            var l = g + e + b;
            0 < l
              ? ((g = 0.5 / Math.sqrt(l + 1)),
                (this._w = 0.25 / g),
                (this._x = (k - f) * g),
                (this._y = (c - h) * g),
                (this._z = (d - a) * g))
              : g > e && g > b
              ? ((g = 2 * Math.sqrt(1 + g - e - b)),
                (this._w = (k - f) / g),
                (this._x = 0.25 * g),
                (this._y = (a + d) / g),
                (this._z = (c + h) / g))
              : e > b
              ? ((g = 2 * Math.sqrt(1 + e - g - b)),
                (this._w = (c - h) / g),
                (this._x = (a + d) / g),
                (this._y = 0.25 * g),
                (this._z = (f + k) / g))
              : ((g = 2 * Math.sqrt(1 + b - g - e)),
                (this._w = (d - a) / g),
                (this._x = (c + h) / g),
                (this._y = (f + k) / g),
                (this._z = 0.25 * g));
            this._onChangeCallback();
            return this;
          },
          setFromUnitVectors: function(a, b) {
            var g = a.dot(b) + 1;
            1e-6 > g
              ? ((g = 0),
                Math.abs(a.x) > Math.abs(a.z)
                  ? ((this._x = -a.y), (this._y = a.x), (this._z = 0))
                  : ((this._x = 0), (this._y = -a.z), (this._z = a.y)))
              : ((this._x = a.y * b.z - a.z * b.y),
                (this._y = a.z * b.x - a.x * b.z),
                (this._z = a.x * b.y - a.y * b.x));
            this._w = g;
            return this.normalize();
          },
          angleTo: function(a) {
            return 2 * Math.acos(Math.abs(ya.clamp(this.dot(a), -1, 1)));
          },
          rotateTowards: function(a, b) {
            var g = this.angleTo(a);
            if (0 === g) return this;
            this.slerp(a, Math.min(1, b / g));
            return this;
          },
          inverse: function() {
            return this.conjugate();
          },
          conjugate: function() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this._onChangeCallback();
            return this;
          },
          dot: function(a) {
            return (
              this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
            );
          },
          lengthSq: function() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          },
          length: function() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          },
          normalize: function() {
            var a = this.length();
            0 === a
              ? ((this._z = this._y = this._x = 0), (this._w = 1))
              : ((a = 1 / a),
                (this._x *= a),
                (this._y *= a),
                (this._z *= a),
                (this._w *= a));
            this._onChangeCallback();
            return this;
          },
          multiply: function(a, b) {
            return void 0 !== b
              ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                ),
                this.multiplyQuaternions(a, b))
              : this.multiplyQuaternions(this, a);
          },
          premultiply: function(a) {
            return this.multiplyQuaternions(a, this);
          },
          multiplyQuaternions: function(a, b) {
            var g = a._x,
              c = a._y,
              d = a._z;
            a = a._w;
            var p = b._x,
              e = b._y,
              f = b._z;
            b = b._w;
            this._x = g * b + a * p + c * f - d * e;
            this._y = c * b + a * e + d * p - g * f;
            this._z = d * b + a * f + g * e - c * p;
            this._w = a * b - g * p - c * e - d * f;
            this._onChangeCallback();
            return this;
          },
          slerp: function(a, b) {
            if (0 === b) return this;
            if (1 === b) return this.copy(a);
            var g = this._x,
              c = this._y,
              d = this._z,
              p = this._w,
              e = p * a._w + g * a._x + c * a._y + d * a._z;
            0 > e
              ? ((this._w = -a._w),
                (this._x = -a._x),
                (this._y = -a._y),
                (this._z = -a._z),
                (e = -e))
              : this.copy(a);
            if (1 <= e)
              return (
                (this._w = p), (this._x = g), (this._y = c), (this._z = d), this
              );
            a = 1 - e * e;
            if (a <= Number.EPSILON)
              return (
                (e = 1 - b),
                (this._w = e * p + b * this._w),
                (this._x = e * g + b * this._x),
                (this._y = e * c + b * this._y),
                (this._z = e * d + b * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            a = Math.sqrt(a);
            var f = Math.atan2(a, e);
            e = Math.sin((1 - b) * f) / a;
            b = Math.sin(b * f) / a;
            this._w = p * e + this._w * b;
            this._x = g * e + this._x * b;
            this._y = c * e + this._y * b;
            this._z = d * e + this._z * b;
            this._onChangeCallback();
            return this;
          },
          equals: function(a) {
            return (
              a._x === this._x &&
              a._y === this._y &&
              a._z === this._z &&
              a._w === this._w
            );
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this._x = a[b];
            this._y = a[b + 1];
            this._z = a[b + 2];
            this._w = a[b + 3];
            this._onChangeCallback();
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._w;
            return a;
          },
          _onChange: function(a) {
            this._onChangeCallback = a;
            return this;
          },
          _onChangeCallback: function() {}
        });
        var Xf = new h(),
          Ug = new f();
        Object.assign(h.prototype, {
          isVector3: !0,
          set: function(a, b, c) {
            this.x = a;
            this.y = b;
            this.z = c;
            return this;
          },
          setScalar: function(a) {
            this.z = this.y = this.x = a;
            return this;
          },
          setX: function(a) {
            this.x = a;
            return this;
          },
          setY: function(a) {
            this.y = a;
            return this;
          },
          setZ: function(a) {
            this.z = a;
            return this;
          },
          setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;
              case 1:
                this.y = b;
                break;
              case 2:
                this.z = b;
                break;
              default:
                throw Error("index is out of range: " + a);
            }
            return this;
          },
          getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw Error("index is out of range: " + a);
            }
          },
          clone: function() {
            return new this.constructor(this.x, this.y, this.z);
          },
          copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this;
          },
          add: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(a, b)
              );
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this;
          },
          addScalar: function(a) {
            this.x += a;
            this.y += a;
            this.z += a;
            return this;
          },
          addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
          },
          addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z += a.z * b;
            return this;
          },
          sub: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(a, b)
              );
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this;
          },
          subScalar: function(a) {
            this.x -= a;
            this.y -= a;
            this.z -= a;
            return this;
          },
          subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
          },
          multiply: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                ),
                this.multiplyVectors(a, b)
              );
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this;
          },
          multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            return this;
          },
          multiplyVectors: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
          },
          applyEuler: function(a) {
            (a && a.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            return this.applyQuaternion(Ug.setFromEuler(a));
          },
          applyAxisAngle: function(a, b) {
            return this.applyQuaternion(Ug.setFromAxisAngle(a, b));
          },
          applyMatrix3: function(a) {
            var b = this.x,
              g = this.y,
              c = this.z;
            a = a.elements;
            this.x = a[0] * b + a[3] * g + a[6] * c;
            this.y = a[1] * b + a[4] * g + a[7] * c;
            this.z = a[2] * b + a[5] * g + a[8] * c;
            return this;
          },
          applyMatrix4: function(a) {
            var b = this.x,
              g = this.y,
              c = this.z;
            a = a.elements;
            var d = 1 / (a[3] * b + a[7] * g + a[11] * c + a[15]);
            this.x = (a[0] * b + a[4] * g + a[8] * c + a[12]) * d;
            this.y = (a[1] * b + a[5] * g + a[9] * c + a[13]) * d;
            this.z = (a[2] * b + a[6] * g + a[10] * c + a[14]) * d;
            return this;
          },
          applyQuaternion: function(a) {
            var b = this.x,
              g = this.y,
              c = this.z,
              d = a.x,
              e = a.y,
              f = a.z;
            a = a.w;
            var h = a * b + e * c - f * g,
              k = a * g + f * b - d * c,
              l = a * c + d * g - e * b;
            b = -d * b - e * g - f * c;
            this.x = h * a + b * -d + k * -f - l * -e;
            this.y = k * a + b * -e + l * -d - h * -f;
            this.z = l * a + b * -f + h * -e - k * -d;
            return this;
          },
          project: function(a) {
            return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(
              a.projectionMatrix
            );
          },
          unproject: function(a) {
            return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(
              a.matrixWorld
            );
          },
          transformDirection: function(a) {
            var b = this.x,
              g = this.y,
              c = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * g + a[8] * c;
            this.y = a[1] * b + a[5] * g + a[9] * c;
            this.z = a[2] * b + a[6] * g + a[10] * c;
            return this.normalize();
          },
          divide: function(a) {
            this.x /= a.x;
            this.y /= a.y;
            this.z /= a.z;
            return this;
          },
          divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
          },
          min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            this.z = Math.min(this.z, a.z);
            return this;
          },
          max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            return this;
          },
          clamp: function(a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            return this;
          },
          clampScalar: function(a, b) {
            this.x = Math.max(a, Math.min(b, this.x));
            this.y = Math.max(a, Math.min(b, this.y));
            this.z = Math.max(a, Math.min(b, this.z));
            return this;
          },
          clampLength: function(a, b) {
            var g = this.length();
            return this.divideScalar(g || 1).multiplyScalar(
              Math.max(a, Math.min(b, g))
            );
          },
          floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
          },
          ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
          },
          round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
          },
          roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
          },
          dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
          },
          lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          },
          length: function() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          },
          manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          },
          normalize: function() {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function(a) {
            return this.normalize().multiplyScalar(a);
          },
          lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            return this;
          },
          lerpVectors: function(a, b, c) {
            return this.subVectors(b, a)
              .multiplyScalar(c)
              .add(a);
          },
          cross: function(a, b) {
            return void 0 !== b
              ? (console.warn(
                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                ),
                this.crossVectors(a, b))
              : this.crossVectors(this, a);
          },
          crossVectors: function(a, b) {
            var g = a.x,
              c = a.y;
            a = a.z;
            var d = b.x,
              p = b.y;
            b = b.z;
            this.x = c * b - a * p;
            this.y = a * d - g * b;
            this.z = g * p - c * d;
            return this;
          },
          projectOnVector: function(a) {
            var b = a.dot(this) / a.lengthSq();
            return this.copy(a).multiplyScalar(b);
          },
          projectOnPlane: function(a) {
            Xf.copy(this).projectOnVector(a);
            return this.sub(Xf);
          },
          reflect: function(a) {
            return this.sub(Xf.copy(a).multiplyScalar(2 * this.dot(a)));
          },
          angleTo: function(a) {
            var b = Math.sqrt(this.lengthSq() * a.lengthSq());
            0 === b &&
              console.error(
                "THREE.Vector3: angleTo() can't handle zero length vectors."
              );
            a = this.dot(a) / b;
            return Math.acos(ya.clamp(a, -1, 1));
          },
          distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a));
          },
          distanceToSquared: function(a) {
            var b = this.x - a.x,
              g = this.y - a.y;
            a = this.z - a.z;
            return b * b + g * g + a * a;
          },
          manhattanDistanceTo: function(a) {
            return (
              Math.abs(this.x - a.x) +
              Math.abs(this.y - a.y) +
              Math.abs(this.z - a.z)
            );
          },
          setFromSpherical: function(a) {
            return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
          },
          setFromSphericalCoords: function(a, b, c) {
            var g = Math.sin(b) * a;
            this.x = g * Math.sin(c);
            this.y = Math.cos(b) * a;
            this.z = g * Math.cos(c);
            return this;
          },
          setFromCylindrical: function(a) {
            return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
          },
          setFromCylindricalCoords: function(a, b, c) {
            this.x = a * Math.sin(b);
            this.y = c;
            this.z = a * Math.cos(b);
            return this;
          },
          setFromMatrixPosition: function(a) {
            a = a.elements;
            this.x = a[12];
            this.y = a[13];
            this.z = a[14];
            return this;
          },
          setFromMatrixScale: function(a) {
            var b = this.setFromMatrixColumn(a, 0).length(),
              g = this.setFromMatrixColumn(a, 1).length();
            a = this.setFromMatrixColumn(a, 2).length();
            this.x = b;
            this.y = g;
            this.z = a;
            return this;
          },
          setFromMatrixColumn: function(a, b) {
            return this.fromArray(a.elements, 4 * b);
          },
          equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z;
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            return a;
          },
          fromBufferAttribute: function(a, b, c) {
            void 0 !== c &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              );
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            return this;
          }
        });
        var Bh = new h();
        Object.assign(k.prototype, {
          isMatrix3: !0,
          set: function(a, b, c, d, e, f, h, k, l) {
            var g = this.elements;
            g[0] = a;
            g[1] = d;
            g[2] = h;
            g[3] = b;
            g[4] = e;
            g[5] = k;
            g[6] = c;
            g[7] = f;
            g[8] = l;
            return this;
          },
          identity: function() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
          },
          clone: function() {
            return new this.constructor().fromArray(this.elements);
          },
          copy: function(a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this;
          },
          setFromMatrix4: function(a) {
            a = a.elements;
            this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
            return this;
          },
          applyToBufferAttribute: function(a) {
            for (var b = 0, g = a.count; b < g; b++)
              (Bh.x = a.getX(b)),
                (Bh.y = a.getY(b)),
                (Bh.z = a.getZ(b)),
                Bh.applyMatrix3(this),
                a.setXYZ(b, Bh.x, Bh.y, Bh.z);
            return a;
          },
          multiply: function(a) {
            return this.multiplyMatrices(this, a);
          },
          premultiply: function(a) {
            return this.multiplyMatrices(a, this);
          },
          multiplyMatrices: function(a, b) {
            var g = a.elements,
              c = b.elements;
            b = this.elements;
            a = g[0];
            var d = g[3],
              p = g[6],
              e = g[1],
              f = g[4],
              h = g[7],
              k = g[2],
              l = g[5];
            g = g[8];
            var m = c[0],
              n = c[3],
              q = c[6],
              t = c[1],
              u = c[4],
              r = c[7],
              y = c[2],
              v = c[5];
            c = c[8];
            b[0] = a * m + d * t + p * y;
            b[3] = a * n + d * u + p * v;
            b[6] = a * q + d * r + p * c;
            b[1] = e * m + f * t + h * y;
            b[4] = e * n + f * u + h * v;
            b[7] = e * q + f * r + h * c;
            b[2] = k * m + l * t + g * y;
            b[5] = k * n + l * u + g * v;
            b[8] = k * q + l * r + g * c;
            return this;
          },
          multiplyScalar: function(a) {
            var b = this.elements;
            b[0] *= a;
            b[3] *= a;
            b[6] *= a;
            b[1] *= a;
            b[4] *= a;
            b[7] *= a;
            b[2] *= a;
            b[5] *= a;
            b[8] *= a;
            return this;
          },
          determinant: function() {
            var a = this.elements,
              b = a[0],
              c = a[1],
              d = a[2],
              e = a[3],
              f = a[4],
              h = a[5],
              k = a[6],
              l = a[7];
            a = a[8];
            return (
              b * f * a -
              b * h * l -
              c * e * a +
              c * h * k +
              d * e * l -
              d * f * k
            );
          },
          getInverse: function(a, b) {
            a &&
              a.isMatrix4 &&
              console.error(
                "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
              );
            var g = a.elements;
            a = this.elements;
            var c = g[0],
              d = g[1],
              p = g[2],
              e = g[3],
              f = g[4],
              h = g[5],
              k = g[6],
              l = g[7];
            g = g[8];
            var m = g * f - h * l,
              n = h * k - g * e,
              q = l * e - f * k,
              t = c * m + d * n + p * q;
            if (0 === t) {
              if (!0 === b)
                throw Error(
                  "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
                );
              console.warn(
                "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
              );
              return this.identity();
            }
            b = 1 / t;
            a[0] = m * b;
            a[1] = (p * l - g * d) * b;
            a[2] = (h * d - p * f) * b;
            a[3] = n * b;
            a[4] = (g * c - p * k) * b;
            a[5] = (p * e - h * c) * b;
            a[6] = q * b;
            a[7] = (d * k - l * c) * b;
            a[8] = (f * c - d * e) * b;
            return this;
          },
          transpose: function() {
            var a = this.elements;
            var b = a[1];
            a[1] = a[3];
            a[3] = b;
            b = a[2];
            a[2] = a[6];
            a[6] = b;
            b = a[5];
            a[5] = a[7];
            a[7] = b;
            return this;
          },
          getNormalMatrix: function(a) {
            return this.setFromMatrix4(a)
              .getInverse(this)
              .transpose();
          },
          transposeIntoArray: function(a) {
            var b = this.elements;
            a[0] = b[0];
            a[1] = b[3];
            a[2] = b[6];
            a[3] = b[1];
            a[4] = b[4];
            a[5] = b[7];
            a[6] = b[2];
            a[7] = b[5];
            a[8] = b[8];
            return this;
          },
          setUvTransform: function(a, b, c, d, e, f, h) {
            var g = Math.cos(e);
            e = Math.sin(e);
            this.set(
              c * g,
              c * e,
              -c * (g * f + e * h) + f + a,
              -d * e,
              d * g,
              -d * (-e * f + g * h) + h + b,
              0,
              0,
              1
            );
          },
          scale: function(a, b) {
            var g = this.elements;
            g[0] *= a;
            g[3] *= a;
            g[6] *= a;
            g[1] *= b;
            g[4] *= b;
            g[7] *= b;
            return this;
          },
          rotate: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            var g = this.elements,
              c = g[0],
              d = g[3],
              e = g[6],
              f = g[1],
              h = g[4],
              k = g[7];
            g[0] = b * c + a * f;
            g[3] = b * d + a * h;
            g[6] = b * e + a * k;
            g[1] = -a * c + b * f;
            g[4] = -a * d + b * h;
            g[7] = -a * e + b * k;
            return this;
          },
          translate: function(a, b) {
            var g = this.elements;
            g[0] += a * g[2];
            g[3] += a * g[5];
            g[6] += a * g[8];
            g[1] += b * g[2];
            g[4] += b * g[5];
            g[7] += b * g[8];
            return this;
          },
          equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var g = 0; 9 > g; g++) if (b[g] !== a[g]) return !1;
            return !0;
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var g = 0; 9 > g; g++) this.elements[g] = a[g + b];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var g = this.elements;
            a[b] = g[0];
            a[b + 1] = g[1];
            a[b + 2] = g[2];
            a[b + 3] = g[3];
            a[b + 4] = g[4];
            a[b + 5] = g[5];
            a[b + 6] = g[6];
            a[b + 7] = g[7];
            a[b + 8] = g[8];
            return a;
          }
        });
        var Yi,
          fg = {
            getDataURL: function(a) {
              if ("undefined" == typeof HTMLCanvasElement) return a.src;
              if (!(a instanceof HTMLCanvasElement)) {
                void 0 === Yi &&
                  (Yi = document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "canvas"
                  ));
                Yi.width = a.width;
                Yi.height = a.height;
                var b = Yi.getContext("2d");
                a instanceof ImageData
                  ? b.putImageData(a, 0, 0)
                  : b.drawImage(a, 0, 0, a.width, a.height);
                a = Yi;
              }
              return 2048 < a.width || 2048 < a.height
                ? a.toDataURL("image/jpeg", 0.6)
                : a.toDataURL("image/png");
            }
          },
          ji = 0;
        l.DEFAULT_IMAGE = void 0;
        l.DEFAULT_MAPPING = 300;
        l.prototype = Object.assign(Object.create(b.prototype), {
          constructor: l,
          isTexture: !0,
          updateMatrix: function() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.name = a.name;
            this.image = a.image;
            this.mipmaps = a.mipmaps.slice(0);
            this.mapping = a.mapping;
            this.wrapS = a.wrapS;
            this.wrapT = a.wrapT;
            this.magFilter = a.magFilter;
            this.minFilter = a.minFilter;
            this.anisotropy = a.anisotropy;
            this.format = a.format;
            this.type = a.type;
            this.offset.copy(a.offset);
            this.repeat.copy(a.repeat);
            this.center.copy(a.center);
            this.rotation = a.rotation;
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrix.copy(a.matrix);
            this.generateMipmaps = a.generateMipmaps;
            this.premultiplyAlpha = a.premultiplyAlpha;
            this.flipY = a.flipY;
            this.unpackAlignment = a.unpackAlignment;
            this.encoding = a.encoding;
            return this;
          },
          toJSON: function(a) {
            var b = void 0 === a || "string" === typeof a;
            if (!b && void 0 !== a.textures[this.uuid])
              return a.textures[this.uuid];
            var g = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
              var c = this.image;
              void 0 === c.uuid && (c.uuid = ya.generateUUID());
              if (!b && void 0 === a.images[c.uuid]) {
                if (Array.isArray(c)) {
                  var d = [];
                  for (var e = 0, f = c.length; e < f; e++)
                    d.push(fg.getDataURL(c[e]));
                } else d = fg.getDataURL(c);
                a.images[c.uuid] = { uuid: c.uuid, url: d };
              }
              g.image = c.uuid;
            }
            b || (a.textures[this.uuid] = g);
            return g;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          },
          transformUv: function(a) {
            if (300 !== this.mapping) return a;
            a.applyMatrix3(this.matrix);
            if (0 > a.x || 1 < a.x)
              switch (this.wrapS) {
                case 1e3:
                  a.x -= Math.floor(a.x);
                  break;
                case 1001:
                  a.x = 0 > a.x ? 0 : 1;
                  break;
                case 1002:
                  a.x =
                    1 === Math.abs(Math.floor(a.x) % 2)
                      ? Math.ceil(a.x) - a.x
                      : a.x - Math.floor(a.x);
              }
            if (0 > a.y || 1 < a.y)
              switch (this.wrapT) {
                case 1e3:
                  a.y -= Math.floor(a.y);
                  break;
                case 1001:
                  a.y = 0 > a.y ? 0 : 1;
                  break;
                case 1002:
                  a.y =
                    1 === Math.abs(Math.floor(a.y) % 2)
                      ? Math.ceil(a.y) - a.y
                      : a.y - Math.floor(a.y);
              }
            this.flipY && (a.y = 1 - a.y);
            return a;
          }
        });
        Object.defineProperty(l.prototype, "needsUpdate", {
          set: function(a) {
            !0 === a && this.version++;
          }
        });
        Object.defineProperties(m.prototype, {
          width: {
            get: function() {
              return this.z;
            },
            set: function(a) {
              this.z = a;
            }
          },
          height: {
            get: function() {
              return this.w;
            },
            set: function(a) {
              this.w = a;
            }
          }
        });
        Object.assign(m.prototype, {
          isVector4: !0,
          set: function(a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this;
          },
          setScalar: function(a) {
            this.w = this.z = this.y = this.x = a;
            return this;
          },
          setX: function(a) {
            this.x = a;
            return this;
          },
          setY: function(a) {
            this.y = a;
            return this;
          },
          setZ: function(a) {
            this.z = a;
            return this;
          },
          setW: function(a) {
            this.w = a;
            return this;
          },
          setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;
              case 1:
                this.y = b;
                break;
              case 2:
                this.z = b;
                break;
              case 3:
                this.w = b;
                break;
              default:
                throw Error("index is out of range: " + a);
            }
            return this;
          },
          getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw Error("index is out of range: " + a);
            }
          },
          clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          },
          copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = void 0 !== a.w ? a.w : 1;
            return this;
          },
          add: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(a, b)
              );
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this;
          },
          addScalar: function(a) {
            this.x += a;
            this.y += a;
            this.z += a;
            this.w += a;
            return this;
          },
          addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
          },
          addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z += a.z * b;
            this.w += a.w * b;
            return this;
          },
          sub: function(a, b) {
            if (void 0 !== b)
              return (
                console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(a, b)
              );
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this;
          },
          subScalar: function(a) {
            this.x -= a;
            this.y -= a;
            this.z -= a;
            this.w -= a;
            return this;
          },
          subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
          },
          multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            this.w *= a;
            return this;
          },
          applyMatrix4: function(a) {
            var b = this.x,
              g = this.y,
              c = this.z,
              d = this.w;
            a = a.elements;
            this.x = a[0] * b + a[4] * g + a[8] * c + a[12] * d;
            this.y = a[1] * b + a[5] * g + a[9] * c + a[13] * d;
            this.z = a[2] * b + a[6] * g + a[10] * c + a[14] * d;
            this.w = a[3] * b + a[7] * g + a[11] * c + a[15] * d;
            return this;
          },
          divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
          },
          setAxisAngleFromQuaternion: function(a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            1e-4 > b
              ? ((this.x = 1), (this.z = this.y = 0))
              : ((this.x = a.x / b), (this.y = a.y / b), (this.z = a.z / b));
            return this;
          },
          setAxisAngleFromRotationMatrix: function(a) {
            a = a.elements;
            var b = a[0];
            var g = a[4];
            var c = a[8],
              d = a[1],
              e = a[5],
              f = a[9];
            var h = a[2];
            var k = a[6];
            var l = a[10];
            if (
              0.01 > Math.abs(g - d) &&
              0.01 > Math.abs(c - h) &&
              0.01 > Math.abs(f - k)
            ) {
              if (
                0.1 > Math.abs(g + d) &&
                0.1 > Math.abs(c + h) &&
                0.1 > Math.abs(f + k) &&
                0.1 > Math.abs(b + e + l - 3)
              )
                return this.set(1, 0, 0, 0), this;
              a = Math.PI;
              b = (b + 1) / 2;
              e = (e + 1) / 2;
              l = (l + 1) / 2;
              g = (g + d) / 4;
              c = (c + h) / 4;
              f = (f + k) / 4;
              b > e && b > l
                ? 0.01 > b
                  ? ((k = 0), (g = h = 0.707106781))
                  : ((k = Math.sqrt(b)), (h = g / k), (g = c / k))
                : e > l
                ? 0.01 > e
                  ? ((k = 0.707106781), (h = 0), (g = 0.707106781))
                  : ((h = Math.sqrt(e)), (k = g / h), (g = f / h))
                : 0.01 > l
                ? ((h = k = 0.707106781), (g = 0))
                : ((g = Math.sqrt(l)), (k = c / g), (h = f / g));
              this.set(k, h, g, a);
              return this;
            }
            a = Math.sqrt(
              (k - f) * (k - f) + (c - h) * (c - h) + (d - g) * (d - g)
            );
            0.001 > Math.abs(a) && (a = 1);
            this.x = (k - f) / a;
            this.y = (c - h) / a;
            this.z = (d - g) / a;
            this.w = Math.acos((b + e + l - 1) / 2);
            return this;
          },
          min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            this.z = Math.min(this.z, a.z);
            this.w = Math.min(this.w, a.w);
            return this;
          },
          max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            this.w = Math.max(this.w, a.w);
            return this;
          },
          clamp: function(a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            this.w = Math.max(a.w, Math.min(b.w, this.w));
            return this;
          },
          clampScalar: function(a, b) {
            this.x = Math.max(a, Math.min(b, this.x));
            this.y = Math.max(a, Math.min(b, this.y));
            this.z = Math.max(a, Math.min(b, this.z));
            this.w = Math.max(a, Math.min(b, this.w));
            return this;
          },
          clampLength: function(a, b) {
            var g = this.length();
            return this.divideScalar(g || 1).multiplyScalar(
              Math.max(a, Math.min(b, g))
            );
          },
          floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
          },
          ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
          },
          round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
          },
          roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
          },
          negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
          },
          dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
          },
          lengthSq: function() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          },
          length: function() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          },
          manhattanLength: function() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          },
          normalize: function() {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function(a) {
            return this.normalize().multiplyScalar(a);
          },
          lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            this.w += (a.w - this.w) * b;
            return this;
          },
          lerpVectors: function(a, b, c) {
            return this.subVectors(b, a)
              .multiplyScalar(c)
              .add(a);
          },
          equals: function(a) {
            return (
              a.x === this.x &&
              a.y === this.y &&
              a.z === this.z &&
              a.w === this.w
            );
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            this.w = a[b + 3];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            a[b + 3] = this.w;
            return a;
          },
          fromBufferAttribute: function(a, b, c) {
            void 0 !== c &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              );
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            this.w = a.getW(b);
            return this;
          }
        });
        n.prototype = Object.assign(Object.create(b.prototype), {
          constructor: n,
          isWebGLRenderTarget: !0,
          setSize: function(a, b) {
            if (this.width !== a || this.height !== b)
              (this.width = a),
                (this.height = b),
                (this.texture.image.width = a),
                (this.texture.image.height = b),
                this.dispose();
            this.viewport.set(0, 0, a, b);
            this.scissor.set(0, 0, a, b);
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.width = a.width;
            this.height = a.height;
            this.viewport.copy(a.viewport);
            this.texture = a.texture.clone();
            this.depthBuffer = a.depthBuffer;
            this.stencilBuffer = a.stencilBuffer;
            this.depthTexture = a.depthTexture;
            return this;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          }
        });
        q.prototype = Object.assign(Object.create(n.prototype), {
          constructor: q,
          isWebGLMultisampleRenderTarget: !0,
          copy: function(a) {
            n.prototype.copy.call(this, a);
            this.samples = a.samples;
            return this;
          }
        });
        var ac = new h(),
          gb = new t(),
          ki = new h(0, 0, 0),
          li = new h(1, 1, 1),
          gg = new h(),
          $e = new h(),
          Ab = new h();
        Object.assign(t.prototype, {
          isMatrix4: !0,
          set: function(a, b, c, d, e, f, h, k, l, m, n, q, t, u, r, y) {
            var g = this.elements;
            g[0] = a;
            g[4] = b;
            g[8] = c;
            g[12] = d;
            g[1] = e;
            g[5] = f;
            g[9] = h;
            g[13] = k;
            g[2] = l;
            g[6] = m;
            g[10] = n;
            g[14] = q;
            g[3] = t;
            g[7] = u;
            g[11] = r;
            g[15] = y;
            return this;
          },
          identity: function() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
          },
          clone: function() {
            return new t().fromArray(this.elements);
          },
          copy: function(a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this;
          },
          copyPosition: function(a) {
            var b = this.elements;
            a = a.elements;
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            return this;
          },
          extractBasis: function(a, b, c) {
            a.setFromMatrixColumn(this, 0);
            b.setFromMatrixColumn(this, 1);
            c.setFromMatrixColumn(this, 2);
            return this;
          },
          makeBasis: function(a, b, c) {
            this.set(
              a.x,
              b.x,
              c.x,
              0,
              a.y,
              b.y,
              c.y,
              0,
              a.z,
              b.z,
              c.z,
              0,
              0,
              0,
              0,
              1
            );
            return this;
          },
          extractRotation: function(a) {
            var b = this.elements,
              g = a.elements,
              c = 1 / ac.setFromMatrixColumn(a, 0).length(),
              d = 1 / ac.setFromMatrixColumn(a, 1).length();
            a = 1 / ac.setFromMatrixColumn(a, 2).length();
            b[0] = g[0] * c;
            b[1] = g[1] * c;
            b[2] = g[2] * c;
            b[3] = 0;
            b[4] = g[4] * d;
            b[5] = g[5] * d;
            b[6] = g[6] * d;
            b[7] = 0;
            b[8] = g[8] * a;
            b[9] = g[9] * a;
            b[10] = g[10] * a;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this;
          },
          makeRotationFromEuler: function(a) {
            (a && a.isEuler) ||
              console.error(
                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
              );
            var b = this.elements,
              g = a.x,
              c = a.y,
              d = a.z,
              e = Math.cos(g);
            g = Math.sin(g);
            var f = Math.cos(c);
            c = Math.sin(c);
            var h = Math.cos(d);
            d = Math.sin(d);
            if ("XYZ" === a.order) {
              a = e * h;
              var k = e * d,
                l = g * h,
                m = g * d;
              b[0] = f * h;
              b[4] = -f * d;
              b[8] = c;
              b[1] = k + l * c;
              b[5] = a - m * c;
              b[9] = -g * f;
              b[2] = m - a * c;
              b[6] = l + k * c;
              b[10] = e * f;
            } else
              "YXZ" === a.order
                ? ((a = f * h),
                  (k = f * d),
                  (l = c * h),
                  (m = c * d),
                  (b[0] = a + m * g),
                  (b[4] = l * g - k),
                  (b[8] = e * c),
                  (b[1] = e * d),
                  (b[5] = e * h),
                  (b[9] = -g),
                  (b[2] = k * g - l),
                  (b[6] = m + a * g),
                  (b[10] = e * f))
                : "ZXY" === a.order
                ? ((a = f * h),
                  (k = f * d),
                  (l = c * h),
                  (m = c * d),
                  (b[0] = a - m * g),
                  (b[4] = -e * d),
                  (b[8] = l + k * g),
                  (b[1] = k + l * g),
                  (b[5] = e * h),
                  (b[9] = m - a * g),
                  (b[2] = -e * c),
                  (b[6] = g),
                  (b[10] = e * f))
                : "ZYX" === a.order
                ? ((a = e * h),
                  (k = e * d),
                  (l = g * h),
                  (m = g * d),
                  (b[0] = f * h),
                  (b[4] = l * c - k),
                  (b[8] = a * c + m),
                  (b[1] = f * d),
                  (b[5] = m * c + a),
                  (b[9] = k * c - l),
                  (b[2] = -c),
                  (b[6] = g * f),
                  (b[10] = e * f))
                : "YZX" === a.order
                ? ((a = e * f),
                  (k = e * c),
                  (l = g * f),
                  (m = g * c),
                  (b[0] = f * h),
                  (b[4] = m - a * d),
                  (b[8] = l * d + k),
                  (b[1] = d),
                  (b[5] = e * h),
                  (b[9] = -g * h),
                  (b[2] = -c * h),
                  (b[6] = k * d + l),
                  (b[10] = a - m * d))
                : "XZY" === a.order &&
                  ((a = e * f),
                  (k = e * c),
                  (l = g * f),
                  (m = g * c),
                  (b[0] = f * h),
                  (b[4] = -d),
                  (b[8] = c * h),
                  (b[1] = a * d + m),
                  (b[5] = e * h),
                  (b[9] = k * d - l),
                  (b[2] = l * d - k),
                  (b[6] = g * h),
                  (b[10] = m * d + a));
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this;
          },
          makeRotationFromQuaternion: function(a) {
            return this.compose(ki, a, li);
          },
          lookAt: function(a, b, c) {
            var g = this.elements;
            Ab.subVectors(a, b);
            0 === Ab.lengthSq() && (Ab.z = 1);
            Ab.normalize();
            gg.crossVectors(c, Ab);
            0 === gg.lengthSq() &&
              (1 === Math.abs(c.z) ? (Ab.x += 1e-4) : (Ab.z += 1e-4),
              Ab.normalize(),
              gg.crossVectors(c, Ab));
            gg.normalize();
            $e.crossVectors(Ab, gg);
            g[0] = gg.x;
            g[4] = $e.x;
            g[8] = Ab.x;
            g[1] = gg.y;
            g[5] = $e.y;
            g[9] = Ab.y;
            g[2] = gg.z;
            g[6] = $e.z;
            g[10] = Ab.z;
            return this;
          },
          multiply: function(a, b) {
            return void 0 !== b
              ? (console.warn(
                  "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                ),
                this.multiplyMatrices(a, b))
              : this.multiplyMatrices(this, a);
          },
          premultiply: function(a) {
            return this.multiplyMatrices(a, this);
          },
          multiplyMatrices: function(a, b) {
            var g = a.elements,
              c = b.elements;
            b = this.elements;
            a = g[0];
            var d = g[4],
              e = g[8],
              p = g[12],
              f = g[1],
              h = g[5],
              k = g[9],
              l = g[13],
              m = g[2],
              n = g[6],
              q = g[10],
              t = g[14],
              u = g[3],
              r = g[7],
              y = g[11];
            g = g[15];
            var v = c[0],
              A = c[4],
              z = c[8],
              C = c[12],
              B = c[1],
              H = c[5],
              N = c[9],
              M = c[13],
              D = c[2],
              E = c[6],
              F = c[10],
              J = c[14],
              I = c[3],
              P = c[7],
              L = c[11];
            c = c[15];
            b[0] = a * v + d * B + e * D + p * I;
            b[4] = a * A + d * H + e * E + p * P;
            b[8] = a * z + d * N + e * F + p * L;
            b[12] = a * C + d * M + e * J + p * c;
            b[1] = f * v + h * B + k * D + l * I;
            b[5] = f * A + h * H + k * E + l * P;
            b[9] = f * z + h * N + k * F + l * L;
            b[13] = f * C + h * M + k * J + l * c;
            b[2] = m * v + n * B + q * D + t * I;
            b[6] = m * A + n * H + q * E + t * P;
            b[10] = m * z + n * N + q * F + t * L;
            b[14] = m * C + n * M + q * J + t * c;
            b[3] = u * v + r * B + y * D + g * I;
            b[7] = u * A + r * H + y * E + g * P;
            b[11] = u * z + r * N + y * F + g * L;
            b[15] = u * C + r * M + y * J + g * c;
            return this;
          },
          multiplyScalar: function(a) {
            var b = this.elements;
            b[0] *= a;
            b[4] *= a;
            b[8] *= a;
            b[12] *= a;
            b[1] *= a;
            b[5] *= a;
            b[9] *= a;
            b[13] *= a;
            b[2] *= a;
            b[6] *= a;
            b[10] *= a;
            b[14] *= a;
            b[3] *= a;
            b[7] *= a;
            b[11] *= a;
            b[15] *= a;
            return this;
          },
          applyToBufferAttribute: function(a) {
            for (var b = 0, g = a.count; b < g; b++)
              (ac.x = a.getX(b)),
                (ac.y = a.getY(b)),
                (ac.z = a.getZ(b)),
                ac.applyMatrix4(this),
                a.setXYZ(b, ac.x, ac.y, ac.z);
            return a;
          },
          determinant: function() {
            var a = this.elements,
              b = a[0],
              c = a[4],
              d = a[8],
              e = a[12],
              f = a[1],
              h = a[5],
              k = a[9],
              l = a[13],
              m = a[2],
              n = a[6],
              q = a[10],
              t = a[14];
            return (
              a[3] *
                (+e * k * n -
                  d * l * n -
                  e * h * q +
                  c * l * q +
                  d * h * t -
                  c * k * t) +
              a[7] *
                (+b * k * t -
                  b * l * q +
                  e * f * q -
                  d * f * t +
                  d * l * m -
                  e * k * m) +
              a[11] *
                (+b * l * n -
                  b * h * t -
                  e * f * n +
                  c * f * t +
                  e * h * m -
                  c * l * m) +
              a[15] *
                (-d * h * m -
                  b * k * n +
                  b * h * q +
                  d * f * n -
                  c * f * q +
                  c * k * m)
            );
          },
          transpose: function() {
            var a = this.elements;
            var b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this;
          },
          setPosition: function(a, b, c) {
            var g = this.elements;
            a.isVector3
              ? ((g[12] = a.x), (g[13] = a.y), (g[14] = a.z))
              : ((g[12] = a), (g[13] = b), (g[14] = c));
            return this;
          },
          getInverse: function(a, b) {
            var g = this.elements,
              c = a.elements;
            a = c[0];
            var d = c[1],
              e = c[2],
              p = c[3],
              f = c[4],
              h = c[5],
              k = c[6],
              l = c[7],
              m = c[8],
              n = c[9],
              q = c[10],
              t = c[11],
              u = c[12],
              r = c[13],
              y = c[14];
            c = c[15];
            var v =
                n * y * l -
                r * q * l +
                r * k * t -
                h * y * t -
                n * k * c +
                h * q * c,
              A =
                u * q * l -
                m * y * l -
                u * k * t +
                f * y * t +
                m * k * c -
                f * q * c,
              z =
                m * r * l -
                u * n * l +
                u * h * t -
                f * r * t -
                m * h * c +
                f * n * c,
              C =
                u * n * k -
                m * r * k -
                u * h * q +
                f * r * q +
                m * h * y -
                f * n * y,
              B = a * v + d * A + e * z + p * C;
            if (0 === B) {
              if (!0 === b)
                throw Error(
                  "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
                );
              console.warn(
                "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
              );
              return this.identity();
            }
            b = 1 / B;
            g[0] = v * b;
            g[1] =
              (r * q * p -
                n * y * p -
                r * e * t +
                d * y * t +
                n * e * c -
                d * q * c) *
              b;
            g[2] =
              (h * y * p -
                r * k * p +
                r * e * l -
                d * y * l -
                h * e * c +
                d * k * c) *
              b;
            g[3] =
              (n * k * p -
                h * q * p -
                n * e * l +
                d * q * l +
                h * e * t -
                d * k * t) *
              b;
            g[4] = A * b;
            g[5] =
              (m * y * p -
                u * q * p +
                u * e * t -
                a * y * t -
                m * e * c +
                a * q * c) *
              b;
            g[6] =
              (u * k * p -
                f * y * p -
                u * e * l +
                a * y * l +
                f * e * c -
                a * k * c) *
              b;
            g[7] =
              (f * q * p -
                m * k * p +
                m * e * l -
                a * q * l -
                f * e * t +
                a * k * t) *
              b;
            g[8] = z * b;
            g[9] =
              (u * n * p -
                m * r * p -
                u * d * t +
                a * r * t +
                m * d * c -
                a * n * c) *
              b;
            g[10] =
              (f * r * p -
                u * h * p +
                u * d * l -
                a * r * l -
                f * d * c +
                a * h * c) *
              b;
            g[11] =
              (m * h * p -
                f * n * p -
                m * d * l +
                a * n * l +
                f * d * t -
                a * h * t) *
              b;
            g[12] = C * b;
            g[13] =
              (m * r * e -
                u * n * e +
                u * d * q -
                a * r * q -
                m * d * y +
                a * n * y) *
              b;
            g[14] =
              (u * h * e -
                f * r * e -
                u * d * k +
                a * r * k +
                f * d * y -
                a * h * y) *
              b;
            g[15] =
              (f * n * e -
                m * h * e +
                m * d * k -
                a * n * k -
                f * d * q +
                a * h * q) *
              b;
            return this;
          },
          scale: function(a) {
            var b = this.elements,
              g = a.x,
              c = a.y;
            a = a.z;
            b[0] *= g;
            b[4] *= c;
            b[8] *= a;
            b[1] *= g;
            b[5] *= c;
            b[9] *= a;
            b[2] *= g;
            b[6] *= c;
            b[10] *= a;
            b[3] *= g;
            b[7] *= c;
            b[11] *= a;
            return this;
          },
          getMaxScaleOnAxis: function() {
            var a = this.elements;
            return Math.sqrt(
              Math.max(
                a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
                a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
                a[8] * a[8] + a[9] * a[9] + a[10] * a[10]
              )
            );
          },
          makeTranslation: function(a, b, c) {
            this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
            return this;
          },
          makeRotationX: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
            return this;
          },
          makeRotationY: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
            return this;
          },
          makeRotationZ: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
          },
          makeRotationAxis: function(a, b) {
            var g = Math.cos(b);
            b = Math.sin(b);
            var c = 1 - g,
              d = a.x,
              e = a.y;
            a = a.z;
            var f = c * d,
              p = c * e;
            this.set(
              f * d + g,
              f * e - b * a,
              f * a + b * e,
              0,
              f * e + b * a,
              p * e + g,
              p * a - b * d,
              0,
              f * a - b * e,
              p * a + b * d,
              c * a * a + g,
              0,
              0,
              0,
              0,
              1
            );
            return this;
          },
          makeScale: function(a, b, c) {
            this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
            return this;
          },
          makeShear: function(a, b, c) {
            this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
            return this;
          },
          compose: function(a, b, c) {
            var g = this.elements,
              d = b._x,
              e = b._y,
              f = b._z,
              p = b._w,
              h = d + d,
              k = e + e,
              w = f + f;
            b = d * h;
            var l = d * k;
            d *= w;
            var m = e * k;
            e *= w;
            f *= w;
            h *= p;
            k *= p;
            p *= w;
            w = c.x;
            var n = c.y;
            c = c.z;
            g[0] = (1 - (m + f)) * w;
            g[1] = (l + p) * w;
            g[2] = (d - k) * w;
            g[3] = 0;
            g[4] = (l - p) * n;
            g[5] = (1 - (b + f)) * n;
            g[6] = (e + h) * n;
            g[7] = 0;
            g[8] = (d + k) * c;
            g[9] = (e - h) * c;
            g[10] = (1 - (b + m)) * c;
            g[11] = 0;
            g[12] = a.x;
            g[13] = a.y;
            g[14] = a.z;
            g[15] = 1;
            return this;
          },
          decompose: function(a, b, c) {
            var g = this.elements,
              d = ac.set(g[0], g[1], g[2]).length(),
              e = ac.set(g[4], g[5], g[6]).length(),
              f = ac.set(g[8], g[9], g[10]).length();
            0 > this.determinant() && (d = -d);
            a.x = g[12];
            a.y = g[13];
            a.z = g[14];
            gb.copy(this);
            a = 1 / d;
            g = 1 / e;
            var p = 1 / f;
            gb.elements[0] *= a;
            gb.elements[1] *= a;
            gb.elements[2] *= a;
            gb.elements[4] *= g;
            gb.elements[5] *= g;
            gb.elements[6] *= g;
            gb.elements[8] *= p;
            gb.elements[9] *= p;
            gb.elements[10] *= p;
            b.setFromRotationMatrix(gb);
            c.x = d;
            c.y = e;
            c.z = f;
            return this;
          },
          makePerspective: function(a, b, c, d, e, f) {
            void 0 === f &&
              console.warn(
                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
              );
            var g = this.elements;
            g[0] = (2 * e) / (b - a);
            g[4] = 0;
            g[8] = (b + a) / (b - a);
            g[12] = 0;
            g[1] = 0;
            g[5] = (2 * e) / (c - d);
            g[9] = (c + d) / (c - d);
            g[13] = 0;
            g[2] = 0;
            g[6] = 0;
            g[10] = -(f + e) / (f - e);
            g[14] = (-2 * f * e) / (f - e);
            g[3] = 0;
            g[7] = 0;
            g[11] = -1;
            g[15] = 0;
            return this;
          },
          makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements,
              p = 1 / (b - a),
              h = 1 / (c - d),
              k = 1 / (f - e);
            g[0] = 2 * p;
            g[4] = 0;
            g[8] = 0;
            g[12] = -((b + a) * p);
            g[1] = 0;
            g[5] = 2 * h;
            g[9] = 0;
            g[13] = -((c + d) * h);
            g[2] = 0;
            g[6] = 0;
            g[10] = -2 * k;
            g[14] = -((f + e) * k);
            g[3] = 0;
            g[7] = 0;
            g[11] = 0;
            g[15] = 1;
            return this;
          },
          equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var g = 0; 16 > g; g++) if (b[g] !== a[g]) return !1;
            return !0;
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var g = 0; 16 > g; g++) this.elements[g] = a[g + b];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var g = this.elements;
            a[b] = g[0];
            a[b + 1] = g[1];
            a[b + 2] = g[2];
            a[b + 3] = g[3];
            a[b + 4] = g[4];
            a[b + 5] = g[5];
            a[b + 6] = g[6];
            a[b + 7] = g[7];
            a[b + 8] = g[8];
            a[b + 9] = g[9];
            a[b + 10] = g[10];
            a[b + 11] = g[11];
            a[b + 12] = g[12];
            a[b + 13] = g[13];
            a[b + 14] = g[14];
            a[b + 15] = g[15];
            return a;
          }
        });
        var Wg = new t(),
          Xg = new f();
        y.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
        y.DefaultOrder = "XYZ";
        Object.defineProperties(y.prototype, {
          x: {
            get: function() {
              return this._x;
            },
            set: function(a) {
              this._x = a;
              this._onChangeCallback();
            }
          },
          y: {
            get: function() {
              return this._y;
            },
            set: function(a) {
              this._y = a;
              this._onChangeCallback();
            }
          },
          z: {
            get: function() {
              return this._z;
            },
            set: function(a) {
              this._z = a;
              this._onChangeCallback();
            }
          },
          order: {
            get: function() {
              return this._order;
            },
            set: function(a) {
              this._order = a;
              this._onChangeCallback();
            }
          }
        });
        Object.assign(y.prototype, {
          isEuler: !0,
          set: function(a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z = c;
            this._order = d || this._order;
            this._onChangeCallback();
            return this;
          },
          clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          },
          copy: function(a) {
            this._x = a._x;
            this._y = a._y;
            this._z = a._z;
            this._order = a._order;
            this._onChangeCallback();
            return this;
          },
          setFromRotationMatrix: function(a, b, c) {
            var g = ya.clamp,
              d = a.elements;
            a = d[0];
            var e = d[4],
              f = d[8],
              p = d[1],
              h = d[5],
              k = d[9],
              w = d[2],
              l = d[6];
            d = d[10];
            b = b || this._order;
            "XYZ" === b
              ? ((this._y = Math.asin(g(f, -1, 1))),
                0.9999999 > Math.abs(f)
                  ? ((this._x = Math.atan2(-k, d)),
                    (this._z = Math.atan2(-e, a)))
                  : ((this._x = Math.atan2(l, h)), (this._z = 0)))
              : "YXZ" === b
              ? ((this._x = Math.asin(-g(k, -1, 1))),
                0.9999999 > Math.abs(k)
                  ? ((this._y = Math.atan2(f, d)), (this._z = Math.atan2(p, h)))
                  : ((this._y = Math.atan2(-w, a)), (this._z = 0)))
              : "ZXY" === b
              ? ((this._x = Math.asin(g(l, -1, 1))),
                0.9999999 > Math.abs(l)
                  ? ((this._y = Math.atan2(-w, d)),
                    (this._z = Math.atan2(-e, h)))
                  : ((this._y = 0), (this._z = Math.atan2(p, a))))
              : "ZYX" === b
              ? ((this._y = Math.asin(-g(w, -1, 1))),
                0.9999999 > Math.abs(w)
                  ? ((this._x = Math.atan2(l, d)), (this._z = Math.atan2(p, a)))
                  : ((this._x = 0), (this._z = Math.atan2(-e, h))))
              : "YZX" === b
              ? ((this._z = Math.asin(g(p, -1, 1))),
                0.9999999 > Math.abs(p)
                  ? ((this._x = Math.atan2(-k, h)),
                    (this._y = Math.atan2(-w, a)))
                  : ((this._x = 0), (this._y = Math.atan2(f, d))))
              : "XZY" === b
              ? ((this._z = Math.asin(-g(e, -1, 1))),
                0.9999999 > Math.abs(e)
                  ? ((this._x = Math.atan2(l, h)), (this._y = Math.atan2(f, a)))
                  : ((this._x = Math.atan2(-k, d)), (this._y = 0)))
              : console.warn(
                  "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                    b
                );
            this._order = b;
            !1 !== c && this._onChangeCallback();
            return this;
          },
          setFromQuaternion: function(a, b, c) {
            Wg.makeRotationFromQuaternion(a);
            return this.setFromRotationMatrix(Wg, b, c);
          },
          setFromVector3: function(a, b) {
            return this.set(a.x, a.y, a.z, b || this._order);
          },
          reorder: function(a) {
            Xg.setFromEuler(this);
            return this.setFromQuaternion(Xg, a);
          },
          equals: function(a) {
            return (
              a._x === this._x &&
              a._y === this._y &&
              a._z === this._z &&
              a._order === this._order
            );
          },
          fromArray: function(a) {
            this._x = a[0];
            this._y = a[1];
            this._z = a[2];
            void 0 !== a[3] && (this._order = a[3]);
            this._onChangeCallback();
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._order;
            return a;
          },
          toVector3: function(a) {
            return a
              ? a.set(this._x, this._y, this._z)
              : new h(this._x, this._y, this._z);
          },
          _onChange: function(a) {
            this._onChangeCallback = a;
            return this;
          },
          _onChangeCallback: function() {}
        });
        Object.assign(u.prototype, {
          set: function(a) {
            this.mask = (1 << a) | 0;
          },
          enable: function(a) {
            this.mask = this.mask | (1 << a) | 0;
          },
          enableAll: function() {
            this.mask = -1;
          },
          toggle: function(a) {
            this.mask ^= (1 << a) | 0;
          },
          disable: function(a) {
            this.mask &= ~((1 << a) | 0);
          },
          disableAll: function() {
            this.mask = 0;
          },
          test: function(a) {
            return 0 !== (this.mask & a.mask);
          }
        });
        var mi = 0,
          Yg = new h(),
          Zi = new f(),
          mf = new t(),
          cf = new h(),
          ek = new h(),
          pi = new h(),
          xi = new f(),
          gh = new h(1, 0, 0),
          hh = new h(0, 1, 0),
          ih = new h(0, 0, 1),
          yi = { type: "added" },
          zi = { type: "removed" };
        v.DefaultUp = new h(0, 1, 0);
        v.DefaultMatrixAutoUpdate = !0;
        v.prototype = Object.assign(Object.create(b.prototype), {
          constructor: v,
          isObject3D: !0,
          onBeforeRender: function() {},
          onAfterRender: function() {},
          applyMatrix: function(a) {
            this.matrixAutoUpdate && this.updateMatrix();
            this.matrix.premultiply(a);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
          },
          applyQuaternion: function(a) {
            this.quaternion.premultiply(a);
            return this;
          },
          setRotationFromAxisAngle: function(a, b) {
            this.quaternion.setFromAxisAngle(a, b);
          },
          setRotationFromEuler: function(a) {
            this.quaternion.setFromEuler(a, !0);
          },
          setRotationFromMatrix: function(a) {
            this.quaternion.setFromRotationMatrix(a);
          },
          setRotationFromQuaternion: function(a) {
            this.quaternion.copy(a);
          },
          rotateOnAxis: function(a, b) {
            Zi.setFromAxisAngle(a, b);
            this.quaternion.multiply(Zi);
            return this;
          },
          rotateOnWorldAxis: function(a, b) {
            Zi.setFromAxisAngle(a, b);
            this.quaternion.premultiply(Zi);
            return this;
          },
          rotateX: function(a) {
            return this.rotateOnAxis(gh, a);
          },
          rotateY: function(a) {
            return this.rotateOnAxis(hh, a);
          },
          rotateZ: function(a) {
            return this.rotateOnAxis(ih, a);
          },
          translateOnAxis: function(a, b) {
            Yg.copy(a).applyQuaternion(this.quaternion);
            this.position.add(Yg.multiplyScalar(b));
            return this;
          },
          translateX: function(a) {
            return this.translateOnAxis(gh, a);
          },
          translateY: function(a) {
            return this.translateOnAxis(hh, a);
          },
          translateZ: function(a) {
            return this.translateOnAxis(ih, a);
          },
          localToWorld: function(a) {
            return a.applyMatrix4(this.matrixWorld);
          },
          worldToLocal: function(a) {
            return a.applyMatrix4(mf.getInverse(this.matrixWorld));
          },
          lookAt: function(a, b, c) {
            a.isVector3 ? cf.copy(a) : cf.set(a, b, c);
            a = this.parent;
            this.updateWorldMatrix(!0, !1);
            ek.setFromMatrixPosition(this.matrixWorld);
            this.isCamera || this.isLight
              ? mf.lookAt(ek, cf, this.up)
              : mf.lookAt(cf, ek, this.up);
            this.quaternion.setFromRotationMatrix(mf);
            a &&
              (mf.extractRotation(a.matrixWorld),
              Zi.setFromRotationMatrix(mf),
              this.quaternion.premultiply(Zi.inverse()));
          },
          add: function(a) {
            if (1 < arguments.length) {
              for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
              return this;
            }
            if (a === this)
              return (
                console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  a
                ),
                this
              );
            a && a.isObject3D
              ? (null !== a.parent && a.parent.remove(a),
                (a.parent = this),
                this.children.push(a),
                a.dispatchEvent(yi))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  a
                );
            return this;
          },
          remove: function(a) {
            if (1 < arguments.length) {
              for (var b = 0; b < arguments.length; b++)
                this.remove(arguments[b]);
              return this;
            }
            b = this.children.indexOf(a);
            -1 !== b &&
              ((a.parent = null),
              this.children.splice(b, 1),
              a.dispatchEvent(zi));
            return this;
          },
          attach: function(a) {
            this.updateWorldMatrix(!0, !1);
            mf.getInverse(this.matrixWorld);
            null !== a.parent &&
              (a.parent.updateWorldMatrix(!0, !1),
              mf.multiply(a.parent.matrixWorld));
            a.applyMatrix(mf);
            a.updateWorldMatrix(!1, !1);
            this.add(a);
            return this;
          },
          getObjectById: function(a) {
            return this.getObjectByProperty("id", a);
          },
          getObjectByName: function(a) {
            return this.getObjectByProperty("name", a);
          },
          getObjectByProperty: function(a, b) {
            if (this[a] === b) return this;
            for (var g = 0, c = this.children.length; g < c; g++) {
              var d = this.children[g].getObjectByProperty(a, b);
              if (void 0 !== d) return d;
            }
          },
          getWorldPosition: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (a = new h()));
            this.updateMatrixWorld(!0);
            return a.setFromMatrixPosition(this.matrixWorld);
          },
          getWorldQuaternion: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (a = new f()));
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(ek, a, pi);
            return a;
          },
          getWorldScale: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (a = new h()));
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(ek, xi, a);
            return a;
          },
          getWorldDirection: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Object3D: .getWorldDirection() target is now required"
              ),
              (a = new h()));
            this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(b[8], b[9], b[10]).normalize();
          },
          raycast: function() {},
          traverse: function(a) {
            a(this);
            for (var b = this.children, g = 0, c = b.length; g < c; g++)
              b[g].traverse(a);
          },
          traverseVisible: function(a) {
            if (!1 !== this.visible) {
              a(this);
              for (var b = this.children, g = 0, c = b.length; g < c; g++)
                b[g].traverseVisible(a);
            }
          },
          traverseAncestors: function(a) {
            var b = this.parent;
            null !== b && (a(b), b.traverseAncestors(a));
          },
          updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = !0;
          },
          updateMatrixWorld: function(a) {
            this.matrixAutoUpdate && this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || a)
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
                (this.matrixWorldNeedsUpdate = !1),
                (a = !0);
            for (var b = this.children, g = 0, c = b.length; g < c; g++)
              b[g].updateMatrixWorld(a);
          },
          updateWorldMatrix: function(a, b) {
            var g = this.parent;
            !0 === a && null !== g && g.updateWorldMatrix(!0, !1);
            this.matrixAutoUpdate && this.updateMatrix();
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                );
            if (!0 === b)
              for (a = this.children, b = 0, g = a.length; b < g; b++)
                a[b].updateWorldMatrix(!1, !0);
          },
          toJSON: function(a) {
            function b(b, g) {
              void 0 === b[g.uuid] && (b[g.uuid] = g.toJSON(a));
              return g.uuid;
            }
            function g(a) {
              var b = [],
                g;
              for (g in a) {
                var c = a[g];
                delete c.metadata;
                b.push(c);
              }
              return b;
            }
            var c = void 0 === a || "string" === typeof a,
              d = {};
            c &&
              ((a = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
              }),
              (d.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
              }));
            var e = {};
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            !0 === this.castShadow && (e.castShadow = !0);
            !0 === this.receiveShadow && (e.receiveShadow = !0);
            !1 === this.visible && (e.visible = !1);
            !1 === this.frustumCulled && (e.frustumCulled = !1);
            0 !== this.renderOrder && (e.renderOrder = this.renderOrder);
            "{}" !== JSON.stringify(this.userData) &&
              (e.userData = this.userData);
            e.layers = this.layers.mask;
            e.matrix = this.matrix.toArray();
            !1 === this.matrixAutoUpdate && (e.matrixAutoUpdate = !1);
            this.isMesh && 0 !== this.drawMode && (e.drawMode = this.drawMode);
            if (this.isMesh || this.isLine || this.isPoints) {
              e.geometry = b(a.geometries, this.geometry);
              var f = this.geometry.parameters;
              if (void 0 !== f && void 0 !== f.shapes)
                if (((f = f.shapes), Array.isArray(f)))
                  for (var h = 0, k = f.length; h < k; h++) b(a.shapes, f[h]);
                else b(a.shapes, f);
            }
            if (void 0 !== this.material)
              if (Array.isArray(this.material)) {
                f = [];
                h = 0;
                for (k = this.material.length; h < k; h++)
                  f.push(b(a.materials, this.material[h]));
                e.material = f;
              } else e.material = b(a.materials, this.material);
            if (0 < this.children.length)
              for (e.children = [], h = 0; h < this.children.length; h++)
                e.children.push(this.children[h].toJSON(a).object);
            if (c) {
              c = g(a.geometries);
              h = g(a.materials);
              k = g(a.textures);
              var l = g(a.images);
              f = g(a.shapes);
              0 < c.length && (d.geometries = c);
              0 < h.length && (d.materials = h);
              0 < k.length && (d.textures = k);
              0 < l.length && (d.images = l);
              0 < f.length && (d.shapes = f);
            }
            d.object = e;
            return d;
          },
          clone: function(a) {
            return new this.constructor().copy(this, a);
          },
          copy: function(a, b) {
            void 0 === b && (b = !0);
            this.name = a.name;
            this.up.copy(a.up);
            this.position.copy(a.position);
            this.quaternion.copy(a.quaternion);
            this.scale.copy(a.scale);
            this.matrix.copy(a.matrix);
            this.matrixWorld.copy(a.matrixWorld);
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
            this.layers.mask = a.layers.mask;
            this.visible = a.visible;
            this.castShadow = a.castShadow;
            this.receiveShadow = a.receiveShadow;
            this.frustumCulled = a.frustumCulled;
            this.renderOrder = a.renderOrder;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            if (!0 === b)
              for (b = 0; b < a.children.length; b++)
                this.add(a.children[b].clone());
            return this;
          }
        });
        r.prototype = Object.assign(Object.create(v.prototype), {
          constructor: r,
          isScene: !0,
          copy: function(a, b) {
            v.prototype.copy.call(this, a, b);
            null !== a.background && (this.background = a.background.clone());
            null !== a.fog && (this.fog = a.fog.clone());
            null !== a.overrideMaterial &&
              (this.overrideMaterial = a.overrideMaterial.clone());
            this.autoUpdate = a.autoUpdate;
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            return this;
          },
          toJSON: function(a) {
            var b = v.prototype.toJSON.call(this, a);
            null !== this.background &&
              (b.object.background = this.background.toJSON(a));
            null !== this.fog && (b.object.fog = this.fog.toJSON());
            return b;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          }
        });
        var nf = [
            new h(),
            new h(),
            new h(),
            new h(),
            new h(),
            new h(),
            new h(),
            new h()
          ],
          Ce = new h(),
          $i = new h(),
          aj = new h(),
          bj = new h(),
          hg = new h(),
          ig = new h(),
          Ch = new h(),
          fk = new h(),
          ef = new h(),
          ff = new h(),
          jh = new h();
        Object.assign(C.prototype, {
          isBox3: !0,
          set: function(a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this;
          },
          setFromArray: function(a) {
            for (
              var b = Infinity,
                g = Infinity,
                c = Infinity,
                d = -Infinity,
                e = -Infinity,
                f = -Infinity,
                h = 0,
                k = a.length;
              h < k;
              h += 3
            ) {
              var l = a[h],
                m = a[h + 1],
                n = a[h + 2];
              l < b && (b = l);
              m < g && (g = m);
              n < c && (c = n);
              l > d && (d = l);
              m > e && (e = m);
              n > f && (f = n);
            }
            this.min.set(b, g, c);
            this.max.set(d, e, f);
            return this;
          },
          setFromBufferAttribute: function(a) {
            for (
              var b = Infinity,
                g = Infinity,
                c = Infinity,
                d = -Infinity,
                e = -Infinity,
                f = -Infinity,
                h = 0,
                k = a.count;
              h < k;
              h++
            ) {
              var l = a.getX(h),
                m = a.getY(h),
                n = a.getZ(h);
              l < b && (b = l);
              m < g && (g = m);
              n < c && (c = n);
              l > d && (d = l);
              m > e && (e = m);
              n > f && (f = n);
            }
            this.min.set(b, g, c);
            this.max.set(d, e, f);
            return this;
          },
          setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, g = a.length; b < g; b++) this.expandByPoint(a[b]);
            return this;
          },
          setFromCenterAndSize: function(a, b) {
            b = Ce.copy(b).multiplyScalar(0.5);
            this.min.copy(a).sub(b);
            this.max.copy(a).add(b);
            return this;
          },
          setFromObject: function(a) {
            this.makeEmpty();
            return this.expandByObject(a);
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this;
          },
          makeEmpty: function() {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
          },
          isEmpty: function() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          },
          getCenter: function(a) {
            void 0 === a &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (a = new h()));
            return this.isEmpty()
              ? a.set(0, 0, 0)
              : a.addVectors(this.min, this.max).multiplyScalar(0.5);
          },
          getSize: function(a) {
            void 0 === a &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (a = new h()));
            return this.isEmpty()
              ? a.set(0, 0, 0)
              : a.subVectors(this.max, this.min);
          },
          expandByPoint: function(a) {
            this.min.min(a);
            this.max.max(a);
            return this;
          },
          expandByVector: function(a) {
            this.min.sub(a);
            this.max.add(a);
            return this;
          },
          expandByScalar: function(a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this;
          },
          expandByObject: function(a) {
            var b;
            a.updateWorldMatrix(!1, !1);
            var g = a.geometry;
            if (void 0 !== g)
              if (g.isGeometry) {
                var c = g.vertices;
                g = 0;
                for (b = c.length; g < b; g++)
                  Ce.copy(c[g]),
                    Ce.applyMatrix4(a.matrixWorld),
                    this.expandByPoint(Ce);
              } else if (
                g.isBufferGeometry &&
                ((c = g.attributes.position), void 0 !== c)
              )
                for (g = 0, b = c.count; g < b; g++)
                  Ce.fromBufferAttribute(c, g).applyMatrix4(a.matrixWorld),
                    this.expandByPoint(Ce);
            a = a.children;
            g = 0;
            for (b = a.length; g < b; g++) this.expandByObject(a[g]);
            return this;
          },
          containsPoint: function(a) {
            return a.x < this.min.x ||
              a.x > this.max.x ||
              a.y < this.min.y ||
              a.y > this.max.y ||
              a.z < this.min.z ||
              a.z > this.max.z
              ? !1
              : !0;
          },
          containsBox: function(a) {
            return (
              this.min.x <= a.min.x &&
              a.max.x <= this.max.x &&
              this.min.y <= a.min.y &&
              a.max.y <= this.max.y &&
              this.min.z <= a.min.z &&
              a.max.z <= this.max.z
            );
          },
          getParameter: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (b = new h()));
            return b.set(
              (a.x - this.min.x) / (this.max.x - this.min.x),
              (a.y - this.min.y) / (this.max.y - this.min.y),
              (a.z - this.min.z) / (this.max.z - this.min.z)
            );
          },
          intersectsBox: function(a) {
            return a.max.x < this.min.x ||
              a.min.x > this.max.x ||
              a.max.y < this.min.y ||
              a.min.y > this.max.y ||
              a.max.z < this.min.z ||
              a.min.z > this.max.z
              ? !1
              : !0;
          },
          intersectsSphere: function(a) {
            this.clampPoint(a.center, Ce);
            return Ce.distanceToSquared(a.center) <= a.radius * a.radius;
          },
          intersectsPlane: function(a) {
            if (0 < a.normal.x) {
              var b = a.normal.x * this.min.x;
              var c = a.normal.x * this.max.x;
            } else (b = a.normal.x * this.max.x), (c = a.normal.x * this.min.x);
            0 < a.normal.y
              ? ((b += a.normal.y * this.min.y), (c += a.normal.y * this.max.y))
              : ((b += a.normal.y * this.max.y),
                (c += a.normal.y * this.min.y));
            0 < a.normal.z
              ? ((b += a.normal.z * this.min.z), (c += a.normal.z * this.max.z))
              : ((b += a.normal.z * this.max.z),
                (c += a.normal.z * this.min.z));
            return b <= -a.constant && c >= -a.constant;
          },
          intersectsTriangle: function(a) {
            if (this.isEmpty()) return !1;
            this.getCenter(fk);
            ef.subVectors(this.max, fk);
            $i.subVectors(a.a, fk);
            aj.subVectors(a.b, fk);
            bj.subVectors(a.c, fk);
            hg.subVectors(aj, $i);
            ig.subVectors(bj, aj);
            Ch.subVectors($i, bj);
            a = [
              0,
              -hg.z,
              hg.y,
              0,
              -ig.z,
              ig.y,
              0,
              -Ch.z,
              Ch.y,
              hg.z,
              0,
              -hg.x,
              ig.z,
              0,
              -ig.x,
              Ch.z,
              0,
              -Ch.x,
              -hg.y,
              hg.x,
              0,
              -ig.y,
              ig.x,
              0,
              -Ch.y,
              Ch.x,
              0
            ];
            if (!z(a, $i, aj, bj, ef)) return !1;
            a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!z(a, $i, aj, bj, ef)) return !1;
            ff.crossVectors(hg, ig);
            a = [ff.x, ff.y, ff.z];
            return z(a, $i, aj, bj, ef);
          },
          clampPoint: function(a, b) {
            void 0 === b &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (b = new h()));
            return b.copy(a).clamp(this.min, this.max);
          },
          distanceToPoint: function(a) {
            return Ce.copy(a)
              .clamp(this.min, this.max)
              .sub(a)
              .length();
          },
          getBoundingSphere: function(a) {
            void 0 === a &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              );
            this.getCenter(a.center);
            a.radius = 0.5 * this.getSize(Ce).length();
            return a;
          },
          intersect: function(a) {
            this.min.max(a.min);
            this.max.min(a.max);
            this.isEmpty() && this.makeEmpty();
            return this;
          },
          union: function(a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this;
          },
          applyMatrix4: function(a) {
            if (this.isEmpty()) return this;
            nf[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
            nf[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
            nf[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
            nf[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
            nf[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
            nf[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
            nf[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
            nf[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
            this.setFromPoints(nf);
            return this;
          },
          translate: function(a) {
            this.min.add(a);
            this.max.add(a);
            return this;
          },
          equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max);
          }
        });
        var jj = new C();
        Object.assign(H.prototype, {
          set: function(a, b) {
            this.center.copy(a);
            this.radius = b;
            return this;
          },
          setFromPoints: function(a, b) {
            var c = this.center;
            void 0 !== b ? c.copy(b) : jj.setFromPoints(a).getCenter(c);
            for (var g = (b = 0), d = a.length; g < d; g++)
              b = Math.max(b, c.distanceToSquared(a[g]));
            this.radius = Math.sqrt(b);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.center.copy(a.center);
            this.radius = a.radius;
            return this;
          },
          empty: function() {
            return 0 >= this.radius;
          },
          containsPoint: function(a) {
            return (
              a.distanceToSquared(this.center) <= this.radius * this.radius
            );
          },
          distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius;
          },
          intersectsSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b;
          },
          intersectsBox: function(a) {
            return a.intersectsSphere(this);
          },
          intersectsPlane: function(a) {
            return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
          },
          clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a);
            void 0 === b &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (b = new h()));
            b.copy(a);
            c > this.radius * this.radius &&
              (b.sub(this.center).normalize(),
              b.multiplyScalar(this.radius).add(this.center));
            return b;
          },
          getBoundingBox: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (a = new C()));
            a.set(this.center, this.center);
            a.expandByScalar(this.radius);
            return a;
          },
          applyMatrix4: function(a) {
            this.center.applyMatrix4(a);
            this.radius *= a.getMaxScaleOnAxis();
            return this;
          },
          translate: function(a) {
            this.center.add(a);
            return this;
          },
          equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius;
          }
        });
        var of = new h(),
          ng = new h(),
          wf = new h(),
          jg = new h(),
          pg = new h(),
          xf = new h(),
          qg = new h();
        Object.assign(N.prototype, {
          set: function(a, b) {
            this.origin.copy(a);
            this.direction.copy(b);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.origin.copy(a.origin);
            this.direction.copy(a.direction);
            return this;
          },
          at: function(a, b) {
            void 0 === b &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (b = new h()));
            return b
              .copy(this.direction)
              .multiplyScalar(a)
              .add(this.origin);
          },
          lookAt: function(a) {
            this.direction
              .copy(a)
              .sub(this.origin)
              .normalize();
            return this;
          },
          recast: function(a) {
            this.origin.copy(this.at(a, of));
            return this;
          },
          closestPointToPoint: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Ray: .closestPointToPoint() target is now required"
              ),
              (b = new h()));
            b.subVectors(a, this.origin);
            a = b.dot(this.direction);
            return 0 > a
              ? b.copy(this.origin)
              : b
                  .copy(this.direction)
                  .multiplyScalar(a)
                  .add(this.origin);
          },
          distanceToPoint: function(a) {
            return Math.sqrt(this.distanceSqToPoint(a));
          },
          distanceSqToPoint: function(a) {
            var b = of.subVectors(a, this.origin).dot(this.direction);
            if (0 > b) return this.origin.distanceToSquared(a);
            of.copy(this.direction)
              .multiplyScalar(b)
              .add(this.origin);
            return of.distanceToSquared(a);
          },
          distanceSqToSegment: function(a, b, c, d) {
            ng.copy(a)
              .add(b)
              .multiplyScalar(0.5);
            wf.copy(b)
              .sub(a)
              .normalize();
            jg.copy(this.origin).sub(ng);
            var g = 0.5 * a.distanceTo(b),
              e = -this.direction.dot(wf),
              f = jg.dot(this.direction),
              h = -jg.dot(wf),
              p = jg.lengthSq(),
              k = Math.abs(1 - e * e);
            if (0 < k) {
              a = e * h - f;
              b = e * f - h;
              var w = g * k;
              0 <= a
                ? b >= -w
                  ? b <= w
                    ? ((g = 1 / k),
                      (a *= g),
                      (b *= g),
                      (e =
                        a * (a + e * b + 2 * f) + b * (e * a + b + 2 * h) + p))
                    : ((b = g),
                      (a = Math.max(0, -(e * b + f))),
                      (e = -a * a + b * (b + 2 * h) + p))
                  : ((b = -g),
                    (a = Math.max(0, -(e * b + f))),
                    (e = -a * a + b * (b + 2 * h) + p))
                : b <= -w
                ? ((a = Math.max(0, -(-e * g + f))),
                  (b = 0 < a ? -g : Math.min(Math.max(-g, -h), g)),
                  (e = -a * a + b * (b + 2 * h) + p))
                : b <= w
                ? ((a = 0),
                  (b = Math.min(Math.max(-g, -h), g)),
                  (e = b * (b + 2 * h) + p))
                : ((a = Math.max(0, -(e * g + f))),
                  (b = 0 < a ? g : Math.min(Math.max(-g, -h), g)),
                  (e = -a * a + b * (b + 2 * h) + p));
            } else
              (b = 0 < e ? -g : g),
                (a = Math.max(0, -(e * b + f))),
                (e = -a * a + b * (b + 2 * h) + p);
            c &&
              c
                .copy(this.direction)
                .multiplyScalar(a)
                .add(this.origin);
            d &&
              d
                .copy(wf)
                .multiplyScalar(b)
                .add(ng);
            return e;
          },
          intersectSphere: function(a, b) {
            of.subVectors(a.center, this.origin);
            var c = of.dot(this.direction),
              g = of.dot(of) - c * c;
            a = a.radius * a.radius;
            if (g > a) return null;
            a = Math.sqrt(a - g);
            g = c - a;
            c += a;
            return 0 > g && 0 > c
              ? null
              : 0 > g
              ? this.at(c, b)
              : this.at(g, b);
          },
          intersectsSphere: function(a) {
            return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
          },
          distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
            a = -(this.origin.dot(a.normal) + a.constant) / b;
            return 0 <= a ? a : null;
          },
          intersectPlane: function(a, b) {
            a = this.distanceToPlane(a);
            return null === a ? null : this.at(a, b);
          },
          intersectsPlane: function(a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
          },
          intersectBox: function(a, b) {
            var c = 1 / this.direction.x;
            var g = 1 / this.direction.y;
            var d = 1 / this.direction.z,
              e = this.origin;
            if (0 <= c) {
              var f = (a.min.x - e.x) * c;
              c *= a.max.x - e.x;
            } else (f = (a.max.x - e.x) * c), (c *= a.min.x - e.x);
            if (0 <= g) {
              var h = (a.min.y - e.y) * g;
              g *= a.max.y - e.y;
            } else (h = (a.max.y - e.y) * g), (g *= a.min.y - e.y);
            if (f > g || h > c) return null;
            if (h > f || f !== f) f = h;
            if (g < c || c !== c) c = g;
            0 <= d
              ? ((h = (a.min.z - e.z) * d), (a = (a.max.z - e.z) * d))
              : ((h = (a.max.z - e.z) * d), (a = (a.min.z - e.z) * d));
            if (f > a || h > c) return null;
            if (h > f || f !== f) f = h;
            if (a < c || c !== c) c = a;
            return 0 > c ? null : this.at(0 <= f ? f : c, b);
          },
          intersectsBox: function(a) {
            return null !== this.intersectBox(a, of);
          },
          intersectTriangle: function(a, b, c, d, e) {
            pg.subVectors(b, a);
            xf.subVectors(c, a);
            qg.crossVectors(pg, xf);
            b = this.direction.dot(qg);
            if (0 < b) {
              if (d) return null;
              d = 1;
            } else if (0 > b) (d = -1), (b = -b);
            else return null;
            jg.subVectors(this.origin, a);
            a = d * this.direction.dot(xf.crossVectors(jg, xf));
            if (0 > a) return null;
            c = d * this.direction.dot(pg.cross(jg));
            if (0 > c || a + c > b) return null;
            a = -d * jg.dot(qg);
            return 0 > a ? null : this.at(a / b, e);
          },
          applyMatrix4: function(a) {
            this.origin.applyMatrix4(a);
            this.direction.transformDirection(a);
            return this;
          },
          equals: function(a) {
            return (
              a.origin.equals(this.origin) && a.direction.equals(this.direction)
            );
          }
        });
        var Fd = new h(),
          pf = new h(),
          rg = new h(),
          qf = new h(),
          cj = new h(),
          dj = new h(),
          Mh = new h(),
          sg = new h(),
          tg = new h(),
          ug = new h();
        Object.assign(B, {
          getNormal: function(a, b, c, d) {
            void 0 === d &&
              (console.warn(
                "THREE.Triangle: .getNormal() target is now required"
              ),
              (d = new h()));
            d.subVectors(c, b);
            Fd.subVectors(a, b);
            d.cross(Fd);
            a = d.lengthSq();
            return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0);
          },
          getBarycoord: function(a, b, c, d, e) {
            Fd.subVectors(d, b);
            pf.subVectors(c, b);
            rg.subVectors(a, b);
            a = Fd.dot(Fd);
            b = Fd.dot(pf);
            c = Fd.dot(rg);
            var g = pf.dot(pf);
            d = pf.dot(rg);
            var f = a * g - b * b;
            void 0 === e &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (e = new h()));
            if (0 === f) return e.set(-2, -1, -1);
            f = 1 / f;
            g = (g * c - b * d) * f;
            a = (a * d - b * c) * f;
            return e.set(1 - g - a, a, g);
          },
          containsPoint: function(a, b, c, d) {
            B.getBarycoord(a, b, c, d, qf);
            return 0 <= qf.x && 0 <= qf.y && 1 >= qf.x + qf.y;
          },
          getUV: function(a, b, c, d, e, f, h, k) {
            this.getBarycoord(a, b, c, d, qf);
            k.set(0, 0);
            k.addScaledVector(e, qf.x);
            k.addScaledVector(f, qf.y);
            k.addScaledVector(h, qf.z);
            return k;
          },
          isFrontFacing: function(a, b, c, d) {
            Fd.subVectors(c, b);
            pf.subVectors(a, b);
            return 0 > Fd.cross(pf).dot(d) ? !0 : !1;
          }
        });
        Object.assign(B.prototype, {
          set: function(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
          },
          setFromPointsAndIndices: function(a, b, c, d) {
            this.a.copy(a[b]);
            this.b.copy(a[c]);
            this.c.copy(a[d]);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.a.copy(a.a);
            this.b.copy(a.b);
            this.c.copy(a.c);
            return this;
          },
          getArea: function() {
            Fd.subVectors(this.c, this.b);
            pf.subVectors(this.a, this.b);
            return 0.5 * Fd.cross(pf).length();
          },
          getMidpoint: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (a = new h()));
            return a
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          },
          getNormal: function(a) {
            return B.getNormal(this.a, this.b, this.c, a);
          },
          getPlane: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (a = new h()));
            return a.setFromCoplanarPoints(this.a, this.b, this.c);
          },
          getBarycoord: function(a, b) {
            return B.getBarycoord(a, this.a, this.b, this.c, b);
          },
          getUV: function(a, b, c, d, e) {
            return B.getUV(a, this.a, this.b, this.c, b, c, d, e);
          },
          containsPoint: function(a) {
            return B.containsPoint(a, this.a, this.b, this.c);
          },
          isFrontFacing: function(a) {
            return B.isFrontFacing(this.a, this.b, this.c, a);
          },
          intersectsBox: function(a) {
            return a.intersectsTriangle(this);
          },
          closestPointToPoint: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Triangle: .closestPointToPoint() target is now required"
              ),
              (b = new h()));
            var c = this.a,
              g = this.b,
              d = this.c;
            cj.subVectors(g, c);
            dj.subVectors(d, c);
            sg.subVectors(a, c);
            var e = cj.dot(sg),
              f = dj.dot(sg);
            if (0 >= e && 0 >= f) return b.copy(c);
            tg.subVectors(a, g);
            var p = cj.dot(tg),
              k = dj.dot(tg);
            if (0 <= p && k <= p) return b.copy(g);
            var l = e * k - p * f;
            if (0 >= l && 0 <= e && 0 >= p)
              return (g = e / (e - p)), b.copy(c).addScaledVector(cj, g);
            ug.subVectors(a, d);
            a = cj.dot(ug);
            var m = dj.dot(ug);
            if (0 <= m && a <= m) return b.copy(d);
            e = a * f - e * m;
            if (0 >= e && 0 <= f && 0 >= m)
              return (l = f / (f - m)), b.copy(c).addScaledVector(dj, l);
            f = p * m - a * k;
            if (0 >= f && 0 <= k - p && 0 <= a - m)
              return (
                Mh.subVectors(d, g),
                (l = (k - p) / (k - p + (a - m))),
                b.copy(g).addScaledVector(Mh, l)
              );
            d = 1 / (f + e + l);
            g = e * d;
            l *= d;
            return b
              .copy(c)
              .addScaledVector(cj, g)
              .addScaledVector(dj, l);
          },
          equals: function(a) {
            return (
              a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
            );
          }
        });
        var rj = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
          },
          Lb = { h: 0, s: 0, l: 0 },
          Bf = { h: 0, s: 0, l: 0 };
        Object.assign(M.prototype, {
          isColor: !0,
          r: 1,
          g: 1,
          b: 1,
          set: function(a) {
            a && a.isColor
              ? this.copy(a)
              : "number" === typeof a
              ? this.setHex(a)
              : "string" === typeof a && this.setStyle(a);
            return this;
          },
          setScalar: function(a) {
            this.b = this.g = this.r = a;
            return this;
          },
          setHex: function(a) {
            a = Math.floor(a);
            this.r = ((a >> 16) & 255) / 255;
            this.g = ((a >> 8) & 255) / 255;
            this.b = (a & 255) / 255;
            return this;
          },
          setRGB: function(a, b, c) {
            this.r = a;
            this.g = b;
            this.b = c;
            return this;
          },
          setHSL: function(a, b, c) {
            a = ya.euclideanModulo(a, 1);
            b = ya.clamp(b, 0, 1);
            c = ya.clamp(c, 0, 1);
            0 === b
              ? (this.r = this.g = this.b = c)
              : ((b = 0.5 >= c ? c * (1 + b) : c + b - c * b),
                (c = 2 * c - b),
                (this.r = E(c, b, a + 1 / 3)),
                (this.g = E(c, b, a)),
                (this.b = E(c, b, a - 1 / 3)));
            return this;
          },
          setStyle: function(a) {
            function b(b) {
              void 0 !== b &&
                1 > parseFloat(b) &&
                console.warn(
                  "THREE.Color: Alpha component of " + a + " will be ignored."
                );
            }
            var c;
            if ((c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a))) {
              var g = c[2];
              switch (c[1]) {
                case "rgb":
                case "rgba":
                  if (
                    (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      g
                    ))
                  )
                    return (
                      (this.r = Math.min(255, parseInt(c[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(c[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(c[3], 10)) / 255),
                      b(c[5]),
                      this
                    );
                  if (
                    (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      g
                    ))
                  )
                    return (
                      (this.r = Math.min(100, parseInt(c[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(c[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(c[3], 10)) / 100),
                      b(c[5]),
                      this
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      g
                    ))
                  ) {
                    g = parseFloat(c[1]) / 360;
                    var d = parseInt(c[2], 10) / 100,
                      e = parseInt(c[3], 10) / 100;
                    b(c[5]);
                    return this.setHSL(g, d, e);
                  }
              }
            } else if ((c = /^#([A-Fa-f0-9]+)$/.exec(a))) {
              c = c[1];
              g = c.length;
              if (3 === g)
                return (
                  (this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255),
                  (this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255),
                  (this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255),
                  this
                );
              if (6 === g)
                return (
                  (this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255),
                  (this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255),
                  (this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255),
                  this
                );
            }
            a &&
              0 < a.length &&
              ((c = rj[a]),
              void 0 !== c
                ? this.setHex(c)
                : console.warn("THREE.Color: Unknown color " + a));
            return this;
          },
          clone: function() {
            return new this.constructor(this.r, this.g, this.b);
          },
          copy: function(a) {
            this.r = a.r;
            this.g = a.g;
            this.b = a.b;
            return this;
          },
          copyGammaToLinear: function(a, b) {
            void 0 === b && (b = 2);
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this;
          },
          copyLinearToGamma: function(a, b) {
            void 0 === b && (b = 2);
            b = 0 < b ? 1 / b : 1;
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this;
          },
          convertGammaToLinear: function(a) {
            this.copyGammaToLinear(this, a);
            return this;
          },
          convertLinearToGamma: function(a) {
            this.copyLinearToGamma(this, a);
            return this;
          },
          copySRGBToLinear: function(a) {
            this.r = L(a.r);
            this.g = L(a.g);
            this.b = L(a.b);
            return this;
          },
          copyLinearToSRGB: function(a) {
            this.r = O(a.r);
            this.g = O(a.g);
            this.b = O(a.b);
            return this;
          },
          convertSRGBToLinear: function() {
            this.copySRGBToLinear(this);
            return this;
          },
          convertLinearToSRGB: function() {
            this.copyLinearToSRGB(this);
            return this;
          },
          getHex: function() {
            return (
              ((255 * this.r) << 16) ^
              ((255 * this.g) << 8) ^
              ((255 * this.b) << 0)
            );
          },
          getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
          },
          getHSL: function(a) {
            void 0 === a &&
              (console.warn("THREE.Color: .getHSL() target is now required"),
              (a = { h: 0, s: 0, l: 0 }));
            var b = this.r,
              c = this.g,
              g = this.b,
              d = Math.max(b, c, g),
              e = Math.min(b, c, g),
              f,
              h = (e + d) / 2;
            if (e === d) e = f = 0;
            else {
              var k = d - e;
              e = 0.5 >= h ? k / (d + e) : k / (2 - d - e);
              switch (d) {
                case b:
                  f = (c - g) / k + (c < g ? 6 : 0);
                  break;
                case c:
                  f = (g - b) / k + 2;
                  break;
                case g:
                  f = (b - c) / k + 4;
              }
              f /= 6;
            }
            a.h = f;
            a.s = e;
            a.l = h;
            return a;
          },
          getStyle: function() {
            return (
              "rgb(" +
              ((255 * this.r) | 0) +
              "," +
              ((255 * this.g) | 0) +
              "," +
              ((255 * this.b) | 0) +
              ")"
            );
          },
          offsetHSL: function(a, b, c) {
            this.getHSL(Lb);
            Lb.h += a;
            Lb.s += b;
            Lb.l += c;
            this.setHSL(Lb.h, Lb.s, Lb.l);
            return this;
          },
          add: function(a) {
            this.r += a.r;
            this.g += a.g;
            this.b += a.b;
            return this;
          },
          addColors: function(a, b) {
            this.r = a.r + b.r;
            this.g = a.g + b.g;
            this.b = a.b + b.b;
            return this;
          },
          addScalar: function(a) {
            this.r += a;
            this.g += a;
            this.b += a;
            return this;
          },
          sub: function(a) {
            this.r = Math.max(0, this.r - a.r);
            this.g = Math.max(0, this.g - a.g);
            this.b = Math.max(0, this.b - a.b);
            return this;
          },
          multiply: function(a) {
            this.r *= a.r;
            this.g *= a.g;
            this.b *= a.b;
            return this;
          },
          multiplyScalar: function(a) {
            this.r *= a;
            this.g *= a;
            this.b *= a;
            return this;
          },
          lerp: function(a, b) {
            this.r += (a.r - this.r) * b;
            this.g += (a.g - this.g) * b;
            this.b += (a.b - this.b) * b;
            return this;
          },
          lerpHSL: function(a, b) {
            this.getHSL(Lb);
            a.getHSL(Bf);
            a = ya.lerp(Lb.h, Bf.h, b);
            var c = ya.lerp(Lb.s, Bf.s, b);
            b = ya.lerp(Lb.l, Bf.l, b);
            this.setHSL(a, c, b);
            return this;
          },
          equals: function(a) {
            return a.r === this.r && a.g === this.g && a.b === this.b;
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.r = a[b];
            this.g = a[b + 1];
            this.b = a[b + 2];
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.r;
            a[b + 1] = this.g;
            a[b + 2] = this.b;
            return a;
          },
          toJSON: function() {
            return this.getHex();
          }
        });
        Object.assign(J.prototype, {
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.normal.copy(a.normal);
            this.color.copy(a.color);
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; b < c; b++)
              this.vertexNormals[b] = a.vertexNormals[b].clone();
            b = 0;
            for (c = a.vertexColors.length; b < c; b++)
              this.vertexColors[b] = a.vertexColors[b].clone();
            return this;
          }
        });
        var sj = 0;
        D.prototype = Object.assign(Object.create(b.prototype), {
          constructor: D,
          isMaterial: !0,
          onBeforeCompile: function() {},
          setValues: function(a) {
            if (void 0 !== a)
              for (var b in a) {
                var c = a[b];
                if (void 0 === c)
                  console.warn(
                    "THREE.Material: '" + b + "' parameter is undefined."
                  );
                else if ("shading" === b)
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = 1 === c ? !0 : !1);
                else {
                  var g = this[b];
                  void 0 === g
                    ? console.warn(
                        "THREE." +
                          this.type +
                          ": '" +
                          b +
                          "' is not a property of this material."
                      )
                    : g && g.isColor
                    ? g.set(c)
                    : g && g.isVector3 && c && c.isVector3
                    ? g.copy(c)
                    : (this[b] = c);
                }
              }
          },
          toJSON: function(a) {
            function b(a) {
              var b = [],
                c;
              for (c in a) {
                var g = a[c];
                delete g.metadata;
                b.push(g);
              }
              return b;
            }
            var c = void 0 === a || "string" === typeof a;
            c && (a = { textures: {}, images: {} });
            var g = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
              }
            };
            g.uuid = this.uuid;
            g.type = this.type;
            "" !== this.name && (g.name = this.name);
            this.color && this.color.isColor && (g.color = this.color.getHex());
            void 0 !== this.roughness && (g.roughness = this.roughness);
            void 0 !== this.metalness && (g.metalness = this.metalness);
            this.sheen && this.sheen.isColor && (g.sheen = this.sheen.getHex());
            this.emissive &&
              this.emissive.isColor &&
              (g.emissive = this.emissive.getHex());
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (g.emissiveIntensity = this.emissiveIntensity);
            this.specular &&
              this.specular.isColor &&
              (g.specular = this.specular.getHex());
            void 0 !== this.shininess && (g.shininess = this.shininess);
            void 0 !== this.clearcoat && (g.clearcoat = this.clearcoat);
            void 0 !== this.clearcoatRoughness &&
              (g.clearcoatRoughness = this.clearcoatRoughness);
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((g.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid),
              (g.clearcoatNormalScale = this.clearcoatNormalScale.toArray()));
            this.map && this.map.isTexture && (g.map = this.map.toJSON(a).uuid);
            this.matcap &&
              this.matcap.isTexture &&
              (g.matcap = this.matcap.toJSON(a).uuid);
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (g.alphaMap = this.alphaMap.toJSON(a).uuid);
            this.lightMap &&
              this.lightMap.isTexture &&
              (g.lightMap = this.lightMap.toJSON(a).uuid);
            this.aoMap &&
              this.aoMap.isTexture &&
              ((g.aoMap = this.aoMap.toJSON(a).uuid),
              (g.aoMapIntensity = this.aoMapIntensity));
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((g.bumpMap = this.bumpMap.toJSON(a).uuid),
              (g.bumpScale = this.bumpScale));
            this.normalMap &&
              this.normalMap.isTexture &&
              ((g.normalMap = this.normalMap.toJSON(a).uuid),
              (g.normalMapType = this.normalMapType),
              (g.normalScale = this.normalScale.toArray()));
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((g.displacementMap = this.displacementMap.toJSON(a).uuid),
              (g.displacementScale = this.displacementScale),
              (g.displacementBias = this.displacementBias));
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (g.roughnessMap = this.roughnessMap.toJSON(a).uuid);
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (g.metalnessMap = this.metalnessMap.toJSON(a).uuid);
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (g.emissiveMap = this.emissiveMap.toJSON(a).uuid);
            this.specularMap &&
              this.specularMap.isTexture &&
              (g.specularMap = this.specularMap.toJSON(a).uuid);
            this.envMap &&
              this.envMap.isTexture &&
              ((g.envMap = this.envMap.toJSON(a).uuid),
              (g.reflectivity = this.reflectivity),
              (g.refractionRatio = this.refractionRatio),
              void 0 !== this.combine && (g.combine = this.combine),
              void 0 !== this.envMapIntensity &&
                (g.envMapIntensity = this.envMapIntensity));
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (g.gradientMap = this.gradientMap.toJSON(a).uuid);
            void 0 !== this.size && (g.size = this.size);
            void 0 !== this.sizeAttenuation &&
              (g.sizeAttenuation = this.sizeAttenuation);
            1 !== this.blending && (g.blending = this.blending);
            !0 === this.flatShading && (g.flatShading = this.flatShading);
            0 !== this.side && (g.side = this.side);
            0 !== this.vertexColors && (g.vertexColors = this.vertexColors);
            1 > this.opacity && (g.opacity = this.opacity);
            !0 === this.transparent && (g.transparent = this.transparent);
            g.depthFunc = this.depthFunc;
            g.depthTest = this.depthTest;
            g.depthWrite = this.depthWrite;
            g.stencilWrite = this.stencilWrite;
            g.stencilWriteMask = this.stencilWriteMask;
            g.stencilFunc = this.stencilFunc;
            g.stencilRef = this.stencilRef;
            g.stencilFuncMask = this.stencilFuncMask;
            g.stencilFail = this.stencilFail;
            g.stencilZFail = this.stencilZFail;
            g.stencilZPass = this.stencilZPass;
            this.rotation &&
              0 !== this.rotation &&
              (g.rotation = this.rotation);
            !0 === this.polygonOffset && (g.polygonOffset = !0);
            0 !== this.polygonOffsetFactor &&
              (g.polygonOffsetFactor = this.polygonOffsetFactor);
            0 !== this.polygonOffsetUnits &&
              (g.polygonOffsetUnits = this.polygonOffsetUnits);
            this.linewidth &&
              1 !== this.linewidth &&
              (g.linewidth = this.linewidth);
            void 0 !== this.dashSize && (g.dashSize = this.dashSize);
            void 0 !== this.gapSize && (g.gapSize = this.gapSize);
            void 0 !== this.scale && (g.scale = this.scale);
            !0 === this.dithering && (g.dithering = !0);
            0 < this.alphaTest && (g.alphaTest = this.alphaTest);
            !0 === this.premultipliedAlpha &&
              (g.premultipliedAlpha = this.premultipliedAlpha);
            !0 === this.wireframe && (g.wireframe = this.wireframe);
            1 < this.wireframeLinewidth &&
              (g.wireframeLinewidth = this.wireframeLinewidth);
            "round" !== this.wireframeLinecap &&
              (g.wireframeLinecap = this.wireframeLinecap);
            "round" !== this.wireframeLinejoin &&
              (g.wireframeLinejoin = this.wireframeLinejoin);
            !0 === this.morphTargets && (g.morphTargets = !0);
            !0 === this.morphNormals && (g.morphNormals = !0);
            !0 === this.skinning && (g.skinning = !0);
            !1 === this.visible && (g.visible = !1);
            !1 === this.toneMapped && (g.toneMapped = !1);
            "{}" !== JSON.stringify(this.userData) &&
              (g.userData = this.userData);
            c &&
              ((c = b(a.textures)),
              (a = b(a.images)),
              0 < c.length && (g.textures = c),
              0 < a.length && (g.images = a));
            return g;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.name = a.name;
            this.fog = a.fog;
            this.blending = a.blending;
            this.side = a.side;
            this.flatShading = a.flatShading;
            this.vertexColors = a.vertexColors;
            this.opacity = a.opacity;
            this.transparent = a.transparent;
            this.blendSrc = a.blendSrc;
            this.blendDst = a.blendDst;
            this.blendEquation = a.blendEquation;
            this.blendSrcAlpha = a.blendSrcAlpha;
            this.blendDstAlpha = a.blendDstAlpha;
            this.blendEquationAlpha = a.blendEquationAlpha;
            this.depthFunc = a.depthFunc;
            this.depthTest = a.depthTest;
            this.depthWrite = a.depthWrite;
            this.stencilWrite = a.stencilWrite;
            this.stencilWriteMask = a.stencilWriteMask;
            this.stencilFunc = a.stencilFunc;
            this.stencilRef = a.stencilRef;
            this.stencilFuncMask = a.stencilFuncMask;
            this.stencilFail = a.stencilFail;
            this.stencilZFail = a.stencilZFail;
            this.stencilZPass = a.stencilZPass;
            this.colorWrite = a.colorWrite;
            this.precision = a.precision;
            this.polygonOffset = a.polygonOffset;
            this.polygonOffsetFactor = a.polygonOffsetFactor;
            this.polygonOffsetUnits = a.polygonOffsetUnits;
            this.dithering = a.dithering;
            this.alphaTest = a.alphaTest;
            this.premultipliedAlpha = a.premultipliedAlpha;
            this.visible = a.visible;
            this.toneMapped = a.toneMapped;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            this.clipShadows = a.clipShadows;
            this.clipIntersection = a.clipIntersection;
            var b = a.clippingPlanes,
              c = null;
            if (null !== b) {
              var g = b.length;
              c = Array(g);
              for (var d = 0; d !== g; ++d) c[d] = b[d].clone();
            }
            this.clippingPlanes = c;
            this.shadowSide = a.shadowSide;
            return this;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          }
        });
        F.prototype = Object.create(D.prototype);
        F.prototype.constructor = F;
        F.prototype.isMeshBasicMaterial = !0;
        F.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.map = a.map;
          this.lightMap = a.lightMap;
          this.lightMapIntensity = a.lightMapIntensity;
          this.aoMap = a.aoMap;
          this.aoMapIntensity = a.aoMapIntensity;
          this.specularMap = a.specularMap;
          this.alphaMap = a.alphaMap;
          this.envMap = a.envMap;
          this.combine = a.combine;
          this.reflectivity = a.reflectivity;
          this.refractionRatio = a.refractionRatio;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.wireframeLinecap = a.wireframeLinecap;
          this.wireframeLinejoin = a.wireframeLinejoin;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          return this;
        };
        Object.defineProperty(I.prototype, "needsUpdate", {
          set: function(a) {
            !0 === a && this.version++;
          }
        });
        Object.assign(I.prototype, {
          isBufferAttribute: !0,
          onUploadCallback: function() {},
          setDynamic: function(a) {
            this.dynamic = a;
            return this;
          },
          copy: function(a) {
            this.name = a.name;
            this.array = new a.array.constructor(a.array);
            this.itemSize = a.itemSize;
            this.count = a.count;
            this.normalized = a.normalized;
            this.dynamic = a.dynamic;
            return this;
          },
          copyAt: function(a, b, c) {
            a *= this.itemSize;
            c *= b.itemSize;
            for (var g = 0, d = this.itemSize; g < d; g++)
              this.array[a + g] = b.array[c + g];
            return this;
          },
          copyArray: function(a) {
            this.array.set(a);
            return this;
          },
          copyColorsArray: function(a) {
            for (var b = this.array, c = 0, g = 0, d = a.length; g < d; g++) {
              var e = a[g];
              void 0 === e &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  g
                ),
                (e = new M()));
              b[c++] = e.r;
              b[c++] = e.g;
              b[c++] = e.b;
            }
            return this;
          },
          copyVector2sArray: function(a) {
            for (var b = this.array, g = 0, d = 0, e = a.length; d < e; d++) {
              var f = a[d];
              void 0 === f &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  d
                ),
                (f = new c()));
              b[g++] = f.x;
              b[g++] = f.y;
            }
            return this;
          },
          copyVector3sArray: function(a) {
            for (var b = this.array, c = 0, g = 0, d = a.length; g < d; g++) {
              var e = a[g];
              void 0 === e &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  g
                ),
                (e = new h()));
              b[c++] = e.x;
              b[c++] = e.y;
              b[c++] = e.z;
            }
            return this;
          },
          copyVector4sArray: function(a) {
            for (var b = this.array, c = 0, g = 0, d = a.length; g < d; g++) {
              var e = a[g];
              void 0 === e &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  g
                ),
                (e = new m()));
              b[c++] = e.x;
              b[c++] = e.y;
              b[c++] = e.z;
              b[c++] = e.w;
            }
            return this;
          },
          set: function(a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this;
          },
          getX: function(a) {
            return this.array[a * this.itemSize];
          },
          setX: function(a, b) {
            this.array[a * this.itemSize] = b;
            return this;
          },
          getY: function(a) {
            return this.array[a * this.itemSize + 1];
          },
          setY: function(a, b) {
            this.array[a * this.itemSize + 1] = b;
            return this;
          },
          getZ: function(a) {
            return this.array[a * this.itemSize + 2];
          },
          setZ: function(a, b) {
            this.array[a * this.itemSize + 2] = b;
            return this;
          },
          getW: function(a) {
            return this.array[a * this.itemSize + 3];
          },
          setW: function(a, b) {
            this.array[a * this.itemSize + 3] = b;
            return this;
          },
          setXY: function(a, b, c) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            return this;
          },
          setXYZ: function(a, b, c, d) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            return this;
          },
          setXYZW: function(a, b, c, d, e) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            this.array[a + 3] = e;
            return this;
          },
          onUpload: function(a) {
            this.onUploadCallback = a;
            return this;
          },
          clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          },
          toJSON: function() {
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized
            };
          }
        });
        V.prototype = Object.create(I.prototype);
        V.prototype.constructor = V;
        W.prototype = Object.create(I.prototype);
        W.prototype.constructor = W;
        T.prototype = Object.create(I.prototype);
        T.prototype.constructor = T;
        ba.prototype = Object.create(I.prototype);
        ba.prototype.constructor = ba;
        ca.prototype = Object.create(I.prototype);
        ca.prototype.constructor = ca;
        ha.prototype = Object.create(I.prototype);
        ha.prototype.constructor = ha;
        fa.prototype = Object.create(I.prototype);
        fa.prototype.constructor = fa;
        P.prototype = Object.create(I.prototype);
        P.prototype.constructor = P;
        ja.prototype = Object.create(I.prototype);
        ja.prototype.constructor = ja;
        Object.assign(ra.prototype, {
          computeGroups: function(a) {
            var b = [],
              c = void 0;
            a = a.faces;
            for (var g = 0; g < a.length; g++) {
              var d = a[g];
              if (d.materialIndex !== c) {
                c = d.materialIndex;
                void 0 !== e && ((e.count = 3 * g - e.start), b.push(e));
                var e = { start: 3 * g, materialIndex: c };
              }
            }
            void 0 !== e && ((e.count = 3 * g - e.start), b.push(e));
            this.groups = b;
          },
          fromGeometry: function(a) {
            var b = a.faces,
              g = a.vertices,
              d = a.faceVertexUvs,
              e = d[0] && 0 < d[0].length,
              f = d[1] && 0 < d[1].length,
              h = a.morphTargets,
              k = h.length;
            if (0 < k) {
              var l = [];
              for (var m = 0; m < k; m++) l[m] = { name: h[m].name, data: [] };
              this.morphTargets.position = l;
            }
            var n = a.morphNormals,
              q = n.length;
            if (0 < q) {
              var t = [];
              for (m = 0; m < q; m++) t[m] = { name: n[m].name, data: [] };
              this.morphTargets.normal = t;
            }
            var u = a.skinIndices,
              r = a.skinWeights,
              y = u.length === g.length,
              v = r.length === g.length;
            0 < g.length &&
              0 === b.length &&
              console.error(
                "THREE.DirectGeometry: Faceless geometries are not supported."
              );
            for (m = 0; m < b.length; m++) {
              var A = b[m];
              this.vertices.push(g[A.a], g[A.b], g[A.c]);
              var z = A.vertexNormals;
              3 === z.length
                ? this.normals.push(z[0], z[1], z[2])
                : ((z = A.normal), this.normals.push(z, z, z));
              z = A.vertexColors;
              3 === z.length
                ? this.colors.push(z[0], z[1], z[2])
                : ((z = A.color), this.colors.push(z, z, z));
              !0 === e &&
                ((z = d[0][m]),
                void 0 !== z
                  ? this.uvs.push(z[0], z[1], z[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      m
                    ),
                    this.uvs.push(new c(), new c(), new c())));
              !0 === f &&
                ((z = d[1][m]),
                void 0 !== z
                  ? this.uvs2.push(z[0], z[1], z[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                      m
                    ),
                    this.uvs2.push(new c(), new c(), new c())));
              for (z = 0; z < k; z++) {
                var C = h[z].vertices;
                l[z].data.push(C[A.a], C[A.b], C[A.c]);
              }
              for (z = 0; z < q; z++)
                (C = n[z].vertexNormals[m]), t[z].data.push(C.a, C.b, C.c);
              y && this.skinIndices.push(u[A.a], u[A.b], u[A.c]);
              v && this.skinWeights.push(r[A.a], r[A.b], r[A.c]);
            }
            this.computeGroups(a);
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            null !== a.boundingSphere &&
              (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox &&
              (this.boundingBox = a.boundingBox.clone());
            return this;
          }
        });
        var tj = 1,
          De = new t(),
          vg = new v(),
          Df = new h(),
          Dh = new C(),
          wg = new C(),
          Gd = new h();
        S.prototype = Object.assign(Object.create(b.prototype), {
          constructor: S,
          isBufferGeometry: !0,
          getIndex: function() {
            return this.index;
          },
          setIndex: function(a) {
            Array.isArray(a)
              ? (this.index = new (65535 < sa(a) ? fa : ca)(a, 1))
              : (this.index = a);
          },
          addAttribute: function(a, b, c) {
            return (b && b.isBufferAttribute) ||
              (b && b.isInterleavedBufferAttribute)
              ? "index" === a
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(b),
                  this)
                : this.setAttribute(a, b)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.addAttribute(a, new I(b, c)));
          },
          getAttribute: function(a) {
            return this.attributes[a];
          },
          setAttribute: function(a, b) {
            this.attributes[a] = b;
            return this;
          },
          removeAttribute: function(a) {
            delete this.attributes[a];
            return this;
          },
          addGroup: function(a, b, c) {
            this.groups.push({
              start: a,
              count: b,
              materialIndex: void 0 !== c ? c : 0
            });
          },
          clearGroups: function() {
            this.groups = [];
          },
          setDrawRange: function(a, b) {
            this.drawRange.start = a;
            this.drawRange.count = b;
          },
          applyMatrix: function(a) {
            var b = this.attributes.position;
            void 0 !== b && (a.applyToBufferAttribute(b), (b.needsUpdate = !0));
            var c = this.attributes.normal;
            void 0 !== c &&
              ((b = new k().getNormalMatrix(a)),
              b.applyToBufferAttribute(c),
              (c.needsUpdate = !0));
            c = this.attributes.tangent;
            void 0 !== c &&
              ((b = new k().getNormalMatrix(a)),
              b.applyToBufferAttribute(c),
              (c.needsUpdate = !0));
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            return this;
          },
          rotateX: function(a) {
            De.makeRotationX(a);
            this.applyMatrix(De);
            return this;
          },
          rotateY: function(a) {
            De.makeRotationY(a);
            this.applyMatrix(De);
            return this;
          },
          rotateZ: function(a) {
            De.makeRotationZ(a);
            this.applyMatrix(De);
            return this;
          },
          translate: function(a, b, c) {
            De.makeTranslation(a, b, c);
            this.applyMatrix(De);
            return this;
          },
          scale: function(a, b, c) {
            De.makeScale(a, b, c);
            this.applyMatrix(De);
            return this;
          },
          lookAt: function(a) {
            vg.lookAt(a);
            vg.updateMatrix();
            this.applyMatrix(vg.matrix);
            return this;
          },
          center: function() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(Df).negate();
            this.translate(Df.x, Df.y, Df.z);
            return this;
          },
          setFromObject: function(a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
              a = new P(3 * b.vertices.length, 3);
              var c = new P(3 * b.colors.length, 3);
              this.addAttribute("position", a.copyVector3sArray(b.vertices));
              this.addAttribute("color", c.copyColorsArray(b.colors));
              b.lineDistances &&
                b.lineDistances.length === b.vertices.length &&
                ((a = new P(b.lineDistances.length, 1)),
                this.addAttribute(
                  "lineDistance",
                  a.copyArray(b.lineDistances)
                ));
              null !== b.boundingSphere &&
                (this.boundingSphere = b.boundingSphere.clone());
              null !== b.boundingBox &&
                (this.boundingBox = b.boundingBox.clone());
            } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this;
          },
          setFromPoints: function(a) {
            for (var b = [], c = 0, g = a.length; c < g; c++) {
              var d = a[c];
              b.push(d.x, d.y, d.z || 0);
            }
            this.addAttribute("position", new P(b, 3));
            return this;
          },
          updateFromObject: function(a) {
            var b = a.geometry;
            if (a.isMesh) {
              var c = b.__directGeometry;
              !0 === b.elementsNeedUpdate &&
                ((c = void 0), (b.elementsNeedUpdate = !1));
              if (void 0 === c) return this.fromGeometry(b);
              c.verticesNeedUpdate = b.verticesNeedUpdate;
              c.normalsNeedUpdate = b.normalsNeedUpdate;
              c.colorsNeedUpdate = b.colorsNeedUpdate;
              c.uvsNeedUpdate = b.uvsNeedUpdate;
              c.groupsNeedUpdate = b.groupsNeedUpdate;
              b.verticesNeedUpdate = !1;
              b.normalsNeedUpdate = !1;
              b.colorsNeedUpdate = !1;
              b.uvsNeedUpdate = !1;
              b.groupsNeedUpdate = !1;
              b = c;
            }
            !0 === b.verticesNeedUpdate &&
              ((c = this.attributes.position),
              void 0 !== c &&
                (c.copyVector3sArray(b.vertices), (c.needsUpdate = !0)),
              (b.verticesNeedUpdate = !1));
            !0 === b.normalsNeedUpdate &&
              ((c = this.attributes.normal),
              void 0 !== c &&
                (c.copyVector3sArray(b.normals), (c.needsUpdate = !0)),
              (b.normalsNeedUpdate = !1));
            !0 === b.colorsNeedUpdate &&
              ((c = this.attributes.color),
              void 0 !== c &&
                (c.copyColorsArray(b.colors), (c.needsUpdate = !0)),
              (b.colorsNeedUpdate = !1));
            b.uvsNeedUpdate &&
              ((c = this.attributes.uv),
              void 0 !== c &&
                (c.copyVector2sArray(b.uvs), (c.needsUpdate = !0)),
              (b.uvsNeedUpdate = !1));
            b.lineDistancesNeedUpdate &&
              ((c = this.attributes.lineDistance),
              void 0 !== c &&
                (c.copyArray(b.lineDistances), (c.needsUpdate = !0)),
              (b.lineDistancesNeedUpdate = !1));
            b.groupsNeedUpdate &&
              (b.computeGroups(a.geometry),
              (this.groups = b.groups),
              (b.groupsNeedUpdate = !1));
            return this;
          },
          fromGeometry: function(a) {
            a.__directGeometry = new ra().fromGeometry(a);
            return this.fromDirectGeometry(a.__directGeometry);
          },
          fromDirectGeometry: function(a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.addAttribute(
              "position",
              new I(b, 3).copyVector3sArray(a.vertices)
            );
            0 < a.normals.length &&
              ((b = new Float32Array(3 * a.normals.length)),
              this.addAttribute(
                "normal",
                new I(b, 3).copyVector3sArray(a.normals)
              ));
            0 < a.colors.length &&
              ((b = new Float32Array(3 * a.colors.length)),
              this.addAttribute(
                "color",
                new I(b, 3).copyColorsArray(a.colors)
              ));
            0 < a.uvs.length &&
              ((b = new Float32Array(2 * a.uvs.length)),
              this.addAttribute("uv", new I(b, 2).copyVector2sArray(a.uvs)));
            0 < a.uvs2.length &&
              ((b = new Float32Array(2 * a.uvs2.length)),
              this.addAttribute("uv2", new I(b, 2).copyVector2sArray(a.uvs2)));
            this.groups = a.groups;
            for (var c in a.morphTargets) {
              b = [];
              for (var g = a.morphTargets[c], d = 0, e = g.length; d < e; d++) {
                var f = g[d],
                  h = new P(3 * f.data.length, 3);
                h.name = f.name;
                b.push(h.copyVector3sArray(f.data));
              }
              this.morphAttributes[c] = b;
            }
            0 < a.skinIndices.length &&
              ((c = new P(4 * a.skinIndices.length, 4)),
              this.addAttribute(
                "skinIndex",
                c.copyVector4sArray(a.skinIndices)
              ));
            0 < a.skinWeights.length &&
              ((c = new P(4 * a.skinWeights.length, 4)),
              this.addAttribute(
                "skinWeight",
                c.copyVector4sArray(a.skinWeights)
              ));
            null !== a.boundingSphere &&
              (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox &&
              (this.boundingBox = a.boundingBox.clone());
            return this;
          },
          computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new C());
            var a = this.attributes.position,
              b = this.morphAttributes.position;
            if (void 0 !== a) {
              if ((this.boundingBox.setFromBufferAttribute(a), b)) {
                a = 0;
                for (var c = b.length; a < c; a++)
                  Dh.setFromBufferAttribute(b[a]),
                    this.boundingBox.expandByPoint(Dh.min),
                    this.boundingBox.expandByPoint(Dh.max);
              }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          },
          computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new H());
            var a = this.attributes.position,
              b = this.morphAttributes.position;
            if (a) {
              var c = this.boundingSphere.center;
              Dh.setFromBufferAttribute(a);
              if (b)
                for (var d = 0, e = b.length; d < e; d++) {
                  var f = b[d];
                  wg.setFromBufferAttribute(f);
                  Dh.expandByPoint(wg.min);
                  Dh.expandByPoint(wg.max);
                }
              Dh.getCenter(c);
              var h = 0;
              d = 0;
              for (e = a.count; d < e; d++)
                Gd.fromBufferAttribute(a, d),
                  (h = Math.max(h, c.distanceToSquared(Gd)));
              if (b)
                for (d = 0, e = b.length; d < e; d++) {
                  f = b[d];
                  a = 0;
                  for (var k = f.count; a < k; a++)
                    Gd.fromBufferAttribute(f, a),
                      (h = Math.max(h, c.distanceToSquared(Gd)));
                }
              this.boundingSphere.radius = Math.sqrt(h);
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
            }
          },
          computeFaceNormals: function() {},
          computeVertexNormals: function() {
            var a = this.index,
              b = this.attributes;
            if (b.position) {
              var c = b.position.array;
              if (void 0 === b.normal)
                this.addAttribute(
                  "normal",
                  new I(new Float32Array(c.length), 3)
                );
              else
                for (var d = b.normal.array, e = 0, f = d.length; e < f; e++)
                  d[e] = 0;
              d = b.normal.array;
              var k = new h(),
                l = new h(),
                m = new h(),
                n = new h(),
                q = new h();
              if (a) {
                var t = a.array;
                e = 0;
                for (f = a.count; e < f; e += 3) {
                  a = 3 * t[e + 0];
                  var u = 3 * t[e + 1];
                  var r = 3 * t[e + 2];
                  k.fromArray(c, a);
                  l.fromArray(c, u);
                  m.fromArray(c, r);
                  n.subVectors(m, l);
                  q.subVectors(k, l);
                  n.cross(q);
                  d[a] += n.x;
                  d[a + 1] += n.y;
                  d[a + 2] += n.z;
                  d[u] += n.x;
                  d[u + 1] += n.y;
                  d[u + 2] += n.z;
                  d[r] += n.x;
                  d[r + 1] += n.y;
                  d[r + 2] += n.z;
                }
              } else
                for (e = 0, f = c.length; e < f; e += 9)
                  k.fromArray(c, e),
                    l.fromArray(c, e + 3),
                    m.fromArray(c, e + 6),
                    n.subVectors(m, l),
                    q.subVectors(k, l),
                    n.cross(q),
                    (d[e] = n.x),
                    (d[e + 1] = n.y),
                    (d[e + 2] = n.z),
                    (d[e + 3] = n.x),
                    (d[e + 4] = n.y),
                    (d[e + 5] = n.z),
                    (d[e + 6] = n.x),
                    (d[e + 7] = n.y),
                    (d[e + 8] = n.z);
              this.normalizeNormals();
              b.normal.needsUpdate = !0;
            }
          },
          merge: function(a, b) {
            if (a && a.isBufferGeometry) {
              void 0 === b &&
                ((b = 0),
                console.warn(
                  "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                ));
              var c = this.attributes,
                g;
              for (g in c)
                if (void 0 !== a.attributes[g]) {
                  var d = c[g].array,
                    e = a.attributes[g],
                    f = e.array,
                    h = e.itemSize * b;
                  e = Math.min(f.length, d.length - h);
                  for (var p = 0; p < e; p++, h++) d[h] = f[p];
                }
              return this;
            }
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              a
            );
          },
          normalizeNormals: function() {
            for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++)
              (Gd.x = a.getX(b)),
                (Gd.y = a.getY(b)),
                (Gd.z = a.getZ(b)),
                Gd.normalize(),
                a.setXYZ(b, Gd.x, Gd.y, Gd.z);
          },
          toNonIndexed: function() {
            function a(a, b) {
              var c = a.array;
              a = a.itemSize;
              for (
                var g = new c.constructor(b.length * a),
                  d,
                  e = 0,
                  f = 0,
                  h = b.length;
                f < h;
                f++
              ) {
                d = b[f] * a;
                for (var p = 0; p < a; p++) g[e++] = c[d++];
              }
              return new I(g, a);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
                ),
                this
              );
            var b = new S(),
              c = this.index.array,
              d = this.attributes,
              e;
            for (e in d) {
              var f = d[e];
              f = a(f, c);
              b.addAttribute(e, f);
            }
            var h = this.morphAttributes;
            for (e in h) {
              var k = [],
                l = h[e];
              d = 0;
              for (var m = l.length; d < m; d++)
                (f = l[d]), (f = a(f, c)), k.push(f);
              b.morphAttributes[e] = k;
            }
            c = this.groups;
            d = 0;
            for (e = c.length; d < e; d++)
              (f = c[d]), b.addGroup(f.start, f.count, f.materialIndex);
            return b;
          },
          toJSON: function() {
            var a = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
              }
            };
            a.uuid = this.uuid;
            a.type = this.type;
            "" !== this.name && (a.name = this.name);
            0 < Object.keys(this.userData).length &&
              (a.userData = this.userData);
            if (void 0 !== this.parameters) {
              var b = this.parameters;
              for (m in b) void 0 !== b[m] && (a[m] = b[m]);
              return a;
            }
            a.data = { attributes: {} };
            b = this.index;
            null !== b &&
              (a.data.index = {
                type: b.array.constructor.name,
                array: Array.prototype.slice.call(b.array)
              });
            var c = this.attributes;
            for (m in c) {
              b = c[m];
              var d = b.toJSON();
              "" !== b.name && (d.name = b.name);
              a.data.attributes[m] = d;
            }
            c = {};
            var e = !1;
            for (m in this.morphAttributes) {
              for (
                var f = this.morphAttributes[m], h = [], k = 0, l = f.length;
                k < l;
                k++
              )
                (b = f[k]),
                  (d = b.toJSON()),
                  "" !== b.name && (d.name = b.name),
                  h.push(d);
              0 < h.length && ((c[m] = h), (e = !0));
            }
            e && (a.data.morphAttributes = c);
            var m = this.groups;
            0 < m.length && (a.data.groups = JSON.parse(JSON.stringify(m)));
            m = this.boundingSphere;
            null !== m &&
              (a.data.boundingSphere = {
                center: m.center.toArray(),
                radius: m.radius
              });
            return a;
          },
          clone: function() {
            return new S().copy(this);
          },
          copy: function(a) {
            var b;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var c = a.index;
            null !== c && this.setIndex(c.clone());
            c = a.attributes;
            for (f in c) this.addAttribute(f, c[f].clone());
            var g = a.morphAttributes;
            for (f in g) {
              var d = [],
                e = g[f];
              c = 0;
              for (b = e.length; c < b; c++) d.push(e[c].clone());
              this.morphAttributes[f] = d;
            }
            var f = a.groups;
            c = 0;
            for (b = f.length; c < b; c++)
              (g = f[c]), this.addGroup(g.start, g.count, g.materialIndex);
            f = a.boundingBox;
            null !== f && (this.boundingBox = f.clone());
            f = a.boundingSphere;
            null !== f && (this.boundingSphere = f.clone());
            this.drawRange.start = a.drawRange.start;
            this.drawRange.count = a.drawRange.count;
            this.userData = a.userData;
            return this;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          }
        });
        var Oh = new t(),
          Eh = new N(),
          xg = new H(),
          kh = new h(),
          lh = new h(),
          mh = new h(),
          Ph = new h(),
          Qh = new h(),
          Rh = new h(),
          yg = new h(),
          Ag = new h(),
          Bg = new h(),
          Ai = new c(),
          Bi = new c(),
          Ci = new c(),
          Sj = new h(),
          Hf = new h();
        da.prototype = Object.assign(Object.create(v.prototype), {
          constructor: da,
          isMesh: !0,
          setDrawMode: function(a) {
            this.drawMode = a;
          },
          copy: function(a) {
            v.prototype.copy.call(this, a);
            this.drawMode = a.drawMode;
            void 0 !== a.morphTargetInfluences &&
              (this.morphTargetInfluences = a.morphTargetInfluences.slice());
            void 0 !== a.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                a.morphTargetDictionary
              ));
            return this;
          },
          updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
              a = a.morphAttributes;
              var b = Object.keys(a);
              if (0 < b.length) {
                var c = a[b[0]];
                if (void 0 !== c)
                  for (
                    this.morphTargetInfluences = [],
                      this.morphTargetDictionary = {},
                      a = 0,
                      b = c.length;
                    a < b;
                    a++
                  ) {
                    var d = c[a].name || String(a);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[d] = a;
                  }
              }
            } else
              (a = a.morphTargets),
                void 0 !== a &&
                  0 < a.length &&
                  console.error(
                    "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                  );
          },
          raycast: function(a, b) {
            var g = this.geometry,
              d = this.material,
              e = this.matrixWorld;
            if (
              void 0 !== d &&
              (null === g.boundingSphere && g.computeBoundingSphere(),
              xg.copy(g.boundingSphere),
              xg.applyMatrix4(e),
              !1 !== a.ray.intersectsSphere(xg) &&
                (Oh.getInverse(e),
                Eh.copy(a.ray).applyMatrix4(Oh),
                null === g.boundingBox ||
                  !1 !== Eh.intersectsBox(g.boundingBox)))
            )
              if (g.isBufferGeometry) {
                var f = g.index;
                e = g.attributes.position;
                var h = g.morphAttributes.position,
                  p = g.attributes.uv,
                  k = g.attributes.uv2,
                  l = g.groups,
                  m = g.drawRange,
                  n,
                  q;
                if (null !== f)
                  if (Array.isArray(d)) {
                    var t = 0;
                    for (n = l.length; t < n; t++) {
                      var u = l[t];
                      var r = d[u.materialIndex];
                      var y = Math.max(u.start, m.start);
                      for (
                        q = g = Math.min(u.start + u.count, m.start + m.count);
                        y < q;
                        y += 3
                      ) {
                        g = f.getX(y);
                        var v = f.getX(y + 1);
                        var z = f.getX(y + 2);
                        if ((g = ma(this, r, a, Eh, e, h, p, k, g, v, z)))
                          (g.faceIndex = Math.floor(y / 3)),
                            (g.face.materialIndex = u.materialIndex),
                            b.push(g);
                      }
                    }
                  } else
                    for (
                      y = Math.max(0, m.start),
                        g = Math.min(f.count, m.start + m.count),
                        t = y,
                        n = g;
                      t < n;
                      t += 3
                    ) {
                      if (
                        ((g = f.getX(t)),
                        (v = f.getX(t + 1)),
                        (z = f.getX(t + 2)),
                        (g = ma(this, d, a, Eh, e, h, p, k, g, v, z)))
                      )
                        (g.faceIndex = Math.floor(t / 3)), b.push(g);
                    }
                else if (void 0 !== e)
                  if (Array.isArray(d))
                    for (t = 0, n = l.length; t < n; t++)
                      for (
                        u = l[t],
                          r = d[u.materialIndex],
                          y = Math.max(u.start, m.start),
                          q = g = Math.min(
                            u.start + u.count,
                            m.start + m.count
                          );
                        y < q;
                        y += 3
                      ) {
                        if (
                          ((g = y),
                          (v = y + 1),
                          (z = y + 2),
                          (g = ma(this, r, a, Eh, e, h, p, k, g, v, z)))
                        )
                          (g.faceIndex = Math.floor(y / 3)),
                            (g.face.materialIndex = u.materialIndex),
                            b.push(g);
                      }
                  else
                    for (
                      y = Math.max(0, m.start),
                        g = Math.min(e.count, m.start + m.count),
                        t = y,
                        n = g;
                      t < n;
                      t += 3
                    )
                      if (
                        ((g = t),
                        (v = t + 1),
                        (z = t + 2),
                        (g = ma(this, d, a, Eh, e, h, p, k, g, v, z)))
                      )
                        (g.faceIndex = Math.floor(t / 3)), b.push(g);
              } else if (g.isGeometry)
                for (
                  e = Array.isArray(d),
                    h = g.vertices,
                    p = g.faces,
                    g = g.faceVertexUvs[0],
                    0 < g.length && (f = g),
                    t = 0,
                    n = p.length;
                  t < n;
                  t++
                )
                  if (
                    ((u = p[t]),
                    (g = e ? d[u.materialIndex] : d),
                    void 0 !== g &&
                      ((k = h[u.a]),
                      (l = h[u.b]),
                      (m = h[u.c]),
                      (g = X(this, g, a, Eh, k, l, m, Sj))))
                  )
                    f &&
                      f[t] &&
                      ((r = f[t]),
                      Ai.copy(r[0]),
                      Bi.copy(r[1]),
                      Ci.copy(r[2]),
                      (g.uv = B.getUV(Sj, k, l, m, Ai, Bi, Ci, new c()))),
                      (g.face = u),
                      (g.faceIndex = t),
                      b.push(g);
          },
          clone: function() {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          }
        });
        var uj = 0,
          Ee = new t(),
          Cg = new v(),
          rk = new h();
        U.prototype = Object.assign(Object.create(b.prototype), {
          constructor: U,
          isGeometry: !0,
          applyMatrix: function(a) {
            for (
              var b = new k().getNormalMatrix(a),
                c = 0,
                g = this.vertices.length;
              c < g;
              c++
            )
              this.vertices[c].applyMatrix4(a);
            c = 0;
            for (g = this.faces.length; c < g; c++) {
              a = this.faces[c];
              a.normal.applyMatrix3(b).normalize();
              for (var d = 0, e = a.vertexNormals.length; d < e; d++)
                a.vertexNormals[d].applyMatrix3(b).normalize();
            }
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
            return this;
          },
          rotateX: function(a) {
            Ee.makeRotationX(a);
            this.applyMatrix(Ee);
            return this;
          },
          rotateY: function(a) {
            Ee.makeRotationY(a);
            this.applyMatrix(Ee);
            return this;
          },
          rotateZ: function(a) {
            Ee.makeRotationZ(a);
            this.applyMatrix(Ee);
            return this;
          },
          translate: function(a, b, c) {
            Ee.makeTranslation(a, b, c);
            this.applyMatrix(Ee);
            return this;
          },
          scale: function(a, b, c) {
            Ee.makeScale(a, b, c);
            this.applyMatrix(Ee);
            return this;
          },
          lookAt: function(a) {
            Cg.lookAt(a);
            Cg.updateMatrix();
            this.applyMatrix(Cg.matrix);
            return this;
          },
          fromBufferGeometry: function(a) {
            function b(a, b, d, e) {
              var f =
                  void 0 === l
                    ? []
                    : [
                        g.colors[a].clone(),
                        g.colors[b].clone(),
                        g.colors[d].clone()
                      ],
                p =
                  void 0 === k
                    ? []
                    : [
                        new h().fromArray(k, 3 * a),
                        new h().fromArray(k, 3 * b),
                        new h().fromArray(k, 3 * d)
                      ];
              e = new J(a, b, d, p, f, e);
              g.faces.push(e);
              void 0 !== m &&
                g.faceVertexUvs[0].push([
                  new c().fromArray(m, 2 * a),
                  new c().fromArray(m, 2 * b),
                  new c().fromArray(m, 2 * d)
                ]);
              void 0 !== n &&
                g.faceVertexUvs[1].push([
                  new c().fromArray(n, 2 * a),
                  new c().fromArray(n, 2 * b),
                  new c().fromArray(n, 2 * d)
                ]);
            }
            var g = this,
              d = null !== a.index ? a.index.array : void 0,
              e = a.attributes;
            if (void 0 === e.position)
              return (
                console.error(
                  "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
                ),
                this
              );
            var f = e.position.array,
              k = void 0 !== e.normal ? e.normal.array : void 0,
              l = void 0 !== e.color ? e.color.array : void 0,
              m = void 0 !== e.uv ? e.uv.array : void 0,
              n = void 0 !== e.uv2 ? e.uv2.array : void 0;
            void 0 !== n && (this.faceVertexUvs[1] = []);
            for (e = 0; e < f.length; e += 3)
              g.vertices.push(new h().fromArray(f, e)),
                void 0 !== l && g.colors.push(new M().fromArray(l, e));
            var q = a.groups;
            if (0 < q.length)
              for (e = 0; e < q.length; e++) {
                f = q[e];
                var t = f.start,
                  u = t;
                for (t += f.count; u < t; u += 3)
                  void 0 !== d
                    ? b(d[u], d[u + 1], d[u + 2], f.materialIndex)
                    : b(u, u + 1, u + 2, f.materialIndex);
              }
            else if (void 0 !== d)
              for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
            else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
            this.computeFaceNormals();
            null !== a.boundingBox &&
              (this.boundingBox = a.boundingBox.clone());
            null !== a.boundingSphere &&
              (this.boundingSphere = a.boundingSphere.clone());
            return this;
          },
          center: function() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(rk).negate();
            this.translate(rk.x, rk.y, rk.z);
            return this;
          },
          normalize: function() {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center,
              b = this.boundingSphere.radius;
            b = 0 === b ? 1 : 1 / b;
            var c = new t();
            c.set(
              b,
              0,
              0,
              -b * a.x,
              0,
              b,
              0,
              -b * a.y,
              0,
              0,
              b,
              -b * a.z,
              0,
              0,
              0,
              1
            );
            this.applyMatrix(c);
            return this;
          },
          computeFaceNormals: function() {
            for (
              var a = new h(), b = new h(), c = 0, d = this.faces.length;
              c < d;
              c++
            ) {
              var e = this.faces[c],
                f = this.vertices[e.a],
                k = this.vertices[e.b];
              a.subVectors(this.vertices[e.c], k);
              b.subVectors(f, k);
              a.cross(b);
              a.normalize();
              e.normal.copy(a);
            }
          },
          computeVertexNormals: function(a) {
            void 0 === a && (a = !0);
            var b;
            var c = Array(this.vertices.length);
            var g = 0;
            for (b = this.vertices.length; g < b; g++) c[g] = new h();
            if (a) {
              var d = new h(),
                e = new h();
              a = 0;
              for (g = this.faces.length; a < g; a++) {
                b = this.faces[a];
                var f = this.vertices[b.a];
                var k = this.vertices[b.b];
                var l = this.vertices[b.c];
                d.subVectors(l, k);
                e.subVectors(f, k);
                d.cross(e);
                c[b.a].add(d);
                c[b.b].add(d);
                c[b.c].add(d);
              }
            } else
              for (
                this.computeFaceNormals(), a = 0, g = this.faces.length;
                a < g;
                a++
              )
                (b = this.faces[a]),
                  c[b.a].add(b.normal),
                  c[b.b].add(b.normal),
                  c[b.c].add(b.normal);
            g = 0;
            for (b = this.vertices.length; g < b; g++) c[g].normalize();
            a = 0;
            for (g = this.faces.length; a < g; a++)
              (b = this.faces[a]),
                (f = b.vertexNormals),
                3 === f.length
                  ? (f[0].copy(c[b.a]), f[1].copy(c[b.b]), f[2].copy(c[b.c]))
                  : ((f[0] = c[b.a].clone()),
                    (f[1] = c[b.b].clone()),
                    (f[2] = c[b.c].clone()));
            0 < this.faces.length && (this.normalsNeedUpdate = !0);
          },
          computeFlatVertexNormals: function() {
            var a;
            this.computeFaceNormals();
            var b = 0;
            for (a = this.faces.length; b < a; b++) {
              var c = this.faces[b];
              var d = c.vertexNormals;
              3 === d.length
                ? (d[0].copy(c.normal),
                  d[1].copy(c.normal),
                  d[2].copy(c.normal))
                : ((d[0] = c.normal.clone()),
                  (d[1] = c.normal.clone()),
                  (d[2] = c.normal.clone()));
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0);
          },
          computeMorphNormals: function() {
            var a, b;
            var c = 0;
            for (b = this.faces.length; c < b; c++) {
              var d = this.faces[c];
              d.__originalFaceNormal
                ? d.__originalFaceNormal.copy(d.normal)
                : (d.__originalFaceNormal = d.normal.clone());
              d.__originalVertexNormals || (d.__originalVertexNormals = []);
              var e = 0;
              for (a = d.vertexNormals.length; e < a; e++)
                d.__originalVertexNormals[e]
                  ? d.__originalVertexNormals[e].copy(d.vertexNormals[e])
                  : (d.__originalVertexNormals[e] = d.vertexNormals[e].clone());
            }
            var f = new U();
            f.faces = this.faces;
            e = 0;
            for (a = this.morphTargets.length; e < a; e++) {
              if (!this.morphNormals[e]) {
                this.morphNormals[e] = {};
                this.morphNormals[e].faceNormals = [];
                this.morphNormals[e].vertexNormals = [];
                d = this.morphNormals[e].faceNormals;
                var k = this.morphNormals[e].vertexNormals;
                c = 0;
                for (b = this.faces.length; c < b; c++) {
                  var l = new h();
                  var m = { a: new h(), b: new h(), c: new h() };
                  d.push(l);
                  k.push(m);
                }
              }
              k = this.morphNormals[e];
              f.vertices = this.morphTargets[e].vertices;
              f.computeFaceNormals();
              f.computeVertexNormals();
              c = 0;
              for (b = this.faces.length; c < b; c++)
                (d = this.faces[c]),
                  (l = k.faceNormals[c]),
                  (m = k.vertexNormals[c]),
                  l.copy(d.normal),
                  m.a.copy(d.vertexNormals[0]),
                  m.b.copy(d.vertexNormals[1]),
                  m.c.copy(d.vertexNormals[2]);
            }
            c = 0;
            for (b = this.faces.length; c < b; c++)
              (d = this.faces[c]),
                (d.normal = d.__originalFaceNormal),
                (d.vertexNormals = d.__originalVertexNormals);
          },
          computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new C());
            this.boundingBox.setFromPoints(this.vertices);
          },
          computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new H());
            this.boundingSphere.setFromPoints(this.vertices);
          },
          merge: function(a, b, c) {
            if (a && a.isGeometry) {
              var g,
                d = this.vertices.length,
                e = this.vertices,
                f = a.vertices,
                h = this.faces,
                p = a.faces,
                l = this.colors,
                w = a.colors;
              void 0 === c && (c = 0);
              void 0 !== b && (g = new k().getNormalMatrix(b));
              for (var m = 0, n = f.length; m < n; m++) {
                var q = f[m].clone();
                void 0 !== b && q.applyMatrix4(b);
                e.push(q);
              }
              m = 0;
              for (n = w.length; m < n; m++) l.push(w[m].clone());
              m = 0;
              for (n = p.length; m < n; m++) {
                f = p[m];
                var t = f.vertexNormals;
                w = f.vertexColors;
                l = new J(f.a + d, f.b + d, f.c + d);
                l.normal.copy(f.normal);
                void 0 !== g && l.normal.applyMatrix3(g).normalize();
                b = 0;
                for (e = t.length; b < e; b++)
                  (q = t[b].clone()),
                    void 0 !== g && q.applyMatrix3(g).normalize(),
                    l.vertexNormals.push(q);
                l.color.copy(f.color);
                b = 0;
                for (e = w.length; b < e; b++)
                  (q = w[b]), l.vertexColors.push(q.clone());
                l.materialIndex = f.materialIndex + c;
                h.push(l);
              }
              m = 0;
              for (n = a.faceVertexUvs.length; m < n; m++)
                for (
                  c = a.faceVertexUvs[m],
                    void 0 === this.faceVertexUvs[m] &&
                      (this.faceVertexUvs[m] = []),
                    b = 0,
                    e = c.length;
                  b < e;
                  b++
                ) {
                  g = c[b];
                  d = [];
                  h = 0;
                  for (p = g.length; h < p; h++) d.push(g[h].clone());
                  this.faceVertexUvs[m].push(d);
                }
            } else
              console.error(
                "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
                a
              );
          },
          mergeMesh: function(a) {
            a && a.isMesh
              ? (a.matrixAutoUpdate && a.updateMatrix(),
                this.merge(a.geometry, a.matrix))
              : console.error(
                  "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                  a
                );
          },
          mergeVertices: function() {
            var a = {},
              b = [],
              c = [],
              d = Math.pow(10, 4),
              e;
            var f = 0;
            for (e = this.vertices.length; f < e; f++) {
              var h = this.vertices[f];
              h =
                Math.round(h.x * d) +
                "_" +
                Math.round(h.y * d) +
                "_" +
                Math.round(h.z * d);
              void 0 === a[h]
                ? ((a[h] = f), b.push(this.vertices[f]), (c[f] = b.length - 1))
                : (c[f] = c[a[h]]);
            }
            a = [];
            f = 0;
            for (e = this.faces.length; f < e; f++)
              for (
                d = this.faces[f],
                  d.a = c[d.a],
                  d.b = c[d.b],
                  d.c = c[d.c],
                  d = [d.a, d.b, d.c],
                  h = 0;
                3 > h;
                h++
              )
                if (d[h] === d[(h + 1) % 3]) {
                  a.push(f);
                  break;
                }
            for (f = a.length - 1; 0 <= f; f--)
              for (
                d = a[f],
                  this.faces.splice(d, 1),
                  c = 0,
                  e = this.faceVertexUvs.length;
                c < e;
                c++
              )
                this.faceVertexUvs[c].splice(d, 1);
            f = this.vertices.length - b.length;
            this.vertices = b;
            return f;
          },
          setFromPoints: function(a) {
            this.vertices = [];
            for (var b = 0, c = a.length; b < c; b++) {
              var g = a[b];
              this.vertices.push(new h(g.x, g.y, g.z || 0));
            }
            return this;
          },
          sortFacesByMaterialIndex: function() {
            for (var a = this.faces, b = a.length, c = 0; c < b; c++)
              a[c]._id = c;
            a.sort(function(a, b) {
              return a.materialIndex - b.materialIndex;
            });
            var d = this.faceVertexUvs[0],
              e = this.faceVertexUvs[1],
              f,
              h;
            d && d.length === b && (f = []);
            e && e.length === b && (h = []);
            for (c = 0; c < b; c++) {
              var k = a[c]._id;
              f && f.push(d[k]);
              h && h.push(e[k]);
            }
            f && (this.faceVertexUvs[0] = f);
            h && (this.faceVertexUvs[1] = h);
          },
          toJSON: function() {
            function a(a, b, c) {
              return c ? a | (1 << b) : a & ~(1 << b);
            }
            function b(a) {
              var b = a.x.toString() + a.y.toString() + a.z.toString();
              if (void 0 !== m[b]) return m[b];
              m[b] = l.length / 3;
              l.push(a.x, a.y, a.z);
              return m[b];
            }
            function c(a) {
              var b = a.r.toString() + a.g.toString() + a.b.toString();
              if (void 0 !== q[b]) return q[b];
              q[b] = n.length;
              n.push(a.getHex());
              return q[b];
            }
            function d(a) {
              var b = a.x.toString() + a.y.toString();
              if (void 0 !== u[b]) return u[b];
              u[b] = t.length / 2;
              t.push(a.x, a.y);
              return u[b];
            }
            var e = {
              metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON"
              }
            };
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            if (void 0 !== this.parameters) {
              var f = this.parameters,
                h;
              for (h in f) void 0 !== f[h] && (e[h] = f[h]);
              return e;
            }
            f = [];
            for (h = 0; h < this.vertices.length; h++) {
              var k = this.vertices[h];
              f.push(k.x, k.y, k.z);
            }
            k = [];
            var l = [],
              m = {},
              n = [],
              q = {},
              t = [],
              u = {};
            for (h = 0; h < this.faces.length; h++) {
              var r = this.faces[h],
                y = void 0 !== this.faceVertexUvs[0][h],
                v = 0 < r.normal.length(),
                z = 0 < r.vertexNormals.length,
                A = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b,
                C = 0 < r.vertexColors.length,
                B = 0;
              B = a(B, 0, 0);
              B = a(B, 1, !0);
              B = a(B, 2, !1);
              B = a(B, 3, y);
              B = a(B, 4, v);
              B = a(B, 5, z);
              B = a(B, 6, A);
              B = a(B, 7, C);
              k.push(B);
              k.push(r.a, r.b, r.c);
              k.push(r.materialIndex);
              y &&
                ((y = this.faceVertexUvs[0][h]),
                k.push(d(y[0]), d(y[1]), d(y[2])));
              v && k.push(b(r.normal));
              z && ((v = r.vertexNormals), k.push(b(v[0]), b(v[1]), b(v[2])));
              A && k.push(c(r.color));
              C && ((r = r.vertexColors), k.push(c(r[0]), c(r[1]), c(r[2])));
            }
            e.data = {};
            e.data.vertices = f;
            e.data.normals = l;
            0 < n.length && (e.data.colors = n);
            0 < t.length && (e.data.uvs = [t]);
            e.data.faces = k;
            return e;
          },
          clone: function() {
            return new U().copy(this);
          },
          copy: function(a) {
            var b, c, g;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var d = a.vertices;
            var e = 0;
            for (b = d.length; e < b; e++) this.vertices.push(d[e].clone());
            d = a.colors;
            e = 0;
            for (b = d.length; e < b; e++) this.colors.push(d[e].clone());
            d = a.faces;
            e = 0;
            for (b = d.length; e < b; e++) this.faces.push(d[e].clone());
            e = 0;
            for (b = a.faceVertexUvs.length; e < b; e++) {
              var f = a.faceVertexUvs[e];
              void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
              d = 0;
              for (c = f.length; d < c; d++) {
                var h = f[d],
                  k = [];
                var l = 0;
                for (g = h.length; l < g; l++) k.push(h[l].clone());
                this.faceVertexUvs[e].push(k);
              }
            }
            l = a.morphTargets;
            e = 0;
            for (b = l.length; e < b; e++) {
              g = {};
              g.name = l[e].name;
              if (void 0 !== l[e].vertices)
                for (
                  g.vertices = [], d = 0, c = l[e].vertices.length;
                  d < c;
                  d++
                )
                  g.vertices.push(l[e].vertices[d].clone());
              if (void 0 !== l[e].normals)
                for (g.normals = [], d = 0, c = l[e].normals.length; d < c; d++)
                  g.normals.push(l[e].normals[d].clone());
              this.morphTargets.push(g);
            }
            l = a.morphNormals;
            e = 0;
            for (b = l.length; e < b; e++) {
              g = {};
              if (void 0 !== l[e].vertexNormals)
                for (
                  g.vertexNormals = [], d = 0, c = l[e].vertexNormals.length;
                  d < c;
                  d++
                )
                  (f = l[e].vertexNormals[d]),
                    (h = {}),
                    (h.a = f.a.clone()),
                    (h.b = f.b.clone()),
                    (h.c = f.c.clone()),
                    g.vertexNormals.push(h);
              if (void 0 !== l[e].faceNormals)
                for (
                  g.faceNormals = [], d = 0, c = l[e].faceNormals.length;
                  d < c;
                  d++
                )
                  g.faceNormals.push(l[e].faceNormals[d].clone());
              this.morphNormals.push(g);
            }
            d = a.skinWeights;
            e = 0;
            for (b = d.length; e < b; e++) this.skinWeights.push(d[e].clone());
            d = a.skinIndices;
            e = 0;
            for (b = d.length; e < b; e++) this.skinIndices.push(d[e].clone());
            d = a.lineDistances;
            e = 0;
            for (b = d.length; e < b; e++) this.lineDistances.push(d[e]);
            e = a.boundingBox;
            null !== e && (this.boundingBox = e.clone());
            e = a.boundingSphere;
            null !== e && (this.boundingSphere = e.clone());
            this.elementsNeedUpdate = a.elementsNeedUpdate;
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this;
          },
          dispose: function() {
            this.dispatchEvent({ type: "dispose" });
          }
        });
        var Dg = (function(a) {
            function b(b, c, g, d, e, f) {
              a.call(this);
              this.type = "BoxGeometry";
              this.parameters = {
                width: b,
                height: c,
                depth: g,
                widthSegments: d,
                heightSegments: e,
                depthSegments: f
              };
              this.fromBufferGeometry(new Tj(b, c, g, d, e, f));
              this.mergeVertices();
            }
            a && (b.__proto__ = a);
            b.prototype = Object.create(a && a.prototype);
            return (b.prototype.constructor = b);
          })(U),
          Tj = (function(a) {
            function b(b, c, g, d, e, f) {
              function p(a, b, c, g, d, e, f, p, K, G, t) {
                var u = e / K,
                  r = f / G,
                  Z = e / 2,
                  y = f / 2,
                  v = p / 2;
                f = K + 1;
                var Y = G + 1,
                  z = (e = 0),
                  R,
                  A,
                  B = new h();
                for (A = 0; A < Y; A++) {
                  var C = A * r - y;
                  for (R = 0; R < f; R++)
                    (B[a] = (R * u - Z) * g),
                      (B[b] = C * d),
                      (B[c] = v),
                      m.push(B.x, B.y, B.z),
                      (B[a] = 0),
                      (B[b] = 0),
                      (B[c] = 0 < p ? 1 : -1),
                      w.push(B.x, B.y, B.z),
                      x.push(R / K),
                      x.push(1 - A / G),
                      (e += 1);
                }
                for (A = 0; A < G; A++)
                  for (R = 0; R < K; R++)
                    (a = n + R + f * (A + 1)),
                      (b = n + (R + 1) + f * (A + 1)),
                      (c = n + (R + 1) + f * A),
                      l.push(n + R + f * A, a, c),
                      l.push(a, b, c),
                      (z += 6);
                k.addGroup(q, z, t);
                q += z;
                n += e;
              }
              a.call(this);
              this.type = "BoxBufferGeometry";
              this.parameters = {
                width: b,
                height: c,
                depth: g,
                widthSegments: d,
                heightSegments: e,
                depthSegments: f
              };
              var k = this;
              b = b || 1;
              c = c || 1;
              g = g || 1;
              d = Math.floor(d) || 1;
              e = Math.floor(e) || 1;
              f = Math.floor(f) || 1;
              var l = [],
                m = [],
                w = [],
                x = [],
                n = 0,
                q = 0;
              p("z", "y", "x", -1, -1, g, c, b, f, e, 0);
              p("z", "y", "x", 1, -1, g, c, -b, f, e, 1);
              p("x", "z", "y", 1, 1, b, g, c, d, f, 2);
              p("x", "z", "y", 1, -1, b, g, -c, d, f, 3);
              p("x", "y", "z", 1, -1, b, c, g, d, e, 4);
              p("x", "y", "z", -1, -1, b, c, -g, d, e, 5);
              this.setIndex(l);
              this.addAttribute("position", new P(m, 3));
              this.addAttribute("normal", new P(w, 3));
              this.addAttribute("uv", new P(x, 2));
            }
            a && (b.__proto__ = a);
            b.prototype = Object.create(a && a.prototype);
            return (b.prototype.constructor = b);
          })(S),
          vj = { clone: Ba, merge: pa };
        qa.prototype = Object.create(D.prototype);
        qa.prototype.constructor = qa;
        qa.prototype.isShaderMaterial = !0;
        qa.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.fragmentShader = a.fragmentShader;
          this.vertexShader = a.vertexShader;
          this.uniforms = Ba(a.uniforms);
          this.defines = Object.assign({}, a.defines);
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.lights = a.lights;
          this.clipping = a.clipping;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          this.extensions = a.extensions;
          return this;
        };
        qa.prototype.toJSON = function(a) {
          var b = D.prototype.toJSON.call(this, a);
          b.uniforms = {};
          for (var c in this.uniforms) {
            var g = this.uniforms[c].value;
            b.uniforms[c] =
              g && g.isTexture
                ? { type: "t", value: g.toJSON(a).uuid }
                : g && g.isColor
                ? { type: "c", value: g.getHex() }
                : g && g.isVector2
                ? { type: "v2", value: g.toArray() }
                : g && g.isVector3
                ? { type: "v3", value: g.toArray() }
                : g && g.isVector4
                ? { type: "v4", value: g.toArray() }
                : g && g.isMatrix3
                ? { type: "m3", value: g.toArray() }
                : g && g.isMatrix4
                ? { type: "m4", value: g.toArray() }
                : { value: g };
          }
          0 < Object.keys(this.defines).length && (b.defines = this.defines);
          b.vertexShader = this.vertexShader;
          b.fragmentShader = this.fragmentShader;
          a = {};
          for (var d in this.extensions)
            !0 === this.extensions[d] && (a[d] = !0);
          0 < Object.keys(a).length && (b.extensions = a);
          return b;
        };
        ua.prototype = Object.assign(Object.create(v.prototype), {
          constructor: ua,
          isCamera: !0,
          copy: function(a, b) {
            v.prototype.copy.call(this, a, b);
            this.matrixWorldInverse.copy(a.matrixWorldInverse);
            this.projectionMatrix.copy(a.projectionMatrix);
            this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
            return this;
          },
          getWorldDirection: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Camera: .getWorldDirection() target is now required"
              ),
              (a = new h()));
            this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(-b[8], -b[9], -b[10]).normalize();
          },
          updateMatrixWorld: function(a) {
            v.prototype.updateMatrixWorld.call(this, a);
            this.matrixWorldInverse.getInverse(this.matrixWorld);
          },
          clone: function() {
            return new this.constructor().copy(this);
          }
        });
        Da.prototype = Object.assign(Object.create(ua.prototype), {
          constructor: Da,
          isPerspectiveCamera: !0,
          copy: function(a, b) {
            ua.prototype.copy.call(this, a, b);
            this.fov = a.fov;
            this.zoom = a.zoom;
            this.near = a.near;
            this.far = a.far;
            this.focus = a.focus;
            this.aspect = a.aspect;
            this.view = null === a.view ? null : Object.assign({}, a.view);
            this.filmGauge = a.filmGauge;
            this.filmOffset = a.filmOffset;
            return this;
          },
          setFocalLength: function(a) {
            a = (0.5 * this.getFilmHeight()) / a;
            this.fov = 2 * ya.RAD2DEG * Math.atan(a);
            this.updateProjectionMatrix();
          },
          getFocalLength: function() {
            var a = Math.tan(0.5 * ya.DEG2RAD * this.fov);
            return (0.5 * this.getFilmHeight()) / a;
          },
          getEffectiveFOV: function() {
            return (
              2 *
              ya.RAD2DEG *
              Math.atan(Math.tan(0.5 * ya.DEG2RAD * this.fov) / this.zoom)
            );
          },
          getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
          },
          getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
          },
          setViewOffset: function(a, b, c, d, e, f) {
            this.aspect = a / b;
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
              });
            this.view.enabled = !0;
            this.view.fullWidth = a;
            this.view.fullHeight = b;
            this.view.offsetX = c;
            this.view.offsetY = d;
            this.view.width = e;
            this.view.height = f;
            this.updateProjectionMatrix();
          },
          clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1);
            this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function() {
            var a = this.near,
              b = (a * Math.tan(0.5 * ya.DEG2RAD * this.fov)) / this.zoom,
              c = 2 * b,
              d = this.aspect * c,
              e = -0.5 * d,
              f = this.view;
            if (null !== this.view && this.view.enabled) {
              var h = f.fullWidth,
                k = f.fullHeight;
              e += (f.offsetX * d) / h;
              b -= (f.offsetY * c) / k;
              d *= f.width / h;
              c *= f.height / k;
            }
            f = this.filmOffset;
            0 !== f && (e += (a * f) / this.getFilmWidth());
            this.projectionMatrix.makePerspective(
              e,
              e + d,
              b,
              b - c,
              a,
              this.far
            );
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function(a) {
            a = v.prototype.toJSON.call(this, a);
            a.object.fov = this.fov;
            a.object.zoom = this.zoom;
            a.object.near = this.near;
            a.object.far = this.far;
            a.object.focus = this.focus;
            a.object.aspect = this.aspect;
            null !== this.view &&
              (a.object.view = Object.assign({}, this.view));
            a.object.filmGauge = this.filmGauge;
            a.object.filmOffset = this.filmOffset;
            return a;
          }
        });
        Ca.prototype = Object.create(v.prototype);
        Ca.prototype.constructor = Ca;
        oa.prototype = Object.create(n.prototype);
        oa.prototype.constructor = oa;
        oa.prototype.isWebGLRenderTargetCube = !0;
        oa.prototype.fromEquirectangularTexture = function(a, b) {
          this.texture.type = b.type;
          this.texture.format = b.format;
          this.texture.encoding = b.encoding;
          var c = new r(),
            g = new qa({
              type: "CubemapFromEquirect",
              uniforms: Ba({ tEquirect: { value: null } }),
              vertexShader:
                "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
              fragmentShader:
                "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
              side: 1,
              blending: 0
            });
          g.uniforms.tEquirect.value = b;
          b = new da(new Tj(5, 5, 5), g);
          c.add(b);
          g = new Ca(1, 10, 1);
          g.renderTarget = this;
          g.renderTarget.texture.name = "CubeCameraTexture";
          g.update(a, c);
          b.geometry.dispose();
          b.material.dispose();
          return this;
        };
        Ia.prototype = Object.create(l.prototype);
        Ia.prototype.constructor = Ia;
        Ia.prototype.isDataTexture = !0;
        var Eg = new h(),
          wj = new h(),
          xj = new k();
        Object.assign(ta.prototype, {
          isPlane: !0,
          set: function(a, b) {
            this.normal.copy(a);
            this.constant = b;
            return this;
          },
          setComponents: function(a, b, c, d) {
            this.normal.set(a, b, c);
            this.constant = d;
            return this;
          },
          setFromNormalAndCoplanarPoint: function(a, b) {
            this.normal.copy(a);
            this.constant = -b.dot(this.normal);
            return this;
          },
          setFromCoplanarPoints: function(a, b, c) {
            b = Eg.subVectors(c, b)
              .cross(wj.subVectors(a, b))
              .normalize();
            this.setFromNormalAndCoplanarPoint(b, a);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.normal.copy(a.normal);
            this.constant = a.constant;
            return this;
          },
          normalize: function() {
            var a = 1 / this.normal.length();
            this.normal.multiplyScalar(a);
            this.constant *= a;
            return this;
          },
          negate: function() {
            this.constant *= -1;
            this.normal.negate();
            return this;
          },
          distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant;
          },
          distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius;
          },
          projectPoint: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (b = new h()));
            return b
              .copy(this.normal)
              .multiplyScalar(-this.distanceToPoint(a))
              .add(a);
          },
          intersectLine: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Plane: .intersectLine() target is now required"
              ),
              (b = new h()));
            var c = a.delta(Eg),
              g = this.normal.dot(c);
            if (0 === g) {
              if (0 === this.distanceToPoint(a.start)) return b.copy(a.start);
            } else if (
              ((g = -(a.start.dot(this.normal) + this.constant) / g),
              !(0 > g || 1 < g))
            )
              return b
                .copy(c)
                .multiplyScalar(g)
                .add(a.start);
          },
          intersectsLine: function(a) {
            var b = this.distanceToPoint(a.start);
            a = this.distanceToPoint(a.end);
            return (0 > b && 0 < a) || (0 > a && 0 < b);
          },
          intersectsBox: function(a) {
            return a.intersectsPlane(this);
          },
          intersectsSphere: function(a) {
            return a.intersectsPlane(this);
          },
          coplanarPoint: function(a) {
            void 0 === a &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (a = new h()));
            return a.copy(this.normal).multiplyScalar(-this.constant);
          },
          applyMatrix4: function(a, b) {
            b = b || xj.getNormalMatrix(a);
            a = this.coplanarPoint(Eg).applyMatrix4(a);
            b = this.normal.applyMatrix3(b).normalize();
            this.constant = -a.dot(b);
            return this;
          },
          translate: function(a) {
            this.constant -= a.dot(this.normal);
            return this;
          },
          equals: function(a) {
            return a.normal.equals(this.normal) && a.constant === this.constant;
          }
        });
        var ej = new H(),
          sk = new h();
        Object.assign(Q.prototype, {
          set: function(a, b, c, d, e, f) {
            var g = this.planes;
            g[0].copy(a);
            g[1].copy(b);
            g[2].copy(c);
            g[3].copy(d);
            g[4].copy(e);
            g[5].copy(f);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
            return this;
          },
          setFromMatrix: function(a) {
            var b = this.planes,
              c = a.elements;
            a = c[0];
            var g = c[1],
              d = c[2],
              e = c[3],
              f = c[4],
              h = c[5],
              k = c[6],
              l = c[7],
              m = c[8],
              n = c[9],
              q = c[10],
              t = c[11],
              u = c[12],
              r = c[13],
              y = c[14];
            c = c[15];
            b[0].setComponents(e - a, l - f, t - m, c - u).normalize();
            b[1].setComponents(e + a, l + f, t + m, c + u).normalize();
            b[2].setComponents(e + g, l + h, t + n, c + r).normalize();
            b[3].setComponents(e - g, l - h, t - n, c - r).normalize();
            b[4].setComponents(e - d, l - k, t - q, c - y).normalize();
            b[5].setComponents(e + d, l + k, t + q, c + y).normalize();
            return this;
          },
          intersectsObject: function(a) {
            var b = a.geometry;
            null === b.boundingSphere && b.computeBoundingSphere();
            ej.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
            return this.intersectsSphere(ej);
          },
          intersectsSprite: function(a) {
            ej.center.set(0, 0, 0);
            ej.radius = 0.7071067811865476;
            ej.applyMatrix4(a.matrixWorld);
            return this.intersectsSphere(ej);
          },
          intersectsSphere: function(a) {
            var b = this.planes,
              c = a.center;
            a = -a.radius;
            for (var g = 0; 6 > g; g++)
              if (b[g].distanceToPoint(c) < a) return !1;
            return !0;
          },
          intersectsBox: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) {
              var g = b[c];
              sk.x = 0 < g.normal.x ? a.max.x : a.min.x;
              sk.y = 0 < g.normal.y ? a.max.y : a.min.y;
              sk.z = 0 < g.normal.z ? a.max.z : a.min.z;
              if (0 > g.distanceToPoint(sk)) return !1;
            }
            return !0;
          },
          containsPoint: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++)
              if (0 > b[c].distanceToPoint(a)) return !1;
            return !0;
          }
        });
        var za = {
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment:
              "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common:
              "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment:
              "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment:
              "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex:
              "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex:
              "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment:
              "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment:
              "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin:
              "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps:
              "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
            clearcoat_normalmap_pars_fragment:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex:
              "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex:
              "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag:
              "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag:
              "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert:
              "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
          },
          ia = {
            common: {
              diffuse: { value: new M(15658734) },
              opacity: { value: 1 },
              map: { value: null },
              uvTransform: { value: new k() },
              alphaMap: { value: null }
            },
            specularmap: { specularMap: { value: null } },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              refractionRatio: { value: 0.98 },
              maxMipLevel: { value: 0 }
            },
            aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 }
            },
            emissivemap: { emissiveMap: { value: null } },
            bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
            normalmap: {
              normalMap: { value: null },
              normalScale: { value: new c(1, 1) }
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 }
            },
            roughnessmap: { roughnessMap: { value: null } },
            metalnessmap: { metalnessMap: { value: null } },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 2.5e-4 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new M(16777215) }
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: {
                value: [],
                properties: {
                  direction: {},
                  color: {},
                  shadow: {},
                  shadowBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
                }
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                  shadow: {},
                  shadowBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
                }
              },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {},
                  shadow: {},
                  shadowBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {}
                }
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} }
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} }
              }
            },
            points: {
              diffuse: { value: new M(15658734) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              uvTransform: { value: new k() }
            },
            sprite: {
              diffuse: { value: new M(15658734) },
              opacity: { value: 1 },
              center: { value: new c(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              uvTransform: { value: new k() }
            }
          },
          we = {
            basic: {
              uniforms: pa([
                ia.common,
                ia.specularmap,
                ia.envmap,
                ia.aomap,
                ia.lightmap,
                ia.fog
              ]),
              vertexShader: za.meshbasic_vert,
              fragmentShader: za.meshbasic_frag
            },
            lambert: {
              uniforms: pa([
                ia.common,
                ia.specularmap,
                ia.envmap,
                ia.aomap,
                ia.lightmap,
                ia.emissivemap,
                ia.fog,
                ia.lights,
                { emissive: { value: new M(0) } }
              ]),
              vertexShader: za.meshlambert_vert,
              fragmentShader: za.meshlambert_frag
            },
            phong: {
              uniforms: pa([
                ia.common,
                ia.specularmap,
                ia.envmap,
                ia.aomap,
                ia.lightmap,
                ia.emissivemap,
                ia.bumpmap,
                ia.normalmap,
                ia.displacementmap,
                ia.gradientmap,
                ia.fog,
                ia.lights,
                {
                  emissive: { value: new M(0) },
                  specular: { value: new M(1118481) },
                  shininess: { value: 30 }
                }
              ]),
              vertexShader: za.meshphong_vert,
              fragmentShader: za.meshphong_frag
            },
            standard: {
              uniforms: pa([
                ia.common,
                ia.envmap,
                ia.aomap,
                ia.lightmap,
                ia.emissivemap,
                ia.bumpmap,
                ia.normalmap,
                ia.displacementmap,
                ia.roughnessmap,
                ia.metalnessmap,
                ia.fog,
                ia.lights,
                {
                  emissive: { value: new M(0) },
                  roughness: { value: 0.5 },
                  metalness: { value: 0.5 },
                  envMapIntensity: { value: 1 }
                }
              ]),
              vertexShader: za.meshphysical_vert,
              fragmentShader: za.meshphysical_frag
            },
            matcap: {
              uniforms: pa([
                ia.common,
                ia.bumpmap,
                ia.normalmap,
                ia.displacementmap,
                ia.fog,
                { matcap: { value: null } }
              ]),
              vertexShader: za.meshmatcap_vert,
              fragmentShader: za.meshmatcap_frag
            },
            points: {
              uniforms: pa([ia.points, ia.fog]),
              vertexShader: za.points_vert,
              fragmentShader: za.points_frag
            },
            dashed: {
              uniforms: pa([
                ia.common,
                ia.fog,
                {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 }
                }
              ]),
              vertexShader: za.linedashed_vert,
              fragmentShader: za.linedashed_frag
            },
            depth: {
              uniforms: pa([ia.common, ia.displacementmap]),
              vertexShader: za.depth_vert,
              fragmentShader: za.depth_frag
            },
            normal: {
              uniforms: pa([
                ia.common,
                ia.bumpmap,
                ia.normalmap,
                ia.displacementmap,
                { opacity: { value: 1 } }
              ]),
              vertexShader: za.normal_vert,
              fragmentShader: za.normal_frag
            },
            sprite: {
              uniforms: pa([ia.sprite, ia.fog]),
              vertexShader: za.sprite_vert,
              fragmentShader: za.sprite_frag
            },
            background: {
              uniforms: {
                uvTransform: { value: new k() },
                t2D: { value: null }
              },
              vertexShader: za.background_vert,
              fragmentShader: za.background_frag
            },
            cube: {
              uniforms: {
                tCube: { value: null },
                tFlip: { value: -1 },
                opacity: { value: 1 }
              },
              vertexShader: za.cube_vert,
              fragmentShader: za.cube_frag
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: za.equirect_vert,
              fragmentShader: za.equirect_frag
            },
            distanceRGBA: {
              uniforms: pa([
                ia.common,
                ia.displacementmap,
                {
                  referencePosition: { value: new h() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 }
                }
              ]),
              vertexShader: za.distanceRGBA_vert,
              fragmentShader: za.distanceRGBA_frag
            },
            shadow: {
              uniforms: pa([
                ia.lights,
                ia.fog,
                { color: { value: new M(0) }, opacity: { value: 1 } }
              ]),
              vertexShader: za.shadow_vert,
              fragmentShader: za.shadow_frag
            }
          };
        we.physical = {
          uniforms: pa([
            we.standard.uniforms,
            {
              transparency: { value: 0 },
              clearcoat: { value: 0 },
              clearcoatRoughness: { value: 0 },
              sheen: { value: new M(0) },
              clearcoatNormalScale: { value: new c(1, 1) },
              clearcoatNormalMap: { value: null }
            }
          ]),
          vertexShader: za.meshphysical_vert,
          fragmentShader: za.meshphysical_frag
        };
        ka.prototype = Object.create(U.prototype);
        ka.prototype.constructor = ka;
        Aa.prototype = Object.create(S.prototype);
        Aa.prototype.constructor = Aa;
        Ha.prototype = Object.create(l.prototype);
        Ha.prototype.constructor = Ha;
        Ha.prototype.isCubeTexture = !0;
        Object.defineProperty(Ha.prototype, "images", {
          get: function() {
            return this.image;
          },
          set: function(a) {
            this.image = a;
          }
        });
        db.prototype = Object.create(l.prototype);
        db.prototype.constructor = db;
        db.prototype.isDataTexture2DArray = !0;
        jb.prototype = Object.create(l.prototype);
        jb.prototype.constructor = jb;
        jb.prototype.isDataTexture3D = !0;
        var Sh = new l(),
          yj = new db(),
          zj = new jb(),
          Th = new Ha(),
          Uh = [],
          Vh = [],
          Wh = new Float32Array(16),
          Xh = new Float32Array(9),
          Yh = new Float32Array(4);
        oc.prototype.updateCache = function(a) {
          var b = this.cache;
          a instanceof Float32Array &&
            b.length !== a.length &&
            (this.cache = new Float32Array(a.length));
          Na(b, a);
        };
        qc.prototype.setValue = function(a, b, c) {
          for (var g = this.seq, d = 0, e = g.length; d !== e; ++d) {
            var f = g[d];
            f.setValue(a, b[f.id], c);
          }
        };
        var Gg = /([\w\d_]+)(\])?(\[|\.)?/g;
        hb.prototype.setValue = function(a, b, c, d) {
          b = this.map[b];
          void 0 !== b && b.setValue(a, c, d);
        };
        hb.prototype.setOptional = function(a, b, c) {
          b = b[c];
          void 0 !== b && this.setValue(a, c, b);
        };
        hb.upload = function(a, b, c, d) {
          for (var g = 0, e = b.length; g !== e; ++g) {
            var f = b[g],
              h = c[f.id];
            !1 !== h.needsUpdate && f.setValue(a, h.value, d);
          }
        };
        hb.seqWithValue = function(a, b) {
          for (var c = [], g = 0, d = a.length; g !== d; ++g) {
            var e = a[g];
            e.id in b && c.push(e);
          }
          return c;
        };
        var Aj = 0,
          Jg = /^[ \t]*#include +<([\w\d./]+)>/gm,
          Zh = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          Cj = 0;
        $f.prototype = Object.create(D.prototype);
        $f.prototype.constructor = $f;
        $f.prototype.isMeshDepthMaterial = !0;
        $f.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.depthPacking = a.depthPacking;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.map = a.map;
          this.alphaMap = a.alphaMap;
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          return this;
        };
        ag.prototype = Object.create(D.prototype);
        ag.prototype.constructor = ag;
        ag.prototype.isMeshDistanceMaterial = !0;
        ag.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.referencePosition.copy(a.referencePosition);
          this.nearDistance = a.nearDistance;
          this.farDistance = a.farDistance;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.map = a.map;
          this.alphaMap = a.alphaMap;
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          return this;
        };
        ld.prototype = Object.assign(Object.create(n.prototype), {
          constructor: ld,
          isWebGLMultiviewRenderTarget: !0,
          copy: function(a) {
            n.prototype.copy.call(this, a);
            this.numViews = a.numViews;
            return this;
          },
          setNumViews: function(a) {
            this.numViews !== a && ((this.numViews = a), this.dispose());
            return this;
          }
        });
        Fb.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Fb,
          isGroup: !0
        });
        Rb.prototype = Object.assign(Object.create(Da.prototype), {
          constructor: Rb,
          isArrayCamera: !0
        });
        var ai = new h(),
          bi = new h();
        Object.assign(od.prototype, b.prototype);
        Object.assign(de.prototype, b.prototype);
        Object.assign(Mc.prototype, {
          isFogExp2: !0,
          clone: function() {
            return new Mc(this.color, this.density);
          },
          toJSON: function() {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density
            };
          }
        });
        Object.assign(Nc.prototype, {
          isFog: !0,
          clone: function() {
            return new Nc(this.color, this.near, this.far);
          },
          toJSON: function() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far
            };
          }
        });
        Object.defineProperty(bg.prototype, "needsUpdate", {
          set: function(a) {
            !0 === a && this.version++;
          }
        });
        Object.assign(bg.prototype, {
          isInterleavedBuffer: !0,
          onUploadCallback: function() {},
          setDynamic: function(a) {
            this.dynamic = a;
            return this;
          },
          copy: function(a) {
            this.array = new a.array.constructor(a.array);
            this.count = a.count;
            this.stride = a.stride;
            this.dynamic = a.dynamic;
            return this;
          },
          copyAt: function(a, b, c) {
            a *= this.stride;
            c *= b.stride;
            for (var g = 0, d = this.stride; g < d; g++)
              this.array[a + g] = b.array[c + g];
            return this;
          },
          set: function(a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          onUpload: function(a) {
            this.onUploadCallback = a;
            return this;
          }
        });
        Object.defineProperties(cc.prototype, {
          count: {
            get: function() {
              return this.data.count;
            }
          },
          array: {
            get: function() {
              return this.data.array;
            }
          }
        });
        Object.assign(cc.prototype, {
          isInterleavedBufferAttribute: !0,
          setX: function(a, b) {
            this.data.array[a * this.data.stride + this.offset] = b;
            return this;
          },
          setY: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 1] = b;
            return this;
          },
          setZ: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 2] = b;
            return this;
          },
          setW: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 3] = b;
            return this;
          },
          getX: function(a) {
            return this.data.array[a * this.data.stride + this.offset];
          },
          getY: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 1];
          },
          getZ: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 2];
          },
          getW: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 3];
          },
          setXY: function(a, b, c) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            return this;
          },
          setXYZ: function(a, b, c, d) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            return this;
          },
          setXYZW: function(a, b, c, d, e) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            this.data.array[a + 3] = e;
            return this;
          }
        });
        cg.prototype = Object.create(D.prototype);
        cg.prototype.constructor = cg;
        cg.prototype.isSpriteMaterial = !0;
        cg.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.map = a.map;
          this.rotation = a.rotation;
          this.sizeAttenuation = a.sizeAttenuation;
          return this;
        };
        var Di,
          gk = new h(),
          fj = new h(),
          gj = new h(),
          Ei = new c(),
          Vj = new c(),
          ci = new t(),
          tk = new h(),
          hk = new h(),
          uk = new h(),
          di = new c(),
          Ng = new c(),
          ei = new c();
        dc.prototype = Object.assign(Object.create(v.prototype), {
          constructor: dc,
          isSprite: !0,
          raycast: function(a, b) {
            null === a.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
              );
            fj.setFromMatrixScale(this.matrixWorld);
            ci.copy(a.camera.matrixWorld);
            this.modelViewMatrix.multiplyMatrices(
              a.camera.matrixWorldInverse,
              this.matrixWorld
            );
            gj.setFromMatrixPosition(this.modelViewMatrix);
            a.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              fj.multiplyScalar(-gj.z);
            var g = this.material.rotation;
            if (0 !== g) {
              var d = Math.cos(g);
              var e = Math.sin(g);
            }
            g = this.center;
            Qc(tk.set(-0.5, -0.5, 0), gj, g, fj, e, d);
            Qc(hk.set(0.5, -0.5, 0), gj, g, fj, e, d);
            Qc(uk.set(0.5, 0.5, 0), gj, g, fj, e, d);
            di.set(0, 0);
            Ng.set(1, 0);
            ei.set(1, 1);
            var f = a.ray.intersectTriangle(tk, hk, uk, !1, gk);
            if (
              null === f &&
              (Qc(hk.set(-0.5, 0.5, 0), gj, g, fj, e, d),
              Ng.set(0, 1),
              (f = a.ray.intersectTriangle(tk, uk, hk, !1, gk)),
              null === f)
            )
              return;
            e = a.ray.origin.distanceTo(gk);
            e < a.near ||
              e > a.far ||
              b.push({
                distance: e,
                point: gk.clone(),
                uv: B.getUV(gk, tk, hk, uk, di, Ng, ei, new c()),
                face: null,
                object: this
              });
          },
          clone: function() {
            return new this.constructor(this.material).copy(this);
          },
          copy: function(a) {
            v.prototype.copy.call(this, a);
            void 0 !== a.center && this.center.copy(a.center);
            return this;
          }
        });
        var vk = new h(),
          fi = new h();
        fc.prototype = Object.assign(Object.create(v.prototype), {
          constructor: fc,
          isLOD: !0,
          copy: function(a) {
            v.prototype.copy.call(this, a, !1);
            a = a.levels;
            for (var b = 0, c = a.length; b < c; b++) {
              var g = a[b];
              this.addLevel(g.object.clone(), g.distance);
            }
            return this;
          },
          addLevel: function(a, b) {
            void 0 === b && (b = 0);
            b = Math.abs(b);
            for (
              var c = this.levels, g = 0;
              g < c.length && !(b < c[g].distance);
              g++
            );
            c.splice(g, 0, { distance: b, object: a });
            this.add(a);
            return this;
          },
          getObjectForDistance: function(a) {
            for (
              var b = this.levels, c = 1, g = b.length;
              c < g && !(a < b[c].distance);
              c++
            );
            return b[c - 1].object;
          },
          raycast: function(a, b) {
            vk.setFromMatrixPosition(this.matrixWorld);
            var c = a.ray.origin.distanceTo(vk);
            this.getObjectForDistance(c).raycast(a, b);
          },
          update: function(a) {
            var b = this.levels;
            if (1 < b.length) {
              vk.setFromMatrixPosition(a.matrixWorld);
              fi.setFromMatrixPosition(this.matrixWorld);
              a = vk.distanceTo(fi);
              b[0].object.visible = !0;
              for (var c = 1, g = b.length; c < g; c++)
                if (a >= b[c].distance)
                  (b[c - 1].object.visible = !1), (b[c].object.visible = !0);
                else break;
              for (; c < g; c++) b[c].object.visible = !1;
            }
          },
          toJSON: function(a) {
            a = v.prototype.toJSON.call(this, a);
            a.object.levels = [];
            for (var b = this.levels, c = 0, g = b.length; c < g; c++) {
              var d = b[c];
              a.object.levels.push({
                object: d.object.uuid,
                distance: d.distance
              });
            }
            return a;
          }
        });
        hc.prototype = Object.assign(Object.create(da.prototype), {
          constructor: hc,
          isSkinnedMesh: !0,
          bind: function(a, b) {
            this.skeleton = a;
            void 0 === b &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (b = this.matrixWorld));
            this.bindMatrix.copy(b);
            this.bindMatrixInverse.getInverse(b);
          },
          pose: function() {
            this.skeleton.pose();
          },
          normalizeSkinWeights: function() {
            for (
              var a = new m(),
                b = this.geometry.attributes.skinWeight,
                c = 0,
                d = b.count;
              c < d;
              c++
            ) {
              a.x = b.getX(c);
              a.y = b.getY(c);
              a.z = b.getZ(c);
              a.w = b.getW(c);
              var e = 1 / a.manhattanLength();
              Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0);
              b.setXYZW(c, a.x, a.y, a.z, a.w);
            }
          },
          updateMatrixWorld: function(a) {
            da.prototype.updateMatrixWorld.call(this, a);
            "attached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.matrixWorld)
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
          },
          clone: function() {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          }
        });
        var gi = new t(),
          Dj = new t();
        Object.assign(Wc.prototype, {
          calculateInverses: function() {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; a < b; a++) {
              var c = new t();
              this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
              this.boneInverses.push(c);
            }
          },
          pose: function() {
            var a, b;
            var c = 0;
            for (b = this.bones.length; c < b; c++)
              (a = this.bones[c]) &&
                a.matrixWorld.getInverse(this.boneInverses[c]);
            c = 0;
            for (b = this.bones.length; c < b; c++)
              if ((a = this.bones[c]))
                a.parent && a.parent.isBone
                  ? (a.matrix.getInverse(a.parent.matrixWorld),
                    a.matrix.multiply(a.matrixWorld))
                  : a.matrix.copy(a.matrixWorld),
                  a.matrix.decompose(a.position, a.quaternion, a.scale);
          },
          update: function() {
            for (
              var a = this.bones,
                b = this.boneInverses,
                c = this.boneMatrices,
                d = this.boneTexture,
                e = 0,
                f = a.length;
              e < f;
              e++
            )
              gi.multiplyMatrices(a[e] ? a[e].matrixWorld : Dj, b[e]),
                gi.toArray(c, 16 * e);
            void 0 !== d && (d.needsUpdate = !0);
          },
          clone: function() {
            return new Wc(this.bones, this.boneInverses);
          },
          getBoneByName: function(a) {
            for (var b = 0, c = this.bones.length; b < c; b++) {
              var g = this.bones[b];
              if (g.name === a) return g;
            }
          }
        });
        Ld.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Ld,
          isBone: !0
        });
        Md.prototype = Object.assign(Object.create(da.prototype), {
          constructor: Md,
          isInstancedMesh: !0,
          raycast: function() {},
          setMatrixAt: function(a, b) {
            b.toArray(this.instanceMatrix.array, 16 * a);
          },
          updateMorphTargets: function() {}
        });
        Ga.prototype = Object.create(D.prototype);
        Ga.prototype.constructor = Ga;
        Ga.prototype.isLineBasicMaterial = !0;
        Ga.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.linewidth = a.linewidth;
          this.linecap = a.linecap;
          this.linejoin = a.linejoin;
          return this;
        };
        var hi = new h(),
          ii = new h(),
          ni = new t(),
          wk = new N(),
          ik = new H();
        nb.prototype = Object.assign(Object.create(v.prototype), {
          constructor: nb,
          isLine: !0,
          computeLineDistances: function() {
            var a = this.geometry;
            if (a.isBufferGeometry)
              if (null === a.index) {
                for (
                  var b = a.attributes.position, c = [0], d = 1, e = b.count;
                  d < e;
                  d++
                )
                  hi.fromBufferAttribute(b, d - 1),
                    ii.fromBufferAttribute(b, d),
                    (c[d] = c[d - 1]),
                    (c[d] += hi.distanceTo(ii));
                a.addAttribute("lineDistance", new P(c, 1));
              } else
                console.warn(
                  "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else if (a.isGeometry)
              for (
                b = a.vertices,
                  c = a.lineDistances,
                  c[0] = 0,
                  d = 1,
                  e = b.length;
                d < e;
                d++
              )
                (c[d] = c[d - 1]), (c[d] += b[d - 1].distanceTo(b[d]));
            return this;
          },
          raycast: function(a, b) {
            var c = a.linePrecision,
              g = this.geometry,
              d = this.matrixWorld;
            null === g.boundingSphere && g.computeBoundingSphere();
            ik.copy(g.boundingSphere);
            ik.applyMatrix4(d);
            ik.radius += c;
            if (!1 !== a.ray.intersectsSphere(ik)) {
              ni.getInverse(d);
              wk.copy(a.ray).applyMatrix4(ni);
              c /= (this.scale.x + this.scale.y + this.scale.z) / 3;
              c *= c;
              var e = new h(),
                f = new h();
              d = new h();
              var k = new h(),
                p = this && this.isLineSegments ? 2 : 1;
              if (g.isBufferGeometry) {
                var l = g.index,
                  m = g.attributes.position.array;
                if (null !== l) {
                  l = l.array;
                  g = 0;
                  for (var n = l.length - 1; g < n; g += p) {
                    var q = l[g + 1];
                    e.fromArray(m, 3 * l[g]);
                    f.fromArray(m, 3 * q);
                    q = wk.distanceSqToSegment(e, f, k, d);
                    q > c ||
                      (k.applyMatrix4(this.matrixWorld),
                      (q = a.ray.origin.distanceTo(k)),
                      q < a.near ||
                        q > a.far ||
                        b.push({
                          distance: q,
                          point: d.clone().applyMatrix4(this.matrixWorld),
                          index: g,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
                  }
                } else
                  for (g = 0, n = m.length / 3 - 1; g < n; g += p)
                    e.fromArray(m, 3 * g),
                      f.fromArray(m, 3 * g + 3),
                      (q = wk.distanceSqToSegment(e, f, k, d)),
                      q > c ||
                        (k.applyMatrix4(this.matrixWorld),
                        (q = a.ray.origin.distanceTo(k)),
                        q < a.near ||
                          q > a.far ||
                          b.push({
                            distance: q,
                            point: d.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                          }));
              } else if (g.isGeometry)
                for (e = g.vertices, f = e.length, g = 0; g < f - 1; g += p)
                  (q = wk.distanceSqToSegment(e[g], e[g + 1], k, d)),
                    q > c ||
                      (k.applyMatrix4(this.matrixWorld),
                      (q = a.ray.origin.distanceTo(k)),
                      q < a.near ||
                        q > a.far ||
                        b.push({
                          distance: q,
                          point: d.clone().applyMatrix4(this.matrixWorld),
                          index: g,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
            }
          },
          clone: function() {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          }
        });
        var xk = new h(),
          yk = new h();
        Qa.prototype = Object.assign(Object.create(nb.prototype), {
          constructor: Qa,
          isLineSegments: !0,
          computeLineDistances: function() {
            var a = this.geometry;
            if (a.isBufferGeometry)
              if (null === a.index) {
                for (
                  var b = a.attributes.position, c = [], d = 0, e = b.count;
                  d < e;
                  d += 2
                )
                  xk.fromBufferAttribute(b, d),
                    yk.fromBufferAttribute(b, d + 1),
                    (c[d] = 0 === d ? 0 : c[d - 1]),
                    (c[d + 1] = c[d] + xk.distanceTo(yk));
                a.addAttribute("lineDistance", new P(c, 1));
              } else
                console.warn(
                  "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else if (a.isGeometry)
              for (
                b = a.vertices, c = a.lineDistances, d = 0, e = b.length;
                d < e;
                d += 2
              )
                xk.copy(b[d]),
                  yk.copy(b[d + 1]),
                  (c[d] = 0 === d ? 0 : c[d - 1]),
                  (c[d + 1] = c[d] + xk.distanceTo(yk));
            return this;
          }
        });
        Zc.prototype = Object.assign(Object.create(nb.prototype), {
          constructor: Zc,
          isLineLoop: !0
        });
        xd.prototype = Object.create(D.prototype);
        xd.prototype.constructor = xd;
        xd.prototype.isPointsMaterial = !0;
        xd.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.map = a.map;
          this.size = a.size;
          this.sizeAttenuation = a.sizeAttenuation;
          this.morphTargets = a.morphTargets;
          return this;
        };
        var oi = new t(),
          Zg = new N(),
          jk = new H(),
          zk = new h();
        Mb.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Mb,
          isPoints: !0,
          raycast: function(a, b) {
            var c = this.geometry,
              g = this.matrixWorld,
              d = a.params.Points.threshold;
            null === c.boundingSphere && c.computeBoundingSphere();
            jk.copy(c.boundingSphere);
            jk.applyMatrix4(g);
            jk.radius += d;
            if (!1 !== a.ray.intersectsSphere(jk))
              if (
                (oi.getInverse(g),
                Zg.copy(a.ray).applyMatrix4(oi),
                (d /= (this.scale.x + this.scale.y + this.scale.z) / 3),
                (d *= d),
                c.isBufferGeometry)
              ) {
                var e = c.index;
                c = c.attributes.position.array;
                if (null !== e) {
                  var f = e.array;
                  e = 0;
                  for (var h = f.length; e < h; e++) {
                    var k = f[e];
                    zk.fromArray(c, 3 * k);
                    Nd(zk, k, d, g, a, b, this);
                  }
                } else
                  for (e = 0, f = c.length / 3; e < f; e++)
                    zk.fromArray(c, 3 * e), Nd(zk, e, d, g, a, b, this);
              } else
                for (c = c.vertices, e = 0, f = c.length; e < f; e++)
                  Nd(c[e], e, d, g, a, b, this);
          },
          updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
              a = a.morphAttributes;
              var b = Object.keys(a);
              if (0 < b.length) {
                var c = a[b[0]];
                if (void 0 !== c)
                  for (
                    this.morphTargetInfluences = [],
                      this.morphTargetDictionary = {},
                      a = 0,
                      b = c.length;
                    a < b;
                    a++
                  ) {
                    var d = c[a].name || String(a);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[d] = a;
                  }
              }
            } else
              (a = a.morphTargets),
                void 0 !== a &&
                  0 < a.length &&
                  console.error(
                    "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                  );
          },
          clone: function() {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          }
        });
        Od.prototype = Object.assign(Object.create(l.prototype), {
          constructor: Od,
          isVideoTexture: !0,
          update: function() {
            var a = this.image;
            a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
          }
        });
        Ob.prototype = Object.create(l.prototype);
        Ob.prototype.constructor = Ob;
        Ob.prototype.isCompressedTexture = !0;
        mc.prototype = Object.create(l.prototype);
        mc.prototype.constructor = mc;
        mc.prototype.isCanvasTexture = !0;
        nc.prototype = Object.create(l.prototype);
        nc.prototype.constructor = nc;
        nc.prototype.isDepthTexture = !0;
        Pb.prototype = Object.create(S.prototype);
        Pb.prototype.constructor = Pb;
        pc.prototype = Object.create(U.prototype);
        pc.prototype.constructor = pc;
        Qb.prototype = Object.create(S.prototype);
        Qb.prototype.constructor = Qb;
        rc.prototype = Object.create(U.prototype);
        rc.prototype.constructor = rc;
        Jb.prototype = Object.create(S.prototype);
        Jb.prototype.constructor = Jb;
        sc.prototype = Object.create(U.prototype);
        sc.prototype.constructor = sc;
        Sb.prototype = Object.create(Jb.prototype);
        Sb.prototype.constructor = Sb;
        tc.prototype = Object.create(U.prototype);
        tc.prototype.constructor = tc;
        nh.prototype = Object.create(Jb.prototype);
        nh.prototype.constructor = nh;
        uc.prototype = Object.create(U.prototype);
        uc.prototype.constructor = uc;
        Tb.prototype = Object.create(Jb.prototype);
        Tb.prototype.constructor = Tb;
        wc.prototype = Object.create(U.prototype);
        wc.prototype.constructor = wc;
        Ub.prototype = Object.create(Jb.prototype);
        Ub.prototype.constructor = Ub;
        xc.prototype = Object.create(U.prototype);
        xc.prototype.constructor = xc;
        oh.prototype = Object.create(S.prototype);
        oh.prototype.constructor = oh;
        oh.prototype.toJSON = function() {
          var a = S.prototype.toJSON.call(this);
          a.path = this.parameters.path.toJSON();
          return a;
        };
        yc.prototype = Object.create(U.prototype);
        yc.prototype.constructor = yc;
        Vb.prototype = Object.create(S.prototype);
        Vb.prototype.constructor = Vb;
        Bc.prototype = Object.create(U.prototype);
        Bc.prototype.constructor = Bc;
        Wb.prototype = Object.create(S.prototype);
        Wb.prototype.constructor = Wb;
        var Ej = {
            triangulate: function(a, b, c) {
              c = c || 2;
              var g = b && b.length,
                d = g ? b[0] * c : a.length,
                e = bf(a, 0, d, c, !0),
                f = [];
              if (!e || e.next === e.prev) return f;
              var h;
              if (g) {
                var k = c;
                g = [];
                var p;
                var l = 0;
                for (p = b.length; l < p; l++) {
                  var m = b[l] * k;
                  var w = l < p - 1 ? b[l + 1] * k : a.length;
                  m = bf(a, m, w, k, !1);
                  m === m.next && (m.steiner = !0);
                  g.push(og(m));
                }
                g.sort(lg);
                for (l = 0; l < g.length; l++) {
                  b = g[l];
                  k = e;
                  if ((k = mg(b, k))) (b = yf(k, b)), Cc(b, b.next);
                  e = Cc(e, e.next);
                }
              }
              if (a.length > 80 * c) {
                var n = (h = a[0]);
                var q = (g = a[1]);
                for (k = c; k < d; k += c)
                  (l = a[k]),
                    (b = a[k + 1]),
                    l < n && (n = l),
                    b < q && (q = b),
                    l > h && (h = l),
                    b > g && (g = b);
                h = Math.max(h - n, g - q);
                h = 0 !== h ? 1 / h : 0;
              }
              Dc(e, f, c, n, q, h);
              return f;
            }
          },
          gf = {
            area: function(a) {
              for (var b = a.length, c = 0, g = b - 1, d = 0; d < b; g = d++)
                c += a[g].x * a[d].y - a[d].x * a[g].y;
              return 0.5 * c;
            },
            isClockWise: function(a) {
              return 0 > gf.area(a);
            },
            triangulateShape: function(a, b) {
              var c = [],
                g = [],
                d = [];
              Ef(a);
              Gf(c, a);
              var e = a.length;
              b.forEach(Ef);
              for (a = 0; a < b.length; a++)
                g.push(e), (e += b[a].length), Gf(c, b[a]);
              b = Ej.triangulate(c, g);
              for (a = 0; a < b.length; a += 3) d.push(b.slice(a, a + 3));
              return d;
            }
          };
        qh.prototype = Object.create(U.prototype);
        qh.prototype.constructor = qh;
        qh.prototype.toJSON = function() {
          var a = U.prototype.toJSON.call(this);
          return If(this.parameters.shapes, this.parameters.options, a);
        };
        xe.prototype = Object.create(S.prototype);
        xe.prototype.constructor = xe;
        xe.prototype.toJSON = function() {
          var a = S.prototype.toJSON.call(this);
          return If(this.parameters.shapes, this.parameters.options, a);
        };
        var Fj = {
          generateTopUV: function(a, b, d, e, f) {
            a = b[3 * e];
            e = b[3 * e + 1];
            var g = b[3 * f];
            f = b[3 * f + 1];
            return [new c(b[3 * d], b[3 * d + 1]), new c(a, e), new c(g, f)];
          },
          generateSideWallUV: function(a, b, d, e, f, h) {
            a = b[3 * d];
            var g = b[3 * d + 1];
            d = b[3 * d + 2];
            var k = b[3 * e],
              p = b[3 * e + 1];
            e = b[3 * e + 2];
            var l = b[3 * f],
              m = b[3 * f + 1];
            f = b[3 * f + 2];
            var w = b[3 * h],
              x = b[3 * h + 1];
            b = b[3 * h + 2];
            return 0.01 > Math.abs(g - p)
              ? [
                  new c(a, 1 - d),
                  new c(k, 1 - e),
                  new c(l, 1 - f),
                  new c(w, 1 - b)
                ]
              : [
                  new c(g, 1 - d),
                  new c(p, 1 - e),
                  new c(m, 1 - f),
                  new c(x, 1 - b)
                ];
          }
        };
        ad.prototype = Object.create(U.prototype);
        ad.prototype.constructor = ad;
        Fi.prototype = Object.create(xe.prototype);
        Fi.prototype.constructor = Fi;
        cd.prototype = Object.create(U.prototype);
        cd.prototype.constructor = cd;
        dg.prototype = Object.create(S.prototype);
        dg.prototype.constructor = dg;
        fd.prototype = Object.create(U.prototype);
        fd.prototype.constructor = fd;
        Gi.prototype = Object.create(S.prototype);
        Gi.prototype.constructor = Gi;
        gd.prototype = Object.create(U.prototype);
        gd.prototype.constructor = gd;
        Hi.prototype = Object.create(S.prototype);
        Hi.prototype.constructor = Hi;
        rh.prototype = Object.create(U.prototype);
        rh.prototype.constructor = rh;
        rh.prototype.toJSON = function() {
          var a = U.prototype.toJSON.call(this);
          return Of(this.parameters.shapes, a);
        };
        sh.prototype = Object.create(S.prototype);
        sh.prototype.constructor = sh;
        sh.prototype.toJSON = function() {
          var a = S.prototype.toJSON.call(this);
          return Of(this.parameters.shapes, a);
        };
        Ii.prototype = Object.create(S.prototype);
        Ii.prototype.constructor = Ii;
        th.prototype = Object.create(U.prototype);
        th.prototype.constructor = th;
        hf.prototype = Object.create(S.prototype);
        hf.prototype.constructor = hf;
        hd.prototype = Object.create(th.prototype);
        hd.prototype.constructor = hd;
        jd.prototype = Object.create(hf.prototype);
        jd.prototype.constructor = jd;
        kd.prototype = Object.create(U.prototype);
        kd.prototype.constructor = kd;
        Ji.prototype = Object.create(S.prototype);
        Ji.prototype.constructor = Ji;
        var Bb = Object.freeze({
          WireframeGeometry: Pb,
          ParametricGeometry: pc,
          ParametricBufferGeometry: Qb,
          TetrahedronGeometry: sc,
          TetrahedronBufferGeometry: Sb,
          OctahedronGeometry: tc,
          OctahedronBufferGeometry: nh,
          IcosahedronGeometry: uc,
          IcosahedronBufferGeometry: Tb,
          DodecahedronGeometry: wc,
          DodecahedronBufferGeometry: Ub,
          PolyhedronGeometry: rc,
          PolyhedronBufferGeometry: Jb,
          TubeGeometry: xc,
          TubeBufferGeometry: oh,
          TorusKnotGeometry: yc,
          TorusKnotBufferGeometry: Vb,
          TorusGeometry: Bc,
          TorusBufferGeometry: Wb,
          TextGeometry: ad,
          TextBufferGeometry: Fi,
          SphereGeometry: cd,
          SphereBufferGeometry: dg,
          RingGeometry: fd,
          RingBufferGeometry: Gi,
          PlaneGeometry: ka,
          PlaneBufferGeometry: Aa,
          LatheGeometry: gd,
          LatheBufferGeometry: Hi,
          ShapeGeometry: rh,
          ShapeBufferGeometry: sh,
          ExtrudeGeometry: qh,
          ExtrudeBufferGeometry: xe,
          EdgesGeometry: Ii,
          ConeGeometry: hd,
          ConeBufferGeometry: jd,
          CylinderGeometry: th,
          CylinderBufferGeometry: hf,
          CircleGeometry: kd,
          CircleBufferGeometry: Ji,
          BoxGeometry: Dg,
          BoxBufferGeometry: Tj
        });
        uh.prototype = Object.create(D.prototype);
        uh.prototype.constructor = uh;
        uh.prototype.isShadowMaterial = !0;
        uh.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          return this;
        };
        Ki.prototype = Object.create(qa.prototype);
        Ki.prototype.constructor = Ki;
        Ki.prototype.isRawShaderMaterial = !0;
        ye.prototype = Object.create(D.prototype);
        ye.prototype.constructor = ye;
        ye.prototype.isMeshStandardMaterial = !0;
        ye.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.defines = { STANDARD: "" };
          this.color.copy(a.color);
          this.roughness = a.roughness;
          this.metalness = a.metalness;
          this.map = a.map;
          this.lightMap = a.lightMap;
          this.lightMapIntensity = a.lightMapIntensity;
          this.aoMap = a.aoMap;
          this.aoMapIntensity = a.aoMapIntensity;
          this.emissive.copy(a.emissive);
          this.emissiveMap = a.emissiveMap;
          this.emissiveIntensity = a.emissiveIntensity;
          this.bumpMap = a.bumpMap;
          this.bumpScale = a.bumpScale;
          this.normalMap = a.normalMap;
          this.normalMapType = a.normalMapType;
          this.normalScale.copy(a.normalScale);
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          this.roughnessMap = a.roughnessMap;
          this.metalnessMap = a.metalnessMap;
          this.alphaMap = a.alphaMap;
          this.envMap = a.envMap;
          this.envMapIntensity = a.envMapIntensity;
          this.refractionRatio = a.refractionRatio;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.wireframeLinecap = a.wireframeLinecap;
          this.wireframeLinejoin = a.wireframeLinejoin;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          return this;
        };
        vh.prototype = Object.create(ye.prototype);
        vh.prototype.constructor = vh;
        vh.prototype.isMeshPhysicalMaterial = !0;
        vh.prototype.copy = function(a) {
          ye.prototype.copy.call(this, a);
          this.defines = { STANDARD: "", PHYSICAL: "" };
          this.reflectivity = a.reflectivity;
          this.clearcoat = a.clearcoat;
          this.clearcoatRoughness = a.clearcoatRoughness;
          this.sheen = a.sheen ? (this.sheen || new M()).copy(a.sheen) : null;
          this.clearcoatNormalMap = a.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
          this.transparency = a.transparency;
          return this;
        };
        yd.prototype = Object.create(D.prototype);
        yd.prototype.constructor = yd;
        yd.prototype.isMeshPhongMaterial = !0;
        yd.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.specular.copy(a.specular);
          this.shininess = a.shininess;
          this.map = a.map;
          this.lightMap = a.lightMap;
          this.lightMapIntensity = a.lightMapIntensity;
          this.aoMap = a.aoMap;
          this.aoMapIntensity = a.aoMapIntensity;
          this.emissive.copy(a.emissive);
          this.emissiveMap = a.emissiveMap;
          this.emissiveIntensity = a.emissiveIntensity;
          this.bumpMap = a.bumpMap;
          this.bumpScale = a.bumpScale;
          this.normalMap = a.normalMap;
          this.normalMapType = a.normalMapType;
          this.normalScale.copy(a.normalScale);
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          this.specularMap = a.specularMap;
          this.alphaMap = a.alphaMap;
          this.envMap = a.envMap;
          this.combine = a.combine;
          this.reflectivity = a.reflectivity;
          this.refractionRatio = a.refractionRatio;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.wireframeLinecap = a.wireframeLinecap;
          this.wireframeLinejoin = a.wireframeLinejoin;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          return this;
        };
        wh.prototype = Object.create(yd.prototype);
        wh.prototype.constructor = wh;
        wh.prototype.isMeshToonMaterial = !0;
        wh.prototype.copy = function(a) {
          yd.prototype.copy.call(this, a);
          this.gradientMap = a.gradientMap;
          return this;
        };
        xh.prototype = Object.create(D.prototype);
        xh.prototype.constructor = xh;
        xh.prototype.isMeshNormalMaterial = !0;
        xh.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.bumpMap = a.bumpMap;
          this.bumpScale = a.bumpScale;
          this.normalMap = a.normalMap;
          this.normalMapType = a.normalMapType;
          this.normalScale.copy(a.normalScale);
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          return this;
        };
        yh.prototype = Object.create(D.prototype);
        yh.prototype.constructor = yh;
        yh.prototype.isMeshLambertMaterial = !0;
        yh.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.color.copy(a.color);
          this.map = a.map;
          this.lightMap = a.lightMap;
          this.lightMapIntensity = a.lightMapIntensity;
          this.aoMap = a.aoMap;
          this.aoMapIntensity = a.aoMapIntensity;
          this.emissive.copy(a.emissive);
          this.emissiveMap = a.emissiveMap;
          this.emissiveIntensity = a.emissiveIntensity;
          this.specularMap = a.specularMap;
          this.alphaMap = a.alphaMap;
          this.envMap = a.envMap;
          this.combine = a.combine;
          this.reflectivity = a.reflectivity;
          this.refractionRatio = a.refractionRatio;
          this.wireframe = a.wireframe;
          this.wireframeLinewidth = a.wireframeLinewidth;
          this.wireframeLinecap = a.wireframeLinecap;
          this.wireframeLinejoin = a.wireframeLinejoin;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          return this;
        };
        zh.prototype = Object.create(D.prototype);
        zh.prototype.constructor = zh;
        zh.prototype.isMeshMatcapMaterial = !0;
        zh.prototype.copy = function(a) {
          D.prototype.copy.call(this, a);
          this.defines = { MATCAP: "" };
          this.color.copy(a.color);
          this.matcap = a.matcap;
          this.map = a.map;
          this.bumpMap = a.bumpMap;
          this.bumpScale = a.bumpScale;
          this.normalMap = a.normalMap;
          this.normalMapType = a.normalMapType;
          this.normalScale.copy(a.normalScale);
          this.displacementMap = a.displacementMap;
          this.displacementScale = a.displacementScale;
          this.displacementBias = a.displacementBias;
          this.alphaMap = a.alphaMap;
          this.skinning = a.skinning;
          this.morphTargets = a.morphTargets;
          this.morphNormals = a.morphNormals;
          return this;
        };
        Ah.prototype = Object.create(Ga.prototype);
        Ah.prototype.constructor = Ah;
        Ah.prototype.isLineDashedMaterial = !0;
        Ah.prototype.copy = function(a) {
          Ga.prototype.copy.call(this, a);
          this.scale = a.scale;
          this.dashSize = a.dashSize;
          this.gapSize = a.gapSize;
          return this;
        };
        var Gj = Object.freeze({
            ShadowMaterial: uh,
            SpriteMaterial: cg,
            RawShaderMaterial: Ki,
            ShaderMaterial: qa,
            PointsMaterial: xd,
            MeshPhysicalMaterial: vh,
            MeshStandardMaterial: ye,
            MeshPhongMaterial: yd,
            MeshToonMaterial: wh,
            MeshNormalMaterial: xh,
            MeshLambertMaterial: yh,
            MeshDepthMaterial: $f,
            MeshDistanceMaterial: ag,
            MeshBasicMaterial: F,
            MeshMatcapMaterial: zh,
            LineDashedMaterial: Ah,
            LineBasicMaterial: Ga,
            Material: D
          }),
          lb = {
            arraySlice: function(a, b, c) {
              return lb.isTypedArray(a)
                ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length))
                : a.slice(b, c);
            },
            convertArray: function(a, b, c) {
              return !a || (!c && a.constructor === b)
                ? a
                : "number" === typeof b.BYTES_PER_ELEMENT
                ? new b(a)
                : Array.prototype.slice.call(a);
            },
            isTypedArray: function(a) {
              return ArrayBuffer.isView(a) && !(a instanceof DataView);
            },
            getKeyframeOrder: function(a) {
              for (var b = a.length, c = Array(b), g = 0; g !== b; ++g)
                c[g] = g;
              c.sort(function(b, c) {
                return a[b] - a[c];
              });
              return c;
            },
            sortedArray: function(a, b, c) {
              for (
                var g = a.length, d = new a.constructor(g), e = 0, f = 0;
                f !== g;
                ++e
              )
                for (var h = c[e] * b, k = 0; k !== b; ++k) d[f++] = a[h + k];
              return d;
            },
            flattenJSON: function(a, b, c, d) {
              for (var g = 1, e = a[0]; void 0 !== e && void 0 === e[d]; )
                e = a[g++];
              if (void 0 !== e) {
                var f = e[d];
                if (void 0 !== f)
                  if (Array.isArray(f)) {
                    do
                      (f = e[d]),
                        void 0 !== f && (b.push(e.time), c.push.apply(c, f)),
                        (e = a[g++]);
                    while (void 0 !== e);
                  } else if (void 0 !== f.toArray) {
                    do
                      (f = e[d]),
                        void 0 !== f &&
                          (b.push(e.time), f.toArray(c, c.length)),
                        (e = a[g++]);
                    while (void 0 !== e);
                  } else {
                    do
                      (f = e[d]),
                        void 0 !== f && (b.push(e.time), c.push(f)),
                        (e = a[g++]);
                    while (void 0 !== e);
                  }
              }
            }
          };
        Object.assign(Zb.prototype, {
          evaluate: function(a) {
            var b = this.parameterPositions,
              c = this._cachedIndex,
              g = b[c],
              d = b[c - 1];
            a: {
              b: {
                c: {
                  d: if (!(a < g)) {
                    for (var e = c + 2; ; ) {
                      if (void 0 === g) {
                        if (a < d) break d;
                        this._cachedIndex = c = b.length;
                        return this.afterEnd_(c - 1, a, d);
                      }
                      if (c === e) break;
                      d = g;
                      g = b[++c];
                      if (a < g) break b;
                    }
                    g = b.length;
                    break c;
                  }
                  if (a >= d) break a;
                  else {
                    e = b[1];
                    a < e && ((c = 2), (d = e));
                    for (e = c - 2; ; ) {
                      if (void 0 === d)
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, a, g)
                        );
                      if (c === e) break;
                      g = d;
                      d = b[--c - 1];
                      if (a >= d) break b;
                    }
                    g = c;
                    c = 0;
                  }
                }
                for (; c < g; )
                  (d = (c + g) >>> 1), a < b[d] ? (g = d) : (c = d + 1);
                g = b[c];
                d = b[c - 1];
                if (void 0 === d)
                  return (this._cachedIndex = 0), this.beforeStart_(0, a, g);
                if (void 0 === g)
                  return (
                    (this._cachedIndex = c = b.length),
                    this.afterEnd_(c - 1, d, a)
                  );
              }
              this._cachedIndex = c;
              this.intervalChanged_(c, d, g);
            }
            return this.interpolate_(c, d, a, g);
          },
          settings: null,
          DefaultSettings_: {},
          getSettings_: function() {
            return this.settings || this.DefaultSettings_;
          },
          copySampleValue_: function(a) {
            var b = this.resultBuffer,
              c = this.sampleValues,
              g = this.valueSize;
            a *= g;
            for (var d = 0; d !== g; ++d) b[d] = c[a + d];
            return b;
          },
          interpolate_: function() {
            throw Error("call to abstract method");
          },
          intervalChanged_: function() {}
        });
        Object.assign(Zb.prototype, {
          beforeStart_: Zb.prototype.copySampleValue_,
          afterEnd_: Zb.prototype.copySampleValue_
        });
        Ud.prototype = Object.assign(Object.create(Zb.prototype), {
          constructor: Ud,
          DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
          intervalChanged_: function(a, b, c) {
            var g = this.parameterPositions,
              d = a - 2,
              e = a + 1,
              f = g[d],
              h = g[e];
            if (void 0 === f)
              switch (this.getSettings_().endingStart) {
                case 2401:
                  d = a;
                  f = 2 * b - c;
                  break;
                case 2402:
                  d = g.length - 2;
                  f = b + g[d] - g[d + 1];
                  break;
                default:
                  (d = a), (f = c);
              }
            if (void 0 === h)
              switch (this.getSettings_().endingEnd) {
                case 2401:
                  e = a;
                  h = 2 * c - b;
                  break;
                case 2402:
                  e = 1;
                  h = c + g[1] - g[0];
                  break;
                default:
                  (e = a - 1), (h = b);
              }
            a = 0.5 * (c - b);
            g = this.valueSize;
            this._weightPrev = a / (b - f);
            this._weightNext = a / (h - c);
            this._offsetPrev = d * g;
            this._offsetNext = e * g;
          },
          interpolate_: function(a, b, c, d) {
            var g = this.resultBuffer,
              e = this.sampleValues,
              f = this.valueSize;
            a *= f;
            var h = a - f,
              k = this._offsetPrev,
              p = this._offsetNext,
              l = this._weightPrev,
              m = this._weightNext,
              w = (c - b) / (d - b);
            c = w * w;
            d = c * w;
            b = -l * d + 2 * l * c - l * w;
            l = (1 + l) * d + (-1.5 - 2 * l) * c + (-0.5 + l) * w + 1;
            w = (-1 - m) * d + (1.5 + m) * c + 0.5 * w;
            m = m * d - m * c;
            for (c = 0; c !== f; ++c)
              g[c] = b * e[k + c] + l * e[h + c] + w * e[a + c] + m * e[p + c];
            return g;
          }
        });
        md.prototype = Object.assign(Object.create(Zb.prototype), {
          constructor: md,
          interpolate_: function(a, b, c, d) {
            var g = this.resultBuffer,
              e = this.sampleValues,
              f = this.valueSize;
            a *= f;
            var h = a - f;
            b = (c - b) / (d - b);
            c = 1 - b;
            for (d = 0; d !== f; ++d) g[d] = e[h + d] * c + e[a + d] * b;
            return g;
          }
        });
        Vd.prototype = Object.assign(Object.create(Zb.prototype), {
          constructor: Vd,
          interpolate_: function(a) {
            return this.copySampleValue_(a - 1);
          }
        });
        Object.assign(pb, {
          toJSON: function(a) {
            var b = a.constructor;
            if (void 0 !== b.toJSON) b = b.toJSON(a);
            else {
              b = {
                name: a.name,
                times: lb.convertArray(a.times, Array),
                values: lb.convertArray(a.values, Array)
              };
              var c = a.getInterpolation();
              c !== a.DefaultInterpolation && (b.interpolation = c);
            }
            b.type = a.ValueTypeName;
            return b;
          }
        });
        Object.assign(pb.prototype, {
          constructor: pb,
          TimeBufferType: Float32Array,
          ValueBufferType: Float32Array,
          DefaultInterpolation: 2301,
          InterpolantFactoryMethodDiscrete: function(a) {
            return new Vd(this.times, this.values, this.getValueSize(), a);
          },
          InterpolantFactoryMethodLinear: function(a) {
            return new md(this.times, this.values, this.getValueSize(), a);
          },
          InterpolantFactoryMethodSmooth: function(a) {
            return new Ud(this.times, this.values, this.getValueSize(), a);
          },
          setInterpolation: function(a) {
            switch (a) {
              case 2300:
                var b = this.InterpolantFactoryMethodDiscrete;
                break;
              case 2301:
                b = this.InterpolantFactoryMethodLinear;
                break;
              case 2302:
                b = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === b) {
              b =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant)
                if (a !== this.DefaultInterpolation)
                  this.setInterpolation(this.DefaultInterpolation);
                else throw Error(b);
              console.warn("THREE.KeyframeTrack:", b);
              return this;
            }
            this.createInterpolant = b;
            return this;
          },
          getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return 2300;
              case this.InterpolantFactoryMethodLinear:
                return 2301;
              case this.InterpolantFactoryMethodSmooth:
                return 2302;
            }
          },
          getValueSize: function() {
            return this.values.length / this.times.length;
          },
          shift: function(a) {
            if (0 !== a)
              for (var b = this.times, c = 0, g = b.length; c !== g; ++c)
                b[c] += a;
            return this;
          },
          scale: function(a) {
            if (1 !== a)
              for (var b = this.times, c = 0, g = b.length; c !== g; ++c)
                b[c] *= a;
            return this;
          },
          trim: function(a, b) {
            for (
              var c = this.times, g = c.length, d = 0, e = g - 1;
              d !== g && c[d] < a;

            )
              ++d;
            for (; -1 !== e && c[e] > b; ) --e;
            ++e;
            if (0 !== d || e !== g)
              d >= e && ((e = Math.max(e, 1)), (d = e - 1)),
                (a = this.getValueSize()),
                (this.times = lb.arraySlice(c, d, e)),
                (this.values = lb.arraySlice(this.values, d * a, e * a));
            return this;
          },
          validate: function() {
            var a = !0,
              b = this.getValueSize();
            0 !== b - Math.floor(b) &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (a = !1));
            var c = this.times;
            b = this.values;
            var d = c.length;
            0 === d &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (a = !1));
            for (var e = null, f = 0; f !== d; f++) {
              var h = c[f];
              if ("number" === typeof h && isNaN(h)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  f,
                  h
                );
                a = !1;
                break;
              }
              if (null !== e && e > h) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  f,
                  h,
                  e
                );
                a = !1;
                break;
              }
              e = h;
            }
            if (void 0 !== b && lb.isTypedArray(b))
              for (f = 0, c = b.length; f !== c; ++f)
                if (((d = b[f]), isNaN(d))) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    f,
                    d
                  );
                  a = !1;
                  break;
                }
            return a;
          },
          optimize: function() {
            for (
              var a = this.times,
                b = this.values,
                c = this.getValueSize(),
                d = 2302 === this.getInterpolation(),
                e = 1,
                f = a.length - 1,
                h = 1;
              h < f;
              ++h
            ) {
              var k = !1,
                l = a[h];
              if (l !== a[h + 1] && (1 !== h || l !== l[0]))
                if (d) k = !0;
                else {
                  var m = h * c,
                    n = m - c,
                    q = m + c;
                  for (l = 0; l !== c; ++l) {
                    var t = b[m + l];
                    if (t !== b[n + l] || t !== b[q + l]) {
                      k = !0;
                      break;
                    }
                  }
                }
              if (k) {
                if (h !== e)
                  for (a[e] = a[h], k = h * c, m = e * c, l = 0; l !== c; ++l)
                    b[m + l] = b[k + l];
                ++e;
              }
            }
            if (0 < f) {
              a[e] = a[f];
              k = f * c;
              m = e * c;
              for (l = 0; l !== c; ++l) b[m + l] = b[k + l];
              ++e;
            }
            e !== a.length &&
              ((this.times = lb.arraySlice(a, 0, e)),
              (this.values = lb.arraySlice(b, 0, e * c)));
            return this;
          },
          clone: function() {
            var a = lb.arraySlice(this.times, 0),
              b = lb.arraySlice(this.values, 0);
            a = new this.constructor(this.name, a, b);
            a.createInterpolant = this.createInterpolant;
            return a;
          }
        });
        Xd.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: Xd,
          ValueTypeName: "bool",
          ValueBufferType: Array,
          DefaultInterpolation: 2300,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0
        });
        Yd.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: Yd,
          ValueTypeName: "color"
        });
        Li.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: Li,
          ValueTypeName: "number"
        });
        Zd.prototype = Object.assign(Object.create(Zb.prototype), {
          constructor: Zd,
          interpolate_: function(a, b, c, d) {
            var g = this.resultBuffer,
              e = this.sampleValues,
              h = this.valueSize;
            a *= h;
            b = (c - b) / (d - b);
            for (c = a + h; a !== c; a += 4)
              f.slerpFlat(g, 0, e, a - h, e, a, b);
            return g;
          }
        });
        nd.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: nd,
          ValueTypeName: "quaternion",
          DefaultInterpolation: 2301,
          InterpolantFactoryMethodLinear: function(a) {
            return new Zd(this.times, this.values, this.getValueSize(), a);
          },
          InterpolantFactoryMethodSmooth: void 0
        });
        $d.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: $d,
          ValueTypeName: "string",
          ValueBufferType: Array,
          DefaultInterpolation: 2300,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0
        });
        Mi.prototype = Object.assign(Object.create(pb.prototype), {
          constructor: Mi,
          ValueTypeName: "vector"
        });
        Object.assign(Oc, {
          parse: function(a) {
            for (
              var b = [],
                c = a.tracks,
                d = 1 / (a.fps || 1),
                g = 0,
                e = c.length;
              g !== e;
              ++g
            )
              b.push(Vg(c[g]).scale(d));
            return new Oc(a.name, a.duration, b);
          },
          toJSON: function(a) {
            var b = [],
              c = a.tracks;
            a = { name: a.name, duration: a.duration, tracks: b, uuid: a.uuid };
            for (var d = 0, g = c.length; d !== g; ++d) b.push(pb.toJSON(c[d]));
            return a;
          },
          CreateFromMorphTargetSequence: function(a, b, c, d) {
            for (var g = b.length, e = [], f = 0; f < g; f++) {
              var h = [],
                k = [];
              h.push((f + g - 1) % g, f, (f + 1) % g);
              k.push(0, 1, 0);
              var p = lb.getKeyframeOrder(h);
              h = lb.sortedArray(h, 1, p);
              k = lb.sortedArray(k, 1, p);
              d || 0 !== h[0] || (h.push(g), k.push(k[0]));
              e.push(
                new Li(".morphTargetInfluences[" + b[f].name + "]", h, k).scale(
                  1 / c
                )
              );
            }
            return new Oc(a, -1, e);
          },
          findByName: function(a, b) {
            var c = a;
            Array.isArray(a) ||
              (c = (a.geometry && a.geometry.animations) || a.animations);
            for (a = 0; a < c.length; a++) if (c[a].name === b) return c[a];
            return null;
          },
          CreateClipsFromMorphTargetSequences: function(a, b, c) {
            for (
              var d = {}, g = /^([\w-]*?)([\d]+)$/, e = 0, f = a.length;
              e < f;
              e++
            ) {
              var h = a[e],
                k = h.name.match(g);
              if (k && 1 < k.length) {
                var p = k[1];
                (k = d[p]) || (d[p] = k = []);
                k.push(h);
              }
            }
            a = [];
            for (p in d)
              a.push(Oc.CreateFromMorphTargetSequence(p, d[p], b, c));
            return a;
          },
          parseAnimation: function(a, b) {
            if (!a)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            var c = function(a, b, c, d, g) {
                if (0 !== c.length) {
                  var e = [],
                    f = [];
                  lb.flattenJSON(c, e, f, d);
                  0 !== e.length && g.push(new a(b, e, f));
                }
              },
              d = [],
              g = a.name || "default",
              e = a.length || -1,
              f = a.fps || 30;
            a = a.hierarchy || [];
            for (var h = 0; h < a.length; h++) {
              var k = a[h].keys;
              if (k && 0 !== k.length)
                if (k[0].morphTargets) {
                  e = {};
                  for (var p = 0; p < k.length; p++)
                    if (k[p].morphTargets)
                      for (var l = 0; l < k[p].morphTargets.length; l++)
                        e[k[p].morphTargets[l]] = -1;
                  for (var m in e) {
                    var n = [],
                      q = [];
                    for (l = 0; l !== k[p].morphTargets.length; ++l) {
                      var t = k[p];
                      n.push(t.time);
                      q.push(t.morphTarget === m ? 1 : 0);
                    }
                    d.push(new Li(".morphTargetInfluence[" + m + "]", n, q));
                  }
                  e = e.length * (f || 1);
                } else
                  (p = ".bones[" + b[h].name + "]"),
                    c(Mi, p + ".position", k, "pos", d),
                    c(nd, p + ".quaternion", k, "rot", d),
                    c(Mi, p + ".scale", k, "scl", d);
            }
            return 0 === d.length ? null : new Oc(g, e, d);
          }
        });
        Object.assign(Oc.prototype, {
          resetDuration: function() {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
              var d = this.tracks[b];
              a = Math.max(a, d.times[d.times.length - 1]);
            }
            this.duration = a;
            return this;
          },
          trim: function() {
            for (var a = 0; a < this.tracks.length; a++)
              this.tracks[a].trim(0, this.duration);
            return this;
          },
          validate: function() {
            for (var a = !0, b = 0; b < this.tracks.length; b++)
              a = a && this.tracks[b].validate();
            return a;
          },
          optimize: function() {
            for (var a = 0; a < this.tracks.length; a++)
              this.tracks[a].optimize();
            return this;
          },
          clone: function() {
            for (var a = [], b = 0; b < this.tracks.length; b++)
              a.push(this.tracks[b].clone());
            return new Oc(this.name, this.duration, a);
          }
        });
        var Fh = {
            enabled: !1,
            files: {},
            add: function(a, b) {
              !1 !== this.enabled && (this.files[a] = b);
            },
            get: function(a) {
              if (!1 !== this.enabled) return this.files[a];
            },
            remove: function(a) {
              delete this.files[a];
            },
            clear: function() {
              this.files = {};
            }
          },
          qi = new Xe();
        Object.assign(Ja.prototype, {
          load: function() {},
          parse: function() {},
          setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this;
          },
          setPath: function(a) {
            this.path = a;
            return this;
          },
          setResourcePath: function(a) {
            this.resourcePath = a;
            return this;
          }
        });
        var Hd = {};
        Pc.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Pc,
          load: function(a, b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var g = this,
              e = Fh.get(a);
            if (void 0 !== e)
              return (
                g.manager.itemStart(a),
                setTimeout(function() {
                  b && b(e);
                  g.manager.itemEnd(a);
                }, 0),
                e
              );
            if (void 0 !== Hd[a])
              Hd[a].push({ onLoad: b, onProgress: c, onError: d });
            else {
              var f = a.match(/^data:(.*?)(;base64)?,(.*)$/);
              if (f) {
                c = f[1];
                var h = !!f[2];
                f = f[3];
                f = decodeURIComponent(f);
                h && (f = atob(f));
                try {
                  var k = (this.responseType || "").toLowerCase();
                  switch (k) {
                    case "arraybuffer":
                    case "blob":
                      var p = new Uint8Array(f.length);
                      for (h = 0; h < f.length; h++) p[h] = f.charCodeAt(h);
                      var l =
                        "blob" === k
                          ? new Blob([p.buffer], { type: c })
                          : p.buffer;
                      break;
                    case "document":
                      l = new DOMParser().parseFromString(f, c);
                      break;
                    case "json":
                      l = JSON.parse(f);
                      break;
                    default:
                      l = f;
                  }
                  setTimeout(function() {
                    b && b(l);
                    g.manager.itemEnd(a);
                  }, 0);
                } catch (Ro) {
                  setTimeout(function() {
                    d && d(Ro);
                    g.manager.itemError(a);
                    g.manager.itemEnd(a);
                  }, 0);
                }
              } else {
                Hd[a] = [];
                Hd[a].push({ onLoad: b, onProgress: c, onError: d });
                var m = new XMLHttpRequest();
                m.open("GET", a, !0);
                m.addEventListener(
                  "load",
                  function(b) {
                    var c = this.response;
                    Fh.add(a, c);
                    var d = Hd[a];
                    delete Hd[a];
                    if (200 === this.status || 0 === this.status) {
                      0 === this.status &&
                        console.warn(
                          "THREE.FileLoader: HTTP Status 0 received."
                        );
                      for (var e = 0, f = d.length; e < f; e++) {
                        var h = d[e];
                        if (h.onLoad) h.onLoad(c);
                      }
                    } else {
                      e = 0;
                      for (f = d.length; e < f; e++)
                        if (((h = d[e]), h.onError)) h.onError(b);
                      g.manager.itemError(a);
                    }
                    g.manager.itemEnd(a);
                  },
                  !1
                );
                m.addEventListener(
                  "progress",
                  function(b) {
                    for (var c = Hd[a], d = 0, g = c.length; d < g; d++) {
                      var e = c[d];
                      if (e.onProgress) e.onProgress(b);
                    }
                  },
                  !1
                );
                m.addEventListener(
                  "error",
                  function(b) {
                    var c = Hd[a];
                    delete Hd[a];
                    for (var d = 0, e = c.length; d < e; d++) {
                      var f = c[d];
                      if (f.onError) f.onError(b);
                    }
                    g.manager.itemError(a);
                    g.manager.itemEnd(a);
                  },
                  !1
                );
                m.addEventListener(
                  "abort",
                  function(b) {
                    var c = Hd[a];
                    delete Hd[a];
                    for (var d = 0, e = c.length; d < e; d++) {
                      var f = c[d];
                      if (f.onError) f.onError(b);
                    }
                    g.manager.itemError(a);
                    g.manager.itemEnd(a);
                  },
                  !1
                );
                void 0 !== this.responseType &&
                  (m.responseType = this.responseType);
                void 0 !== this.withCredentials &&
                  (m.withCredentials = this.withCredentials);
                m.overrideMimeType &&
                  m.overrideMimeType(
                    void 0 !== this.mimeType ? this.mimeType : "text/plain"
                  );
                for (h in this.requestHeader)
                  m.setRequestHeader(h, this.requestHeader[h]);
                m.send(null);
              }
              g.manager.itemStart(a);
              return m;
            }
          },
          setResponseType: function(a) {
            this.responseType = a;
            return this;
          },
          setWithCredentials: function(a) {
            this.withCredentials = a;
            return this;
          },
          setMimeType: function(a) {
            this.mimeType = a;
            return this;
          },
          setRequestHeader: function(a) {
            this.requestHeader = a;
            return this;
          }
        });
        Ye.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Ye,
          load: function(a, b, c, d) {
            var g = this,
              e = new Pc(g.manager);
            e.setPath(g.path);
            e.load(
              a,
              function(a) {
                b(g.parse(JSON.parse(a)));
              },
              c,
              d
            );
          },
          parse: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
              var d = Oc.parse(a[c]);
              b.push(d);
            }
            return b;
          }
        });
        Ze.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Ze,
          load: function(a, b, c, d) {
            function g(g) {
              k.load(
                a[g],
                function(a) {
                  a = e.parse(a, !0);
                  f[g] = {
                    width: a.width,
                    height: a.height,
                    format: a.format,
                    mipmaps: a.mipmaps
                  };
                  l += 1;
                  6 === l &&
                    (1 === a.mipmapCount && (h.minFilter = 1006),
                    (h.format = a.format),
                    (h.needsUpdate = !0),
                    b && b(h));
                },
                c,
                d
              );
            }
            var e = this,
              f = [],
              h = new Ob();
            h.image = f;
            var k = new Pc(this.manager);
            k.setPath(this.path);
            k.setResponseType("arraybuffer");
            if (Array.isArray(a))
              for (var l = 0, p = 0, m = a.length; p < m; ++p) g(p);
            else
              k.load(
                a,
                function(a) {
                  a = e.parse(a, !0);
                  if (a.isCubemap)
                    for (
                      var c = a.mipmaps.length / a.mipmapCount, d = 0;
                      d < c;
                      d++
                    ) {
                      f[d] = { mipmaps: [] };
                      for (var g = 0; g < a.mipmapCount; g++)
                        f[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]),
                          (f[d].format = a.format),
                          (f[d].width = a.width),
                          (f[d].height = a.height);
                    }
                  else
                    (h.image.width = a.width),
                      (h.image.height = a.height),
                      (h.mipmaps = a.mipmaps);
                  1 === a.mipmapCount && (h.minFilter = 1006);
                  h.format = a.format;
                  h.needsUpdate = !0;
                  b && b(h);
                },
                c,
                d
              );
            return h;
          }
        });
        ae.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: ae,
          load: function(a, b, c, d) {
            var g = this,
              e = new Ia(),
              f = new Pc(this.manager);
            f.setResponseType("arraybuffer");
            f.setPath(this.path);
            f.load(
              a,
              function(a) {
                if ((a = g.parse(a)))
                  void 0 !== a.image
                    ? (e.image = a.image)
                    : void 0 !== a.data &&
                      ((e.image.width = a.width),
                      (e.image.height = a.height),
                      (e.image.data = a.data)),
                    (e.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001),
                    (e.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001),
                    (e.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006),
                    (e.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008),
                    (e.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1),
                    void 0 !== a.format && (e.format = a.format),
                    void 0 !== a.type && (e.type = a.type),
                    void 0 !== a.mipmaps && (e.mipmaps = a.mipmaps),
                    1 === a.mipmapCount && (e.minFilter = 1006),
                    (e.needsUpdate = !0),
                    b && b(e, a);
              },
              c,
              d
            );
            return e;
          }
        });
        Ni.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Ni,
          load: function(a, b, c, d) {
            function g() {
              k.removeEventListener("load", g, !1);
              k.removeEventListener("error", e, !1);
              Fh.add(a, this);
              b && b(this);
              f.manager.itemEnd(a);
            }
            function e(b) {
              k.removeEventListener("load", g, !1);
              k.removeEventListener("error", e, !1);
              d && d(b);
              f.manager.itemError(a);
              f.manager.itemEnd(a);
            }
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var f = this,
              h = Fh.get(a);
            if (void 0 !== h)
              return (
                f.manager.itemStart(a),
                setTimeout(function() {
                  b && b(h);
                  f.manager.itemEnd(a);
                }, 0),
                h
              );
            var k = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            k.addEventListener("load", g, !1);
            k.addEventListener("error", e, !1);
            "data:" !== a.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (k.crossOrigin = this.crossOrigin);
            f.manager.itemStart(a);
            k.src = a;
            return k;
          }
        });
        ce.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: ce,
          load: function(a, b, c, d) {
            function g(c) {
              f.load(
                a[c],
                function(a) {
                  e.images[c] = a;
                  h++;
                  6 === h && ((e.needsUpdate = !0), b && b(e));
                },
                void 0,
                d
              );
            }
            var e = new Ha(),
              f = new Ni(this.manager);
            f.setCrossOrigin(this.crossOrigin);
            f.setPath(this.path);
            var h = 0;
            for (c = 0; c < a.length; ++c) g(c);
            return e;
          }
        });
        ee.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: ee,
          load: function(a, b, c, d) {
            var g = new l(),
              e = new Ni(this.manager);
            e.setCrossOrigin(this.crossOrigin);
            e.setPath(this.path);
            e.load(
              a,
              function(c) {
                g.image = c;
                c =
                  0 < a.search(/\.jpe?g($|\?)/i) ||
                  0 === a.search(/^data:image\/jpeg/);
                g.format = c ? 1022 : 1023;
                g.needsUpdate = !0;
                void 0 !== b && b(g);
              },
              c,
              d
            );
            return g;
          }
        });
        Object.assign(la.prototype, {
          getPoint: function() {
            console.warn("THREE.Curve: .getPoint() not implemented.");
            return null;
          },
          getPointAt: function(a, b) {
            a = this.getUtoTmapping(a);
            return this.getPoint(a, b);
          },
          getPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            return b;
          },
          getSpacedPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
            return b;
          },
          getLength: function() {
            var a = this.getLengths();
            return a[a.length - 1];
          },
          getLengths: function(a) {
            void 0 === a && (a = this.arcLengthDivisions);
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === a + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b = [],
              c = this.getPoint(0),
              d,
              g = 0;
            b.push(0);
            for (d = 1; d <= a; d++) {
              var e = this.getPoint(d / a);
              g += e.distanceTo(c);
              b.push(g);
              c = e;
            }
            return (this.cacheArcLengths = b);
          },
          updateArcLengths: function() {
            this.needsUpdate = !0;
            this.getLengths();
          },
          getUtoTmapping: function(a, b) {
            var c = this.getLengths(),
              d = c.length;
            b = b ? b : a * c[d - 1];
            for (var g = 0, e = d - 1, f; g <= e; )
              if (((a = Math.floor(g + (e - g) / 2)), (f = c[a] - b), 0 > f))
                g = a + 1;
              else if (0 < f) e = a - 1;
              else {
                e = a;
                break;
              }
            a = e;
            if (c[a] === b) return a / (d - 1);
            g = c[a];
            return (a + (b - g) / (c[a + 1] - g)) / (d - 1);
          },
          getTangent: function(a) {
            var b = a - 1e-4;
            a += 1e-4;
            0 > b && (b = 0);
            1 < a && (a = 1);
            b = this.getPoint(b);
            return this.getPoint(a)
              .clone()
              .sub(b)
              .normalize();
          },
          getTangentAt: function(a) {
            a = this.getUtoTmapping(a);
            return this.getTangent(a);
          },
          computeFrenetFrames: function(a, b) {
            var c = new h(),
              d = [],
              g = [],
              e = [],
              f = new h(),
              k = new t(),
              l;
            for (l = 0; l <= a; l++) {
              var p = l / a;
              d[l] = this.getTangentAt(p);
              d[l].normalize();
            }
            g[0] = new h();
            e[0] = new h();
            l = Number.MAX_VALUE;
            p = Math.abs(d[0].x);
            var m = Math.abs(d[0].y),
              n = Math.abs(d[0].z);
            p <= l && ((l = p), c.set(1, 0, 0));
            m <= l && ((l = m), c.set(0, 1, 0));
            n <= l && c.set(0, 0, 1);
            f.crossVectors(d[0], c).normalize();
            g[0].crossVectors(d[0], f);
            e[0].crossVectors(d[0], g[0]);
            for (l = 1; l <= a; l++)
              (g[l] = g[l - 1].clone()),
                (e[l] = e[l - 1].clone()),
                f.crossVectors(d[l - 1], d[l]),
                f.length() > Number.EPSILON &&
                  (f.normalize(),
                  (c = Math.acos(ya.clamp(d[l - 1].dot(d[l]), -1, 1))),
                  g[l].applyMatrix4(k.makeRotationAxis(f, c))),
                e[l].crossVectors(d[l], g[l]);
            if (!0 === b)
              for (
                c = Math.acos(ya.clamp(g[0].dot(g[a]), -1, 1)),
                  c /= a,
                  0 < d[0].dot(f.crossVectors(g[0], g[a])) && (c = -c),
                  l = 1;
                l <= a;
                l++
              )
                g[l].applyMatrix4(k.makeRotationAxis(d[l], c * l)),
                  e[l].crossVectors(d[l], g[l]);
            return { tangents: d, normals: g, binormals: e };
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.arcLengthDivisions = a.arcLengthDivisions;
            return this;
          },
          toJSON: function() {
            var a = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
              }
            };
            a.arcLengthDivisions = this.arcLengthDivisions;
            a.type = this.type;
            return a;
          },
          fromJSON: function(a) {
            this.arcLengthDivisions = a.arcLengthDivisions;
            return this;
          }
        });
        $b.prototype = Object.create(la.prototype);
        $b.prototype.constructor = $b;
        $b.prototype.isEllipseCurve = !0;
        $b.prototype.getPoint = function(a, b) {
          b = b || new c();
          for (
            var d = 2 * Math.PI,
              g = this.aEndAngle - this.aStartAngle,
              e = Math.abs(g) < Number.EPSILON;
            0 > g;

          )
            g += d;
          for (; g > d; ) g -= d;
          g < Number.EPSILON && (g = e ? 0 : d);
          !0 !== this.aClockwise || e || (g = g === d ? -d : g - d);
          d = this.aStartAngle + a * g;
          a = this.aX + this.xRadius * Math.cos(d);
          var f = this.aY + this.yRadius * Math.sin(d);
          0 !== this.aRotation &&
            ((d = Math.cos(this.aRotation)),
            (g = Math.sin(this.aRotation)),
            (e = a - this.aX),
            (f -= this.aY),
            (a = e * d - f * g + this.aX),
            (f = e * g + f * d + this.aY));
          return b.set(a, f);
        };
        $b.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.aX = a.aX;
          this.aY = a.aY;
          this.xRadius = a.xRadius;
          this.yRadius = a.yRadius;
          this.aStartAngle = a.aStartAngle;
          this.aEndAngle = a.aEndAngle;
          this.aClockwise = a.aClockwise;
          this.aRotation = a.aRotation;
          return this;
        };
        $b.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.aX = this.aX;
          a.aY = this.aY;
          a.xRadius = this.xRadius;
          a.yRadius = this.yRadius;
          a.aStartAngle = this.aStartAngle;
          a.aEndAngle = this.aEndAngle;
          a.aClockwise = this.aClockwise;
          a.aRotation = this.aRotation;
          return a;
        };
        $b.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.aX = a.aX;
          this.aY = a.aY;
          this.xRadius = a.xRadius;
          this.yRadius = a.yRadius;
          this.aStartAngle = a.aStartAngle;
          this.aEndAngle = a.aEndAngle;
          this.aClockwise = a.aClockwise;
          this.aRotation = a.aRotation;
          return this;
        };
        Oi.prototype = Object.create($b.prototype);
        Oi.prototype.constructor = Oi;
        Oi.prototype.isArcCurve = !0;
        var Ak = new h(),
          $g = new af(),
          ah = new af(),
          bh = new af();
        sb.prototype = Object.create(la.prototype);
        sb.prototype.constructor = sb;
        sb.prototype.isCatmullRomCurve3 = !0;
        sb.prototype.getPoint = function(a, b) {
          b = b || new h();
          var c = this.points,
            d = c.length;
          a *= d - (this.closed ? 0 : 1);
          var g = Math.floor(a);
          a -= g;
          this.closed
            ? (g += 0 < g ? 0 : (Math.floor(Math.abs(g) / d) + 1) * d)
            : 0 === a && g === d - 1 && ((g = d - 2), (a = 1));
          if (this.closed || 0 < g) var e = c[(g - 1) % d];
          else Ak.subVectors(c[0], c[1]).add(c[0]), (e = Ak);
          var f = c[g % d];
          var k = c[(g + 1) % d];
          this.closed || g + 2 < d
            ? (c = c[(g + 2) % d])
            : (Ak.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), (c = Ak));
          if (
            "centripetal" === this.curveType ||
            "chordal" === this.curveType
          ) {
            var l = "chordal" === this.curveType ? 0.5 : 0.25;
            d = Math.pow(e.distanceToSquared(f), l);
            g = Math.pow(f.distanceToSquared(k), l);
            l = Math.pow(k.distanceToSquared(c), l);
            1e-4 > g && (g = 1);
            1e-4 > d && (d = g);
            1e-4 > l && (l = g);
            $g.initNonuniformCatmullRom(e.x, f.x, k.x, c.x, d, g, l);
            ah.initNonuniformCatmullRom(e.y, f.y, k.y, c.y, d, g, l);
            bh.initNonuniformCatmullRom(e.z, f.z, k.z, c.z, d, g, l);
          } else
            "catmullrom" === this.curveType &&
              ($g.initCatmullRom(e.x, f.x, k.x, c.x, this.tension),
              ah.initCatmullRom(e.y, f.y, k.y, c.y, this.tension),
              bh.initCatmullRom(e.z, f.z, k.z, c.z, this.tension));
          b.set($g.calc(a), ah.calc(a), bh.calc(a));
          return b;
        };
        sb.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.points = [];
          for (var b = 0, c = a.points.length; b < c; b++)
            this.points.push(a.points[b].clone());
          this.closed = a.closed;
          this.curveType = a.curveType;
          this.tension = a.tension;
          return this;
        };
        sb.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.points = [];
          for (var b = 0, c = this.points.length; b < c; b++)
            a.points.push(this.points[b].toArray());
          a.closed = this.closed;
          a.curveType = this.curveType;
          a.tension = this.tension;
          return a;
        };
        sb.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.points = [];
          for (var b = 0, c = a.points.length; b < c; b++) {
            var d = a.points[b];
            this.points.push(new h().fromArray(d));
          }
          this.closed = a.closed;
          this.curveType = a.curveType;
          this.tension = a.tension;
          return this;
        };
        zd.prototype = Object.create(la.prototype);
        zd.prototype.constructor = zd;
        zd.prototype.isCubicBezierCurve = !0;
        zd.prototype.getPoint = function(a, b) {
          b = b || new c();
          var d = this.v0,
            g = this.v1,
            e = this.v2,
            f = this.v3;
          b.set(qd(a, d.x, g.x, e.x, f.x), qd(a, d.y, g.y, e.y, f.y));
          return b;
        };
        zd.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v0.copy(a.v0);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          this.v3.copy(a.v3);
          return this;
        };
        zd.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v0 = this.v0.toArray();
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          a.v3 = this.v3.toArray();
          return a;
        };
        zd.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v0.fromArray(a.v0);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          this.v3.fromArray(a.v3);
          return this;
        };
        ze.prototype = Object.create(la.prototype);
        ze.prototype.constructor = ze;
        ze.prototype.isCubicBezierCurve3 = !0;
        ze.prototype.getPoint = function(a, b) {
          b = b || new h();
          var c = this.v0,
            d = this.v1,
            g = this.v2,
            e = this.v3;
          b.set(
            qd(a, c.x, d.x, g.x, e.x),
            qd(a, c.y, d.y, g.y, e.y),
            qd(a, c.z, d.z, g.z, e.z)
          );
          return b;
        };
        ze.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v0.copy(a.v0);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          this.v3.copy(a.v3);
          return this;
        };
        ze.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v0 = this.v0.toArray();
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          a.v3 = this.v3.toArray();
          return a;
        };
        ze.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v0.fromArray(a.v0);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          this.v3.fromArray(a.v3);
          return this;
        };
        Kb.prototype = Object.create(la.prototype);
        Kb.prototype.constructor = Kb;
        Kb.prototype.isLineCurve = !0;
        Kb.prototype.getPoint = function(a, b) {
          b = b || new c();
          1 === a
            ? b.copy(this.v2)
            : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
          return b;
        };
        Kb.prototype.getPointAt = function(a, b) {
          return this.getPoint(a, b);
        };
        Kb.prototype.getTangent = function() {
          return this.v2
            .clone()
            .sub(this.v1)
            .normalize();
        };
        Kb.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          return this;
        };
        Kb.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          return a;
        };
        Kb.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          return this;
        };
        Ad.prototype = Object.create(la.prototype);
        Ad.prototype.constructor = Ad;
        Ad.prototype.isLineCurve3 = !0;
        Ad.prototype.getPoint = function(a, b) {
          b = b || new h();
          1 === a
            ? b.copy(this.v2)
            : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
          return b;
        };
        Ad.prototype.getPointAt = function(a, b) {
          return this.getPoint(a, b);
        };
        Ad.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          return this;
        };
        Ad.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          return a;
        };
        Ad.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          return this;
        };
        Bd.prototype = Object.create(la.prototype);
        Bd.prototype.constructor = Bd;
        Bd.prototype.isQuadraticBezierCurve = !0;
        Bd.prototype.getPoint = function(a, b) {
          b = b || new c();
          var d = this.v0,
            g = this.v1,
            e = this.v2;
          b.set(pd(a, d.x, g.x, e.x), pd(a, d.y, g.y, e.y));
          return b;
        };
        Bd.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v0.copy(a.v0);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          return this;
        };
        Bd.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v0 = this.v0.toArray();
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          return a;
        };
        Bd.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v0.fromArray(a.v0);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          return this;
        };
        Ae.prototype = Object.create(la.prototype);
        Ae.prototype.constructor = Ae;
        Ae.prototype.isQuadraticBezierCurve3 = !0;
        Ae.prototype.getPoint = function(a, b) {
          b = b || new h();
          var c = this.v0,
            d = this.v1,
            g = this.v2;
          b.set(
            pd(a, c.x, d.x, g.x),
            pd(a, c.y, d.y, g.y),
            pd(a, c.z, d.z, g.z)
          );
          return b;
        };
        Ae.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.v0.copy(a.v0);
          this.v1.copy(a.v1);
          this.v2.copy(a.v2);
          return this;
        };
        Ae.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.v0 = this.v0.toArray();
          a.v1 = this.v1.toArray();
          a.v2 = this.v2.toArray();
          return a;
        };
        Ae.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.v0.fromArray(a.v0);
          this.v1.fromArray(a.v1);
          this.v2.fromArray(a.v2);
          return this;
        };
        Cd.prototype = Object.create(la.prototype);
        Cd.prototype.constructor = Cd;
        Cd.prototype.isSplineCurve = !0;
        Cd.prototype.getPoint = function(a, b) {
          b = b || new c();
          var d = this.points,
            g = (d.length - 1) * a;
          a = Math.floor(g);
          g -= a;
          var e = d[0 === a ? a : a - 1],
            f = d[a],
            h = d[a > d.length - 2 ? d.length - 1 : a + 1];
          d = d[a > d.length - 3 ? d.length - 1 : a + 2];
          b.set(Yf(g, e.x, f.x, h.x, d.x), Yf(g, e.y, f.y, h.y, d.y));
          return b;
        };
        Cd.prototype.copy = function(a) {
          la.prototype.copy.call(this, a);
          this.points = [];
          for (var b = 0, c = a.points.length; b < c; b++)
            this.points.push(a.points[b].clone());
          return this;
        };
        Cd.prototype.toJSON = function() {
          var a = la.prototype.toJSON.call(this);
          a.points = [];
          for (var b = 0, c = this.points.length; b < c; b++)
            a.points.push(this.points[b].toArray());
          return a;
        };
        Cd.prototype.fromJSON = function(a) {
          la.prototype.fromJSON.call(this, a);
          this.points = [];
          for (var b = 0, d = a.points.length; b < d; b++) {
            var g = a.points[b];
            this.points.push(new c().fromArray(g));
          }
          return this;
        };
        var ch = Object.freeze({
          ArcCurve: Oi,
          CatmullRomCurve3: sb,
          CubicBezierCurve: zd,
          CubicBezierCurve3: ze,
          EllipseCurve: $b,
          LineCurve: Kb,
          LineCurve3: Ad,
          QuadraticBezierCurve: Bd,
          QuadraticBezierCurve3: Ae,
          SplineCurve: Cd
        });
        jf.prototype = Object.assign(Object.create(la.prototype), {
          constructor: jf,
          add: function(a) {
            this.curves.push(a);
          },
          closePath: function() {
            var a = this.curves[0].getPoint(0),
              b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new Kb(b, a));
          },
          getPoint: function(a) {
            var b = a * this.getLength(),
              c = this.getCurveLengths();
            for (a = 0; a < c.length; ) {
              if (c[a] >= b)
                return (
                  (b = c[a] - b),
                  (a = this.curves[a]),
                  (c = a.getLength()),
                  a.getPointAt(0 === c ? 0 : 1 - b / c)
                );
              a++;
            }
            return null;
          },
          getLength: function() {
            var a = this.getCurveLengths();
            return a[a.length - 1];
          },
          updateArcLengths: function() {
            this.needsUpdate = !0;
            this.cacheLengths = null;
            this.getCurveLengths();
          },
          getCurveLengths: function() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)
              (b += this.curves[c].getLength()), a.push(b);
            return (this.cacheLengths = a);
          },
          getSpacedPoints: function(a) {
            void 0 === a && (a = 40);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            this.autoClose && b.push(b[0]);
            return b;
          },
          getPoints: function(a) {
            a = a || 12;
            for (var b = [], c, d = 0, g = this.curves; d < g.length; d++) {
              var e = g[d];
              e = e.getPoints(
                e && e.isEllipseCurve
                  ? 2 * a
                  : e && (e.isLineCurve || e.isLineCurve3)
                  ? 1
                  : e && e.isSplineCurve
                  ? a * e.points.length
                  : a
              );
              for (var f = 0; f < e.length; f++) {
                var h = e[f];
                (c && c.equals(h)) || (b.push(h), (c = h));
              }
            }
            this.autoClose &&
              1 < b.length &&
              !b[b.length - 1].equals(b[0]) &&
              b.push(b[0]);
            return b;
          },
          copy: function(a) {
            la.prototype.copy.call(this, a);
            this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++)
              this.curves.push(a.curves[b].clone());
            this.autoClose = a.autoClose;
            return this;
          },
          toJSON: function() {
            var a = la.prototype.toJSON.call(this);
            a.autoClose = this.autoClose;
            a.curves = [];
            for (var b = 0, c = this.curves.length; b < c; b++)
              a.curves.push(this.curves[b].toJSON());
            return a;
          },
          fromJSON: function(a) {
            la.prototype.fromJSON.call(this, a);
            this.autoClose = a.autoClose;
            this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++) {
              var d = a.curves[b];
              this.curves.push(new ch[d.type]().fromJSON(d));
            }
            return this;
          }
        });
        Dd.prototype = Object.assign(Object.create(jf.prototype), {
          constructor: Dd,
          setFromPoints: function(a) {
            this.moveTo(a[0].x, a[0].y);
            for (var b = 1, c = a.length; b < c; b++)
              this.lineTo(a[b].x, a[b].y);
          },
          moveTo: function(a, b) {
            this.currentPoint.set(a, b);
          },
          lineTo: function(a, b) {
            var d = new Kb(this.currentPoint.clone(), new c(a, b));
            this.curves.push(d);
            this.currentPoint.set(a, b);
          },
          quadraticCurveTo: function(a, b, d, e) {
            a = new Bd(this.currentPoint.clone(), new c(a, b), new c(d, e));
            this.curves.push(a);
            this.currentPoint.set(d, e);
          },
          bezierCurveTo: function(a, b, d, e, f, h) {
            a = new zd(
              this.currentPoint.clone(),
              new c(a, b),
              new c(d, e),
              new c(f, h)
            );
            this.curves.push(a);
            this.currentPoint.set(f, h);
          },
          splineThru: function(a) {
            var b = [this.currentPoint.clone()].concat(a);
            b = new Cd(b);
            this.curves.push(b);
            this.currentPoint.copy(a[a.length - 1]);
          },
          arc: function(a, b, c, d, e, f) {
            this.absarc(
              a + this.currentPoint.x,
              b + this.currentPoint.y,
              c,
              d,
              e,
              f
            );
          },
          absarc: function(a, b, c, d, e, f) {
            this.absellipse(a, b, c, c, d, e, f);
          },
          ellipse: function(a, b, c, d, e, f, h, k) {
            this.absellipse(
              a + this.currentPoint.x,
              b + this.currentPoint.y,
              c,
              d,
              e,
              f,
              h,
              k
            );
          },
          absellipse: function(a, b, c, d, e, f, h, k) {
            a = new $b(a, b, c, d, e, f, h, k);
            0 < this.curves.length &&
              ((b = a.getPoint(0)),
              b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
            this.curves.push(a);
            a = a.getPoint(1);
            this.currentPoint.copy(a);
          },
          copy: function(a) {
            jf.prototype.copy.call(this, a);
            this.currentPoint.copy(a.currentPoint);
            return this;
          },
          toJSON: function() {
            var a = jf.prototype.toJSON.call(this);
            a.currentPoint = this.currentPoint.toArray();
            return a;
          },
          fromJSON: function(a) {
            jf.prototype.fromJSON.call(this, a);
            this.currentPoint.fromArray(a.currentPoint);
            return this;
          }
        });
        eg.prototype = Object.assign(Object.create(Dd.prototype), {
          constructor: eg,
          getPointsHoles: function(a) {
            for (var b = [], c = 0, d = this.holes.length; c < d; c++)
              b[c] = this.holes[c].getPoints(a);
            return b;
          },
          extractPoints: function(a) {
            return { shape: this.getPoints(a), holes: this.getPointsHoles(a) };
          },
          copy: function(a) {
            Dd.prototype.copy.call(this, a);
            this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++)
              this.holes.push(a.holes[b].clone());
            return this;
          },
          toJSON: function() {
            var a = Dd.prototype.toJSON.call(this);
            a.uuid = this.uuid;
            a.holes = [];
            for (var b = 0, c = this.holes.length; b < c; b++)
              a.holes.push(this.holes[b].toJSON());
            return a;
          },
          fromJSON: function(a) {
            Dd.prototype.fromJSON.call(this, a);
            this.uuid = a.uuid;
            this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++) {
              var d = a.holes[b];
              this.holes.push(new Dd().fromJSON(d));
            }
            return this;
          }
        });
        Ka.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Ka,
          isLight: !0,
          copy: function(a) {
            v.prototype.copy.call(this, a);
            this.color.copy(a.color);
            this.intensity = a.intensity;
            return this;
          },
          toJSON: function(a) {
            a = v.prototype.toJSON.call(this, a);
            a.object.color = this.color.getHex();
            a.object.intensity = this.intensity;
            void 0 !== this.groundColor &&
              (a.object.groundColor = this.groundColor.getHex());
            void 0 !== this.distance && (a.object.distance = this.distance);
            void 0 !== this.angle && (a.object.angle = this.angle);
            void 0 !== this.decay && (a.object.decay = this.decay);
            void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
            void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
            return a;
          }
        });
        ge.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: ge,
          isHemisphereLight: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.groundColor.copy(a.groundColor);
            return this;
          }
        });
        Object.assign(Be.prototype, {
          _projScreenMatrix: new t(),
          _lightPositionWorld: new h(),
          _lookTarget: new h(),
          getViewportCount: function() {
            return this._viewportCount;
          },
          getFrustum: function() {
            return this._frustum;
          },
          updateMatrices: function(a) {
            var b = this.camera,
              c = this.matrix,
              d = this._projScreenMatrix,
              g = this._lookTarget,
              e = this._lightPositionWorld;
            e.setFromMatrixPosition(a.matrixWorld);
            b.position.copy(e);
            g.setFromMatrixPosition(a.target.matrixWorld);
            b.lookAt(g);
            b.updateMatrixWorld();
            d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            this._frustum.setFromMatrix(d);
            c.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            c.multiply(b.projectionMatrix);
            c.multiply(b.matrixWorldInverse);
          },
          getViewport: function(a) {
            return this._viewports[a];
          },
          getFrameExtents: function() {
            return this._frameExtents;
          },
          copy: function(a) {
            this.camera = a.camera.clone();
            this.bias = a.bias;
            this.radius = a.radius;
            this.mapSize.copy(a.mapSize);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          toJSON: function() {
            var a = {};
            0 !== this.bias && (a.bias = this.bias);
            1 !== this.radius && (a.radius = this.radius);
            if (512 !== this.mapSize.x || 512 !== this.mapSize.y)
              a.mapSize = this.mapSize.toArray();
            a.camera = this.camera.toJSON(!1).object;
            delete a.camera.matrix;
            return a;
          }
        });
        he.prototype = Object.assign(Object.create(Be.prototype), {
          constructor: he,
          isSpotLightShadow: !0,
          updateMatrices: function(a, b, c) {
            var d = this.camera,
              g = 2 * ya.RAD2DEG * a.angle,
              e = this.mapSize.width / this.mapSize.height,
              f = a.distance || d.far;
            if (g !== d.fov || e !== d.aspect || f !== d.far)
              (d.fov = g),
                (d.aspect = e),
                (d.far = f),
                d.updateProjectionMatrix();
            Be.prototype.updateMatrices.call(this, a, b, c);
          }
        });
        ie.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: ie,
          isSpotLight: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.distance = a.distance;
            this.angle = a.angle;
            this.penumbra = a.penumbra;
            this.decay = a.decay;
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this;
          }
        });
        df.prototype = Object.assign(Object.create(Be.prototype), {
          constructor: df,
          isPointLightShadow: !0,
          updateMatrices: function(a, b, c) {
            b = this.camera;
            var d = this.matrix,
              g = this._lightPositionWorld,
              e = this._lookTarget,
              f = this._projScreenMatrix;
            g.setFromMatrixPosition(a.matrixWorld);
            b.position.copy(g);
            e.copy(b.position);
            e.add(this._cubeDirections[c]);
            b.up.copy(this._cubeUps[c]);
            b.lookAt(e);
            b.updateMatrixWorld();
            d.makeTranslation(-g.x, -g.y, -g.z);
            f.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            this._frustum.setFromMatrix(f);
          }
        });
        je.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: je,
          isPointLight: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.distance = a.distance;
            this.decay = a.decay;
            this.shadow = a.shadow.clone();
            return this;
          }
        });
        td.prototype = Object.assign(Object.create(ua.prototype), {
          constructor: td,
          isOrthographicCamera: !0,
          copy: function(a, b) {
            ua.prototype.copy.call(this, a, b);
            this.left = a.left;
            this.right = a.right;
            this.top = a.top;
            this.bottom = a.bottom;
            this.near = a.near;
            this.far = a.far;
            this.zoom = a.zoom;
            this.view = null === a.view ? null : Object.assign({}, a.view);
            return this;
          },
          setViewOffset: function(a, b, c, d, e, f) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
              });
            this.view.enabled = !0;
            this.view.fullWidth = a;
            this.view.fullHeight = b;
            this.view.offsetX = c;
            this.view.offsetY = d;
            this.view.width = e;
            this.view.height = f;
            this.updateProjectionMatrix();
          },
          clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1);
            this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function() {
            var a = (this.right - this.left) / (2 * this.zoom),
              b = (this.top - this.bottom) / (2 * this.zoom),
              c = (this.right + this.left) / 2,
              d = (this.top + this.bottom) / 2,
              e = c - a;
            c += a;
            a = d + b;
            b = d - b;
            if (null !== this.view && this.view.enabled) {
              c = this.zoom / (this.view.width / this.view.fullWidth);
              b = this.zoom / (this.view.height / this.view.fullHeight);
              var f = (this.right - this.left) / this.view.width;
              d = (this.top - this.bottom) / this.view.height;
              e += (this.view.offsetX / c) * f;
              c = e + (this.view.width / c) * f;
              a -= (this.view.offsetY / b) * d;
              b = a - (this.view.height / b) * d;
            }
            this.projectionMatrix.makeOrthographic(
              e,
              c,
              a,
              b,
              this.near,
              this.far
            );
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
          },
          toJSON: function(a) {
            a = v.prototype.toJSON.call(this, a);
            a.object.zoom = this.zoom;
            a.object.left = this.left;
            a.object.right = this.right;
            a.object.top = this.top;
            a.object.bottom = this.bottom;
            a.object.near = this.near;
            a.object.far = this.far;
            null !== this.view &&
              (a.object.view = Object.assign({}, this.view));
            return a;
          }
        });
        le.prototype = Object.assign(Object.create(Be.prototype), {
          constructor: le,
          isDirectionalLightShadow: !0,
          updateMatrices: function(a, b, c) {
            Be.prototype.updateMatrices.call(this, a, b, c);
          }
        });
        me.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: me,
          isDirectionalLight: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this;
          }
        });
        ne.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: ne,
          isAmbientLight: !0
        });
        oe.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: oe,
          isRectAreaLight: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.width = a.width;
            this.height = a.height;
            return this;
          },
          toJSON: function(a) {
            a = Ka.prototype.toJSON.call(this, a);
            a.object.width = this.width;
            a.object.height = this.height;
            return a;
          }
        });
        pe.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: pe,
          load: function(a, b, c, d) {
            var g = this,
              e = new Pc(g.manager);
            e.setPath(g.path);
            e.load(
              a,
              function(a) {
                b(g.parse(JSON.parse(a)));
              },
              c,
              d
            );
          },
          parse: function(a) {
            function b(a) {
              void 0 === d[a] &&
                console.warn("THREE.MaterialLoader: Undefined texture", a);
              return d[a];
            }
            var d = this.textures,
              g = new Gj[a.type]();
            void 0 !== a.uuid && (g.uuid = a.uuid);
            void 0 !== a.name && (g.name = a.name);
            void 0 !== a.color && g.color.setHex(a.color);
            void 0 !== a.roughness && (g.roughness = a.roughness);
            void 0 !== a.metalness && (g.metalness = a.metalness);
            void 0 !== a.sheen && (g.sheen = new M().setHex(a.sheen));
            void 0 !== a.emissive && g.emissive.setHex(a.emissive);
            void 0 !== a.specular && g.specular.setHex(a.specular);
            void 0 !== a.shininess && (g.shininess = a.shininess);
            void 0 !== a.clearcoat && (g.clearcoat = a.clearcoat);
            void 0 !== a.clearcoatRoughness &&
              (g.clearcoatRoughness = a.clearcoatRoughness);
            void 0 !== a.vertexColors && (g.vertexColors = a.vertexColors);
            void 0 !== a.fog && (g.fog = a.fog);
            void 0 !== a.flatShading && (g.flatShading = a.flatShading);
            void 0 !== a.blending && (g.blending = a.blending);
            void 0 !== a.combine && (g.combine = a.combine);
            void 0 !== a.side && (g.side = a.side);
            void 0 !== a.opacity && (g.opacity = a.opacity);
            void 0 !== a.transparent && (g.transparent = a.transparent);
            void 0 !== a.alphaTest && (g.alphaTest = a.alphaTest);
            void 0 !== a.depthTest && (g.depthTest = a.depthTest);
            void 0 !== a.depthWrite && (g.depthWrite = a.depthWrite);
            void 0 !== a.colorWrite && (g.colorWrite = a.colorWrite);
            void 0 !== a.stencilWrite && (g.stencilWrite = a.stencilWrite);
            void 0 !== a.stencilWriteMask &&
              (g.stencilWriteMask = a.stencilWriteMask);
            void 0 !== a.stencilFunc && (g.stencilFunc = a.stencilFunc);
            void 0 !== a.stencilRef && (g.stencilRef = a.stencilRef);
            void 0 !== a.stencilFuncMask &&
              (g.stencilFuncMask = a.stencilFuncMask);
            void 0 !== a.stencilFail && (g.stencilFail = a.stencilFail);
            void 0 !== a.stencilZFail && (g.stencilZFail = a.stencilZFail);
            void 0 !== a.stencilZPass && (g.stencilZPass = a.stencilZPass);
            void 0 !== a.wireframe && (g.wireframe = a.wireframe);
            void 0 !== a.wireframeLinewidth &&
              (g.wireframeLinewidth = a.wireframeLinewidth);
            void 0 !== a.wireframeLinecap &&
              (g.wireframeLinecap = a.wireframeLinecap);
            void 0 !== a.wireframeLinejoin &&
              (g.wireframeLinejoin = a.wireframeLinejoin);
            void 0 !== a.rotation && (g.rotation = a.rotation);
            1 !== a.linewidth && (g.linewidth = a.linewidth);
            void 0 !== a.dashSize && (g.dashSize = a.dashSize);
            void 0 !== a.gapSize && (g.gapSize = a.gapSize);
            void 0 !== a.scale && (g.scale = a.scale);
            void 0 !== a.polygonOffset && (g.polygonOffset = a.polygonOffset);
            void 0 !== a.polygonOffsetFactor &&
              (g.polygonOffsetFactor = a.polygonOffsetFactor);
            void 0 !== a.polygonOffsetUnits &&
              (g.polygonOffsetUnits = a.polygonOffsetUnits);
            void 0 !== a.skinning && (g.skinning = a.skinning);
            void 0 !== a.morphTargets && (g.morphTargets = a.morphTargets);
            void 0 !== a.morphNormals && (g.morphNormals = a.morphNormals);
            void 0 !== a.dithering && (g.dithering = a.dithering);
            void 0 !== a.visible && (g.visible = a.visible);
            void 0 !== a.toneMapped && (g.toneMapped = a.toneMapped);
            void 0 !== a.userData && (g.userData = a.userData);
            if (void 0 !== a.uniforms)
              for (var e in a.uniforms) {
                var f = a.uniforms[e];
                g.uniforms[e] = {};
                switch (f.type) {
                  case "t":
                    g.uniforms[e].value = b(f.value);
                    break;
                  case "c":
                    g.uniforms[e].value = new M().setHex(f.value);
                    break;
                  case "v2":
                    g.uniforms[e].value = new c().fromArray(f.value);
                    break;
                  case "v3":
                    g.uniforms[e].value = new h().fromArray(f.value);
                    break;
                  case "v4":
                    g.uniforms[e].value = new m().fromArray(f.value);
                    break;
                  case "m3":
                    g.uniforms[e].value = new k().fromArray(f.value);
                  case "m4":
                    g.uniforms[e].value = new t().fromArray(f.value);
                    break;
                  default:
                    g.uniforms[e].value = f.value;
                }
              }
            void 0 !== a.defines && (g.defines = a.defines);
            void 0 !== a.vertexShader && (g.vertexShader = a.vertexShader);
            void 0 !== a.fragmentShader &&
              (g.fragmentShader = a.fragmentShader);
            if (void 0 !== a.extensions)
              for (var l in a.extensions) g.extensions[l] = a.extensions[l];
            void 0 !== a.shading && (g.flatShading = 1 === a.shading);
            void 0 !== a.size && (g.size = a.size);
            void 0 !== a.sizeAttenuation &&
              (g.sizeAttenuation = a.sizeAttenuation);
            void 0 !== a.map && (g.map = b(a.map));
            void 0 !== a.matcap && (g.matcap = b(a.matcap));
            void 0 !== a.alphaMap &&
              ((g.alphaMap = b(a.alphaMap)), (g.transparent = !0));
            void 0 !== a.bumpMap && (g.bumpMap = b(a.bumpMap));
            void 0 !== a.bumpScale && (g.bumpScale = a.bumpScale);
            void 0 !== a.normalMap && (g.normalMap = b(a.normalMap));
            void 0 !== a.normalMapType && (g.normalMapType = a.normalMapType);
            void 0 !== a.normalScale &&
              ((e = a.normalScale),
              !1 === Array.isArray(e) && (e = [e, e]),
              (g.normalScale = new c().fromArray(e)));
            void 0 !== a.displacementMap &&
              (g.displacementMap = b(a.displacementMap));
            void 0 !== a.displacementScale &&
              (g.displacementScale = a.displacementScale);
            void 0 !== a.displacementBias &&
              (g.displacementBias = a.displacementBias);
            void 0 !== a.roughnessMap && (g.roughnessMap = b(a.roughnessMap));
            void 0 !== a.metalnessMap && (g.metalnessMap = b(a.metalnessMap));
            void 0 !== a.emissiveMap && (g.emissiveMap = b(a.emissiveMap));
            void 0 !== a.emissiveIntensity &&
              (g.emissiveIntensity = a.emissiveIntensity);
            void 0 !== a.specularMap && (g.specularMap = b(a.specularMap));
            void 0 !== a.envMap && (g.envMap = b(a.envMap));
            void 0 !== a.envMapIntensity &&
              (g.envMapIntensity = a.envMapIntensity);
            void 0 !== a.reflectivity && (g.reflectivity = a.reflectivity);
            void 0 !== a.refractionRatio &&
              (g.refractionRatio = a.refractionRatio);
            void 0 !== a.lightMap && (g.lightMap = b(a.lightMap));
            void 0 !== a.lightMapIntensity &&
              (g.lightMapIntensity = a.lightMapIntensity);
            void 0 !== a.aoMap && (g.aoMap = b(a.aoMap));
            void 0 !== a.aoMapIntensity &&
              (g.aoMapIntensity = a.aoMapIntensity);
            void 0 !== a.gradientMap && (g.gradientMap = b(a.gradientMap));
            void 0 !== a.clearcoatNormalMap &&
              (g.clearcoatNormalMap = b(a.clearcoatNormalMap));
            void 0 !== a.clearcoatNormalScale &&
              (g.clearcoatNormalScale = new c().fromArray(
                a.clearcoatNormalScale
              ));
            return g;
          },
          setTextures: function(a) {
            this.textures = a;
            return this;
          }
        });
        var dh = {
          decodeText: function(a) {
            if ("undefined" !== typeof TextDecoder)
              return new TextDecoder().decode(a);
            for (var b = "", c = 0, d = a.length; c < d; c++)
              b += String.fromCharCode(a[c]);
            try {
              return decodeURIComponent(escape(b));
            } catch (K) {
              return b;
            }
          },
          extractUrlBase: function(a) {
            var b = a.lastIndexOf("/");
            return -1 === b ? "./" : a.substr(0, b + 1);
          }
        };
        qe.prototype = Object.assign(Object.create(S.prototype), {
          constructor: qe,
          isInstancedBufferGeometry: !0,
          copy: function(a) {
            S.prototype.copy.call(this, a);
            this.maxInstancedCount = a.maxInstancedCount;
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          toJSON: function() {
            var a = S.prototype.toJSON.call(this);
            a.maxInstancedCount = this.maxInstancedCount;
            a.isInstancedBufferGeometry = !0;
            return a;
          }
        });
        re.prototype = Object.assign(Object.create(I.prototype), {
          constructor: re,
          isInstancedBufferAttribute: !0,
          copy: function(a) {
            I.prototype.copy.call(this, a);
            this.meshPerAttribute = a.meshPerAttribute;
            return this;
          },
          toJSON: function() {
            var a = I.prototype.toJSON.call(this);
            a.meshPerAttribute = this.meshPerAttribute;
            a.isInstancedBufferAttribute = !0;
            return a;
          }
        });
        se.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: se,
          load: function(a, b, c, d) {
            var g = this,
              e = new Pc(g.manager);
            e.setPath(g.path);
            e.load(
              a,
              function(a) {
                b(g.parse(JSON.parse(a)));
              },
              c,
              d
            );
          },
          parse: function(a) {
            var b = a.isInstancedBufferGeometry ? new qe() : new S(),
              c = a.data.index;
            if (void 0 !== c) {
              var d = new eh[c.type](c.array);
              b.setIndex(new I(d, 1));
            }
            c = a.data.attributes;
            for (var g in c) {
              var e = c[g];
              d = new eh[e.type](e.array);
              d = new (e.isInstancedBufferAttribute ? re : I)(
                d,
                e.itemSize,
                e.normalized
              );
              void 0 !== e.name && (d.name = e.name);
              b.addAttribute(g, d);
            }
            var f = a.data.morphAttributes;
            if (f)
              for (g in f) {
                var k = f[g],
                  l = [];
                c = 0;
                for (var m = k.length; c < m; c++)
                  (e = k[c]),
                    (d = new eh[e.type](e.array)),
                    (d = new I(d, e.itemSize, e.normalized)),
                    void 0 !== e.name && (d.name = e.name),
                    l.push(d);
                b.morphAttributes[g] = l;
              }
            g = a.data.groups || a.data.drawcalls || a.data.offsets;
            if (void 0 !== g)
              for (c = 0, e = g.length; c !== e; ++c)
                (d = g[c]), b.addGroup(d.start, d.count, d.materialIndex);
            c = a.data.boundingSphere;
            void 0 !== c &&
              ((g = new h()),
              void 0 !== c.center && g.fromArray(c.center),
              (b.boundingSphere = new H(g, c.radius)));
            a.name && (b.name = a.name);
            a.userData && (b.userData = a.userData);
            return b;
          }
        });
        var eh = {
          Int8Array: Int8Array,
          Uint8Array: Uint8Array,
          Uint8ClampedArray:
            "undefined" !== typeof Uint8ClampedArray
              ? Uint8ClampedArray
              : Uint8Array,
          Int16Array: Int16Array,
          Uint16Array: Uint16Array,
          Int32Array: Int32Array,
          Uint32Array: Uint32Array,
          Float32Array: Float32Array,
          Float64Array: Float64Array
        };
        Ge.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Ge,
          load: function(a, b, c, d) {
            var g = this,
              e = "" === this.path ? dh.extractUrlBase(a) : this.path;
            this.resourcePath = this.resourcePath || e;
            e = new Pc(g.manager);
            e.setPath(this.path);
            e.load(
              a,
              function(c) {
                var e = null;
                try {
                  e = JSON.parse(c);
                } catch (R) {
                  void 0 !== d && d(R);
                  console.error(
                    "THREE:ObjectLoader: Can't parse " + a + ".",
                    R.message
                  );
                  return;
                }
                c = e.metadata;
                void 0 === c ||
                void 0 === c.type ||
                "geometry" === c.type.toLowerCase()
                  ? console.error("THREE.ObjectLoader: Can't load " + a)
                  : g.parse(e, b);
              },
              c,
              d
            );
          },
          parse: function(a, b) {
            var c = this.parseShape(a.shapes);
            c = this.parseGeometries(a.geometries, c);
            var d = this.parseImages(a.images, function() {
              void 0 !== b && b(g);
            });
            d = this.parseTextures(a.textures, d);
            d = this.parseMaterials(a.materials, d);
            var g = this.parseObject(a.object, c, d);
            a.animations && (g.animations = this.parseAnimations(a.animations));
            (void 0 !== a.images && 0 !== a.images.length) ||
              void 0 === b ||
              b(g);
            return g;
          },
          parseShape: function(a) {
            var b = {};
            if (void 0 !== a)
              for (var c = 0, d = a.length; c < d; c++) {
                var g = new eg().fromJSON(a[c]);
                b[g.uuid] = g;
              }
            return b;
          },
          parseGeometries: function(a, b) {
            var c = {};
            if (void 0 !== a)
              for (var d = new se(), g = 0, e = a.length; g < e; g++) {
                var f = a[g];
                switch (f.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    var h = new Bb[f.type](
                      f.width,
                      f.height,
                      f.widthSegments,
                      f.heightSegments
                    );
                    break;
                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    h = new Bb[f.type](
                      f.width,
                      f.height,
                      f.depth,
                      f.widthSegments,
                      f.heightSegments,
                      f.depthSegments
                    );
                    break;
                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    h = new Bb[f.type](
                      f.radius,
                      f.segments,
                      f.thetaStart,
                      f.thetaLength
                    );
                    break;
                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    h = new Bb[f.type](
                      f.radiusTop,
                      f.radiusBottom,
                      f.height,
                      f.radialSegments,
                      f.heightSegments,
                      f.openEnded,
                      f.thetaStart,
                      f.thetaLength
                    );
                    break;
                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    h = new Bb[f.type](
                      f.radius,
                      f.height,
                      f.radialSegments,
                      f.heightSegments,
                      f.openEnded,
                      f.thetaStart,
                      f.thetaLength
                    );
                    break;
                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    h = new Bb[f.type](
                      f.radius,
                      f.widthSegments,
                      f.heightSegments,
                      f.phiStart,
                      f.phiLength,
                      f.thetaStart,
                      f.thetaLength
                    );
                    break;
                  case "DodecahedronGeometry":
                  case "DodecahedronBufferGeometry":
                  case "IcosahedronGeometry":
                  case "IcosahedronBufferGeometry":
                  case "OctahedronGeometry":
                  case "OctahedronBufferGeometry":
                  case "TetrahedronGeometry":
                  case "TetrahedronBufferGeometry":
                    h = new Bb[f.type](f.radius, f.detail);
                    break;
                  case "RingGeometry":
                  case "RingBufferGeometry":
                    h = new Bb[f.type](
                      f.innerRadius,
                      f.outerRadius,
                      f.thetaSegments,
                      f.phiSegments,
                      f.thetaStart,
                      f.thetaLength
                    );
                    break;
                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    h = new Bb[f.type](
                      f.radius,
                      f.tube,
                      f.radialSegments,
                      f.tubularSegments,
                      f.arc
                    );
                    break;
                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    h = new Bb[f.type](
                      f.radius,
                      f.tube,
                      f.tubularSegments,
                      f.radialSegments,
                      f.p,
                      f.q
                    );
                    break;
                  case "TubeGeometry":
                  case "TubeBufferGeometry":
                    h = new Bb[f.type](
                      new ch[f.path.type]().fromJSON(f.path),
                      f.tubularSegments,
                      f.radius,
                      f.radialSegments,
                      f.closed
                    );
                    break;
                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    h = new Bb[f.type](
                      f.points,
                      f.segments,
                      f.phiStart,
                      f.phiLength
                    );
                    break;
                  case "PolyhedronGeometry":
                  case "PolyhedronBufferGeometry":
                    h = new Bb[f.type](
                      f.vertices,
                      f.indices,
                      f.radius,
                      f.details
                    );
                    break;
                  case "ShapeGeometry":
                  case "ShapeBufferGeometry":
                    h = [];
                    for (var k = 0, l = f.shapes.length; k < l; k++) {
                      var p = b[f.shapes[k]];
                      h.push(p);
                    }
                    h = new Bb[f.type](h, f.curveSegments);
                    break;
                  case "ExtrudeGeometry":
                  case "ExtrudeBufferGeometry":
                    h = [];
                    k = 0;
                    for (l = f.shapes.length; k < l; k++)
                      (p = b[f.shapes[k]]), h.push(p);
                    k = f.options.extrudePath;
                    void 0 !== k &&
                      (f.options.extrudePath = new ch[k.type]().fromJSON(k));
                    h = new Bb[f.type](h, f.options);
                    break;
                  case "BufferGeometry":
                  case "InstancedBufferGeometry":
                    h = d.parse(f);
                    break;
                  case "Geometry":
                    "THREE" in window && "LegacyJSONLoader" in THREE
                      ? (h = new THREE.LegacyJSONLoader().parse(
                          f,
                          this.resourcePath
                        ).geometry)
                      : console.error(
                          'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
                        );
                    break;
                  default:
                    console.warn(
                      'THREE.ObjectLoader: Unsupported geometry type "' +
                        f.type +
                        '"'
                    );
                    continue;
                }
                h.uuid = f.uuid;
                void 0 !== f.name && (h.name = f.name);
                !0 === h.isBufferGeometry &&
                  void 0 !== f.userData &&
                  (h.userData = f.userData);
                c[f.uuid] = h;
              }
            return c;
          },
          parseMaterials: function(a, b) {
            var c = {},
              d = {};
            if (void 0 !== a) {
              var g = new pe();
              g.setTextures(b);
              b = 0;
              for (var e = a.length; b < e; b++) {
                var f = a[b];
                if ("MultiMaterial" === f.type) {
                  for (var h = [], k = 0; k < f.materials.length; k++) {
                    var l = f.materials[k];
                    void 0 === c[l.uuid] && (c[l.uuid] = g.parse(l));
                    h.push(c[l.uuid]);
                  }
                  d[f.uuid] = h;
                } else
                  void 0 === c[f.uuid] && (c[f.uuid] = g.parse(f)),
                    (d[f.uuid] = c[f.uuid]);
              }
            }
            return d;
          },
          parseAnimations: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
              var d = a[c],
                g = Oc.parse(d);
              void 0 !== d.uuid && (g.uuid = d.uuid);
              b.push(g);
            }
            return b;
          },
          parseImages: function(a, b) {
            function c(a) {
              d.manager.itemStart(a);
              return e.load(
                a,
                function() {
                  d.manager.itemEnd(a);
                },
                void 0,
                function() {
                  d.manager.itemError(a);
                  d.manager.itemEnd(a);
                }
              );
            }
            var d = this,
              g = {};
            if (void 0 !== a && 0 < a.length) {
              b = new Xe(b);
              var e = new Ni(b);
              e.setCrossOrigin(this.crossOrigin);
              b = 0;
              for (var f = a.length; b < f; b++) {
                var h = a[b],
                  k = h.url;
                if (Array.isArray(k)) {
                  g[h.uuid] = [];
                  for (var l = 0, p = k.length; l < p; l++) {
                    var m = k[l];
                    m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m)
                      ? m
                      : d.resourcePath + m;
                    g[h.uuid].push(c(m));
                  }
                } else
                  (m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url)
                    ? h.url
                    : d.resourcePath + h.url),
                    (g[h.uuid] = c(m));
              }
            }
            return g;
          },
          parseTextures: function(a, b) {
            function c(a, b) {
              if ("number" === typeof a) return a;
              console.warn(
                "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                a
              );
              return b[a];
            }
            var d = {};
            if (void 0 !== a)
              for (var g = 0, e = a.length; g < e; g++) {
                var f = a[g];
                void 0 === f.image &&
                  console.warn(
                    'THREE.ObjectLoader: No "image" specified for',
                    f.uuid
                  );
                void 0 === b[f.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", f.image);
                var h = Array.isArray(b[f.image])
                  ? new Ha(b[f.image])
                  : new l(b[f.image]);
                h.needsUpdate = !0;
                h.uuid = f.uuid;
                void 0 !== f.name && (h.name = f.name);
                void 0 !== f.mapping && (h.mapping = c(f.mapping, Hj));
                void 0 !== f.offset && h.offset.fromArray(f.offset);
                void 0 !== f.repeat && h.repeat.fromArray(f.repeat);
                void 0 !== f.center && h.center.fromArray(f.center);
                void 0 !== f.rotation && (h.rotation = f.rotation);
                void 0 !== f.wrap &&
                  ((h.wrapS = c(f.wrap[0], ri)), (h.wrapT = c(f.wrap[1], ri)));
                void 0 !== f.format && (h.format = f.format);
                void 0 !== f.type && (h.type = f.type);
                void 0 !== f.encoding && (h.encoding = f.encoding);
                void 0 !== f.minFilter && (h.minFilter = c(f.minFilter, si));
                void 0 !== f.magFilter && (h.magFilter = c(f.magFilter, si));
                void 0 !== f.anisotropy && (h.anisotropy = f.anisotropy);
                void 0 !== f.flipY && (h.flipY = f.flipY);
                void 0 !== f.premultiplyAlpha &&
                  (h.premultiplyAlpha = f.premultiplyAlpha);
                void 0 !== f.unpackAlignment &&
                  (h.unpackAlignment = f.unpackAlignment);
                d[f.uuid] = h;
              }
            return d;
          },
          parseObject: function(a, b, c) {
            function d(a) {
              void 0 === b[a] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", a);
              return b[a];
            }
            function g(a) {
              if (void 0 !== a) {
                if (Array.isArray(a)) {
                  for (var b = [], d = 0, g = a.length; d < g; d++) {
                    var e = a[d];
                    void 0 === c[e] &&
                      console.warn("THREE.ObjectLoader: Undefined material", e);
                    b.push(c[e]);
                  }
                  return b;
                }
                void 0 === c[a] &&
                  console.warn("THREE.ObjectLoader: Undefined material", a);
                return c[a];
              }
            }
            switch (a.type) {
              case "Scene":
                var e = new r();
                void 0 !== a.background &&
                  Number.isInteger(a.background) &&
                  (e.background = new M(a.background));
                void 0 !== a.fog &&
                  ("Fog" === a.fog.type
                    ? (e.fog = new Nc(a.fog.color, a.fog.near, a.fog.far))
                    : "FogExp2" === a.fog.type &&
                      (e.fog = new Mc(a.fog.color, a.fog.density)));
                break;
              case "PerspectiveCamera":
                e = new Da(a.fov, a.aspect, a.near, a.far);
                void 0 !== a.focus && (e.focus = a.focus);
                void 0 !== a.zoom && (e.zoom = a.zoom);
                void 0 !== a.filmGauge && (e.filmGauge = a.filmGauge);
                void 0 !== a.filmOffset && (e.filmOffset = a.filmOffset);
                void 0 !== a.view && (e.view = Object.assign({}, a.view));
                break;
              case "OrthographicCamera":
                e = new td(a.left, a.right, a.top, a.bottom, a.near, a.far);
                void 0 !== a.zoom && (e.zoom = a.zoom);
                void 0 !== a.view && (e.view = Object.assign({}, a.view));
                break;
              case "AmbientLight":
                e = new ne(a.color, a.intensity);
                break;
              case "DirectionalLight":
                e = new me(a.color, a.intensity);
                break;
              case "PointLight":
                e = new je(a.color, a.intensity, a.distance, a.decay);
                break;
              case "RectAreaLight":
                e = new oe(a.color, a.intensity, a.width, a.height);
                break;
              case "SpotLight":
                e = new ie(
                  a.color,
                  a.intensity,
                  a.distance,
                  a.angle,
                  a.penumbra,
                  a.decay
                );
                break;
              case "HemisphereLight":
                e = new ge(a.color, a.groundColor, a.intensity);
                break;
              case "SkinnedMesh":
                console.warn(
                  "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
                );
              case "Mesh":
                e = d(a.geometry);
                var f = g(a.material);
                e = e.bones && 0 < e.bones.length ? new hc(e, f) : new da(e, f);
                void 0 !== a.drawMode && e.setDrawMode(a.drawMode);
                break;
              case "LOD":
                e = new fc();
                break;
              case "Line":
                e = new nb(d(a.geometry), g(a.material), a.mode);
                break;
              case "LineLoop":
                e = new Zc(d(a.geometry), g(a.material));
                break;
              case "LineSegments":
                e = new Qa(d(a.geometry), g(a.material));
                break;
              case "PointCloud":
              case "Points":
                e = new Mb(d(a.geometry), g(a.material));
                break;
              case "Sprite":
                e = new dc(g(a.material));
                break;
              case "Group":
                e = new Fb();
                break;
              default:
                e = new v();
            }
            e.uuid = a.uuid;
            void 0 !== a.name && (e.name = a.name);
            void 0 !== a.matrix
              ? (e.matrix.fromArray(a.matrix),
                void 0 !== a.matrixAutoUpdate &&
                  (e.matrixAutoUpdate = a.matrixAutoUpdate),
                e.matrixAutoUpdate &&
                  e.matrix.decompose(e.position, e.quaternion, e.scale))
              : (void 0 !== a.position && e.position.fromArray(a.position),
                void 0 !== a.rotation && e.rotation.fromArray(a.rotation),
                void 0 !== a.quaternion && e.quaternion.fromArray(a.quaternion),
                void 0 !== a.scale && e.scale.fromArray(a.scale));
            void 0 !== a.castShadow && (e.castShadow = a.castShadow);
            void 0 !== a.receiveShadow && (e.receiveShadow = a.receiveShadow);
            a.shadow &&
              (void 0 !== a.shadow.bias && (e.shadow.bias = a.shadow.bias),
              void 0 !== a.shadow.radius && (e.shadow.radius = a.shadow.radius),
              void 0 !== a.shadow.mapSize &&
                e.shadow.mapSize.fromArray(a.shadow.mapSize),
              void 0 !== a.shadow.camera &&
                (e.shadow.camera = this.parseObject(a.shadow.camera)));
            void 0 !== a.visible && (e.visible = a.visible);
            void 0 !== a.frustumCulled && (e.frustumCulled = a.frustumCulled);
            void 0 !== a.renderOrder && (e.renderOrder = a.renderOrder);
            void 0 !== a.userData && (e.userData = a.userData);
            void 0 !== a.layers && (e.layers.mask = a.layers);
            if (void 0 !== a.children) {
              f = a.children;
              for (var h = 0; h < f.length; h++)
                e.add(this.parseObject(f[h], b, c));
            }
            if ("LOD" === a.type)
              for (a = a.levels, f = 0; f < a.length; f++) {
                h = a[f];
                var k = e.getObjectByProperty("uuid", h.object);
                void 0 !== k && e.addLevel(k, h.distance);
              }
            return e;
          }
        });
        var Hj = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
          },
          ri = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
          },
          si = {
            NearestFilter: 1003,
            NearestMipmapNearestFilter: 1004,
            NearestMipmapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipmapNearestFilter: 1007,
            LinearMipmapLinearFilter: 1008
          };
        sf.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: sf,
          setOptions: function(a) {
            this.options = a;
            return this;
          },
          load: function(a, b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var g = this,
              e = Fh.get(a);
            if (void 0 !== e)
              return (
                g.manager.itemStart(a),
                setTimeout(function() {
                  b && b(e);
                  g.manager.itemEnd(a);
                }, 0),
                e
              );
            fetch(a)
              .then(function(a) {
                return a.blob();
              })
              .then(function(a) {
                return void 0 === g.options
                  ? createImageBitmap(a)
                  : createImageBitmap(a, g.options);
              })
              .then(function(c) {
                Fh.add(a, c);
                b && b(c);
                g.manager.itemEnd(a);
              })
              .catch(function(b) {
                d && d(b);
                g.manager.itemError(a);
                g.manager.itemEnd(a);
              });
            g.manager.itemStart(a);
          }
        });
        Object.assign(tf.prototype, {
          moveTo: function(a, b) {
            this.currentPath = new Dd();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(a, b);
          },
          lineTo: function(a, b) {
            this.currentPath.lineTo(a, b);
          },
          quadraticCurveTo: function(a, b, c, d) {
            this.currentPath.quadraticCurveTo(a, b, c, d);
          },
          bezierCurveTo: function(a, b, c, d, e, f) {
            this.currentPath.bezierCurveTo(a, b, c, d, e, f);
          },
          splineThru: function(a) {
            this.currentPath.splineThru(a);
          },
          toShapes: function(a, b) {
            function c(a) {
              for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c],
                  g = new eg();
                g.curves = e.curves;
                b.push(g);
              }
              return b;
            }
            function d(a, b) {
              for (var c = b.length, d = !1, e = c - 1, g = 0; g < c; e = g++) {
                var f = b[e],
                  h = b[g],
                  k = h.x - f.x,
                  l = h.y - f.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (0 > l && ((f = b[g]), (k = -k), (h = b[e]), (l = -l)),
                    !(a.y < f.y || a.y > h.y))
                  )
                    if (a.y === f.y) {
                      if (a.x === f.x) return !0;
                    } else {
                      e = l * (a.x - f.x) - k * (a.y - f.y);
                      if (0 === e) return !0;
                      0 > e || (d = !d);
                    }
                } else if (
                  a.y === f.y &&
                  ((h.x <= a.x && a.x <= f.x) || (f.x <= a.x && a.x <= h.x))
                )
                  return !0;
              }
              return d;
            }
            var e = gf.isClockWise,
              g = this.subPaths;
            if (0 === g.length) return [];
            if (!0 === b) return c(g);
            b = [];
            if (1 === g.length) {
              var f = g[0];
              var h = new eg();
              h.curves = f.curves;
              b.push(h);
              return b;
            }
            var k = !e(g[0].getPoints());
            k = a ? !k : k;
            h = [];
            var l = [],
              m = [],
              p = 0;
            l[p] = void 0;
            m[p] = [];
            for (var n = 0, q = g.length; n < q; n++) {
              f = g[n];
              var t = f.getPoints();
              var u = e(t);
              (u = a ? !u : u)
                ? (!k && l[p] && p++,
                  (l[p] = { s: new eg(), p: t }),
                  (l[p].s.curves = f.curves),
                  k && p++,
                  (m[p] = []))
                : m[p].push({ h: f, p: t[0] });
            }
            if (!l[0]) return c(g);
            if (1 < l.length) {
              n = !1;
              a = [];
              e = 0;
              for (g = l.length; e < g; e++) h[e] = [];
              e = 0;
              for (g = l.length; e < g; e++)
                for (f = m[e], u = 0; u < f.length; u++) {
                  k = f[u];
                  p = !0;
                  for (t = 0; t < l.length; t++)
                    d(k.p, l[t].p) &&
                      (e !== t && a.push({ froms: e, tos: t, hole: u }),
                      p ? ((p = !1), h[t].push(k)) : (n = !0));
                  p && h[e].push(k);
                }
              0 < a.length && (n || (m = h));
            }
            n = 0;
            for (e = l.length; n < e; n++)
              for (
                h = l[n].s, b.push(h), a = m[n], g = 0, f = a.length;
                g < f;
                g++
              )
                h.holes.push(a[g].h);
            return b;
          }
        });
        Object.assign(vf.prototype, {
          isFont: !0,
          generateShapes: function(a, b) {
            void 0 === b && (b = 100);
            var c = [],
              d = b;
            b = this.data;
            var e = Array.from ? Array.from(a) : String(a).split("");
            d /= b.resolution;
            var g =
              (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) *
              d;
            a = [];
            for (var f = 0, h = 0, k = 0; k < e.length; k++) {
              var l = e[k];
              if ("\n" === l) (f = 0), (h -= g);
              else {
                var m = l;
                l = d;
                var p = f,
                  n = h,
                  q = b,
                  t = q.glyphs[m] || q.glyphs["?"];
                if (t) {
                  m = new tf();
                  if (t.o) {
                    q = t._cachedOutline || (t._cachedOutline = t.o.split(" "));
                    for (var u = 0, r = q.length; u < r; )
                      switch (q[u++]) {
                        case "m":
                          var y = q[u++] * l + p;
                          var v = q[u++] * l + n;
                          m.moveTo(y, v);
                          break;
                        case "l":
                          y = q[u++] * l + p;
                          v = q[u++] * l + n;
                          m.lineTo(y, v);
                          break;
                        case "q":
                          var z = q[u++] * l + p;
                          var A = q[u++] * l + n;
                          var B = q[u++] * l + p;
                          var C = q[u++] * l + n;
                          m.quadraticCurveTo(B, C, z, A);
                          break;
                        case "b":
                          (z = q[u++] * l + p),
                            (A = q[u++] * l + n),
                            (B = q[u++] * l + p),
                            (C = q[u++] * l + n),
                            (y = q[u++] * l + p),
                            (v = q[u++] * l + n),
                            m.bezierCurveTo(B, C, y, v, z, A);
                      }
                  }
                  l = { offsetX: t.ha * l, path: m };
                } else
                  console.error(
                    'THREE.Font: character "' +
                      m +
                      '" does not exists in font family ' +
                      q.familyName +
                      "."
                  ),
                    (l = void 0);
                f += l.offsetX;
                a.push(l.path);
              }
            }
            b = 0;
            for (e = a.length; b < e; b++)
              Array.prototype.push.apply(c, a[b].toShapes());
            return c;
          }
        });
        Af.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Af,
          load: function(a, b, c, d) {
            var e = this,
              g = new Pc(this.manager);
            g.setPath(this.path);
            g.load(
              a,
              function(a) {
                try {
                  var c = JSON.parse(a);
                } catch (R) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (c = JSON.parse(a.substring(65, a.length - 2)));
                }
                a = e.parse(c);
                b && b(a);
              },
              c,
              d
            );
          },
          parse: function(a) {
            return new vf(a);
          }
        });
        var Bk,
          fh = {
            getContext: function() {
              void 0 === Bk &&
                (Bk = new (window.AudioContext || window.webkitAudioContext)());
              return Bk;
            },
            setContext: function(a) {
              Bk = a;
            }
          };
        Me.prototype = Object.assign(Object.create(Ja.prototype), {
          constructor: Me,
          load: function(a, b, c, d) {
            var e = new Pc(this.manager);
            e.setResponseType("arraybuffer");
            e.setPath(this.path);
            e.load(
              a,
              function(a) {
                a = a.slice(0);
                fh.getContext().decodeAudioData(a, function(a) {
                  b(a);
                });
              },
              c,
              d
            );
          }
        });
        Object.assign(Ne.prototype, {
          isSphericalHarmonics3: !0,
          set: function(a) {
            for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
            return this;
          },
          zero: function() {
            for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
            return this;
          },
          getAt: function(a, b) {
            var c = a.x,
              d = a.y;
            a = a.z;
            var e = this.coefficients;
            b.copy(e[0]).multiplyScalar(0.282095);
            b.addScale(e[1], 0.488603 * d);
            b.addScale(e[2], 0.488603 * a);
            b.addScale(e[3], 0.488603 * c);
            b.addScale(e[4], 1.092548 * c * d);
            b.addScale(e[5], 1.092548 * d * a);
            b.addScale(e[6], 0.315392 * (3 * a * a - 1));
            b.addScale(e[7], 1.092548 * c * a);
            b.addScale(e[8], 0.546274 * (c * c - d * d));
            return b;
          },
          getIrradianceAt: function(a, b) {
            var c = a.x,
              d = a.y;
            a = a.z;
            var e = this.coefficients;
            b.copy(e[0]).multiplyScalar(0.886227);
            b.addScale(e[1], 1.023328 * d);
            b.addScale(e[2], 1.023328 * a);
            b.addScale(e[3], 1.023328 * c);
            b.addScale(e[4], 0.858086 * c * d);
            b.addScale(e[5], 0.858086 * d * a);
            b.addScale(e[6], 0.743125 * a * a - 0.247708);
            b.addScale(e[7], 0.858086 * c * a);
            b.addScale(e[8], 0.429043 * (c * c - d * d));
            return b;
          },
          add: function(a) {
            for (var b = 0; 9 > b; b++)
              this.coefficients[b].add(a.coefficients[b]);
            return this;
          },
          scale: function(a) {
            for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
            return this;
          },
          lerp: function(a, b) {
            for (var c = 0; 9 > c; c++)
              this.coefficients[c].lerp(a.coefficients[c], b);
            return this;
          },
          equals: function(a) {
            for (var b = 0; 9 > b; b++)
              if (!this.coefficients[b].equals(a.coefficients[b])) return !1;
            return !0;
          },
          copy: function(a) {
            return this.set(a.coefficients);
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = this.coefficients, d = 0; 9 > d; d++)
              c[d].fromArray(a, b + 3 * d);
            return this;
          },
          toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            for (var c = this.coefficients, d = 0; 9 > d; d++)
              c[d].toArray(a, b + 3 * d);
            return a;
          }
        });
        Object.assign(Ne, {
          getBasisAt: function(a, b) {
            var c = a.x,
              d = a.y;
            a = a.z;
            b[0] = 0.282095;
            b[1] = 0.488603 * d;
            b[2] = 0.488603 * a;
            b[3] = 0.488603 * c;
            b[4] = 1.092548 * c * d;
            b[5] = 1.092548 * d * a;
            b[6] = 0.315392 * (3 * a * a - 1);
            b[7] = 1.092548 * c * a;
            b[8] = 0.546274 * (c * c - d * d);
          }
        });
        Ed.prototype = Object.assign(Object.create(Ka.prototype), {
          constructor: Ed,
          isLightProbe: !0,
          copy: function(a) {
            Ka.prototype.copy.call(this, a);
            this.sh.copy(a.sh);
            this.intensity = a.intensity;
            return this;
          },
          toJSON: function(a) {
            return Ka.prototype.toJSON.call(this, a);
          }
        });
        Cf.prototype = Object.assign(Object.create(Ed.prototype), {
          constructor: Cf,
          isHemisphereLightProbe: !0,
          copy: function(a) {
            Ed.prototype.copy.call(this, a);
            return this;
          },
          toJSON: function(a) {
            return Ed.prototype.toJSON.call(this, a);
          }
        });
        Ff.prototype = Object.assign(Object.create(Ed.prototype), {
          constructor: Ff,
          isAmbientLightProbe: !0,
          copy: function(a) {
            Ed.prototype.copy.call(this, a);
            return this;
          },
          toJSON: function(a) {
            return Ed.prototype.toJSON.call(this, a);
          }
        });
        var ti = new t(),
          ui = new t();
        Object.assign(zg.prototype, {
          update: function(a) {
            var b = this._cache;
            if (
              b.focus !== a.focus ||
              b.fov !== a.fov ||
              b.aspect !== a.aspect * this.aspect ||
              b.near !== a.near ||
              b.far !== a.far ||
              b.zoom !== a.zoom ||
              b.eyeSep !== this.eyeSep
            ) {
              b.focus = a.focus;
              b.fov = a.fov;
              b.aspect = a.aspect * this.aspect;
              b.near = a.near;
              b.far = a.far;
              b.zoom = a.zoom;
              b.eyeSep = this.eyeSep;
              var c = a.projectionMatrix.clone(),
                d = b.eyeSep / 2,
                e = (d * b.near) / b.focus,
                g = (b.near * Math.tan(ya.DEG2RAD * b.fov * 0.5)) / b.zoom;
              ui.elements[12] = -d;
              ti.elements[12] = d;
              d = -g * b.aspect + e;
              var f = g * b.aspect + e;
              c.elements[0] = (2 * b.near) / (f - d);
              c.elements[8] = (f + d) / (f - d);
              this.cameraL.projectionMatrix.copy(c);
              d = -g * b.aspect - e;
              f = g * b.aspect - e;
              c.elements[0] = (2 * b.near) / (f - d);
              c.elements[8] = (f + d) / (f - d);
              this.cameraR.projectionMatrix.copy(c);
            }
            this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(ui);
            this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(ti);
          }
        });
        Object.assign(Jf.prototype, {
          start: function() {
            this.oldTime = this.startTime = ("undefined" === typeof performance
              ? Date
              : performance
            ).now();
            this.elapsedTime = 0;
            this.running = !0;
          },
          stop: function() {
            this.getElapsedTime();
            this.autoStart = this.running = !1;
          },
          getElapsedTime: function() {
            this.getDelta();
            return this.elapsedTime;
          },
          getDelta: function() {
            var a = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              var b = ("undefined" === typeof performance
                ? Date
                : performance
              ).now();
              a = (b - this.oldTime) / 1e3;
              this.oldTime = b;
              this.elapsedTime += a;
            }
            return a;
          }
        });
        var Gh = new h(),
          vi = new f(),
          Ij = new h(),
          Hh = new h();
        Kf.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Kf,
          getInput: function() {
            return this.gain;
          },
          removeFilter: function() {
            null !== this.filter &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null));
            return this;
          },
          getFilter: function() {
            return this.filter;
          },
          setFilter: function(a) {
            null !== this.filter
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination);
            this.filter = a;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
            return this;
          },
          getMasterVolume: function() {
            return this.gain.gain.value;
          },
          setMasterVolume: function(a) {
            this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
            return this;
          },
          updateMatrixWorld: function(a) {
            v.prototype.updateMatrixWorld.call(this, a);
            a = this.context.listener;
            var b = this.up;
            this.timeDelta = this._clock.getDelta();
            this.matrixWorld.decompose(Gh, vi, Ij);
            Hh.set(0, 0, -1).applyQuaternion(vi);
            if (a.positionX) {
              var c = this.context.currentTime + this.timeDelta;
              a.positionX.linearRampToValueAtTime(Gh.x, c);
              a.positionY.linearRampToValueAtTime(Gh.y, c);
              a.positionZ.linearRampToValueAtTime(Gh.z, c);
              a.forwardX.linearRampToValueAtTime(Hh.x, c);
              a.forwardY.linearRampToValueAtTime(Hh.y, c);
              a.forwardZ.linearRampToValueAtTime(Hh.z, c);
              a.upX.linearRampToValueAtTime(b.x, c);
              a.upY.linearRampToValueAtTime(b.y, c);
              a.upZ.linearRampToValueAtTime(b.z, c);
            } else
              a.setPosition(Gh.x, Gh.y, Gh.z),
                a.setOrientation(Hh.x, Hh.y, Hh.z, b.x, b.y, b.z);
          }
        });
        Pi.prototype = Object.assign(Object.create(v.prototype), {
          constructor: Pi,
          getOutput: function() {
            return this.gain;
          },
          setNodeSource: function(a) {
            this.hasPlaybackControl = !1;
            this.sourceType = "audioNode";
            this.source = a;
            this.connect();
            return this;
          },
          setMediaElementSource: function(a) {
            this.hasPlaybackControl = !1;
            this.sourceType = "mediaNode";
            this.source = this.context.createMediaElementSource(a);
            this.connect();
            return this;
          },
          setMediaStreamSource: function(a) {
            this.hasPlaybackControl = !1;
            this.sourceType = "mediaStreamNode";
            this.source = this.context.createMediaStreamSource(a);
            this.connect();
            return this;
          },
          setBuffer: function(a) {
            this.buffer = a;
            this.sourceType = "buffer";
            this.autoplay && this.play();
            return this;
          },
          play: function() {
            if (!0 === this.isPlaying)
              console.warn("THREE.Audio: Audio is already playing.");
            else if (!1 === this.hasPlaybackControl)
              console.warn("THREE.Audio: this Audio has no playback control.");
            else {
              var a = this.context.createBufferSource();
              a.buffer = this.buffer;
              a.loop = this.loop;
              a.onended = this.onEnded.bind(this);
              this.startTime = this.context.currentTime;
              a.start(this.startTime, this.offset, this.duration);
              this.isPlaying = !0;
              this.source = a;
              this.setDetune(this.detune);
              this.setPlaybackRate(this.playbackRate);
              return this.connect();
            }
          },
          pause: function() {
            if (!1 === this.hasPlaybackControl)
              console.warn("THREE.Audio: this Audio has no playback control.");
            else
              return (
                !0 === this.isPlaying &&
                  (this.source.stop(),
                  (this.source.onended = null),
                  (this.offset +=
                    (this.context.currentTime - this.startTime) *
                    this.playbackRate),
                  (this.isPlaying = !1)),
                this
              );
          },
          stop: function() {
            if (!1 === this.hasPlaybackControl)
              console.warn("THREE.Audio: this Audio has no playback control.");
            else
              return (
                this.source.stop(),
                (this.source.onended = null),
                (this.offset = 0),
                (this.isPlaying = !1),
                this
              );
          },
          connect: function() {
            if (0 < this.filters.length) {
              this.source.connect(this.filters[0]);
              for (var a = 1, b = this.filters.length; a < b; a++)
                this.filters[a - 1].connect(this.filters[a]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
          },
          disconnect: function() {
            if (0 < this.filters.length) {
              this.source.disconnect(this.filters[0]);
              for (var a = 1, b = this.filters.length; a < b; a++)
                this.filters[a - 1].disconnect(this.filters[a]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return this;
          },
          getFilters: function() {
            return this.filters;
          },
          setFilters: function(a) {
            a || (a = []);
            !0 === this.isPlaying
              ? (this.disconnect(), (this.filters = a), this.connect())
              : (this.filters = a);
            return this;
          },
          setDetune: function(a) {
            this.detune = a;
            if (void 0 !== this.source.detune)
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
          },
          getDetune: function() {
            return this.detune;
          },
          getFilter: function() {
            return this.getFilters()[0];
          },
          setFilter: function(a) {
            return this.setFilters(a ? [a] : []);
          },
          setPlaybackRate: function(a) {
            if (!1 === this.hasPlaybackControl)
              console.warn("THREE.Audio: this Audio has no playback control.");
            else
              return (
                (this.playbackRate = a),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
          },
          getPlaybackRate: function() {
            return this.playbackRate;
          },
          onEnded: function() {
            this.isPlaying = !1;
          },
          getLoop: function() {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  "THREE.Audio: this Audio has no playback control."
                ),
                !1)
              : this.loop;
          },
          setLoop: function(a) {
            if (!1 === this.hasPlaybackControl)
              console.warn("THREE.Audio: this Audio has no playback control.");
            else
              return (
                (this.loop = a),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
          },
          getVolume: function() {
            return this.gain.gain.value;
          },
          setVolume: function(a) {
            this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
            return this;
          }
        });
        var Ih = new h(),
          wi = new f(),
          Jj = new h(),
          Jh = new h();
        Lf.prototype = Object.assign(Object.create(Pi.prototype), {
          constructor: Lf,
          getOutput: function() {
            return this.panner;
          },
          getRefDistance: function() {
            return this.panner.refDistance;
          },
          setRefDistance: function(a) {
            this.panner.refDistance = a;
            return this;
          },
          getRolloffFactor: function() {
            return this.panner.rolloffFactor;
          },
          setRolloffFactor: function(a) {
            this.panner.rolloffFactor = a;
            return this;
          },
          getDistanceModel: function() {
            return this.panner.distanceModel;
          },
          setDistanceModel: function(a) {
            this.panner.distanceModel = a;
            return this;
          },
          getMaxDistance: function() {
            return this.panner.maxDistance;
          },
          setMaxDistance: function(a) {
            this.panner.maxDistance = a;
            return this;
          },
          setDirectionalCone: function(a, b, c) {
            this.panner.coneInnerAngle = a;
            this.panner.coneOuterAngle = b;
            this.panner.coneOuterGain = c;
            return this;
          },
          updateMatrixWorld: function(a) {
            v.prototype.updateMatrixWorld.call(this, a);
            if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
              if (
                (this.matrixWorld.decompose(Ih, wi, Jj),
                Jh.set(0, 0, 1).applyQuaternion(wi),
                (a = this.panner),
                a.positionX)
              ) {
                var b = this.context.currentTime + this.listener.timeDelta;
                a.positionX.linearRampToValueAtTime(Ih.x, b);
                a.positionY.linearRampToValueAtTime(Ih.y, b);
                a.positionZ.linearRampToValueAtTime(Ih.z, b);
                a.orientationX.linearRampToValueAtTime(Jh.x, b);
                a.orientationY.linearRampToValueAtTime(Jh.y, b);
                a.orientationZ.linearRampToValueAtTime(Jh.z, b);
              } else
                a.setPosition(Ih.x, Ih.y, Ih.z),
                  a.setOrientation(Jh.x, Jh.y, Jh.z);
          }
        });
        Object.assign(Mf.prototype, {
          getFrequencyData: function() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
          },
          getAverageFrequency: function() {
            for (
              var a = 0, b = this.getFrequencyData(), c = 0;
              c < b.length;
              c++
            )
              a += b[c];
            return a / b.length;
          }
        });
        Object.assign(Nf.prototype, {
          accumulate: function(a, b) {
            var c = this.buffer,
              d = this.valueSize;
            a = a * d + d;
            var e = this.cumulativeWeight;
            if (0 === e) {
              for (e = 0; e !== d; ++e) c[a + e] = c[e];
              e = b;
            } else (e += b), this._mixBufferRegion(c, a, 0, b / e, d);
            this.cumulativeWeight = e;
          },
          apply: function(a) {
            var b = this.valueSize,
              c = this.buffer;
            a = a * b + b;
            var d = this.cumulativeWeight,
              e = this.binding;
            this.cumulativeWeight = 0;
            1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
            d = b;
            for (var g = b + b; d !== g; ++d)
              if (c[d] !== c[d + b]) {
                e.setValue(c, a);
                break;
              }
          },
          saveOriginalState: function() {
            var a = this.buffer,
              b = this.valueSize,
              c = 3 * b;
            this.binding.getValue(a, c);
            for (var d = b; d !== c; ++d) a[d] = a[c + (d % b)];
            this.cumulativeWeight = 0;
          },
          restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize);
          },
          _select: function(a, b, c, d, e) {
            if (0.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
          },
          _slerp: function(a, b, c, d) {
            f.slerpFlat(a, b, a, b, a, c, d);
          },
          _lerp: function(a, b, c, d, e) {
            for (var g = 1 - d, f = 0; f !== e; ++f) {
              var h = b + f;
              a[h] = a[h] * g + a[c + f] * d;
            }
          }
        });
        var Kj = /[\[\]\.:\/]/g,
          Lj = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
          Mj = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
          Nj = /(WCOD+)?/.source.replace("WCOD", Lj),
          Oj = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
            "WC",
            "[^\\[\\]\\.:\\/]"
          ),
          Pj = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
          Qj = new RegExp("^" + Mj + Nj + Oj + Pj + "$"),
          Rj = ["material", "materials", "bones"];
        Object.assign(Fg.prototype, {
          getValue: function(a, b) {
            this.bind();
            var c = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== c && c.getValue(a, b);
          },
          setValue: function(a, b) {
            for (
              var c = this._bindings,
                d = this._targetGroup.nCachedObjects_,
                e = c.length;
              d !== e;
              ++d
            )
              c[d].setValue(a, b);
          },
          bind: function() {
            for (
              var a = this._bindings,
                b = this._targetGroup.nCachedObjects_,
                c = a.length;
              b !== c;
              ++b
            )
              a[b].bind();
          },
          unbind: function() {
            for (
              var a = this._bindings,
                b = this._targetGroup.nCachedObjects_,
                c = a.length;
              b !== c;
              ++b
            )
              a[b].unbind();
          }
        });
        Object.assign(tb, {
          Composite: Fg,
          create: function(a, b, c) {
            return a && a.isAnimationObjectGroup
              ? new tb.Composite(a, b, c)
              : new tb(a, b, c);
          },
          sanitizeNodeName: function(a) {
            return a.replace(/\s/g, "_").replace(Kj, "");
          },
          parseTrackName: function(a) {
            var b = Qj.exec(a);
            if (!b)
              throw Error("PropertyBinding: Cannot parse trackName: " + a);
            b = {
              nodeName: b[2],
              objectName: b[3],
              objectIndex: b[4],
              propertyName: b[5],
              propertyIndex: b[6]
            };
            var c = b.nodeName && b.nodeName.lastIndexOf(".");
            if (void 0 !== c && -1 !== c) {
              var d = b.nodeName.substring(c + 1);
              -1 !== Rj.indexOf(d) &&
                ((b.nodeName = b.nodeName.substring(0, c)), (b.objectName = d));
            }
            if (null === b.propertyName || 0 === b.propertyName.length)
              throw Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  a
              );
            return b;
          },
          findNode: function(a, b) {
            if (
              !b ||
              "" === b ||
              "root" === b ||
              "." === b ||
              -1 === b ||
              b === a.name ||
              b === a.uuid
            )
              return a;
            if (a.skeleton) {
              var c = a.skeleton.getBoneByName(b);
              if (void 0 !== c) return c;
            }
            return a.children &&
              (a = (function G(a) {
                for (var c = 0; c < a.length; c++) {
                  var d = a[c];
                  if (d.name === b || d.uuid === b || (d = G(d.children)))
                    return d;
                }
                return null;
              })(a.children))
              ? a
              : null;
          }
        });
        Object.assign(tb.prototype, {
          _getValue_unavailable: function() {},
          _setValue_unavailable: function() {},
          BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
          },
          Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
          GetterByBindingType: [
            function(a, b) {
              a[b] = this.node[this.propertyName];
            },
            function(a, b) {
              for (
                var c = this.resolvedProperty, d = 0, e = c.length;
                d !== e;
                ++d
              )
                a[b++] = c[d];
            },
            function(a, b) {
              a[b] = this.resolvedProperty[this.propertyIndex];
            },
            function(a, b) {
              this.resolvedProperty.toArray(a, b);
            }
          ],
          SetterByBindingTypeAndVersioning: [
            [
              function(a, b) {
                this.targetObject[this.propertyName] = a[b];
              },
              function(a, b) {
                this.targetObject[this.propertyName] = a[b];
                this.targetObject.needsUpdate = !0;
              },
              function(a, b) {
                this.targetObject[this.propertyName] = a[b];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              }
            ],
            [
              function(a, b) {
                for (
                  var c = this.resolvedProperty, d = 0, e = c.length;
                  d !== e;
                  ++d
                )
                  c[d] = a[b++];
              },
              function(a, b) {
                for (
                  var c = this.resolvedProperty, d = 0, e = c.length;
                  d !== e;
                  ++d
                )
                  c[d] = a[b++];
                this.targetObject.needsUpdate = !0;
              },
              function(a, b) {
                for (
                  var c = this.resolvedProperty, d = 0, e = c.length;
                  d !== e;
                  ++d
                )
                  c[d] = a[b++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              }
            ],
            [
              function(a, b) {
                this.resolvedProperty[this.propertyIndex] = a[b];
              },
              function(a, b) {
                this.resolvedProperty[this.propertyIndex] = a[b];
                this.targetObject.needsUpdate = !0;
              },
              function(a, b) {
                this.resolvedProperty[this.propertyIndex] = a[b];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              }
            ],
            [
              function(a, b) {
                this.resolvedProperty.fromArray(a, b);
              },
              function(a, b) {
                this.resolvedProperty.fromArray(a, b);
                this.targetObject.needsUpdate = !0;
              },
              function(a, b) {
                this.resolvedProperty.fromArray(a, b);
                this.targetObject.matrixWorldNeedsUpdate = !0;
              }
            ]
          ],
          getValue: function(a, b) {
            this.bind();
            this.getValue(a, b);
          },
          setValue: function(a, b) {
            this.bind();
            this.setValue(a, b);
          },
          bind: function() {
            var a = this.node,
              b = this.parsedPath,
              c = b.objectName,
              d = b.propertyName,
              e = b.propertyIndex;
            a ||
              (this.node = a =
                tb.findNode(this.rootNode, b.nodeName) || this.rootNode);
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (a) {
              if (c) {
                var f = b.objectIndex;
                switch (c) {
                  case "materials":
                    if (!a.material) {
                      console.error(
                        "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                        this
                      );
                      return;
                    }
                    if (!a.material.materials) {
                      console.error(
                        "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                        this
                      );
                      return;
                    }
                    a = a.material.materials;
                    break;
                  case "bones":
                    if (!a.skeleton) {
                      console.error(
                        "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                        this
                      );
                      return;
                    }
                    a = a.skeleton.bones;
                    for (c = 0; c < a.length; c++)
                      if (a[c].name === f) {
                        f = c;
                        break;
                      }
                    break;
                  default:
                    if (void 0 === a[c]) {
                      console.error(
                        "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                        this
                      );
                      return;
                    }
                    a = a[c];
                }
                if (void 0 !== f) {
                  if (void 0 === a[f]) {
                    console.error(
                      "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                      this,
                      a
                    );
                    return;
                  }
                  a = a[f];
                }
              }
              f = a[d];
              if (void 0 === f)
                console.error(
                  "THREE.PropertyBinding: Trying to update property for track: " +
                    b.nodeName +
                    "." +
                    d +
                    " but it wasn't found.",
                  a
                );
              else {
                b = this.Versioning.None;
                this.targetObject = a;
                void 0 !== a.needsUpdate
                  ? (b = this.Versioning.NeedsUpdate)
                  : void 0 !== a.matrixWorldNeedsUpdate &&
                    (b = this.Versioning.MatrixWorldNeedsUpdate);
                c = this.BindingType.Direct;
                if (void 0 !== e) {
                  if ("morphTargetInfluences" === d) {
                    if (!a.geometry) {
                      console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                        this
                      );
                      return;
                    }
                    if (a.geometry.isBufferGeometry) {
                      if (!a.geometry.morphAttributes) {
                        console.error(
                          "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                          this
                        );
                        return;
                      }
                      for (
                        c = 0;
                        c < this.node.geometry.morphAttributes.position.length;
                        c++
                      )
                        if (a.geometry.morphAttributes.position[c].name === e) {
                          e = c;
                          break;
                        }
                    } else {
                      if (!a.geometry.morphTargets) {
                        console.error(
                          "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                          this
                        );
                        return;
                      }
                      for (
                        c = 0;
                        c < this.node.geometry.morphTargets.length;
                        c++
                      )
                        if (a.geometry.morphTargets[c].name === e) {
                          e = c;
                          break;
                        }
                    }
                  }
                  c = this.BindingType.ArrayElement;
                  this.resolvedProperty = f;
                  this.propertyIndex = e;
                } else
                  void 0 !== f.fromArray && void 0 !== f.toArray
                    ? ((c = this.BindingType.HasFromToArray),
                      (this.resolvedProperty = f))
                    : Array.isArray(f)
                    ? ((c = this.BindingType.EntireArray),
                      (this.resolvedProperty = f))
                    : (this.propertyName = d);
                this.getValue = this.GetterByBindingType[c];
                this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
              }
            } else
              console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
          },
          unbind: function() {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
          }
        });
        Object.assign(tb.prototype, {
          _getValue_unbound: tb.prototype.getValue,
          _setValue_unbound: tb.prototype.setValue
        });
        Object.assign(Hg.prototype, {
          isAnimationObjectGroup: !0,
          add: function() {
            for (
              var a = this._objects,
                b = a.length,
                c = this.nCachedObjects_,
                d = this._indicesByUUID,
                e = this._paths,
                f = this._parsedPaths,
                h = this._bindings,
                k = h.length,
                l = void 0,
                m = 0,
                n = arguments.length;
              m !== n;
              ++m
            ) {
              var q = arguments[m],
                t = q.uuid,
                u = d[t];
              if (void 0 === u) {
                u = b++;
                d[t] = u;
                a.push(q);
                t = 0;
                for (var r = k; t !== r; ++t) h[t].push(new tb(q, e[t], f[t]));
              } else if (u < c) {
                l = a[u];
                var y = --c;
                r = a[y];
                d[r.uuid] = u;
                a[u] = r;
                d[t] = y;
                a[y] = q;
                t = 0;
                for (r = k; t !== r; ++t) {
                  var v = h[t],
                    z = v[u];
                  v[u] = v[y];
                  void 0 === z && (z = new tb(q, e[t], f[t]));
                  v[y] = z;
                }
              } else
                a[u] !== l &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = c;
          },
          remove: function() {
            for (
              var a = this._objects,
                b = this.nCachedObjects_,
                c = this._indicesByUUID,
                d = this._bindings,
                e = d.length,
                f = 0,
                h = arguments.length;
              f !== h;
              ++f
            ) {
              var k = arguments[f],
                l = k.uuid,
                m = c[l];
              if (void 0 !== m && m >= b) {
                var n = b++,
                  q = a[n];
                c[q.uuid] = m;
                a[m] = q;
                c[l] = n;
                a[n] = k;
                k = 0;
                for (l = e; k !== l; ++k) {
                  q = d[k];
                  var t = q[m];
                  q[m] = q[n];
                  q[n] = t;
                }
              }
            }
            this.nCachedObjects_ = b;
          },
          uncache: function() {
            for (
              var a = this._objects,
                b = a.length,
                c = this.nCachedObjects_,
                d = this._indicesByUUID,
                e = this._bindings,
                f = e.length,
                h = 0,
                k = arguments.length;
              h !== k;
              ++h
            ) {
              var l = arguments[h].uuid,
                m = d[l];
              if (void 0 !== m)
                if ((delete d[l], m < c)) {
                  l = --c;
                  var n = a[l],
                    q = --b,
                    t = a[q];
                  d[n.uuid] = m;
                  a[m] = n;
                  d[t.uuid] = l;
                  a[l] = t;
                  a.pop();
                  n = 0;
                  for (t = f; n !== t; ++n) {
                    var u = e[n],
                      r = u[q];
                    u[m] = u[l];
                    u[l] = r;
                    u.pop();
                  }
                } else
                  for (
                    q = --b,
                      t = a[q],
                      d[t.uuid] = m,
                      a[m] = t,
                      a.pop(),
                      n = 0,
                      t = f;
                    n !== t;
                    ++n
                  )
                    (u = e[n]), (u[m] = u[q]), u.pop();
            }
            this.nCachedObjects_ = c;
          },
          subscribe_: function(a, b) {
            var c = this._bindingsIndicesByPath,
              d = c[a],
              e = this._bindings;
            if (void 0 !== d) return e[d];
            var f = this._paths,
              g = this._parsedPaths,
              h = this._objects,
              k = this.nCachedObjects_,
              l = Array(h.length);
            d = e.length;
            c[a] = d;
            f.push(a);
            g.push(b);
            e.push(l);
            c = k;
            for (d = h.length; c !== d; ++c) l[c] = new tb(h[c], a, b);
            return l;
          },
          unsubscribe_: function(a) {
            var b = this._bindingsIndicesByPath,
              c = b[a];
            if (void 0 !== c) {
              var d = this._paths,
                e = this._parsedPaths,
                f = this._bindings,
                g = f.length - 1,
                h = f[g];
              b[a[g]] = c;
              f[c] = h;
              f.pop();
              e[c] = e[g];
              e.pop();
              d[c] = d[g];
              d.pop();
            }
          }
        });
        Object.assign(Ig.prototype, {
          play: function() {
            this._mixer._activateAction(this);
            return this;
          },
          stop: function() {
            this._mixer._deactivateAction(this);
            return this.reset();
          },
          reset: function() {
            this.paused = !1;
            this.enabled = !0;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping();
          },
          isRunning: function() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          },
          isScheduled: function() {
            return this._mixer._isActiveAction(this);
          },
          startAt: function(a) {
            this._startTime = a;
            return this;
          },
          setLoop: function(a, b) {
            this.loop = a;
            this.repetitions = b;
            return this;
          },
          setEffectiveWeight: function(a) {
            this.weight = a;
            this._effectiveWeight = this.enabled ? a : 0;
            return this.stopFading();
          },
          getEffectiveWeight: function() {
            return this._effectiveWeight;
          },
          fadeIn: function(a) {
            return this._scheduleFading(a, 0, 1);
          },
          fadeOut: function(a) {
            return this._scheduleFading(a, 1, 0);
          },
          crossFadeFrom: function(a, b, c) {
            a.fadeOut(b);
            this.fadeIn(b);
            if (c) {
              c = this._clip.duration;
              var d = a._clip.duration,
                e = c / d;
              a.warp(1, d / c, b);
              this.warp(e, 1, b);
            }
            return this;
          },
          crossFadeTo: function(a, b, c) {
            return a.crossFadeFrom(this, b, c);
          },
          stopFading: function() {
            var a = this._weightInterpolant;
            null !== a &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(a));
            return this;
          },
          setEffectiveTimeScale: function(a) {
            this.timeScale = a;
            this._effectiveTimeScale = this.paused ? 0 : a;
            return this.stopWarping();
          },
          getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
          },
          setDuration: function(a) {
            this.timeScale = this._clip.duration / a;
            return this.stopWarping();
          },
          syncWith: function(a) {
            this.time = a.time;
            this.timeScale = a.timeScale;
            return this.stopWarping();
          },
          halt: function(a) {
            return this.warp(this._effectiveTimeScale, 0, a);
          },
          warp: function(a, b, c) {
            var d = this._mixer,
              e = d.time,
              f = this._timeScaleInterpolant,
              g = this.timeScale;
            null === f &&
              (this._timeScaleInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            d[1] = e + c;
            f[0] = a / g;
            f[1] = b / g;
            return this;
          },
          stopWarping: function() {
            var a = this._timeScaleInterpolant;
            null !== a &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(a));
            return this;
          },
          getMixer: function() {
            return this._mixer;
          },
          getClip: function() {
            return this._clip;
          },
          getRoot: function() {
            return this._localRoot || this._mixer._root;
          },
          _update: function(a, b, c, d) {
            if (this.enabled) {
              var e = this._startTime;
              if (null !== e) {
                b = (a - e) * c;
                if (0 > b || 0 === c) return;
                this._startTime = null;
                b *= c;
              }
              b *= this._updateTimeScale(a);
              c = this._updateTime(b);
              a = this._updateWeight(a);
              if (0 < a) {
                b = this._interpolants;
                e = this._propertyBindings;
                for (var f = 0, g = b.length; f !== g; ++f)
                  b[f].evaluate(c), e[f].accumulate(d, a);
              }
            } else this._updateWeight(a);
          },
          _updateWeight: function(a) {
            var b = 0;
            if (this.enabled) {
              b = this.weight;
              var c = this._weightInterpolant;
              if (null !== c) {
                var d = c.evaluate(a)[0];
                b *= d;
                a > c.parameterPositions[1] &&
                  (this.stopFading(), 0 === d && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = b);
          },
          _updateTimeScale: function(a) {
            var b = 0;
            if (!this.paused) {
              b = this.timeScale;
              var c = this._timeScaleInterpolant;
              if (null !== c) {
                var d = c.evaluate(a)[0];
                b *= d;
                a > c.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === b ? (this.paused = !0) : (this.timeScale = b));
              }
            }
            return (this._effectiveTimeScale = b);
          },
          _updateTime: function(a) {
            var b = this.time + a,
              c = this._clip.duration,
              d = this.loop,
              e = this._loopCount,
              f = 2202 === d;
            if (0 === a) return -1 === e ? b : f && 1 === (e & 1) ? c - b : b;
            if (2200 === d)
              a: {
                if (
                  (-1 === e &&
                    ((this._loopCount = 0), this._setEndings(!0, !0, !1)),
                  b >= c)
                )
                  b = c;
                else if (0 > b) b = 0;
                else {
                  this.time = b;
                  break a;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1);
                this.time = b;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: 0 > a ? -1 : 1
                });
              }
            else {
              -1 === e &&
                (0 <= a
                  ? ((e = 0), this._setEndings(!0, 0 === this.repetitions, f))
                  : this._setEndings(0 === this.repetitions, !0, f));
              if (b >= c || 0 > b) {
                d = Math.floor(b / c);
                b -= c * d;
                e += Math.abs(d);
                var g = this.repetitions - e;
                0 >= g
                  ? (this.clampWhenFinished
                      ? (this.paused = !0)
                      : (this.enabled = !1),
                    (this.time = b = 0 < a ? c : 0),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: 0 < a ? 1 : -1
                    }))
                  : (1 === g
                      ? ((a = 0 > a), this._setEndings(a, !a, f))
                      : this._setEndings(!1, !1, f),
                    (this._loopCount = e),
                    (this.time = b),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: d
                    }));
              } else this.time = b;
              if (f && 1 === (e & 1)) return c - b;
            }
            return b;
          },
          _setEndings: function(a, b, c) {
            var d = this._interpolantSettings;
            c
              ? ((d.endingStart = 2401), (d.endingEnd = 2401))
              : ((d.endingStart = a
                  ? this.zeroSlopeAtStart
                    ? 2401
                    : 2400
                  : 2402),
                (d.endingEnd = b ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
          },
          _scheduleFading: function(a, b, c) {
            var d = this._mixer,
              e = d.time,
              f = this._weightInterpolant;
            null === f &&
              (this._weightInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            f[0] = b;
            d[1] = e + a;
            f[1] = c;
            return this;
          }
        });
        Pf.prototype = Object.assign(Object.create(b.prototype), {
          constructor: Pf,
          _bindAction: function(a, b) {
            var c = a._localRoot || this._root,
              d = a._clip.tracks,
              e = d.length,
              f = a._propertyBindings;
            a = a._interpolants;
            var g = c.uuid,
              h = this._bindingsByRootAndName,
              k = h[g];
            void 0 === k && ((k = {}), (h[g] = k));
            for (h = 0; h !== e; ++h) {
              var l = d[h],
                m = l.name,
                p = k[m];
              if (void 0 === p) {
                p = f[h];
                if (void 0 !== p) {
                  null === p._cacheIndex &&
                    (++p.referenceCount, this._addInactiveBinding(p, g, m));
                  continue;
                }
                p = new Nf(
                  tb.create(
                    c,
                    m,
                    b && b._propertyBindings[h].binding.parsedPath
                  ),
                  l.ValueTypeName,
                  l.getValueSize()
                );
                ++p.referenceCount;
                this._addInactiveBinding(p, g, m);
              }
              f[h] = p;
              a[h].resultBuffer = p.buffer;
            }
          },
          _activateAction: function(a) {
            if (!this._isActiveAction(a)) {
              if (null === a._cacheIndex) {
                var b = (a._localRoot || this._root).uuid,
                  c = a._clip.uuid,
                  d = this._actionsByClip[c];
                this._bindAction(a, d && d.knownActions[0]);
                this._addInactiveAction(a, c, b);
              }
              b = a._propertyBindings;
              c = 0;
              for (d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === e.useCount++ &&
                  (this._lendBinding(e), e.saveOriginalState());
              }
              this._lendAction(a);
            }
          },
          _deactivateAction: function(a) {
            if (this._isActiveAction(a)) {
              for (
                var b = a._propertyBindings, c = 0, d = b.length;
                c !== d;
                ++c
              ) {
                var e = b[c];
                0 === --e.useCount &&
                  (e.restoreOriginalState(), this._takeBackBinding(e));
              }
              this._takeBackAction(a);
            }
          },
          _initMemoryManager: function() {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
              actions: {
                get total() {
                  return a._actions.length;
                },
                get inUse() {
                  return a._nActiveActions;
                }
              },
              bindings: {
                get total() {
                  return a._bindings.length;
                },
                get inUse() {
                  return a._nActiveBindings;
                }
              },
              controlInterpolants: {
                get total() {
                  return a._controlInterpolants.length;
                },
                get inUse() {
                  return a._nActiveControlInterpolants;
                }
              }
            };
          },
          _isActiveAction: function(a) {
            a = a._cacheIndex;
            return null !== a && a < this._nActiveActions;
          },
          _addInactiveAction: function(a, b, c) {
            var d = this._actions,
              e = this._actionsByClip,
              f = e[b];
            void 0 === f
              ? ((f = { knownActions: [a], actionByRoot: {} }),
                (a._byClipCacheIndex = 0),
                (e[b] = f))
              : ((b = f.knownActions),
                (a._byClipCacheIndex = b.length),
                b.push(a));
            a._cacheIndex = d.length;
            d.push(a);
            f.actionByRoot[c] = a;
          },
          _removeInactiveAction: function(a) {
            var b = this._actions,
              c = b[b.length - 1],
              d = a._cacheIndex;
            c._cacheIndex = d;
            b[d] = c;
            b.pop();
            a._cacheIndex = null;
            b = a._clip.uuid;
            c = this._actionsByClip;
            d = c[b];
            var e = d.knownActions,
              f = e[e.length - 1],
              g = a._byClipCacheIndex;
            f._byClipCacheIndex = g;
            e[g] = f;
            e.pop();
            a._byClipCacheIndex = null;
            delete d.actionByRoot[(a._localRoot || this._root).uuid];
            0 === e.length && delete c[b];
            this._removeInactiveBindingsForAction(a);
          },
          _removeInactiveBindingsForAction: function(a) {
            a = a._propertyBindings;
            for (var b = 0, c = a.length; b !== c; ++b) {
              var d = a[b];
              0 === --d.referenceCount && this._removeInactiveBinding(d);
            }
          },
          _lendAction: function(a) {
            var b = this._actions,
              c = a._cacheIndex,
              d = this._nActiveActions++,
              e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e;
          },
          _takeBackAction: function(a) {
            var b = this._actions,
              c = a._cacheIndex,
              d = --this._nActiveActions,
              e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e;
          },
          _addInactiveBinding: function(a, b, c) {
            var d = this._bindingsByRootAndName,
              e = d[b],
              f = this._bindings;
            void 0 === e && ((e = {}), (d[b] = e));
            e[c] = a;
            a._cacheIndex = f.length;
            f.push(a);
          },
          _removeInactiveBinding: function(a) {
            var b = this._bindings,
              c = a.binding,
              d = c.rootNode.uuid;
            c = c.path;
            var e = this._bindingsByRootAndName,
              f = e[d],
              g = b[b.length - 1];
            a = a._cacheIndex;
            g._cacheIndex = a;
            b[a] = g;
            b.pop();
            delete f[c];
            0 === Object.keys(f).length && delete e[d];
          },
          _lendBinding: function(a) {
            var b = this._bindings,
              c = a._cacheIndex,
              d = this._nActiveBindings++,
              e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e;
          },
          _takeBackBinding: function(a) {
            var b = this._bindings,
              c = a._cacheIndex,
              d = --this._nActiveBindings,
              e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e;
          },
          _lendControlInterpolant: function() {
            var a = this._controlInterpolants,
              b = this._nActiveControlInterpolants++,
              c = a[b];
            void 0 === c &&
              ((c = new md(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (c.__cacheIndex = b),
              (a[b] = c));
            return c;
          },
          _takeBackControlInterpolant: function(a) {
            var b = this._controlInterpolants,
              c = a.__cacheIndex,
              d = --this._nActiveControlInterpolants,
              e = b[d];
            a.__cacheIndex = d;
            b[d] = a;
            e.__cacheIndex = c;
            b[c] = e;
          },
          _controlInterpolantsResultBuffer: new Float32Array(1),
          clipAction: function(a, b) {
            var c = b || this._root,
              d = c.uuid;
            c = "string" === typeof a ? Oc.findByName(c, a) : a;
            a = null !== c ? c.uuid : a;
            var e = this._actionsByClip[a],
              f = null;
            if (void 0 !== e) {
              f = e.actionByRoot[d];
              if (void 0 !== f) return f;
              f = e.knownActions[0];
              null === c && (c = f._clip);
            }
            if (null === c) return null;
            b = new Ig(this, c, b);
            this._bindAction(b, f);
            this._addInactiveAction(b, a, d);
            return b;
          },
          existingAction: function(a, b) {
            var c = b || this._root;
            b = c.uuid;
            c = "string" === typeof a ? Oc.findByName(c, a) : a;
            a = this._actionsByClip[c ? c.uuid : a];
            return void 0 !== a ? a.actionByRoot[b] || null : null;
          },
          stopAllAction: function() {
            for (
              var a = this._actions,
                b = this._nActiveActions,
                c = this._bindings,
                d = this._nActiveBindings,
                e = (this._nActiveBindings = this._nActiveActions = 0);
              e !== b;
              ++e
            )
              a[e].reset();
            for (e = 0; e !== d; ++e) c[e].useCount = 0;
            return this;
          },
          update: function(a) {
            a *= this.timeScale;
            for (
              var b = this._actions,
                c = this._nActiveActions,
                d = (this.time += a),
                e = Math.sign(a),
                f = (this._accuIndex ^= 1),
                g = 0;
              g !== c;
              ++g
            )
              b[g]._update(d, a, e, f);
            a = this._bindings;
            b = this._nActiveBindings;
            for (g = 0; g !== b; ++g) a[g].apply(f);
            return this;
          },
          setTime: function(a) {
            for (var b = (this.time = 0); b < this._actions.length; b++)
              this._actions[b].time = 0;
            return this.update(a);
          },
          getRoot: function() {
            return this._root;
          },
          uncacheClip: function(a) {
            var b = this._actions;
            a = a.uuid;
            var c = this._actionsByClip,
              d = c[a];
            if (void 0 !== d) {
              d = d.knownActions;
              for (var e = 0, f = d.length; e !== f; ++e) {
                var g = d[e];
                this._deactivateAction(g);
                var h = g._cacheIndex,
                  k = b[b.length - 1];
                g._cacheIndex = null;
                g._byClipCacheIndex = null;
                k._cacheIndex = h;
                b[h] = k;
                b.pop();
                this._removeInactiveBindingsForAction(g);
              }
              delete c[a];
            }
          },
          uncacheRoot: function(a) {
            a = a.uuid;
            var b = this._actionsByClip;
            for (d in b) {
              var c = b[d].actionByRoot[a];
              void 0 !== c &&
                (this._deactivateAction(c), this._removeInactiveAction(c));
            }
            var d = this._bindingsByRootAndName[a];
            if (void 0 !== d)
              for (var e in d)
                (a = d[e]),
                  a.restoreOriginalState(),
                  this._removeInactiveBinding(a);
          },
          uncacheAction: function(a, b) {
            a = this.existingAction(a, b);
            null !== a &&
              (this._deactivateAction(a), this._removeInactiveAction(a));
          }
        });
        Ue.prototype.clone = function() {
          return new Ue(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        };
        Sf.prototype = Object.assign(Object.create(bg.prototype), {
          constructor: Sf,
          isInstancedInterleavedBuffer: !0,
          copy: function(a) {
            bg.prototype.copy.call(this, a);
            this.meshPerAttribute = a.meshPerAttribute;
            return this;
          }
        });
        Object.assign(Lg.prototype, {
          linePrecision: 1,
          set: function(a, b) {
            this.ray.set(a, b);
          },
          setFromCamera: function(a, b) {
            b && b.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld),
                this.ray.direction
                  .set(a.x, a.y, 0.5)
                  .unproject(b)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = b))
              : b && b.isOrthographicCamera
              ? (this.ray.origin
                  .set(a.x, a.y, (b.near + b.far) / (b.near - b.far))
                  .unproject(b),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(b.matrixWorld),
                (this.camera = b))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function(a, b, c) {
            c = c || [];
            Tf(a, this, c, b);
            c.sort(Mg);
            return c;
          },
          intersectObjects: function(a, b, c) {
            c = c || [];
            if (!1 === Array.isArray(a))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                c
              );
            for (var d = 0, e = a.length; d < e; d++) Tf(a[d], this, c, b);
            c.sort(Mg);
            return c;
          }
        });
        Object.assign(Og.prototype, {
          set: function(a, b, c) {
            this.radius = a;
            this.phi = b;
            this.theta = c;
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.radius = a.radius;
            this.phi = a.phi;
            this.theta = a.theta;
            return this;
          },
          makeSafe: function() {
            this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));
            return this;
          },
          setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z);
          },
          setFromCartesianCoords: function(a, b, c) {
            this.radius = Math.sqrt(a * a + b * b + c * c);
            0 === this.radius
              ? (this.phi = this.theta = 0)
              : ((this.theta = Math.atan2(a, c)),
                (this.phi = Math.acos(ya.clamp(b / this.radius, -1, 1))));
            return this;
          }
        });
        Object.assign(Pg.prototype, {
          set: function(a, b, c) {
            this.radius = a;
            this.theta = b;
            this.y = c;
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.radius = a.radius;
            this.theta = a.theta;
            this.y = a.y;
            return this;
          },
          setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z);
          },
          setFromCartesianCoords: function(a, b, c) {
            this.radius = Math.sqrt(a * a + c * c);
            this.theta = Math.atan2(a, c);
            this.y = b;
            return this;
          }
        });
        var hj = new c();
        Object.assign(Uf.prototype, {
          set: function(a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this;
          },
          setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
            return this;
          },
          setFromCenterAndSize: function(a, b) {
            b = hj.copy(b).multiplyScalar(0.5);
            this.min.copy(a).sub(b);
            this.max.copy(a).add(b);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this;
          },
          makeEmpty: function() {
            this.min.x = this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
          },
          isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          },
          getCenter: function(a) {
            void 0 === a &&
              (console.warn("THREE.Box2: .getCenter() target is now required"),
              (a = new c()));
            return this.isEmpty()
              ? a.set(0, 0)
              : a.addVectors(this.min, this.max).multiplyScalar(0.5);
          },
          getSize: function(a) {
            void 0 === a &&
              (console.warn("THREE.Box2: .getSize() target is now required"),
              (a = new c()));
            return this.isEmpty()
              ? a.set(0, 0)
              : a.subVectors(this.max, this.min);
          },
          expandByPoint: function(a) {
            this.min.min(a);
            this.max.max(a);
            return this;
          },
          expandByVector: function(a) {
            this.min.sub(a);
            this.max.add(a);
            return this;
          },
          expandByScalar: function(a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this;
          },
          containsPoint: function(a) {
            return a.x < this.min.x ||
              a.x > this.max.x ||
              a.y < this.min.y ||
              a.y > this.max.y
              ? !1
              : !0;
          },
          containsBox: function(a) {
            return (
              this.min.x <= a.min.x &&
              a.max.x <= this.max.x &&
              this.min.y <= a.min.y &&
              a.max.y <= this.max.y
            );
          },
          getParameter: function(a, b) {
            void 0 === b &&
              (console.warn(
                "THREE.Box2: .getParameter() target is now required"
              ),
              (b = new c()));
            return b.set(
              (a.x - this.min.x) / (this.max.x - this.min.x),
              (a.y - this.min.y) / (this.max.y - this.min.y)
            );
          },
          intersectsBox: function(a) {
            return a.max.x < this.min.x ||
              a.min.x > this.max.x ||
              a.max.y < this.min.y ||
              a.min.y > this.max.y
              ? !1
              : !0;
          },
          clampPoint: function(a, b) {
            void 0 === b &&
              (console.warn("THREE.Box2: .clampPoint() target is now required"),
              (b = new c()));
            return b.copy(a).clamp(this.min, this.max);
          },
          distanceToPoint: function(a) {
            return hj
              .copy(a)
              .clamp(this.min, this.max)
              .sub(a)
              .length();
          },
          intersect: function(a) {
            this.min.max(a.min);
            this.max.min(a.max);
            return this;
          },
          union: function(a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this;
          },
          translate: function(a) {
            this.min.add(a);
            this.max.add(a);
            return this;
          },
          equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max);
          }
        });
        var ij = new h(),
          Ck = new h();
        Object.assign(Vf.prototype, {
          set: function(a, b) {
            this.start.copy(a);
            this.end.copy(b);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          },
          copy: function(a) {
            this.start.copy(a.start);
            this.end.copy(a.end);
            return this;
          },
          getCenter: function(a) {
            void 0 === a &&
              (console.warn("THREE.Line3: .getCenter() target is now required"),
              (a = new h()));
            return a.addVectors(this.start, this.end).multiplyScalar(0.5);
          },
          delta: function(a) {
            void 0 === a &&
              (console.warn("THREE.Line3: .delta() target is now required"),
              (a = new h()));
            return a.subVectors(this.end, this.start);
          },
          distanceSq: function() {
            return this.start.distanceToSquared(this.end);
          },
          distance: function() {
            return this.start.distanceTo(this.end);
          },
          at: function(a, b) {
            void 0 === b &&
              (console.warn("THREE.Line3: .at() target is now required"),
              (b = new h()));
            return this.delta(b)
              .multiplyScalar(a)
              .add(this.start);
          },
          closestPointToPointParameter: function(a, b) {
            ij.subVectors(a, this.start);
            Ck.subVectors(this.end, this.start);
            a = Ck.dot(Ck);
            a = Ck.dot(ij) / a;
            b && (a = ya.clamp(a, 0, 1));
            return a;
          },
          closestPointToPoint: function(a, b, c) {
            a = this.closestPointToPointParameter(a, b);
            void 0 === c &&
              (console.warn(
                "THREE.Line3: .closestPointToPoint() target is now required"
              ),
              (c = new h()));
            return this.delta(c)
              .multiplyScalar(a)
              .add(this.start);
          },
          applyMatrix4: function(a) {
            this.start.applyMatrix4(a);
            this.end.applyMatrix4(a);
            return this;
          },
          equals: function(a) {
            return a.start.equals(this.start) && a.end.equals(this.end);
          }
        });
        Wj.prototype = Object.create(v.prototype);
        Wj.prototype.constructor = Wj;
        Wj.prototype.isImmediateRenderObject = !0;
        var Fe = new h(),
          rf = new h(),
          Kh = new k(),
          lk = ["a", "b", "c"];
        Xj.prototype = Object.create(Qa.prototype);
        Xj.prototype.constructor = Xj;
        Xj.prototype.update = function() {
          this.object.updateMatrixWorld(!0);
          Kh.getNormalMatrix(this.object.matrixWorld);
          var a = this.object.matrixWorld,
            b = this.geometry.attributes.position,
            c = this.object.geometry;
          if (c && c.isGeometry)
            for (
              var d = c.vertices, e = c.faces, f = (c = 0), h = e.length;
              f < h;
              f++
            )
              for (
                var k = e[f], l = 0, m = k.vertexNormals.length;
                l < m;
                l++
              ) {
                var n = k.vertexNormals[l];
                Fe.copy(d[k[lk[l]]]).applyMatrix4(a);
                rf.copy(n)
                  .applyMatrix3(Kh)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(Fe);
                b.setXYZ(c, Fe.x, Fe.y, Fe.z);
                c += 1;
                b.setXYZ(c, rf.x, rf.y, rf.z);
                c += 1;
              }
          else if (c && c.isBufferGeometry)
            for (
              d = c.attributes.position,
                e = c.attributes.normal,
                l = c = 0,
                m = d.count;
              l < m;
              l++
            )
              Fe.set(d.getX(l), d.getY(l), d.getZ(l)).applyMatrix4(a),
                rf.set(e.getX(l), e.getY(l), e.getZ(l)),
                rf
                  .applyMatrix3(Kh)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(Fe),
                b.setXYZ(c, Fe.x, Fe.y, Fe.z),
                (c += 1),
                b.setXYZ(c, rf.x, rf.y, rf.z),
                (c += 1);
          b.needsUpdate = !0;
        };
        var kj = new h();
        Qi.prototype = Object.create(v.prototype);
        Qi.prototype.constructor = Qi;
        Qi.prototype.dispose = function() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        };
        Qi.prototype.update = function() {
          this.light.updateMatrixWorld();
          var a = this.light.distance ? this.light.distance : 1e3,
            b = a * Math.tan(this.light.angle);
          this.cone.scale.set(b, b, a);
          kj.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(kj);
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
        };
        var kg = new h(),
          Dk = new t(),
          Lh = new t();
        Ri.prototype = Object.create(Qa.prototype);
        Ri.prototype.constructor = Ri;
        Ri.prototype.updateMatrixWorld = function(a) {
          var b = this.bones,
            c = this.geometry,
            d = c.getAttribute("position");
          Lh.getInverse(this.root.matrixWorld);
          for (var e = 0, f = 0; e < b.length; e++) {
            var g = b[e];
            g.parent &&
              g.parent.isBone &&
              (Dk.multiplyMatrices(Lh, g.matrixWorld),
              kg.setFromMatrixPosition(Dk),
              d.setXYZ(f, kg.x, kg.y, kg.z),
              Dk.multiplyMatrices(Lh, g.parent.matrixWorld),
              kg.setFromMatrixPosition(Dk),
              d.setXYZ(f + 1, kg.x, kg.y, kg.z),
              (f += 2));
          }
          c.getAttribute("position").needsUpdate = !0;
          v.prototype.updateMatrixWorld.call(this, a);
        };
        Si.prototype = Object.create(da.prototype);
        Si.prototype.constructor = Si;
        Si.prototype.dispose = function() {
          this.geometry.dispose();
          this.material.dispose();
        };
        Si.prototype.update = function() {
          void 0 !== this.color
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        };
        Ti.prototype = Object.create(nb.prototype);
        Ti.prototype.constructor = Ti;
        Ti.prototype.update = function() {
          this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
          if (void 0 !== this.color)
            this.material.color.set(this.color),
              this.children[0].material.color.set(this.color);
          else {
            this.material.color
              .copy(this.light.color)
              .multiplyScalar(this.light.intensity);
            var a = this.material.color,
              b = Math.max(a.r, a.g, a.b);
            1 < b && a.multiplyScalar(1 / b);
            this.children[0].material.color.copy(this.material.color);
          }
        };
        Ti.prototype.dispose = function() {
          this.geometry.dispose();
          this.material.dispose();
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        };
        var mk = new h(),
          lj = new M(),
          mj = new M();
        Ui.prototype = Object.create(v.prototype);
        Ui.prototype.constructor = Ui;
        Ui.prototype.dispose = function() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        };
        Ui.prototype.update = function() {
          var a = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            var b = a.geometry.getAttribute("color");
            lj.copy(this.light.color);
            mj.copy(this.light.groundColor);
            for (var c = 0, d = b.count; c < d; c++) {
              var e = c < d / 2 ? lj : mj;
              b.setXYZ(c, e.r, e.g, e.b);
            }
            b.needsUpdate = !0;
          }
          a.lookAt(mk.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
        Vi.prototype = Object.create(da.prototype);
        Vi.prototype.constructor = Vi;
        Vi.prototype.dispose = function() {
          this.geometry.dispose();
          this.material.dispose();
        };
        Vi.prototype.onBeforeRender = function() {
          this.position.copy(this.lightProbe.position);
          this.scale.set(1, 1, 1).multiplyScalar(this.size);
          this.material.uniforms.intensity.value = this.lightProbe.intensity;
        };
        Ve.prototype = Object.assign(Object.create(Qa.prototype), {
          constructor: Ve,
          copy: function(a) {
            Qa.prototype.copy.call(this, a);
            this.geometry.copy(a.geometry);
            this.material.copy(a.material);
            return this;
          },
          clone: function() {
            return new this.constructor().copy(this);
          }
        });
        We.prototype = Object.create(Qa.prototype);
        We.prototype.constructor = We;
        Wi.prototype = Object.create(nb.prototype);
        Wi.prototype.constructor = Wi;
        Wi.prototype.update = function() {
          function a(a, b, d, e) {
            d = (b - a) / d;
            u.setXYZ(l, 0, 0, 0);
            m++;
            for (n = a; n < b; n += d)
              (q = l + m),
                u.setXYZ(q, Math.sin(n) * c, 0, Math.cos(n) * c),
                u.setXYZ(
                  q + 1,
                  Math.sin(Math.min(n + d, b)) * c,
                  0,
                  Math.cos(Math.min(n + d, b)) * c
                ),
                u.setXYZ(q + 2, 0, 0, 0),
                (m += 3);
            t.addGroup(l, m, e);
            l += m;
            m = 0;
          }
          var b = this.audio,
            c = this.range,
            d = this.divisionsInnerAngle,
            e = this.divisionsOuterAngle,
            f = ya.degToRad(b.panner.coneInnerAngle);
          b = ya.degToRad(b.panner.coneOuterAngle);
          var h = f / 2,
            k = b / 2,
            l = 0,
            m = 0,
            n,
            q,
            t = this.geometry,
            u = t.attributes.position;
          t.clearGroups();
          a(-k, -h, e, 0);
          a(-h, h, d, 1);
          a(h, k, e, 0);
          u.needsUpdate = !0;
          f === b && (this.material[0].visible = !1);
        };
        Wi.prototype.dispose = function() {
          this.geometry.dispose();
          this.material[0].dispose();
          this.material[1].dispose();
        };
        var kk = new h(),
          Ek = new h(),
          nj = new k();
        Yj.prototype = Object.create(Qa.prototype);
        Yj.prototype.constructor = Yj;
        Yj.prototype.update = function() {
          this.object.updateMatrixWorld(!0);
          nj.getNormalMatrix(this.object.matrixWorld);
          var a = this.object.matrixWorld,
            b = this.geometry.attributes.position,
            c = this.object.geometry,
            d = c.vertices;
          c = c.faces;
          for (var e = 0, f = 0, h = c.length; f < h; f++) {
            var k = c[f],
              l = k.normal;
            kk.copy(d[k.a])
              .add(d[k.b])
              .add(d[k.c])
              .divideScalar(3)
              .applyMatrix4(a);
            Ek.copy(l)
              .applyMatrix3(nj)
              .normalize()
              .multiplyScalar(this.size)
              .add(kk);
            b.setXYZ(e, kk.x, kk.y, kk.z);
            e += 1;
            b.setXYZ(e, Ek.x, Ek.y, Ek.z);
            e += 1;
          }
          b.needsUpdate = !0;
        };
        var oj = new h(),
          Fk = new h(),
          pj = new h();
        Xi.prototype = Object.create(v.prototype);
        Xi.prototype.constructor = Xi;
        Xi.prototype.dispose = function() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        };
        Xi.prototype.update = function() {
          oj.setFromMatrixPosition(this.light.matrixWorld);
          Fk.setFromMatrixPosition(this.light.target.matrixWorld);
          pj.subVectors(Fk, oj);
          this.lightPlane.lookAt(Fk);
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color));
          this.targetLine.lookAt(Fk);
          this.targetLine.scale.z = pj.length();
        };
        var pk = new h(),
          Va = new ua();
        Zj.prototype = Object.create(Qa.prototype);
        Zj.prototype.constructor = Zj;
        Zj.prototype.update = function() {
          var a = this.geometry,
            b = this.pointMap;
          Va.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          fb("c", b, a, Va, 0, 0, -1);
          fb("t", b, a, Va, 0, 0, 1);
          fb("n1", b, a, Va, -1, -1, -1);
          fb("n2", b, a, Va, 1, -1, -1);
          fb("n3", b, a, Va, -1, 1, -1);
          fb("n4", b, a, Va, 1, 1, -1);
          fb("f1", b, a, Va, -1, -1, 1);
          fb("f2", b, a, Va, 1, -1, 1);
          fb("f3", b, a, Va, -1, 1, 1);
          fb("f4", b, a, Va, 1, 1, 1);
          fb("u1", b, a, Va, 0.7, 1.1, -1);
          fb("u2", b, a, Va, -0.7, 1.1, -1);
          fb("u3", b, a, Va, 0, 2, -1);
          fb("cf1", b, a, Va, -1, 0, 1);
          fb("cf2", b, a, Va, 1, 0, 1);
          fb("cf3", b, a, Va, 0, -1, 1);
          fb("cf4", b, a, Va, 0, 1, 1);
          fb("cn1", b, a, Va, -1, 0, -1);
          fb("cn2", b, a, Va, 1, 0, -1);
          fb("cn3", b, a, Va, 0, -1, -1);
          fb("cn4", b, a, Va, 0, 1, -1);
          a.getAttribute("position").needsUpdate = !0;
        };
        var Gk = new C();
        kf.prototype = Object.create(Qa.prototype);
        kf.prototype.constructor = kf;
        kf.prototype.update = function(a) {
          void 0 !== a &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          void 0 !== this.object && Gk.setFromObject(this.object);
          if (!Gk.isEmpty()) {
            a = Gk.min;
            var b = Gk.max,
              c = this.geometry.attributes.position,
              d = c.array;
            d[0] = b.x;
            d[1] = b.y;
            d[2] = b.z;
            d[3] = a.x;
            d[4] = b.y;
            d[5] = b.z;
            d[6] = a.x;
            d[7] = a.y;
            d[8] = b.z;
            d[9] = b.x;
            d[10] = a.y;
            d[11] = b.z;
            d[12] = b.x;
            d[13] = b.y;
            d[14] = a.z;
            d[15] = a.x;
            d[16] = b.y;
            d[17] = a.z;
            d[18] = a.x;
            d[19] = a.y;
            d[20] = a.z;
            d[21] = b.x;
            d[22] = a.y;
            d[23] = a.z;
            c.needsUpdate = !0;
            this.geometry.computeBoundingSphere();
          }
        };
        kf.prototype.setFromObject = function(a) {
          this.object = a;
          this.update();
          return this;
        };
        kf.prototype.copy = function(a) {
          Qa.prototype.copy.call(this, a);
          this.object = a.object;
          return this;
        };
        kf.prototype.clone = function() {
          return new this.constructor().copy(this);
        };
        ak.prototype = Object.create(Qa.prototype);
        ak.prototype.constructor = ak;
        ak.prototype.updateMatrixWorld = function(a) {
          var b = this.box;
          b.isEmpty() ||
            (b.getCenter(this.position),
            b.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            v.prototype.updateMatrixWorld.call(this, a));
        };
        bk.prototype = Object.create(nb.prototype);
        bk.prototype.constructor = bk;
        bk.prototype.updateMatrixWorld = function(a) {
          var b = -this.plane.constant;
          1e-8 > Math.abs(b) && (b = 1e-8);
          this.scale.set(0.5 * this.size, 0.5 * this.size, b);
          this.children[0].material.side = 0 > b ? 1 : 0;
          this.lookAt(this.plane.normal);
          v.prototype.updateMatrixWorld.call(this, a);
        };
        var qj = new h(),
          qk,
          Nh;
        lf.prototype = Object.create(v.prototype);
        lf.prototype.constructor = lf;
        lf.prototype.setDirection = function(a) {
          0.99999 < a.y
            ? this.quaternion.set(0, 0, 0, 1)
            : -0.99999 > a.y
            ? this.quaternion.set(1, 0, 0, 0)
            : (qj.set(a.z, 0, -a.x).normalize(),
              this.quaternion.setFromAxisAngle(qj, Math.acos(a.y)));
        };
        lf.prototype.setLength = function(a, b, c) {
          void 0 === b && (b = 0.2 * a);
          void 0 === c && (c = 0.2 * b);
          this.line.scale.set(1, Math.max(1e-4, a - b), 1);
          this.line.updateMatrix();
          this.cone.scale.set(c, b, c);
          this.cone.position.y = a;
          this.cone.updateMatrix();
        };
        lf.prototype.setColor = function(a) {
          this.line.material.color.set(a);
          this.cone.material.color.set(a);
        };
        lf.prototype.copy = function(a) {
          v.prototype.copy.call(this, a, !1);
          this.line.copy(a.line);
          this.cone.copy(a.cone);
          return this;
        };
        lf.prototype.clone = function() {
          return new this.constructor().copy(this);
        };
        ck.prototype = Object.create(Qa.prototype);
        ck.prototype.constructor = ck;
        la.create = function(a, b) {
          a.prototype = Object.create(la.prototype);
          a.prototype.constructor = a;
          a.prototype.getPoint = b;
          return a;
        };
        Object.assign(jf.prototype, {
          createPointsGeometry: function(a) {
            console.warn(
              "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            a = this.getPoints(a);
            return this.createGeometry(a);
          },
          createSpacedPointsGeometry: function(a) {
            console.warn(
              "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            a = this.getSpacedPoints(a);
            return this.createGeometry(a);
          },
          createGeometry: function(a) {
            console.warn(
              "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            for (var b = new U(), c = 0, d = a.length; c < d; c++) {
              var e = a[c];
              b.vertices.push(new h(e.x, e.y, e.z || 0));
            }
            return b;
          }
        });
        Object.assign(Dd.prototype, {
          fromPoints: function(a) {
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            );
            this.setFromPoints(a);
          }
        });
        Rg.prototype = Object.create(sb.prototype);
        Sg.prototype = Object.create(sb.prototype);
        Wf.prototype = Object.create(sb.prototype);
        Object.assign(Wf.prototype, {
          initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.");
          },
          getControlPointsArray: function() {
            console.error(
              "THREE.Spline: .getControlPointsArray() has been removed."
            );
          },
          reparametrizeByArcLength: function() {
            console.error(
              "THREE.Spline: .reparametrizeByArcLength() has been removed."
            );
          }
        });
        Ve.prototype.setColors = function() {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        };
        Ri.prototype.update = function() {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        };
        Object.assign(Ja.prototype, {
          extractUrlBase: function(a) {
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            );
            return dh.extractUrlBase(a);
          }
        });
        Ja.Handlers = {
          add: function() {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function() {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          }
        };
        Object.assign(Ge.prototype, {
          setTexturePath: function(a) {
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            );
            return this.setResourcePath(a);
          }
        });
        Object.assign(Uf.prototype, {
          center: function(a) {
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            );
            return this.getCenter(a);
          },
          empty: function() {
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            );
            return this.isEmpty();
          },
          isIntersectionBox: function(a) {
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
          size: function(a) {
            console.warn("THREE.Box2: .size() has been renamed to .getSize().");
            return this.getSize(a);
          }
        });
        Object.assign(C.prototype, {
          center: function(a) {
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            );
            return this.getCenter(a);
          },
          empty: function() {
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            );
            return this.isEmpty();
          },
          isIntersectionBox: function(a) {
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
          isIntersectionSphere: function(a) {
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            );
            return this.intersectsSphere(a);
          },
          size: function(a) {
            console.warn("THREE.Box3: .size() has been renamed to .getSize().");
            return this.getSize(a);
          }
        });
        Vf.prototype.center = function(a) {
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          );
          return this.getCenter(a);
        };
        Object.assign(ya, {
          random16: function() {
            console.warn(
              "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
            );
            return Math.random();
          },
          nearestPowerOfTwo: function(a) {
            console.warn(
              "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
            );
            return ya.floorPowerOfTwo(a);
          },
          nextPowerOfTwo: function(a) {
            console.warn(
              "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
            );
            return ya.ceilPowerOfTwo(a);
          }
        });
        Object.assign(k.prototype, {
          flattenToArrayOffset: function(a, b) {
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            );
            return this.toArray(a, b);
          },
          multiplyVector3: function(a) {
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            );
            return a.applyMatrix3(this);
          },
          multiplyVector3Array: function() {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          },
          applyToBuffer: function(a) {
            console.warn(
              "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            );
            return this.applyToBufferAttribute(a);
          },
          applyToVector3Array: function() {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          }
        });
        Object.assign(t.prototype, {
          extractPosition: function(a) {
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            );
            return this.copyPosition(a);
          },
          flattenToArrayOffset: function(a, b) {
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            );
            return this.toArray(a, b);
          },
          getPosition: function() {
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            );
            return new h().setFromMatrixColumn(this, 3);
          },
          setRotationFromQuaternion: function(a) {
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            );
            return this.makeRotationFromQuaternion(a);
          },
          multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          },
          multiplyVector3: function(a) {
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            );
            return a.applyMatrix4(this);
          },
          multiplyVector4: function(a) {
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            );
            return a.applyMatrix4(this);
          },
          multiplyVector3Array: function() {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          },
          rotateAxis: function(a) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            );
            a.transformDirection(this);
          },
          crossVector: function(a) {
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            );
            return a.applyMatrix4(this);
          },
          translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.");
          },
          rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          },
          rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          },
          rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          },
          rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          },
          applyToBuffer: function(a) {
            console.warn(
              "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            );
            return this.applyToBufferAttribute(a);
          },
          applyToVector3Array: function() {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          },
          makeFrustum: function(a, b, c, d, e, f) {
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            );
            return this.makePerspective(a, b, d, c, e, f);
          }
        });
        ta.prototype.isIntersectionLine = function(a) {
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          );
          return this.intersectsLine(a);
        };
        f.prototype.multiplyVector3 = function(a) {
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          );
          return a.applyQuaternion(this);
        };
        Object.assign(N.prototype, {
          isIntersectionBox: function(a) {
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
          isIntersectionPlane: function(a) {
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            );
            return this.intersectsPlane(a);
          },
          isIntersectionSphere: function(a) {
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            );
            return this.intersectsSphere(a);
          }
        });
        Object.assign(B.prototype, {
          area: function() {
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            );
            return this.getArea();
          },
          barycoordFromPoint: function(a, b) {
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            );
            return this.getBarycoord(a, b);
          },
          midpoint: function(a) {
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            );
            return this.getMidpoint(a);
          },
          normal: function(a) {
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            );
            return this.getNormal(a);
          },
          plane: function(a) {
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            );
            return this.getPlane(a);
          }
        });
        Object.assign(B, {
          barycoordFromPoint: function(a, b, c, d, e) {
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            );
            return B.getBarycoord(a, b, c, d, e);
          },
          normal: function(a, b, c, d) {
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            );
            return B.getNormal(a, b, c, d);
          }
        });
        Object.assign(eg.prototype, {
          extractAllPoints: function(a) {
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            );
            return this.extractPoints(a);
          },
          extrude: function(a) {
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            );
            return new qh(this, a);
          },
          makeGeometry: function(a) {
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            );
            return new rh(this, a);
          }
        });
        Object.assign(c.prototype, {
          fromAttribute: function(a, b, c) {
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            );
            return this.fromBufferAttribute(a, b, c);
          },
          distanceToManhattan: function(a) {
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            );
            return this.manhattanDistanceTo(a);
          },
          lengthManhattan: function() {
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            );
            return this.manhattanLength();
          }
        });
        Object.assign(h.prototype, {
          setEulerFromRotationMatrix: function() {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          },
          setEulerFromQuaternion: function() {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          },
          getPositionFromMatrix: function(a) {
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            );
            return this.setFromMatrixPosition(a);
          },
          getScaleFromMatrix: function(a) {
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            );
            return this.setFromMatrixScale(a);
          },
          getColumnFromMatrix: function(a, b) {
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            );
            return this.setFromMatrixColumn(b, a);
          },
          applyProjection: function(a) {
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            );
            return this.applyMatrix4(a);
          },
          fromAttribute: function(a, b, c) {
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            );
            return this.fromBufferAttribute(a, b, c);
          },
          distanceToManhattan: function(a) {
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            );
            return this.manhattanDistanceTo(a);
          },
          lengthManhattan: function() {
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            );
            return this.manhattanLength();
          }
        });
        Object.assign(m.prototype, {
          fromAttribute: function(a, b, c) {
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            );
            return this.fromBufferAttribute(a, b, c);
          },
          lengthManhattan: function() {
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            );
            return this.manhattanLength();
          }
        });
        Object.assign(U.prototype, {
          computeTangents: function() {
            console.error(
              "THREE.Geometry: .computeTangents() has been removed."
            );
          },
          computeLineDistances: function() {
            console.error(
              "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
            );
          }
        });
        Object.assign(v.prototype, {
          getChildByName: function(a) {
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            );
            return this.getObjectByName(a);
          },
          renderDepth: function() {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          },
          translate: function(a, b) {
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            );
            return this.translateOnAxis(b, a);
          },
          getWorldRotation: function() {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          }
        });
        Object.defineProperties(v.prototype, {
          eulerOrder: {
            get: function() {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              );
              return this.rotation.order;
            },
            set: function(a) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              );
              this.rotation.order = a;
            }
          },
          useQuaternion: {
            get: function() {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function() {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            }
          }
        });
        Object.defineProperties(fc.prototype, {
          objects: {
            get: function() {
              console.warn("THREE.LOD: .objects has been renamed to .levels.");
              return this.levels;
            }
          }
        });
        Object.defineProperty(Wc.prototype, "useVertexTexture", {
          get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
          set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          }
        });
        hc.prototype.initBones = function() {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        };
        Object.defineProperty(la.prototype, "__arcLengthDivisions", {
          get: function() {
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            );
            return this.arcLengthDivisions;
          },
          set: function(a) {
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            );
            this.arcLengthDivisions = a;
          }
        });
        Da.prototype.setLens = function(a, b) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          );
          void 0 !== b && (this.filmGauge = b);
          this.setFocalLength(a);
        };
        Object.defineProperties(Ka.prototype, {
          onlyShadow: {
            set: function() {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            }
          },
          shadowCameraFov: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              );
              this.shadow.camera.fov = a;
            }
          },
          shadowCameraLeft: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              );
              this.shadow.camera.left = a;
            }
          },
          shadowCameraRight: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              );
              this.shadow.camera.right = a;
            }
          },
          shadowCameraTop: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              );
              this.shadow.camera.top = a;
            }
          },
          shadowCameraBottom: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              );
              this.shadow.camera.bottom = a;
            }
          },
          shadowCameraNear: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              );
              this.shadow.camera.near = a;
            }
          },
          shadowCameraFar: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              );
              this.shadow.camera.far = a;
            }
          },
          shadowCameraVisible: {
            set: function() {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            }
          },
          shadowBias: {
            set: function(a) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
              this.shadow.bias = a;
            }
          },
          shadowDarkness: {
            set: function() {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            }
          },
          shadowMapWidth: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              );
              this.shadow.mapSize.width = a;
            }
          },
          shadowMapHeight: {
            set: function(a) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              );
              this.shadow.mapSize.height = a;
            }
          }
        });
        Object.defineProperties(I.prototype, {
          length: {
            get: function() {
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              );
              return this.array.length;
            }
          }
        });
        Object.assign(I.prototype, {
          copyIndicesArray: function() {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          },
          setArray: function(a) {
            console.warn(
              "THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
            this.count = void 0 !== a ? a.length / this.itemSize : 0;
            this.array = a;
            return this;
          }
        });
        Object.assign(S.prototype, {
          addIndex: function(a) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            );
            this.setIndex(a);
          },
          addDrawCall: function(a, b, c) {
            void 0 !== c &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              );
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            );
            this.addGroup(a, b);
          },
          clearDrawCalls: function() {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            );
            this.clearGroups();
          },
          computeTangents: function() {
            console.warn(
              "THREE.BufferGeometry: .computeTangents() has been removed."
            );
          },
          computeOffsets: function() {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          }
        });
        Object.defineProperties(S.prototype, {
          drawcalls: {
            get: function() {
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              );
              return this.groups;
            }
          },
          offsets: {
            get: function() {
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              );
              return this.groups;
            }
          }
        });
        Object.assign(bg.prototype, {
          setArray: function(a) {
            console.warn(
              "THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
            this.count = void 0 !== a ? a.length / this.stride : 0;
            this.array = a;
            return this;
          }
        });
        Object.assign(xe.prototype, {
          getArrays: function() {
            console.error(
              "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
            );
          },
          addShapeList: function() {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
            );
          },
          addShape: function() {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
            );
          }
        });
        Object.defineProperties(Ue.prototype, {
          dynamic: {
            set: function() {
              console.warn(
                "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
              );
            }
          },
          onUpdate: {
            value: function() {
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              );
              return this;
            }
          }
        });
        Object.defineProperties(D.prototype, {
          wrapAround: {
            get: function() {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function() {
              console.warn("THREE.Material: .wrapAround has been removed.");
            }
          },
          overdraw: {
            get: function() {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function() {
              console.warn("THREE.Material: .overdraw has been removed.");
            }
          },
          wrapRGB: {
            get: function() {
              console.warn("THREE.Material: .wrapRGB has been removed.");
              return new M();
            }
          },
          shading: {
            get: function() {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function(a) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
              this.flatShading = 1 === a;
            }
          },
          stencilMask: {
            get: function() {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              );
              return this.stencilFuncMask;
            },
            set: function(a) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              );
              this.stencilFuncMask = a;
            }
          }
        });
        Object.defineProperties(yd.prototype, {
          metal: {
            get: function() {
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
              );
              return !1;
            },
            set: function() {
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
              );
            }
          }
        });
        Object.defineProperties(qa.prototype, {
          derivatives: {
            get: function() {
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              );
              return this.extensions.derivatives;
            },
            set: function(a) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              );
              this.extensions.derivatives = a;
            }
          }
        });
        Object.assign(rd.prototype, {
          clearTarget: function(a, b, c, d) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            );
            this.setRenderTarget(a);
            this.clear(b, c, d);
          },
          animate: function(a) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            );
            this.setAnimationLoop(a);
          },
          getCurrentRenderTarget: function() {
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            );
            return this.getRenderTarget();
          },
          getMaxAnisotropy: function() {
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            );
            return this.capabilities.getMaxAnisotropy();
          },
          getPrecision: function() {
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            );
            return this.capabilities.precision;
          },
          resetGLState: function() {
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            );
            return this.state.reset();
          },
          supportsFloatTextures: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            );
            return this.extensions.get("OES_texture_float");
          },
          supportsHalfFloatTextures: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            );
            return this.extensions.get("OES_texture_half_float");
          },
          supportsStandardDerivatives: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            );
            return this.extensions.get("OES_standard_derivatives");
          },
          supportsCompressedTextureS3TC: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            );
            return this.extensions.get("WEBGL_compressed_texture_s3tc");
          },
          supportsCompressedTexturePVRTC: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            );
            return this.extensions.get("WEBGL_compressed_texture_pvrtc");
          },
          supportsBlendMinMax: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            );
            return this.extensions.get("EXT_blend_minmax");
          },
          supportsVertexTextures: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            );
            return this.capabilities.vertexTextures;
          },
          supportsInstancedArrays: function() {
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            );
            return this.extensions.get("ANGLE_instanced_arrays");
          },
          enableScissorTest: function(a) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            );
            this.setScissorTest(a);
          },
          initMaterial: function() {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          },
          addPrePlugin: function() {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          },
          addPostPlugin: function() {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          },
          updateShadowMap: function() {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          },
          setFaceCulling: function() {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          },
          allocTextureUnit: function() {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          },
          setTexture: function() {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          },
          setTexture2D: function() {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          },
          setTextureCube: function() {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          },
          getActiveMipMapLevel: function() {
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            );
            return this.getActiveMipmapLevel();
          }
        });
        Object.defineProperties(rd.prototype, {
          shadowMapEnabled: {
            get: function() {
              return this.shadowMap.enabled;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              );
              this.shadowMap.enabled = a;
            }
          },
          shadowMapType: {
            get: function() {
              return this.shadowMap.type;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              );
              this.shadowMap.type = a;
            }
          },
          shadowMapCullFace: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            }
          },
          context: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              );
              return this.getContext();
            }
          }
        });
        Object.defineProperties(Qd.prototype, {
          cullFace: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            }
          },
          renderReverseSided: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            }
          },
          renderSingleSided: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function() {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            }
          }
        });
        Object.defineProperties(oa.prototype, {
          activeCubeFace: {
            set: function() {
              console.warn(
                "THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
              );
            }
          },
          activeMipMapLevel: {
            set: function() {
              console.warn(
                "THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
              );
            }
          }
        });
        Object.defineProperties(n.prototype, {
          wrapS: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              );
              return this.texture.wrapS;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              );
              this.texture.wrapS = a;
            }
          },
          wrapT: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              );
              return this.texture.wrapT;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              );
              this.texture.wrapT = a;
            }
          },
          magFilter: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              );
              return this.texture.magFilter;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              );
              this.texture.magFilter = a;
            }
          },
          minFilter: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              );
              return this.texture.minFilter;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              );
              this.texture.minFilter = a;
            }
          },
          anisotropy: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              );
              return this.texture.anisotropy;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              );
              this.texture.anisotropy = a;
            }
          },
          offset: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              );
              return this.texture.offset;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              );
              this.texture.offset = a;
            }
          },
          repeat: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              );
              return this.texture.repeat;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              );
              this.texture.repeat = a;
            }
          },
          format: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              );
              return this.texture.format;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              );
              this.texture.format = a;
            }
          },
          type: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              );
              return this.texture.type;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              );
              this.texture.type = a;
            }
          },
          generateMipmaps: {
            get: function() {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              );
              return this.texture.generateMipmaps;
            },
            set: function(a) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              );
              this.texture.generateMipmaps = a;
            }
          }
        });
        Object.defineProperties(od.prototype, {
          standing: {
            set: function() {
              console.warn("THREE.WebVRManager: .standing has been removed.");
            }
          },
          userHeight: {
            set: function() {
              console.warn("THREE.WebVRManager: .userHeight has been removed.");
            }
          }
        });
        Pi.prototype.load = function(a) {
          console.warn(
            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
          );
          var b = this;
          new Me().load(a, function(a) {
            b.setBuffer(a);
          });
          return this;
        };
        Mf.prototype.getData = function() {
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          );
          return this.getFrequencyData();
        };
        Ca.prototype.updateCubeMap = function(a, b) {
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
          return this.update(a, b);
        };
        fg.crossOrigin = void 0;
        fg.loadTexture = function(a, b, c, d) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          var e = new ee();
          e.setCrossOrigin(this.crossOrigin);
          a = e.load(a, c, void 0, d);
          b && (a.mapping = b);
          return a;
        };
        fg.loadTextureCube = function(a, b, c, d) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          var e = new ce();
          e.setCrossOrigin(this.crossOrigin);
          a = e.load(a, c, void 0, d);
          b && (a.mapping = b);
          return a;
        };
        fg.loadCompressedTexture = function() {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        };
        fg.loadCompressedTextureCube = function() {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        };
        "undefined" !== typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: "109" } })
          );
        a.ACESFilmicToneMapping = 5;
        a.AddEquation = 100;
        a.AddOperation = 2;
        a.AdditiveBlending = 2;
        a.AlphaFormat = 1021;
        a.AlwaysDepth = 1;
        a.AlwaysStencilFunc = 519;
        a.AmbientLight = ne;
        a.AmbientLightProbe = Ff;
        a.AnimationClip = Oc;
        a.AnimationLoader = Ye;
        a.AnimationMixer = Pf;
        a.AnimationObjectGroup = Hg;
        a.AnimationUtils = lb;
        a.ArcCurve = Oi;
        a.ArrayCamera = Rb;
        a.ArrowHelper = lf;
        a.Audio = Pi;
        a.AudioAnalyser = Mf;
        a.AudioContext = fh;
        a.AudioListener = Kf;
        a.AudioLoader = Me;
        a.AxesHelper = ck;
        a.AxisHelper = function(a) {
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          );
          return new ck(a);
        };
        a.BackSide = 1;
        a.BasicDepthPacking = 3200;
        a.BasicShadowMap = 0;
        a.BinaryTextureLoader = function(a) {
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          );
          return new ae(a);
        };
        a.Bone = Ld;
        a.BooleanKeyframeTrack = Xd;
        a.BoundingBoxHelper = function(a, b) {
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          );
          return new kf(a, b);
        };
        a.Box2 = Uf;
        a.Box3 = C;
        a.Box3Helper = ak;
        a.BoxBufferGeometry = Tj;
        a.BoxGeometry = Dg;
        a.BoxHelper = kf;
        a.BufferAttribute = I;
        a.BufferGeometry = S;
        a.BufferGeometryLoader = se;
        a.ByteType = 1010;
        a.Cache = Fh;
        a.Camera = ua;
        a.CameraHelper = Zj;
        a.CanvasRenderer = function() {
          console.error("THREE.CanvasRenderer has been removed");
        };
        a.CanvasTexture = mc;
        a.CatmullRomCurve3 = sb;
        a.CineonToneMapping = 4;
        a.CircleBufferGeometry = Ji;
        a.CircleGeometry = kd;
        a.ClampToEdgeWrapping = 1001;
        a.Clock = Jf;
        a.ClosedSplineCurve3 = Rg;
        a.Color = M;
        a.ColorKeyframeTrack = Yd;
        a.CompressedTexture = Ob;
        a.CompressedTextureLoader = Ze;
        a.ConeBufferGeometry = jd;
        a.ConeGeometry = hd;
        a.CubeCamera = Ca;
        a.CubeGeometry = Dg;
        a.CubeReflectionMapping = 301;
        a.CubeRefractionMapping = 302;
        a.CubeTexture = Ha;
        a.CubeTextureLoader = ce;
        a.CubeUVReflectionMapping = 306;
        a.CubeUVRefractionMapping = 307;
        a.CubicBezierCurve = zd;
        a.CubicBezierCurve3 = ze;
        a.CubicInterpolant = Ud;
        a.CullFaceBack = 1;
        a.CullFaceFront = 2;
        a.CullFaceFrontBack = 3;
        a.CullFaceNone = 0;
        a.Curve = la;
        a.CurvePath = jf;
        a.CustomBlending = 5;
        a.CylinderBufferGeometry = hf;
        a.CylinderGeometry = th;
        a.Cylindrical = Pg;
        a.DataTexture = Ia;
        a.DataTexture2DArray = db;
        a.DataTexture3D = jb;
        a.DataTextureLoader = ae;
        a.DecrementStencilOp = 7683;
        a.DecrementWrapStencilOp = 34056;
        a.DefaultLoadingManager = qi;
        a.DepthFormat = 1026;
        a.DepthStencilFormat = 1027;
        a.DepthTexture = nc;
        a.DirectionalLight = me;
        a.DirectionalLightHelper = Xi;
        a.DirectionalLightShadow = le;
        a.DiscreteInterpolant = Vd;
        a.DodecahedronBufferGeometry = Ub;
        a.DodecahedronGeometry = wc;
        a.DoubleSide = 2;
        a.DstAlphaFactor = 206;
        a.DstColorFactor = 208;
        a.DynamicBufferAttribute = function(a, b) {
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
          );
          return new I(a, b).setDynamic(!0);
        };
        a.EdgesGeometry = Ii;
        a.EdgesHelper = function(a, b) {
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          );
          return new Qa(
            new Ii(a.geometry),
            new Ga({ color: void 0 !== b ? b : 16777215 })
          );
        };
        a.EllipseCurve = $b;
        a.EqualDepth = 4;
        a.EqualStencilFunc = 514;
        a.EquirectangularReflectionMapping = 303;
        a.EquirectangularRefractionMapping = 304;
        a.Euler = y;
        a.EventDispatcher = b;
        a.ExtrudeBufferGeometry = xe;
        a.ExtrudeGeometry = qh;
        a.Face3 = J;
        a.Face4 = function(a, b, c, d, e, f, h) {
          console.warn(
            "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
          );
          return new J(a, b, c, e, f, h);
        };
        a.FaceColors = 1;
        a.FaceNormalsHelper = Yj;
        a.FileLoader = Pc;
        a.FlatShading = 1;
        a.Float32Attribute = function(a, b) {
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          );
          return new P(a, b);
        };
        a.Float32BufferAttribute = P;
        a.Float64Attribute = function(a, b) {
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          );
          return new ja(a, b);
        };
        a.Float64BufferAttribute = ja;
        a.FloatType = 1015;
        a.Fog = Nc;
        a.FogExp2 = Mc;
        a.Font = vf;
        a.FontLoader = Af;
        a.FrontFaceDirectionCCW = 1;
        a.FrontFaceDirectionCW = 0;
        a.FrontSide = 0;
        a.Frustum = Q;
        a.GammaEncoding = 3007;
        a.Geometry = U;
        a.GeometryUtils = {
          merge: function(a, b, c) {
            console.warn(
              "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
            );
            if (b.isMesh) {
              b.matrixAutoUpdate && b.updateMatrix();
              var d = b.matrix;
              b = b.geometry;
            }
            a.merge(b, d, c);
          },
          center: function(a) {
            console.warn(
              "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
            );
            return a.center();
          }
        };
        a.GreaterDepth = 6;
        a.GreaterEqualDepth = 5;
        a.GreaterEqualStencilFunc = 518;
        a.GreaterStencilFunc = 516;
        a.GridHelper = Ve;
        a.Group = Fb;
        a.HalfFloatType = 1016;
        a.HemisphereLight = ge;
        a.HemisphereLightHelper = Ui;
        a.HemisphereLightProbe = Cf;
        a.IcosahedronBufferGeometry = Tb;
        a.IcosahedronGeometry = uc;
        a.ImageBitmapLoader = sf;
        a.ImageLoader = Ni;
        a.ImageUtils = fg;
        a.ImmediateRenderObject = Wj;
        a.IncrementStencilOp = 7682;
        a.IncrementWrapStencilOp = 34055;
        a.InstancedBufferAttribute = re;
        a.InstancedBufferGeometry = qe;
        a.InstancedInterleavedBuffer = Sf;
        a.InstancedMesh = Md;
        a.Int16Attribute = function(a, b) {
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          );
          return new ba(a, b);
        };
        a.Int16BufferAttribute = ba;
        a.Int32Attribute = function(a, b) {
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          );
          return new ha(a, b);
        };
        a.Int32BufferAttribute = ha;
        a.Int8Attribute = function(a, b) {
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          );
          return new V(a, b);
        };
        a.Int8BufferAttribute = V;
        a.IntType = 1013;
        a.InterleavedBuffer = bg;
        a.InterleavedBufferAttribute = cc;
        a.Interpolant = Zb;
        a.InterpolateDiscrete = 2300;
        a.InterpolateLinear = 2301;
        a.InterpolateSmooth = 2302;
        a.InvertStencilOp = 5386;
        a.JSONLoader = function() {
          console.error("THREE.JSONLoader has been removed.");
        };
        a.KeepStencilOp = 7680;
        a.KeyframeTrack = pb;
        a.LOD = fc;
        a.LatheBufferGeometry = Hi;
        a.LatheGeometry = gd;
        a.Layers = u;
        a.LensFlare = function() {
          console.error(
            "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
          );
        };
        a.LessDepth = 2;
        a.LessEqualDepth = 3;
        a.LessEqualStencilFunc = 515;
        a.LessStencilFunc = 513;
        a.Light = Ka;
        a.LightProbe = Ed;
        a.LightProbeHelper = Vi;
        a.LightShadow = Be;
        a.Line = nb;
        a.Line3 = Vf;
        a.LineBasicMaterial = Ga;
        a.LineCurve = Kb;
        a.LineCurve3 = Ad;
        a.LineDashedMaterial = Ah;
        a.LineLoop = Zc;
        a.LinePieces = 1;
        a.LineSegments = Qa;
        a.LineStrip = 0;
        a.LinearEncoding = 3e3;
        a.LinearFilter = 1006;
        a.LinearInterpolant = md;
        a.LinearMipMapLinearFilter = 1008;
        a.LinearMipMapNearestFilter = 1007;
        a.LinearMipmapLinearFilter = 1008;
        a.LinearMipmapNearestFilter = 1007;
        a.LinearToneMapping = 1;
        a.Loader = Ja;
        a.LoaderUtils = dh;
        a.LoadingManager = Xe;
        a.LogLuvEncoding = 3003;
        a.LoopOnce = 2200;
        a.LoopPingPong = 2202;
        a.LoopRepeat = 2201;
        a.LuminanceAlphaFormat = 1025;
        a.LuminanceFormat = 1024;
        a.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
        a.Material = D;
        a.MaterialLoader = pe;
        a.Math = ya;
        a.Matrix3 = k;
        a.Matrix4 = t;
        a.MaxEquation = 104;
        a.Mesh = da;
        a.MeshBasicMaterial = F;
        a.MeshDepthMaterial = $f;
        a.MeshDistanceMaterial = ag;
        a.MeshFaceMaterial = function(a) {
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          );
          return a;
        };
        a.MeshLambertMaterial = yh;
        a.MeshMatcapMaterial = zh;
        a.MeshNormalMaterial = xh;
        a.MeshPhongMaterial = yd;
        a.MeshPhysicalMaterial = vh;
        a.MeshStandardMaterial = ye;
        a.MeshToonMaterial = wh;
        a.MinEquation = 103;
        a.MirroredRepeatWrapping = 1002;
        a.MixOperation = 1;
        a.MultiMaterial = function(a) {
          void 0 === a && (a = []);
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          );
          a.isMultiMaterial = !0;
          a.materials = a;
          a.clone = function() {
            return a.slice();
          };
          return a;
        };
        a.MultiplyBlending = 4;
        a.MultiplyOperation = 0;
        a.NearestFilter = 1003;
        a.NearestMipMapLinearFilter = 1005;
        a.NearestMipMapNearestFilter = 1004;
        a.NearestMipmapLinearFilter = 1005;
        a.NearestMipmapNearestFilter = 1004;
        a.NeverDepth = 0;
        a.NeverStencilFunc = 512;
        a.NoBlending = 0;
        a.NoColors = 0;
        a.NoToneMapping = 0;
        a.NormalBlending = 1;
        a.NotEqualDepth = 7;
        a.NotEqualStencilFunc = 517;
        a.NumberKeyframeTrack = Li;
        a.Object3D = v;
        a.ObjectLoader = Ge;
        a.ObjectSpaceNormalMap = 1;
        a.OctahedronBufferGeometry = nh;
        a.OctahedronGeometry = tc;
        a.OneFactor = 201;
        a.OneMinusDstAlphaFactor = 207;
        a.OneMinusDstColorFactor = 209;
        a.OneMinusSrcAlphaFactor = 205;
        a.OneMinusSrcColorFactor = 203;
        a.OrthographicCamera = td;
        a.PCFShadowMap = 1;
        a.PCFSoftShadowMap = 2;
        a.ParametricBufferGeometry = Qb;
        a.ParametricGeometry = pc;
        a.Particle = function(a) {
          console.warn("THREE.Particle has been renamed to THREE.Sprite.");
          return new dc(a);
        };
        a.ParticleBasicMaterial = function(a) {
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          );
          return new xd(a);
        };
        a.ParticleSystem = function(a, b) {
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          );
          return new Mb(a, b);
        };
        a.ParticleSystemMaterial = function(a) {
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          );
          return new xd(a);
        };
        a.Path = Dd;
        a.PerspectiveCamera = Da;
        a.Plane = ta;
        a.PlaneBufferGeometry = Aa;
        a.PlaneGeometry = ka;
        a.PlaneHelper = bk;
        a.PointCloud = function(a, b) {
          console.warn("THREE.PointCloud has been renamed to THREE.Points.");
          return new Mb(a, b);
        };
        a.PointCloudMaterial = function(a) {
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          );
          return new xd(a);
        };
        a.PointLight = je;
        a.PointLightHelper = Si;
        a.Points = Mb;
        a.PointsMaterial = xd;
        a.PolarGridHelper = We;
        a.PolyhedronBufferGeometry = Jb;
        a.PolyhedronGeometry = rc;
        a.PositionalAudio = Lf;
        a.PositionalAudioHelper = Wi;
        a.PropertyBinding = tb;
        a.PropertyMixer = Nf;
        a.QuadraticBezierCurve = Bd;
        a.QuadraticBezierCurve3 = Ae;
        a.Quaternion = f;
        a.QuaternionKeyframeTrack = nd;
        a.QuaternionLinearInterpolant = Zd;
        a.REVISION = "109";
        a.RGBADepthPacking = 3201;
        a.RGBAFormat = 1023;
        a.RGBA_ASTC_10x10_Format = 37819;
        a.RGBA_ASTC_10x5_Format = 37816;
        a.RGBA_ASTC_10x6_Format = 37817;
        a.RGBA_ASTC_10x8_Format = 37818;
        a.RGBA_ASTC_12x10_Format = 37820;
        a.RGBA_ASTC_12x12_Format = 37821;
        a.RGBA_ASTC_4x4_Format = 37808;
        a.RGBA_ASTC_5x4_Format = 37809;
        a.RGBA_ASTC_5x5_Format = 37810;
        a.RGBA_ASTC_6x5_Format = 37811;
        a.RGBA_ASTC_6x6_Format = 37812;
        a.RGBA_ASTC_8x5_Format = 37813;
        a.RGBA_ASTC_8x6_Format = 37814;
        a.RGBA_ASTC_8x8_Format = 37815;
        a.RGBA_PVRTC_2BPPV1_Format = 35843;
        a.RGBA_PVRTC_4BPPV1_Format = 35842;
        a.RGBA_S3TC_DXT1_Format = 33777;
        a.RGBA_S3TC_DXT3_Format = 33778;
        a.RGBA_S3TC_DXT5_Format = 33779;
        a.RGBDEncoding = 3006;
        a.RGBEEncoding = 3002;
        a.RGBEFormat = 1023;
        a.RGBFormat = 1022;
        a.RGBM16Encoding = 3005;
        a.RGBM7Encoding = 3004;
        a.RGB_ETC1_Format = 36196;
        a.RGB_PVRTC_2BPPV1_Format = 35841;
        a.RGB_PVRTC_4BPPV1_Format = 35840;
        a.RGB_S3TC_DXT1_Format = 33776;
        a.RawShaderMaterial = Ki;
        a.Ray = N;
        a.Raycaster = Lg;
        a.RectAreaLight = oe;
        a.RectAreaLightHelper = Ti;
        a.RedFormat = 1028;
        a.ReinhardToneMapping = 2;
        a.RepeatWrapping = 1e3;
        a.ReplaceStencilOp = 7681;
        a.ReverseSubtractEquation = 102;
        a.RingBufferGeometry = Gi;
        a.RingGeometry = fd;
        a.Scene = r;
        a.SceneUtils = {
          createMultiMaterialObject: function() {
            console.error(
              "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
            );
          },
          detach: function() {
            console.error(
              "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
            );
          },
          attach: function() {
            console.error(
              "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
            );
          }
        };
        a.ShaderChunk = za;
        a.ShaderLib = we;
        a.ShaderMaterial = qa;
        a.ShadowMaterial = uh;
        a.Shape = eg;
        a.ShapeBufferGeometry = sh;
        a.ShapeGeometry = rh;
        a.ShapePath = tf;
        a.ShapeUtils = gf;
        a.ShortType = 1011;
        a.Skeleton = Wc;
        a.SkeletonHelper = Ri;
        a.SkinnedMesh = hc;
        a.SmoothShading = 2;
        a.Sphere = H;
        a.SphereBufferGeometry = dg;
        a.SphereGeometry = cd;
        a.Spherical = Og;
        a.SphericalHarmonics3 = Ne;
        a.SphericalReflectionMapping = 305;
        a.Spline = Wf;
        a.SplineCurve = Cd;
        a.SplineCurve3 = Sg;
        a.SpotLight = ie;
        a.SpotLightHelper = Qi;
        a.SpotLightShadow = he;
        a.Sprite = dc;
        a.SpriteMaterial = cg;
        a.SrcAlphaFactor = 204;
        a.SrcAlphaSaturateFactor = 210;
        a.SrcColorFactor = 202;
        a.StereoCamera = zg;
        a.StringKeyframeTrack = $d;
        a.SubtractEquation = 101;
        a.SubtractiveBlending = 3;
        a.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
        a.TangentSpaceNormalMap = 0;
        a.TetrahedronBufferGeometry = Sb;
        a.TetrahedronGeometry = sc;
        a.TextBufferGeometry = Fi;
        a.TextGeometry = ad;
        a.Texture = l;
        a.TextureLoader = ee;
        a.TorusBufferGeometry = Wb;
        a.TorusGeometry = Bc;
        a.TorusKnotBufferGeometry = Vb;
        a.TorusKnotGeometry = yc;
        a.Triangle = B;
        a.TriangleFanDrawMode = 2;
        a.TriangleStripDrawMode = 1;
        a.TrianglesDrawMode = 0;
        a.TubeBufferGeometry = oh;
        a.TubeGeometry = xc;
        a.UVMapping = 300;
        a.Uint16Attribute = function(a, b) {
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          );
          return new ca(a, b);
        };
        a.Uint16BufferAttribute = ca;
        a.Uint32Attribute = function(a, b) {
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          );
          return new fa(a, b);
        };
        a.Uint32BufferAttribute = fa;
        a.Uint8Attribute = function(a, b) {
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          );
          return new W(a, b);
        };
        a.Uint8BufferAttribute = W;
        a.Uint8ClampedAttribute = function(a, b) {
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          );
          return new T(a, b);
        };
        a.Uint8ClampedBufferAttribute = T;
        a.Uncharted2ToneMapping = 3;
        a.Uniform = Ue;
        a.UniformsLib = ia;
        a.UniformsUtils = vj;
        a.UnsignedByteType = 1009;
        a.UnsignedInt248Type = 1020;
        a.UnsignedIntType = 1014;
        a.UnsignedShort4444Type = 1017;
        a.UnsignedShort5551Type = 1018;
        a.UnsignedShort565Type = 1019;
        a.UnsignedShortType = 1012;
        a.VSMShadowMap = 3;
        a.Vector2 = c;
        a.Vector3 = h;
        a.Vector4 = m;
        a.VectorKeyframeTrack = Mi;
        a.Vertex = function(a, b, c) {
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          );
          return new h(a, b, c);
        };
        a.VertexColors = 2;
        a.VertexNormalsHelper = Xj;
        a.VideoTexture = Od;
        a.WebGLMultisampleRenderTarget = q;
        a.WebGLRenderTarget = n;
        a.WebGLRenderTargetCube = oa;
        a.WebGLRenderer = rd;
        a.WebGLUtils = Rd;
        a.WireframeGeometry = Pb;
        a.WireframeHelper = function(a, b) {
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          );
          return new Qa(
            new Pb(a.geometry),
            new Ga({ color: void 0 !== b ? b : 16777215 })
          );
        };
        a.WrapAroundEnding = 2402;
        a.XHRLoader = function(a) {
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
          return new Pc(a);
        };
        a.ZeroCurvatureEnding = 2400;
        a.ZeroFactor = 200;
        a.ZeroSlopeEnding = 2401;
        a.ZeroStencilOp = 0;
        a.sRGBEncoding = 3001;
        Object.defineProperty(a, "__esModule", { value: !0 });
      });
    }),
    wm = (function(a) {
      return a &&
        a.__esModule &&
        Object.prototype.hasOwnProperty.call(a, "default")
        ? a["default"]
        : a;
    })(vm);
  window.THREE && (wm = window.THREE);
  var ja = wm;
  Wk(Nd, {
    EARTHRADIUS: 6370996.81,
    MCBAND: [1.289059486e7, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
    LLBAND: [75, 60, 45, 30, 15, 0],
    MC2LL: [
      [
        1.410526172116255e-8,
        8.98305509648872e-6,
        -1.9939833816331,
        200.9824383106796,
        -187.2403703815547,
        91.6087516669843,
        -23.38765649603339,
        2.57121317296198,
        -0.03801003308653,
        1.73379812e7
      ],
      [
        -7.435856389565537e-9,
        8.983055097726239e-6,
        -0.78625201886289,
        96.32687599759846,
        -1.85204757529826,
        -59.36935905485877,
        47.40033549296737,
        -16.50741931063887,
        2.28786674699375,
        1.026014486e7
      ],
      [
        -3.030883460898826e-8,
        8.98305509983578e-6,
        0.30071316287616,
        59.74293618442277,
        7.357984074871,
        -25.38371002664745,
        13.45380521110908,
        -3.29883767235584,
        0.32710905363475,
        6856817.37
      ],
      [
        -1.981981304930552e-8,
        8.983055099779535e-6,
        0.03278182852591,
        40.31678527705744,
        0.65659298677277,
        -4.44255534477492,
        0.85341911805263,
        0.12923347998204,
        -0.04625736007561,
        4482777.06
      ],
      [
        3.09191371068437e-9,
        8.983055096812155e-6,
        6.995724062e-5,
        23.10934304144901,
        -2.3663490511e-4,
        -0.6321817810242,
        -0.00663494467273,
        0.03430082397953,
        -0.00466043876332,
        2555164.4
      ],
      [
        2.890871144776878e-9,
        8.983055095805407e-6,
        -3.068298e-8,
        7.47137025468032,
        -3.53937994e-6,
        -0.02145144861037,
        -1.234426596e-5,
        1.0322952773e-4,
        -3.23890364e-6,
        826088.5
      ]
    ],
    LL2MC: [
      [
        -0.0015702102444,
        111320.7020616939,
        0x60e374c3105a3,
        -0x24bb4115e2e164,
        0x5cc55543bb0ae8,
        -0x7ce070193f3784,
        0x5e7ca61ddf8150,
        -0x261a578d8b24d0,
        0x665d60f3742ca,
        82.5
      ],
      [
        8.277824516172526e-4,
        111320.7020463578,
        6.477955746671607e8,
        -4.082003173641316e9,
        1.077490566351142e10,
        -1.517187553151559e10,
        1.205306533862167e10,
        -5.124939663577472e9,
        9.133119359512032e8,
        67.5
      ],
      [
        0.00337398766765,
        111320.7020202162,
        4481351.045890365,
        -2.339375119931662e7,
        7.968221547186455e7,
        -1.159649932797253e8,
        9.723671115602145e7,
        -4.366194633752821e7,
        8477230.501135234,
        52.5
      ],
      [
        0.00220636496208,
        111320.7020209128,
        51751.86112841131,
        3796837.749470245,
        992013.7397791013,
        -1221952.21711287,
        1340652.697009075,
        -620943.6990984312,
        144416.9293806241,
        37.5
      ],
      [
        -3.441963504368392e-4,
        111320.7020576856,
        278.2353980772752,
        2485758.690035394,
        6070.750963243378,
        54821.18345352118,
        9540.606633304236,
        -2710.55326746645,
        1405.483844121726,
        22.5
      ],
      [
        -3.218135878613132e-4,
        111320.7020701615,
        0.00369383431289,
        823725.6402795718,
        0.46104986909093,
        2351.343141331292,
        1.58060784298199,
        8.77738589078284,
        0.37238884252424,
        7.45
      ]
    ],
    getDistanceByMC: function(a, b) {
      if (!a || !b) return 0;
      a = this.convertMC2LL(a);
      if (!a) return 0;
      var c = this.toRadians(a.lng);
      a = this.toRadians(a.lat);
      b = this.convertMC2LL(b);
      if (!b) return 0;
      var d = this.toRadians(b.lng);
      b = this.toRadians(b.lat);
      return this.getDistance(c, d, a, b);
    },
    getDistanceByLL: function(a, b) {
      if (!a || !b) return 0;
      a.lng = this.getLoop(a.lng, -180, 180);
      a.lat = this.getRange(a.lat, -74, 74);
      b.lng = this.getLoop(b.lng, -180, 180);
      b.lat = this.getRange(b.lat, -74, 74);
      var c = this.toRadians(a.lng);
      var d = this.toRadians(a.lat);
      a = this.toRadians(b.lng);
      b = this.toRadians(b.lat);
      return this.getDistance(c, a, d, b);
    },
    convertMC2LL: function(a) {
      if (null === a || void 0 === a) return new bd(0, 0);
      var b = new bd(Math.abs(a.lng), Math.abs(a.lat));
      for (var c = 0; c < this.MCBAND.length; c++)
        if (b.lat >= this.MCBAND[c]) {
          var d = this.MC2LL[c];
          break;
        }
      a = this.convertor(a, d);
      return (a = new bd(a.lng.toFixed(6), a.lat.toFixed(6)));
    },
    convertLL2MC: function(a) {
      if (null === a || void 0 === a) return new bd(0, 0);
      if (180 < a.lng || -180 > a.lng || 90 < a.lat || -90 > a.lat) return a;
      a.lng = this.getLoop(a.lng, -180, 180);
      a.lat = this.getRange(a.lat, -74, 74);
      var b = new bd(a.lng, a.lat);
      for (var c = 0; c < this.LLBAND.length; c++)
        if (b.lat >= this.LLBAND[c]) {
          var d = this.LL2MC[c];
          break;
        }
      if (!d)
        for (c = 0; c < this.LLBAND.length; c++)
          if (b.lat <= -this.LLBAND[c]) {
            d = this.LL2MC[c];
            break;
          }
      a = this.convertor(a, d);
      return (a = new bd(Number(a.lng.toFixed(2)), Number(a.lat.toFixed(2))));
    },
    convertor: function(a, b) {
      if (a && b) {
        var c = b[0] + b[1] * Math.abs(a.lng),
          d = Math.abs(a.lat) / b[9];
        b =
          b[2] +
          b[3] * d +
          b[4] * d * d +
          b[5] * d * d * d +
          b[6] * d * d * d * d +
          b[7] * d * d * d * d * d +
          b[8] * d * d * d * d * d * d;
        c *= 0 > a.lng ? -1 : 1;
        b *= 0 > a.lat ? -1 : 1;
        return new bd(c, b);
      }
    },
    getDistance: function(a, b, c, d) {
      return (
        this.EARTHRADIUS *
        Math.acos(
          Math.sin(c) * Math.sin(d) +
            Math.cos(c) * Math.cos(d) * Math.cos(b - a)
        )
      );
    },
    toRadians: function(a) {
      return (Math.PI * a) / 180;
    },
    toDegrees: function(a) {
      return (180 * a) / Math.PI;
    },
    getRange: function(a, b, c) {
      null != b && (a = Math.max(a, b));
      null != c && (a = Math.min(a, c));
      return a;
    },
    getLoop: function(a, b, c) {
      for (; a > c; ) a -= c - b;
      for (; a < b; ) a += c - b;
      return a;
    }
  });
  Wk(Nd.prototype, {
    lngLatToMercator: function(a) {
      return Nd.convertLL2MC(a);
    },
    lngLatToPoint: function(a) {
      a = Nd.convertLL2MC(a);
      return new Xk(a.lng, a.lat);
    },
    mercatorToLngLat: function(a) {
      return Nd.convertMC2LL(a);
    },
    pointToLngLat: function(a) {
      a = new bd(a.x, a.y);
      return Nd.convertMC2LL(a);
    },
    pointToPixel: function(a, b, c, d, e) {
      if (a)
        return (
          (a = this.lngLatToMercator(a, e)),
          (b = this.getZoomUnits(b)),
          new Xk(
            Math.round((a.lng - c.lng) / b + d.width / 2),
            Math.round((c.lat - a.lat) / b + d.height / 2)
          )
        );
    },
    pixelToPoint: function(a, b, c, d, e) {
      if (a)
        return (
          (b = this.getZoomUnits(b)),
          (a = new bd(
            c.lng + b * (a.x - d.width / 2),
            c.lat - b * (a.y - d.height / 2)
          )),
          this.mercatorToLngLat(a, e)
        );
    },
    getZoomUnits: function(a) {
      return Math.pow(2, 18 - a);
    }
  });
  var xm = (function() {
      function a(b) {
        ud(this, a);
        this.options = this.getDefaultOptions();
        this.autoUpdate = !1;
        Object.assign(this.options, b);
        this.options.data && (this.data = this.options.data);
      }
      Nc(a, [
        {
          key: "getDefaultOptions",
          value: function() {
            return {};
          }
        },
        { key: "initialize", value: function(a) {} },
        {
          key: "destroy",
          value: function() {
            this.onDestroy && this.onDestroy();
          }
        },
        { key: "render", value: function() {} },
        {
          key: "setData",
          value: function(a, c) {
            c = c || {};
            this.data = a;
            this.onDataChanged && this.onDataChanged(this.getData());
            this.onChanged && this.onChanged(this.getOptions(), this.getData());
            !1 !== c.autoRender && this.webglLayer && this.webglLayer.render();
          }
        },
        {
          key: "getData",
          value: function() {
            return this.data || [];
          }
        },
        {
          key: "setOptions",
          value: function(a) {
            a = a || {};
            Object.assign(this.options, a);
            this.onOptionsChanged && this.onOptionsChanged(this.getOptions());
            this.onChanged && this.onChanged(this.getOptions(), this.getData());
            a.data
              ? this.setData(a.data)
              : this.webglLayer && this.webglLayer.render();
          }
        },
        {
          key: "getOptions",
          value: function() {
            return this.options || {};
          }
        },
        { key: "onOptionsChanged", value: function(a) {} },
        { key: "onDataChanged", value: function(a) {} },
        { key: "onChanged", value: function(a, c) {} },
        { key: "onDestroy", value: function() {} },
        { key: "lnglatToMercator", value: function(a, c) {} },
        {
          key: "setWebglLayer",
          value: function(a) {
            this.webglLayer = a;
          }
        },
        {
          key: "getWebglLayer",
          value: function() {
            return this.webglLayer;
          }
        },
        {
          key: "isRequestAnimation",
          value: function() {
            return this.autoUpdate;
          }
        }
      ]);
      return a;
    })(),
    bc = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    },
    Ge = ad(function(a) {
      var b = Array.prototype.concat,
        c = Array.prototype.slice,
        d = (a.exports = function(a) {
          for (var d = [], e = 0, k = a.length; e < k; e++) {
            var l = a[e];
            var m =
              (m = l) && "string" !== typeof m
                ? m instanceof Array ||
                  Array.isArray(m) ||
                  (0 <= m.length &&
                    (m.splice instanceof Function ||
                      (Object.getOwnPropertyDescriptor(m, m.length - 1) &&
                        "String" !== m.constructor.name)))
                : !1;
            m ? (d = b.call(d, c.call(l))) : d.push(l);
          }
          return d;
        });
      d.wrap = function(a) {
        return function() {
          return a(d(arguments));
        };
      };
    }),
    cd = ad(function(a) {
      function b(a, b, c) {
        return Math.min(Math.max(b, a), c);
      }
      function c(a) {
        a = a.toString(16).toUpperCase();
        return 2 > a.length ? "0" + a : a;
      }
      var d = {},
        e;
      for (e in bc) bc.hasOwnProperty(e) && (d[bc[e]] = e);
      var f = (a.exports = { to: {}, get: {} });
      f.get = function(a) {
        switch (a.substring(0, 3).toLowerCase()) {
          case "hsl":
            a = f.get.hsl(a);
            var b = "hsl";
            break;
          case "hwb":
            a = f.get.hwb(a);
            b = "hwb";
            break;
          default:
            (a = f.get.rgb(a)), (b = "rgb");
        }
        return a ? { model: b, value: a } : null;
      };
      f.get.rgb = function(a) {
        if (!a) return null;
        var c = /^#([a-f0-9]{3,4})$/i,
          d = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
          e = /^rgba?\(\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
          f = /(\D+)/,
          h = [0, 0, 0, 1],
          t;
        if ((t = a.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i))) {
          c = t[2];
          t = t[1];
          for (a = 0; 3 > a; a++)
            (d = 2 * a), (h[a] = parseInt(t.slice(d, d + 2), 16));
          c && (h[3] = Math.round((parseInt(c, 16) / 255) * 100) / 100);
        } else if ((t = a.match(c))) {
          t = t[1];
          c = t[3];
          for (a = 0; 3 > a; a++) h[a] = parseInt(t[a] + t[a], 16);
          c && (h[3] = Math.round((parseInt(c + c, 16) / 255) * 100) / 100);
        } else if ((t = a.match(d))) {
          for (a = 0; 3 > a; a++) h[a] = parseInt(t[a + 1], 0);
          t[4] && (h[3] = parseFloat(t[4]));
        } else if ((t = a.match(e))) {
          for (a = 0; 3 > a; a++)
            h[a] = Math.round(2.55 * parseFloat(t[a + 1]));
          t[4] && (h[3] = parseFloat(t[4]));
        } else {
          if ((t = a.match(f))) {
            if ("transparent" === t[1]) return [0, 0, 0, 0];
            h = bc[t[1]];
            if (!h) return null;
            h[3] = 1;
            return h;
          }
          return null;
        }
        for (a = 0; 3 > a; a++) h[a] = b(h[a], 0, 255);
        h[3] = b(h[3], 0, 1);
        return h;
      };
      f.get.hsl = function(a) {
        if (!a) return null;
        var c = a.match(
          /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
        );
        if (c) {
          var d = parseFloat(c[4]);
          a = (parseFloat(c[1]) + 360) % 360;
          var e = b(parseFloat(c[2]), 0, 100);
          c = b(parseFloat(c[3]), 0, 100);
          d = b(isNaN(d) ? 1 : d, 0, 1);
          return [a, e, c, d];
        }
        return null;
      };
      f.get.hwb = function(a) {
        if (!a) return null;
        var c = a.match(
          /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
        );
        if (c) {
          var d = parseFloat(c[4]);
          a = ((parseFloat(c[1]) % 360) + 360) % 360;
          var e = b(parseFloat(c[2]), 0, 100);
          c = b(parseFloat(c[3]), 0, 100);
          d = b(isNaN(d) ? 1 : d, 0, 1);
          return [a, e, c, d];
        }
        return null;
      };
      f.to.hex = function() {
        var a = Ge(arguments);
        return (
          "#" +
          c(a[0]) +
          c(a[1]) +
          c(a[2]) +
          (1 > a[3] ? c(Math.round(255 * a[3])) : "")
        );
      };
      f.to.rgb = function() {
        var a = Ge(arguments);
        return 4 > a.length || 1 === a[3]
          ? "rgb(" +
              Math.round(a[0]) +
              ", " +
              Math.round(a[1]) +
              ", " +
              Math.round(a[2]) +
              ")"
          : "rgba(" +
              Math.round(a[0]) +
              ", " +
              Math.round(a[1]) +
              ", " +
              Math.round(a[2]) +
              ", " +
              a[3] +
              ")";
      };
      f.to.rgb.percent = function() {
        var a = Ge(arguments),
          b = Math.round((a[0] / 255) * 100),
          c = Math.round((a[1] / 255) * 100),
          d = Math.round((a[2] / 255) * 100);
        return 4 > a.length || 1 === a[3]
          ? "rgb(" + b + "%, " + c + "%, " + d + "%)"
          : "rgba(" + b + "%, " + c + "%, " + d + "%, " + a[3] + ")";
      };
      f.to.hsl = function() {
        var a = Ge(arguments);
        return 4 > a.length || 1 === a[3]
          ? "hsl(" + a[0] + ", " + a[1] + "%, " + a[2] + "%)"
          : "hsla(" + a[0] + ", " + a[1] + "%, " + a[2] + "%, " + a[3] + ")";
      };
      f.to.hwb = function() {
        var a = Ge(arguments),
          b = "";
        4 <= a.length && 1 !== a[3] && (b = ", " + a[3]);
        return "hwb(" + a[0] + ", " + a[1] + "%, " + a[2] + "%" + b + ")";
      };
      f.to.keyword = function(a) {
        return d[a.slice(0, 3)];
      };
    }),
    cc = ad(function(a) {
      var b = {};
      for (e in bc) bc.hasOwnProperty(e) && (b[bc[e]] = e);
      var c = (a.exports = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] }
        }),
        d;
      for (d in c)
        if (c.hasOwnProperty(d)) {
          if (!("channels" in c[d]))
            throw Error("missing channels property: " + d);
          if (!("labels" in c[d]))
            throw Error("missing channel labels property: " + d);
          if (c[d].labels.length !== c[d].channels)
            throw Error("channel and label counts mismatch: " + d);
          a = c[d].channels;
          var e = c[d].labels;
          delete c[d].channels;
          delete c[d].labels;
          Object.defineProperty(c[d], "channels", { value: a });
          Object.defineProperty(c[d], "labels", { value: e });
        }
      c.rgb.hsl = function(a) {
        var b = a[0] / 255,
          c = a[1] / 255,
          d = a[2] / 255;
        a = Math.min(b, c, d);
        var e = Math.max(b, c, d),
          f = e - a,
          q;
        e === a
          ? (q = 0)
          : b === e
          ? (q = (c - d) / f)
          : c === e
          ? (q = 2 + (d - b) / f)
          : d === e && (q = 4 + (b - c) / f);
        q = Math.min(60 * q, 360);
        0 > q && (q += 360);
        b = (a + e) / 2;
        return [
          q,
          100 * (e === a ? 0 : 0.5 >= b ? f / (e + a) : f / (2 - e - a)),
          100 * b
        ];
      };
      c.rgb.hsv = function(a) {
        var b,
          c = a[0] / 255,
          d = a[1] / 255,
          e = a[2] / 255,
          f = Math.max(c, d, e);
        var q = f - Math.min(c, d, e);
        if (0 === q) var t = (b = 0);
        else {
          b = q / f;
          a = (f - c) / 6 / q + 0.5;
          var r = (f - d) / 6 / q + 0.5;
          q = (f - e) / 6 / q + 0.5;
          c === f
            ? (t = q - r)
            : d === f
            ? (t = 1 / 3 + a - q)
            : e === f && (t = 2 / 3 + r - a);
          0 > t ? (t += 1) : 1 < t && --t;
        }
        return [360 * t, 100 * b, 100 * f];
      };
      c.rgb.hwb = function(a) {
        var b = a[0],
          d = a[1],
          e = a[2];
        a = c.rgb.hsl(a)[0];
        var f = (1 / 255) * Math.min(b, Math.min(d, e));
        e = 1 - (1 / 255) * Math.max(b, Math.max(d, e));
        return [a, 100 * f, 100 * e];
      };
      c.rgb.cmyk = function(a) {
        var b = a[0] / 255,
          c = a[1] / 255;
        a = a[2] / 255;
        var d = Math.min(1 - b, 1 - c, 1 - a);
        return [
          100 * ((1 - b - d) / (1 - d) || 0),
          100 * ((1 - c - d) / (1 - d) || 0),
          100 * ((1 - a - d) / (1 - d) || 0),
          100 * d
        ];
      };
      c.rgb.keyword = function(a) {
        var c = b[a];
        if (c) return c;
        c = Infinity;
        var d;
        for (d in bc)
          if (bc.hasOwnProperty(d)) {
            var e = bc[d];
            e =
              Math.pow(a[0] - e[0], 2) +
              Math.pow(a[1] - e[1], 2) +
              Math.pow(a[2] - e[2], 2);
            if (e < c) {
              c = e;
              var f = d;
            }
          }
        return f;
      };
      c.keyword.rgb = function(a) {
        return bc[a];
      };
      c.rgb.xyz = function(a) {
        var b = a[0] / 255,
          c = a[1] / 255;
        a = a[2] / 255;
        b = 0.04045 < b ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        c = 0.04045 < c ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
        a = 0.04045 < a ? Math.pow((a + 0.055) / 1.055, 2.4) : a / 12.92;
        return [
          100 * (0.4124 * b + 0.3576 * c + 0.1805 * a),
          100 * (0.2126 * b + 0.7152 * c + 0.0722 * a),
          100 * (0.0193 * b + 0.1192 * c + 0.9505 * a)
        ];
      };
      c.rgb.lab = function(a) {
        var b = c.rgb.xyz(a);
        a = b[0];
        var d = b[1];
        b = b[2];
        a /= 95.047;
        d /= 100;
        b /= 108.883;
        a = 0.008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116;
        d = 0.008856 < d ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116;
        b = 0.008856 < b ? Math.pow(b, 1 / 3) : 7.787 * b + 16 / 116;
        return [116 * d - 16, 500 * (a - d), 200 * (d - b)];
      };
      c.hsl.rgb = function(a) {
        var b = a[0] / 360,
          c = a[1] / 100;
        a = a[2] / 100;
        if (0 === c) {
          var d = 255 * a;
          return [d, d, d];
        }
        c = 0.5 > a ? a * (1 + c) : a + c - a * c;
        a = 2 * a - c;
        var e = [0, 0, 0];
        for (var f = 0; 3 > f; f++)
          (d = b + (1 / 3) * -(f - 1)),
            0 > d && d++,
            1 < d && d--,
            (d =
              1 > 6 * d
                ? a + 6 * (c - a) * d
                : 1 > 2 * d
                ? c
                : 2 > 3 * d
                ? a + (c - a) * (2 / 3 - d) * 6
                : a),
            (e[f] = 255 * d);
        return e;
      };
      c.hsl.hsv = function(a) {
        var b = a[0],
          c = a[1] / 100;
        a = a[2] / 100;
        var d = c,
          e = Math.max(a, 0.01);
        a *= 2;
        c *= 1 >= a ? a : 2 - a;
        d *= 1 >= e ? e : 2 - e;
        return [
          b,
          100 * (0 === a ? (2 * d) / (e + d) : (2 * c) / (a + c)),
          ((a + c) / 2) * 100
        ];
      };
      c.hsv.rgb = function(a) {
        var b = a[0] / 60,
          c = a[1] / 100;
        a = a[2] / 100;
        var d = Math.floor(b) % 6,
          e = b - Math.floor(b);
        b = 255 * a * (1 - c);
        var f = 255 * a * (1 - c * e);
        c = 255 * a * (1 - c * (1 - e));
        a *= 255;
        switch (d) {
          case 0:
            return [a, c, b];
          case 1:
            return [f, a, b];
          case 2:
            return [b, a, c];
          case 3:
            return [b, f, a];
          case 4:
            return [c, b, a];
          case 5:
            return [a, b, f];
        }
      };
      c.hsv.hsl = function(a) {
        var b = a[0],
          c = a[1] / 100;
        a = a[2] / 100;
        var d = Math.max(a, 0.01);
        var e = (2 - c) * d;
        d = (c * d) / (1 >= e ? e : 2 - e) || 0;
        return [b, 100 * d, (((2 - c) * a) / 2) * 100];
      };
      c.hwb.rgb = function(a) {
        var b = a[0] / 360,
          c = a[1] / 100;
        a = a[2] / 100;
        var d = c + a;
        1 < d && ((c /= d), (a /= d));
        d = Math.floor(6 * b);
        a = 1 - a;
        b = 6 * b - d;
        0 !== (d & 1) && (b = 1 - b);
        b = c + b * (a - c);
        switch (d) {
          default:
          case 6:
          case 0:
            d = a;
            var e = b;
            break;
          case 1:
            d = b;
            e = a;
            break;
          case 2:
            d = c;
            e = a;
            c = b;
            break;
          case 3:
            d = c;
            e = b;
            c = a;
            break;
          case 4:
            d = b;
            e = c;
            c = a;
            break;
          case 5:
            (d = a), (e = c), (c = b);
        }
        return [255 * d, 255 * e, 255 * c];
      };
      c.cmyk.rgb = function(a) {
        var b = a[3] / 100;
        return [
          255 * (1 - Math.min(1, (a[0] / 100) * (1 - b) + b)),
          255 * (1 - Math.min(1, (a[1] / 100) * (1 - b) + b)),
          255 * (1 - Math.min(1, (a[2] / 100) * (1 - b) + b))
        ];
      };
      c.xyz.rgb = function(a) {
        var b = a[0] / 100,
          c = a[1] / 100,
          d = a[2] / 100;
        a = 3.2406 * b + -1.5372 * c + -0.4986 * d;
        var e = -0.9689 * b + 1.8758 * c + 0.0415 * d;
        b = 0.0557 * b + -0.204 * c + 1.057 * d;
        a = 0.0031308 < a ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : 12.92 * a;
        e = 0.0031308 < e ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055 : 12.92 * e;
        b = 0.0031308 < b ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
        a = Math.min(Math.max(0, a), 1);
        e = Math.min(Math.max(0, e), 1);
        b = Math.min(Math.max(0, b), 1);
        return [255 * a, 255 * e, 255 * b];
      };
      c.xyz.lab = function(a) {
        var b = a[0],
          c = a[1];
        a = a[2];
        b /= 95.047;
        c /= 100;
        a /= 108.883;
        b = 0.008856 < b ? Math.pow(b, 1 / 3) : 7.787 * b + 16 / 116;
        c = 0.008856 < c ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116;
        a = 0.008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116;
        return [116 * c - 16, 500 * (b - c), 200 * (c - a)];
      };
      c.lab.xyz = function(a) {
        var b = a[1],
          c = a[2];
        a = (a[0] + 16) / 116;
        b = b / 500 + a;
        c = a - c / 200;
        var d = Math.pow(a, 3),
          e = Math.pow(b, 3),
          f = Math.pow(c, 3);
        return [
          95.047 * (0.008856 < e ? e : (b - 16 / 116) / 7.787),
          100 * (0.008856 < d ? d : (a - 16 / 116) / 7.787),
          108.883 * (0.008856 < f ? f : (c - 16 / 116) / 7.787)
        ];
      };
      c.lab.lch = function(a) {
        var b = a[0],
          c = a[1];
        a = a[2];
        var d = (360 * Math.atan2(a, c)) / 2 / Math.PI;
        0 > d && (d += 360);
        return [b, Math.sqrt(c * c + a * a), d];
      };
      c.lch.lab = function(a) {
        var b = a[0],
          c = a[1];
        a = (a[2] / 360) * 2 * Math.PI;
        return [b, c * Math.cos(a), c * Math.sin(a)];
      };
      c.rgb.ansi16 = function(a) {
        var b = a[0],
          d = a[1],
          e = a[2],
          f = 1 in arguments ? arguments[1] : c.rgb.hsv(a)[2];
        f = Math.round(f / 50);
        if (0 === f) return 30;
        b =
          30 +
          ((Math.round(e / 255) << 2) |
            (Math.round(d / 255) << 1) |
            Math.round(b / 255));
        2 === f && (b += 60);
        return b;
      };
      c.hsv.ansi16 = function(a) {
        return c.rgb.ansi16(c.hsv.rgb(a), a[2]);
      };
      c.rgb.ansi256 = function(a) {
        var b = a[0],
          c = a[1];
        a = a[2];
        return b === c && c === a
          ? 8 > b
            ? 16
            : 248 < b
            ? 231
            : Math.round(((b - 8) / 247) * 24) + 232
          : 16 +
              36 * Math.round((b / 255) * 5) +
              6 * Math.round((c / 255) * 5) +
              Math.round((a / 255) * 5);
      };
      c.ansi16.rgb = function(a) {
        var b = a % 10;
        if (0 === b || 7 === b)
          return 50 < a && (b += 3.5), (b = (b / 10.5) * 255), [b, b, b];
        a = 0.5 * (~~(50 < a) + 1);
        return [
          (b & 1) * a * 255,
          ((b >> 1) & 1) * a * 255,
          ((b >> 2) & 1) * a * 255
        ];
      };
      c.ansi256.rgb = function(a) {
        if (232 <= a) {
          var b = 10 * (a - 232) + 8;
          return [b, b, b];
        }
        a -= 16;
        b = (Math.floor(a / 36) / 5) * 255;
        var c = (Math.floor((a %= 36) / 6) / 5) * 255;
        return [b, c, ((a % 6) / 5) * 255];
      };
      c.rgb.hex = function(a) {
        a = (
          ((Math.round(a[0]) & 255) << 16) +
          ((Math.round(a[1]) & 255) << 8) +
          (Math.round(a[2]) & 255)
        )
          .toString(16)
          .toUpperCase();
        return "000000".substring(a.length) + a;
      };
      c.hex.rgb = function(a) {
        a = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!a) return [0, 0, 0];
        var b = a[0];
        3 === a[0].length &&
          (b = b
            .split("")
            .map(function(a) {
              return a + a;
            })
            .join(""));
        a = parseInt(b, 16);
        return [(a >> 16) & 255, (a >> 8) & 255, a & 255];
      };
      c.rgb.hcg = function(a) {
        var b = a[0] / 255,
          c = a[1] / 255;
        a = a[2] / 255;
        var d = Math.max(Math.max(b, c), a),
          e = Math.min(Math.min(b, c), a),
          f = d - e;
        return [
          (((0 >= f
            ? 0
            : d === b
            ? ((c - a) / f) % 6
            : d === c
            ? 2 + (a - b) / f
            : (b - c) / f + 8) /
            6) %
            1) *
            360,
          100 * f,
          100 * (1 > f ? e / (1 - f) : 0)
        ];
      };
      c.hsl.hcg = function(a) {
        var b = a[1] / 100,
          c = a[2] / 100,
          d = 0;
        b = 0.5 > c ? 2 * b * c : 2 * b * (1 - c);
        1 > b && (d = (c - 0.5 * b) / (1 - b));
        return [a[0], 100 * b, 100 * d];
      };
      c.hsv.hcg = function(a) {
        var b = a[2] / 100,
          c = (a[1] / 100) * b,
          d = 0;
        1 > c && (d = (b - c) / (1 - c));
        return [a[0], 100 * c, 100 * d];
      };
      c.hcg.rgb = function(a) {
        var b = a[1] / 100,
          c = a[2] / 100;
        if (0 === b) return [255 * c, 255 * c, 255 * c];
        var d = [0, 0, 0];
        a = ((a[0] / 360) % 1) * 6;
        var e = a % 1,
          f = 1 - e;
        switch (Math.floor(a)) {
          case 0:
            d[0] = 1;
            d[1] = e;
            d[2] = 0;
            break;
          case 1:
            d[0] = f;
            d[1] = 1;
            d[2] = 0;
            break;
          case 2:
            d[0] = 0;
            d[1] = 1;
            d[2] = e;
            break;
          case 3:
            d[0] = 0;
            d[1] = f;
            d[2] = 1;
            break;
          case 4:
            d[0] = e;
            d[1] = 0;
            d[2] = 1;
            break;
          default:
            (d[0] = 1), (d[1] = 0), (d[2] = f);
        }
        c *= 1 - b;
        return [
          255 * (b * d[0] + c),
          255 * (b * d[1] + c),
          255 * (b * d[2] + c)
        ];
      };
      c.hcg.hsv = function(a) {
        var b = a[1] / 100,
          c = b + (a[2] / 100) * (1 - b),
          d = 0;
        0 < c && (d = b / c);
        return [a[0], 100 * d, 100 * c];
      };
      c.hcg.hsl = function(a) {
        var b = a[1] / 100,
          c = (a[2] / 100) * (1 - b) + 0.5 * b,
          d = 0;
        0 < c && 0.5 > c
          ? (d = b / (2 * c))
          : 0.5 <= c && 1 > c && (d = b / (2 * (1 - c)));
        return [a[0], 100 * d, 100 * c];
      };
      c.hcg.hwb = function(a) {
        var b = a[1] / 100,
          c = b + (a[2] / 100) * (1 - b);
        return [a[0], 100 * (c - b), 100 * (1 - c)];
      };
      c.hwb.hcg = function(a) {
        var b = 1 - a[2] / 100,
          c = b - a[1] / 100,
          d = 0;
        1 > c && (d = (b - c) / (1 - c));
        return [a[0], 100 * c, 100 * d];
      };
      c.apple.rgb = function(a) {
        return [
          (a[0] / 65535) * 255,
          (a[1] / 65535) * 255,
          (a[2] / 65535) * 255
        ];
      };
      c.rgb.apple = function(a) {
        return [
          (a[0] / 255) * 65535,
          (a[1] / 255) * 65535,
          (a[2] / 255) * 65535
        ];
      };
      c.gray.rgb = function(a) {
        return [(a[0] / 100) * 255, (a[0] / 100) * 255, (a[0] / 100) * 255];
      };
      c.gray.hsl = c.gray.hsv = function(a) {
        return [0, 0, a[0]];
      };
      c.gray.hwb = function(a) {
        return [0, 100, a[0]];
      };
      c.gray.cmyk = function(a) {
        return [0, 0, 0, a[0]];
      };
      c.gray.lab = function(a) {
        return [a[0], 0, 0];
      };
      c.gray.hex = function(a) {
        a = Math.round((a[0] / 100) * 255) & 255;
        a = ((a << 16) + (a << 8) + a).toString(16).toUpperCase();
        return "000000".substring(a.length) + a;
      };
      c.rgb.gray = function(a) {
        return [((a[0] + a[1] + a[2]) / 3 / 255) * 100];
      };
    }),
    So = function(a) {
      for (var b = {}, c = Object.keys(cc), d = c.length, e = 0; e < d; e++)
        b[c[e]] = { distance: -1, parent: null };
      c = [a];
      for (b[a].distance = 0; c.length; ) {
        a = c.pop();
        d = Object.keys(cc[a]);
        e = d.length;
        for (var f = 0; f < e; f++) {
          var h = d[f],
            k = b[h];
          -1 === k.distance &&
            ((k.distance = b[a].distance + 1), (k.parent = a), c.unshift(h));
        }
      }
      c = {};
      a = Object.keys(b);
      d = a.length;
      for (e = 0; e < d; e++) {
        var l = a[e];
        if (null !== b[l].parent) {
          f = l;
          h = b;
          k = [h[l].parent, l];
          var m = cc[h[l].parent][l];
          for (l = h[l].parent; h[l].parent; )
            k.unshift(h[l].parent),
              (m = jn(cc[h[l].parent][l], m)),
              (l = h[l].parent);
          m.conversion = k;
          c[f] = m;
        }
      }
      return c;
    },
    lg = {};
  Object.keys(cc).forEach(function(a) {
    lg[a] = {};
    Object.defineProperty(lg[a], "channels", { value: cc[a].channels });
    Object.defineProperty(lg[a], "labels", { value: cc[a].labels });
    var b = So(a);
    Object.keys(b).forEach(function(c) {
      var d = b[c];
      lg[a][c] = ln(d);
      lg[a][c].raw = kn(d);
    });
  });
  var ub = lg,
    uj = [].slice,
    Yk = ["keyword", "gray", "hex"],
    Dg = {};
  Object.keys(ub).forEach(function(a) {
    Dg[
      uj
        .call(ub[a].labels)
        .sort()
        .join("")
    ] = a;
  });
  var Jf = {};
  cb.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(a) {
      var b = this.model in cd.to ? this : this.rgb();
      b = b.round("number" === typeof a ? a : 1);
      a = 1 === b.valpha ? b.color : b.color.concat(this.valpha);
      return cd.to[b.model](a);
    },
    percentString: function(a) {
      a = this.rgb().round("number" === typeof a ? a : 1);
      a = 1 === a.valpha ? a.color : a.color.concat(this.valpha);
      return cd.to.rgb.percent(a);
    },
    array: function() {
      return 1 === this.valpha
        ? this.color.slice()
        : this.color.concat(this.valpha);
    },
    object: function() {
      for (
        var a = {},
          b = ub[this.model].channels,
          c = ub[this.model].labels,
          d = 0;
        d < b;
        d++
      )
        a[c[d]] = this.color[d];
      1 !== this.valpha && (a.alpha = this.valpha);
      return a;
    },
    unitArray: function() {
      var a = this.rgb().color;
      a[0] /= 255;
      a[1] /= 255;
      a[2] /= 255;
      1 !== this.valpha && a.push(this.valpha);
      return a;
    },
    unitObject: function() {
      var a = this.rgb().object();
      a.r /= 255;
      a.g /= 255;
      a.b /= 255;
      1 !== this.valpha && (a.alpha = this.valpha);
      return a;
    },
    round: function(a) {
      a = Math.max(a || 0, 0);
      return new cb(this.color.map(mn(a)).concat(this.valpha), this.model);
    },
    alpha: function(a) {
      return arguments.length
        ? new cb(this.color.concat(Math.max(0, Math.min(1, a))), this.model)
        : this.valpha;
    },
    red: Ba("rgb", 0, ta(255)),
    green: Ba("rgb", 1, ta(255)),
    blue: Ba("rgb", 2, ta(255)),
    hue: Ba(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(a) {
      return ((a % 360) + 360) % 360;
    }),
    saturationl: Ba("hsl", 1, ta(100)),
    lightness: Ba("hsl", 2, ta(100)),
    saturationv: Ba("hsv", 1, ta(100)),
    value: Ba("hsv", 2, ta(100)),
    chroma: Ba("hcg", 1, ta(100)),
    gray: Ba("hcg", 2, ta(100)),
    white: Ba("hwb", 1, ta(100)),
    wblack: Ba("hwb", 2, ta(100)),
    cyan: Ba("cmyk", 0, ta(100)),
    magenta: Ba("cmyk", 1, ta(100)),
    yellow: Ba("cmyk", 2, ta(100)),
    black: Ba("cmyk", 3, ta(100)),
    x: Ba("xyz", 0, ta(100)),
    y: Ba("xyz", 1, ta(100)),
    z: Ba("xyz", 2, ta(100)),
    l: Ba("lab", 0, ta(100)),
    a: Ba("lab", 1),
    b: Ba("lab", 2),
    keyword: function(a) {
      return arguments.length ? new cb(a) : ub[this.model].keyword(this.color);
    },
    hex: function(a) {
      return arguments.length ? new cb(a) : cd.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var a = this.rgb().color;
      return ((a[0] & 255) << 16) | ((a[1] & 255) << 8) | (a[2] & 255);
    },
    luminosity: function() {
      for (var a = this.rgb().color, b = [], c = 0; c < a.length; c++) {
        var d = a[c] / 255;
        b[c] = 0.03928 >= d ? d / 12.92 : Math.pow((d + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * b[0] + 0.7152 * b[1] + 0.0722 * b[2];
    },
    contrast: function(a) {
      var b = this.luminosity();
      a = a.luminosity();
      return b > a ? (b + 0.05) / (a + 0.05) : (a + 0.05) / (b + 0.05);
    },
    level: function(a) {
      a = this.contrast(a);
      return 7.1 <= a ? "AAA" : 4.5 <= a ? "AA" : "";
    },
    isDark: function() {
      var a = this.rgb().color;
      return 128 > (299 * a[0] + 587 * a[1] + 114 * a[2]) / 1e3;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      for (var a = this.rgb(), b = 0; 3 > b; b++) a.color[b] = 255 - a.color[b];
      return a;
    },
    lighten: function(a) {
      var b = this.hsl();
      b.color[2] += b.color[2] * a;
      return b;
    },
    darken: function(a) {
      var b = this.hsl();
      b.color[2] -= b.color[2] * a;
      return b;
    },
    saturate: function(a) {
      var b = this.hsl();
      b.color[1] += b.color[1] * a;
      return b;
    },
    desaturate: function(a) {
      var b = this.hsl();
      b.color[1] -= b.color[1] * a;
      return b;
    },
    whiten: function(a) {
      var b = this.hwb();
      b.color[1] += b.color[1] * a;
      return b;
    },
    blacken: function(a) {
      var b = this.hwb();
      b.color[2] += b.color[2] * a;
      return b;
    },
    grayscale: function() {
      var a = this.rgb().color;
      a = 0.3 * a[0] + 0.59 * a[1] + 0.11 * a[2];
      return cb.rgb(a, a, a);
    },
    fade: function(a) {
      return this.alpha(this.valpha - this.valpha * a);
    },
    opaquer: function(a) {
      return this.alpha(this.valpha + this.valpha * a);
    },
    rotate: function(a) {
      var b = this.hsl(),
        c = b.color[0];
      c = (c + a) % 360;
      b.color[0] = 0 > c ? 360 + c : c;
      return b;
    },
    mix: function(a, b) {
      if (!a || !a.rgb)
        throw Error(
          'Argument to "mix" was not a Color instance, but rather an instance of ' +
            ("undefined" === typeof a ? "undefined" : nk(a))
        );
      a = a.rgb();
      var c = this.rgb();
      b = void 0 === b ? 0.5 : b;
      var d = 2 * b - 1,
        e = a.alpha() - c.alpha();
      d = ((-1 === d * e ? d : (d + e) / (1 + d * e)) + 1) / 2;
      e = 1 - d;
      return cb.rgb(
        d * a.red() + e * c.red(),
        d * a.green() + e * c.green(),
        d * a.blue() + e * c.blue(),
        a.alpha() * b + c.alpha() * (1 - b)
      );
    }
  };
  Object.keys(ub).forEach(function(a) {
    if (-1 === Yk.indexOf(a)) {
      var b = ub[a].channels;
      cb.prototype[a] = function() {
        if (this.model === a) return new cb(this);
        if (arguments.length) return new cb(arguments, a);
        var c = "number" === typeof arguments[b] ? b : this.valpha;
        var d = ub[this.model][a].raw(this.color);
        d = Array.isArray(d) ? d : [d];
        return new cb(d.concat(c), a);
      };
      cb[a] = function(c) {
        "number" === typeof c && (c = Cg(uj.call(arguments), b));
        return new cb(c, a);
      };
    }
  });
  var ym = (function(a) {
      function b(a) {
        ud(this, b);
        a = ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this, a));
        a.layerType = "ThreeLayer";
        return a;
      }
      ue(b, a);
      Nc(b, [
        {
          key: "initialize",
          value: function(a) {
            this.getOptions();
            var b = this.webglLayer.map.map;
            "three" === this.webglLayer.map.type
              ? ((this.camera = b.camera), (this.scene = b.scene))
              : ((this.camera = new ja.Camera()),
                (this.scene = new ja.Scene()));
            this.world = new ja.Group();
            this.scene.add(this.world);
            "three" !== this.webglLayer.map.type &&
              ((this.camera.matrixAutoUpdate = !1),
              (this.world.matrixAutoUpdate = !1),
              (this.renderer = new ja.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: a.canvas,
                context: a
              })),
              (this.renderer.autoClear = !1));
          }
        },
        {
          key: "add",
          value: function(a, b) {
            var c = this.getOptions();
            this.scene.add(a);
            var d = [0, 0];
            !0 === c.enabledPointOffset && (d = this.getPointOffset());
            b
              ? ((c = new ja.Group()),
                (c.isGeoGroup = !0),
                (c.object = a),
                (c.point = b),
                c.add(a),
                (c.position.x = b.lng - d[0]),
                (c.position.y = b.lat - d[1]),
                (c.position.z = a.position.z),
                this.world.add(c))
              : this.world.add(a);
            this.update();
          }
        },
        {
          key: "update",
          value: function() {
            this.webglLayer.render();
          }
        },
        {
          key: "getCamera",
          value: function() {
            return this.camera;
          }
        },
        {
          key: "getScene",
          value: function() {
            return this.scene;
          }
        },
        {
          key: "getRenderer",
          value: function() {
            return this.renderer;
          }
        },
        {
          key: "getWorld",
          value: function() {
            return this.world;
          }
        },
        {
          key: "updatePoint",
          value: function(a, b) {
            for (var c = this.world.children, d = 0; d < c.length; d++)
              if (c[d].isGeoGroup && c[d].object === a) {
                var h = c[d];
                h.position.x = b.lng;
                h.position.y = b.lat;
                h.position.z = a.position.z;
              }
          }
        },
        {
          key: "remove",
          value: function(a) {
            this.world.remove(a);
            for (var b = this.world.children, c = 0; c < b.length; c++)
              b[c].children &&
                0 < b[c].children.length &&
                b[c].children[0] === a &&
                this.world.remove(b[c]);
            this.update();
          }
        },
        {
          key: "updateCamera",
          value: function() {
            var a = this.world,
              b = this.map.getZoomUnits();
            a = a.children;
            for (var e = 0; e < a.length; e++)
              a[e].point && a[e].scale.set(b, b, b);
          }
        },
        {
          key: "render",
          value: function(a) {
            var b = this.getOptions();
            if (a) {
              if (!this.webglLayer.map.map.camera) {
                this.updateCamera();
                var c = this.getPointOffset(),
                  f = new ja.Matrix4().fromArray(a.viewMatrix);
                this.camera.projectionMatrix = new ja.Matrix4().fromArray(
                  a.projectionMatrix
                );
                !0 === b.enabledPointOffset
                  ? (this.world.matrix = f)
                  : ((a = new ja.Matrix4().makeTranslation(-c[0], -c[1], 0)),
                    (this.world.matrix = f.multiply(a)));
                this.renderer.state.reset();
                this.postProcessing
                  ? this.postProcessing.render()
                  : this.renderer.render(this.scene, this.camera);
              }
            } else this.update();
          }
        }
      ]);
      return b;
    })(
      (function(a) {
        function b(a) {
          ud(this, b);
          return ve(
            this,
            (b.__proto__ || Object.getPrototypeOf(b)).call(this, a)
          );
        }
        ue(b, a);
        Nc(b, [
          {
            key: "normizedColor",
            value: function(a) {
              var b = a;
              a instanceof Array || (b = cb(a).unitArray());
              void 0 === b[3] && (b[3] = 1);
              return b;
            }
          },
          {
            key: "normizedPoint",
            value: function(a) {
              if (!a || !a[0] || !a[1]) return [0, 0, 0];
              var b = [0, 0],
                c = this.getOptions();
              this.webglLayer && this.webglLayer.options.pointOffset
                ? (b = this.webglLayer.options.pointOffset)
                : c.pointOffset && (b = c.pointOffset);
              c = Number(a[0]);
              var f = Number(a[1]);
              -180 <= c &&
                180 >= c &&
                -90 <= f &&
                90 >= f &&
                ((f = this.webglLayer.map.lnglatToMercator(c, f)),
                (c = f[0]),
                (f = f[1]));
              var h = Number(a[2]) || 0;
              this.webglLayer &&
                "cesium" === this.webglLayer.options.mapType &&
                window.Cesium &&
                ((c = this.convertLngLat([c, f])),
                (h = window.Cesium.Cartesian3.fromDegrees(c[0], c[1], h)),
                (c = h.x),
                (f = h.y),
                (h = h.z));
              return 3 < a.length
                ? [c - b[0], f - b[1], h].concat(tm(a.slice(3)))
                : [c - b[0], f - b[1], h];
            }
          },
          {
            key: "convertLngLat",
            value: function(a) {
              return [
                (a[0] / 2.003750834e7) * 180,
                (180 / Math.PI) *
                  (2 *
                    Math.atan(
                      Math.exp(((a[1] / 2.003750834e7) * 180 * Math.PI) / 180)
                    ) -
                    Math.PI / 2)
              ];
            }
          },
          {
            key: "getPointOffset",
            value: function() {
              return this.webglLayer && this.webglLayer.options.pointOffset
                ? this.webglLayer.options.pointOffset
                : [0, 0];
            }
          },
          {
            key: "indexToRgb",
            value: function(a) {
              a++;
              var b = Math.floor(a / 65536);
              a -= 65536 * b;
              var c = Math.floor(a / 256);
              return [a - 256 * c, c, b];
            }
          },
          {
            key: "rgbToIndex",
            value: function(a) {
              return a[0] + 256 * a[1] + 65536 * a[2] - 1;
            }
          },
          {
            key: "pick",
            value: function(a, b) {
              var c = this.gl;
              this.webglLayer.bindFramebuffer(this.webglLayer.pickFBO);
              this.webglLayer.clear();
              this.render({
                gl: c,
                isPickRender: !0,
                matrix: this.webglLayer.matrix,
                projectionMatrix: this.webglLayer.projectionMatrix,
                viewMatrix: this.webglLayer.viewMatrix
              });
              var d = new Uint8Array(4);
              c.readPixels(
                a * window.devicePixelRatio,
                c.canvas.height - b * window.devicePixelRatio,
                1,
                1,
                c.RGBA,
                c.UNSIGNED_BYTE,
                d
              );
              a = this.rgbToIndex(d);
              this.pickedColor = [d[0] / 255, d[1] / 255, d[2] / 255];
              return a;
            }
          }
        ]);
        return b;
      })(xm)
    ),
    hj = (function(a) {
      function b(a) {
        ud(this, b);
        var c = ve(
          this,
          (b.__proto__ || Object.getPrototypeOf(b)).call(this, a)
        );
        c.layerType = "threeLayer";
        c.setOptions(a);
        return c;
      }
      ue(b, a);
      Nc(b, [
        {
          key: "setWebglLayer",
          value: function(a) {
            a.threeLayer ||
              (a.threeLayer = new ym({
                enabledPointOffset: !0,
                webglLayer: a
              }));
            this.threeLayer = a.threeLayer;
          }
        },
        {
          key: "getPointOffset",
          value: function() {
            return this.threeLayer.getPointOffset();
          }
        },
        {
          key: "getThreeLayer",
          value: function() {
            return this.threeLayer;
          }
        }
      ]);
      return b;
    })(xm);
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
  void 0 === Number.isInteger &&
    (Number.isInteger = function(a) {
      return "number" === typeof a && isFinite(a) && Math.floor(a) === a;
    });
  void 0 === Math.sign &&
    (Math.sign = function(a) {
      return 0 > a ? -1 : 0 < a ? 1 : +a;
    });
  !1 === "name" in Function.prototype &&
    Object.defineProperty(Function.prototype, "name", {
      get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
      }
    });
  void 0 === Object.assign &&
    (Object.assign = function(a) {
      if (void 0 === a || null === a)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var b = Object(a), c = 1; c < arguments.length; c++) {
        var d = arguments[c];
        if (void 0 !== d && null !== d)
          for (var e in d)
            Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);
      }
      return b;
    });
  Object.assign(lc.prototype, {
    addEventListener: function(a, b) {
      void 0 === this._listeners && (this._listeners = {});
      var c = this._listeners;
      void 0 === c[a] && (c[a] = []);
      -1 === c[a].indexOf(b) && c[a].push(b);
    },
    hasEventListener: function(a, b) {
      if (void 0 === this._listeners) return !1;
      var c = this._listeners;
      return void 0 !== c[a] && -1 !== c[a].indexOf(b);
    },
    removeEventListener: function(a, b) {
      void 0 !== this._listeners &&
        ((a = this._listeners[a]),
        void 0 !== a && ((b = a.indexOf(b)), -1 !== b && a.splice(b, 1)));
    },
    dispatchEvent: function(a) {
      if (void 0 !== this._listeners) {
        var b = this._listeners[a.type];
        if (void 0 !== b) {
          a.target = this;
          b = b.slice(0);
          for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a);
        }
      }
    }
  });
  for (var bb = [], sf = 0; 256 > sf; sf++)
    bb[sf] = (16 > sf ? "0" : "") + sf.toString(16);
  var ca = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      var a = (4294967295 * Math.random()) | 0,
        b = (4294967295 * Math.random()) | 0,
        c = (4294967295 * Math.random()) | 0,
        d = (4294967295 * Math.random()) | 0;
      return (
        bb[a & 255] +
        bb[(a >> 8) & 255] +
        bb[(a >> 16) & 255] +
        bb[(a >> 24) & 255] +
        "-" +
        bb[b & 255] +
        bb[(b >> 8) & 255] +
        "-" +
        bb[((b >> 16) & 15) | 64] +
        bb[(b >> 24) & 255] +
        "-" +
        bb[(c & 63) | 128] +
        bb[(c >> 8) & 255] +
        "-" +
        bb[(c >> 16) & 255] +
        bb[(c >> 24) & 255] +
        bb[d & 255] +
        bb[(d >> 8) & 255] +
        bb[(d >> 16) & 255] +
        bb[(d >> 24) & 255]
      ).toUpperCase();
    },
    clamp: function(a, b, c) {
      return Math.max(b, Math.min(c, a));
    },
    euclideanModulo: function(a, b) {
      return ((a % b) + b) % b;
    },
    mapLinear: function(a, b, c, d, e) {
      return d + ((a - b) * (e - d)) / (c - b);
    },
    lerp: function(a, b, c) {
      return (1 - c) * a + c * b;
    },
    smoothstep: function(a, b, c) {
      if (a <= b) return 0;
      if (a >= c) return 1;
      a = (a - b) / (c - b);
      return a * a * (3 - 2 * a);
    },
    smootherstep: function(a, b, c) {
      if (a <= b) return 0;
      if (a >= c) return 1;
      a = (a - b) / (c - b);
      return a * a * a * (a * (6 * a - 15) + 10);
    },
    randInt: function(a, b) {
      return a + Math.floor(Math.random() * (b - a + 1));
    },
    randFloat: function(a, b) {
      return a + Math.random() * (b - a);
    },
    randFloatSpread: function(a) {
      return a * (0.5 - Math.random());
    },
    degToRad: function(a) {
      return a * ca.DEG2RAD;
    },
    radToDeg: function(a) {
      return a * ca.RAD2DEG;
    },
    isPowerOfTwo: function(a) {
      return 0 === (a & (a - 1)) && 0 !== a;
    },
    ceilPowerOfTwo: function(a) {
      return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
    },
    floorPowerOfTwo: function(a) {
      return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
    }
  };
  Object.defineProperties(E.prototype, {
    width: {
      get: function() {
        return this.x;
      },
      set: function(a) {
        this.x = a;
      }
    },
    height: {
      get: function() {
        return this.y;
      },
      set: function(a) {
        this.y = a;
      }
    }
  });
  Object.assign(E.prototype, {
    isVector2: !0,
    set: function(a, b) {
      this.x = a;
      this.y = b;
      return this;
    },
    setScalar: function(a) {
      this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(a, b)
        );
      this.x += a.x;
      this.y += a.y;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(a, b)
        );
      this.x -= a.x;
      this.y -= a.y;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    },
    multiply: function(a) {
      this.x *= a.x;
      this.y *= a.y;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      return this;
    },
    divide: function(a) {
      this.x /= a.x;
      this.y /= a.y;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    applyMatrix3: function(a) {
      var b = this.x,
        c = this.y;
      a = a.elements;
      this.x = a[0] * b + a[3] * c + a[6];
      this.y = a[1] * b + a[4] * c + a[7];
      return this;
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(
        Math.max(a, Math.min(b, c))
      );
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y;
    },
    cross: function(a) {
      return this.x * a.y - this.y * a.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var a = Math.atan2(this.y, this.x);
      0 > a && (a += 2 * Math.PI);
      return a;
    },
    distanceTo: function(a) {
      return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
      var b = this.x - a.x;
      a = this.y - a.y;
      return b * b + a * a;
    },
    manhattanDistanceTo: function(a) {
      return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a)
        .multiplyScalar(c)
        .add(a);
    },
    equals: function(a) {
      return a.x === this.x && a.y === this.y;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        );
      this.x = a.getX(b);
      this.y = a.getY(b);
      return this;
    },
    rotateAround: function(a, b) {
      var c = Math.cos(b);
      b = Math.sin(b);
      var d = this.x - a.x,
        e = this.y - a.y;
      this.x = d * c - e * b + a.x;
      this.y = d * b + e * c + a.y;
      return this;
    }
  });
  Object.assign(mb, {
    slerp: function(a, b, c, d) {
      return c.copy(a).slerp(b, d);
    },
    slerpFlat: function(a, b, c, d, e, f, h) {
      var k = c[d + 0],
        l = c[d + 1],
        m = c[d + 2];
      c = c[d + 3];
      d = e[f + 0];
      var n = e[f + 1],
        q = e[f + 2];
      e = e[f + 3];
      if (c !== e || k !== d || l !== n || m !== q) {
        f = 1 - h;
        var t = k * d + l * n + m * q + c * e,
          r = 0 <= t ? 1 : -1,
          u = 1 - t * t;
        u > Number.EPSILON &&
          ((u = Math.sqrt(u)),
          (t = Math.atan2(u, t * r)),
          (f = Math.sin(f * t) / u),
          (h = Math.sin(h * t) / u));
        r *= h;
        k = k * f + d * r;
        l = l * f + n * r;
        m = m * f + q * r;
        c = c * f + e * r;
        f === 1 - h &&
          ((h = 1 / Math.sqrt(k * k + l * l + m * m + c * c)),
          (k *= h),
          (l *= h),
          (m *= h),
          (c *= h));
      }
      a[b] = k;
      a[b + 1] = l;
      a[b + 2] = m;
      a[b + 3] = c;
    }
  });
  Object.defineProperties(mb.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(a) {
        this._x = a;
        this._onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(a) {
        this._y = a;
        this._onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(a) {
        this._z = a;
        this._onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(a) {
        this._w = a;
        this._onChangeCallback();
      }
    }
  });
  Object.assign(mb.prototype, {
    isQuaternion: !0,
    set: function(a, b, c, d) {
      this._x = a;
      this._y = b;
      this._z = c;
      this._w = d;
      this._onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(a) {
      this._x = a.x;
      this._y = a.y;
      this._z = a.z;
      this._w = a.w;
      this._onChangeCallback();
      return this;
    },
    setFromEuler: function(a, b) {
      if (!a || !a.isEuler)
        throw Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      var c = a._x,
        d = a._y,
        e = a._z;
      a = a.order;
      var f = Math.cos,
        h = Math.sin,
        k = f(c / 2),
        l = f(d / 2);
      f = f(e / 2);
      c = h(c / 2);
      d = h(d / 2);
      e = h(e / 2);
      "XYZ" === a
        ? ((this._x = c * l * f + k * d * e),
          (this._y = k * d * f - c * l * e),
          (this._z = k * l * e + c * d * f),
          (this._w = k * l * f - c * d * e))
        : "YXZ" === a
        ? ((this._x = c * l * f + k * d * e),
          (this._y = k * d * f - c * l * e),
          (this._z = k * l * e - c * d * f),
          (this._w = k * l * f + c * d * e))
        : "ZXY" === a
        ? ((this._x = c * l * f - k * d * e),
          (this._y = k * d * f + c * l * e),
          (this._z = k * l * e + c * d * f),
          (this._w = k * l * f - c * d * e))
        : "ZYX" === a
        ? ((this._x = c * l * f - k * d * e),
          (this._y = k * d * f + c * l * e),
          (this._z = k * l * e - c * d * f),
          (this._w = k * l * f + c * d * e))
        : "YZX" === a
        ? ((this._x = c * l * f + k * d * e),
          (this._y = k * d * f + c * l * e),
          (this._z = k * l * e - c * d * f),
          (this._w = k * l * f - c * d * e))
        : "XZY" === a &&
          ((this._x = c * l * f - k * d * e),
          (this._y = k * d * f - c * l * e),
          (this._z = k * l * e + c * d * f),
          (this._w = k * l * f + c * d * e));
      !1 !== b && this._onChangeCallback();
      return this;
    },
    setFromAxisAngle: function(a, b) {
      b /= 2;
      var c = Math.sin(b);
      this._x = a.x * c;
      this._y = a.y * c;
      this._z = a.z * c;
      this._w = Math.cos(b);
      this._onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(a) {
      var b = a.elements,
        c = b[0];
      a = b[4];
      var d = b[8],
        e = b[1],
        f = b[5],
        h = b[9],
        k = b[2],
        l = b[6];
      b = b[10];
      var m = c + f + b;
      0 < m
        ? ((c = 0.5 / Math.sqrt(m + 1)),
          (this._w = 0.25 / c),
          (this._x = (l - h) * c),
          (this._y = (d - k) * c),
          (this._z = (e - a) * c))
        : c > f && c > b
        ? ((c = 2 * Math.sqrt(1 + c - f - b)),
          (this._w = (l - h) / c),
          (this._x = 0.25 * c),
          (this._y = (a + e) / c),
          (this._z = (d + k) / c))
        : f > b
        ? ((c = 2 * Math.sqrt(1 + f - c - b)),
          (this._w = (d - k) / c),
          (this._x = (a + e) / c),
          (this._y = 0.25 * c),
          (this._z = (h + l) / c))
        : ((c = 2 * Math.sqrt(1 + b - c - f)),
          (this._w = (e - a) / c),
          (this._x = (d + k) / c),
          (this._y = (h + l) / c),
          (this._z = 0.25 * c));
      this._onChangeCallback();
      return this;
    },
    setFromUnitVectors: function(a, b) {
      var c = a.dot(b) + 1;
      1e-6 > c
        ? ((c = 0),
          Math.abs(a.x) > Math.abs(a.z)
            ? ((this._x = -a.y), (this._y = a.x), (this._z = 0))
            : ((this._x = 0), (this._y = -a.z), (this._z = a.y)))
        : ((this._x = a.y * b.z - a.z * b.y),
          (this._y = a.z * b.x - a.x * b.z),
          (this._z = a.x * b.y - a.y * b.x));
      this._w = c;
      return this.normalize();
    },
    angleTo: function(a) {
      return 2 * Math.acos(Math.abs(ca.clamp(this.dot(a), -1, 1)));
    },
    rotateTowards: function(a, b) {
      var c = this.angleTo(a);
      if (0 === c) return this;
      this.slerp(a, Math.min(1, b / c));
      return this;
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    },
    dot: function(a) {
      return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
    },
    lengthSq: function() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    },
    length: function() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    },
    normalize: function() {
      var a = this.length();
      0 === a
        ? ((this._z = this._y = this._x = 0), (this._w = 1))
        : ((a = 1 / a),
          (this._x *= a),
          (this._y *= a),
          (this._z *= a),
          (this._w *= a));
      this._onChangeCallback();
      return this;
    },
    multiply: function(a, b) {
      return void 0 !== b
        ? (console.warn(
            "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
          ),
          this.multiplyQuaternions(a, b))
        : this.multiplyQuaternions(this, a);
    },
    premultiply: function(a) {
      return this.multiplyQuaternions(a, this);
    },
    multiplyQuaternions: function(a, b) {
      var c = a._x,
        d = a._y,
        e = a._z;
      a = a._w;
      var f = b._x,
        h = b._y,
        k = b._z;
      b = b._w;
      this._x = c * b + a * f + d * k - e * h;
      this._y = d * b + a * h + e * f - c * k;
      this._z = e * b + a * k + c * h - d * f;
      this._w = a * b - c * f - d * h - e * k;
      this._onChangeCallback();
      return this;
    },
    slerp: function(a, b) {
      if (0 === b) return this;
      if (1 === b) return this.copy(a);
      var c = this._x,
        d = this._y,
        e = this._z,
        f = this._w,
        h = f * a._w + c * a._x + d * a._y + e * a._z;
      0 > h
        ? ((this._w = -a._w),
          (this._x = -a._x),
          (this._y = -a._y),
          (this._z = -a._z),
          (h = -h))
        : this.copy(a);
      if (1 <= h)
        return (this._w = f), (this._x = c), (this._y = d), (this._z = e), this;
      a = 1 - h * h;
      if (a <= Number.EPSILON)
        return (
          (h = 1 - b),
          (this._w = h * f + b * this._w),
          (this._x = h * c + b * this._x),
          (this._y = h * d + b * this._y),
          (this._z = h * e + b * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      a = Math.sqrt(a);
      var k = Math.atan2(a, h);
      h = Math.sin((1 - b) * k) / a;
      b = Math.sin(b * k) / a;
      this._w = f * h + this._w * b;
      this._x = c * h + this._x * b;
      this._y = d * h + this._y * b;
      this._z = e * h + this._z * b;
      this._onChangeCallback();
      return this;
    },
    equals: function(a) {
      return (
        a._x === this._x &&
        a._y === this._y &&
        a._z === this._z &&
        a._w === this._w
      );
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this._x = a[b];
      this._y = a[b + 1];
      this._z = a[b + 2];
      this._w = a[b + 3];
      this._onChangeCallback();
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this._x;
      a[b + 1] = this._y;
      a[b + 2] = this._z;
      a[b + 3] = this._w;
      return a;
    },
    _onChange: function(a) {
      this._onChangeCallback = a;
      return this;
    },
    _onChangeCallback: function() {}
  });
  var ij = new r(),
    zm = new mb();
  Object.assign(r.prototype, {
    isVector3: !0,
    set: function(a, b, c) {
      this.x = a;
      this.y = b;
      this.z = c;
      return this;
    },
    setScalar: function(a) {
      this.z = this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setZ: function(a) {
      this.z = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        case 2:
          this.z = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(a, b)
        );
      this.x += a.x;
      this.y += a.y;
      this.z += a.z;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      this.z += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      this.z += a.z * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(a, b)
        );
      this.x -= a.x;
      this.y -= a.y;
      this.z -= a.z;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      this.z -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
          ),
          this.multiplyVectors(a, b)
        );
      this.x *= a.x;
      this.y *= a.y;
      this.z *= a.z;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      this.z *= a;
      return this;
    },
    multiplyVectors: function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyEuler: function(a) {
      (a && a.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      return this.applyQuaternion(zm.setFromEuler(a));
    },
    applyAxisAngle: function(a, b) {
      return this.applyQuaternion(zm.setFromAxisAngle(a, b));
    },
    applyMatrix3: function(a) {
      var b = this.x,
        c = this.y,
        d = this.z;
      a = a.elements;
      this.x = a[0] * b + a[3] * c + a[6] * d;
      this.y = a[1] * b + a[4] * c + a[7] * d;
      this.z = a[2] * b + a[5] * c + a[8] * d;
      return this;
    },
    applyMatrix4: function(a) {
      var b = this.x,
        c = this.y,
        d = this.z;
      a = a.elements;
      var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
      this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
      this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
      this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
      return this;
    },
    applyQuaternion: function(a) {
      var b = this.x,
        c = this.y,
        d = this.z,
        e = a.x,
        f = a.y,
        h = a.z;
      a = a.w;
      var k = a * b + f * d - h * c,
        l = a * c + h * b - e * d,
        m = a * d + e * c - f * b;
      b = -e * b - f * c - h * d;
      this.x = k * a + b * -e + l * -h - m * -f;
      this.y = l * a + b * -f + m * -e - k * -h;
      this.z = m * a + b * -h + k * -f - l * -e;
      return this;
    },
    project: function(a) {
      return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(
        a.projectionMatrix
      );
    },
    unproject: function(a) {
      return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(
        a.matrixWorld
      );
    },
    transformDirection: function(a) {
      var b = this.x,
        c = this.y,
        d = this.z;
      a = a.elements;
      this.x = a[0] * b + a[4] * c + a[8] * d;
      this.y = a[1] * b + a[5] * c + a[9] * d;
      this.z = a[2] * b + a[6] * c + a[10] * d;
      return this.normalize();
    },
    divide: function(a) {
      this.x /= a.x;
      this.y /= a.y;
      this.z /= a.z;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      this.z = Math.min(this.z, a.z);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      this.z = Math.max(this.z, a.z);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      this.z = Math.max(a.z, Math.min(b.z, this.z));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      this.z = Math.max(a, Math.min(b, this.z));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(
        Math.max(a, Math.min(b, c))
      );
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      this.z += (a.z - this.z) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a)
        .multiplyScalar(c)
        .add(a);
    },
    cross: function(a, b) {
      return void 0 !== b
        ? (console.warn(
            "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
          ),
          this.crossVectors(a, b))
        : this.crossVectors(this, a);
    },
    crossVectors: function(a, b) {
      var c = a.x,
        d = a.y;
      a = a.z;
      var e = b.x,
        f = b.y;
      b = b.z;
      this.x = d * b - a * f;
      this.y = a * e - c * b;
      this.z = c * f - d * e;
      return this;
    },
    projectOnVector: function(a) {
      var b = a.dot(this) / a.lengthSq();
      return this.copy(a).multiplyScalar(b);
    },
    projectOnPlane: function(a) {
      ij.copy(this).projectOnVector(a);
      return this.sub(ij);
    },
    reflect: function(a) {
      return this.sub(ij.copy(a).multiplyScalar(2 * this.dot(a)));
    },
    angleTo: function(a) {
      var b = Math.sqrt(this.lengthSq() * a.lengthSq());
      0 === b &&
        console.error(
          "THREE.Vector3: angleTo() can't handle zero length vectors."
        );
      a = this.dot(a) / b;
      return Math.acos(ca.clamp(a, -1, 1));
    },
    distanceTo: function(a) {
      return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
      var b = this.x - a.x,
        c = this.y - a.y;
      a = this.z - a.z;
      return b * b + c * c + a * a;
    },
    manhattanDistanceTo: function(a) {
      return (
        Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
      );
    },
    setFromSpherical: function(a) {
      return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
    },
    setFromSphericalCoords: function(a, b, c) {
      var d = Math.sin(b) * a;
      this.x = d * Math.sin(c);
      this.y = Math.cos(b) * a;
      this.z = d * Math.cos(c);
      return this;
    },
    setFromCylindrical: function(a) {
      return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
    },
    setFromCylindricalCoords: function(a, b, c) {
      this.x = a * Math.sin(b);
      this.y = c;
      this.z = a * Math.cos(b);
      return this;
    },
    setFromMatrixPosition: function(a) {
      a = a.elements;
      this.x = a[12];
      this.y = a[13];
      this.z = a[14];
      return this;
    },
    setFromMatrixScale: function(a) {
      var b = this.setFromMatrixColumn(a, 0).length(),
        c = this.setFromMatrixColumn(a, 1).length();
      a = this.setFromMatrixColumn(a, 2).length();
      this.x = b;
      this.y = c;
      this.z = a;
      return this;
    },
    setFromMatrixColumn: function(a, b) {
      return this.fromArray(a.elements, 4 * b);
    },
    equals: function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      this.z = a[b + 2];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      a[b + 2] = this.z;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        );
      this.x = a.getX(b);
      this.y = a.getY(b);
      this.z = a.getZ(b);
      return this;
    }
  });
  var dc = new r();
  Object.assign(Ya.prototype, {
    isMatrix3: !0,
    set: function(a, b, c, d, e, f, h, k, l) {
      var m = this.elements;
      m[0] = a;
      m[1] = d;
      m[2] = h;
      m[3] = b;
      m[4] = e;
      m[5] = k;
      m[6] = c;
      m[7] = f;
      m[8] = l;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(a) {
      var b = this.elements;
      a = a.elements;
      b[0] = a[0];
      b[1] = a[1];
      b[2] = a[2];
      b[3] = a[3];
      b[4] = a[4];
      b[5] = a[5];
      b[6] = a[6];
      b[7] = a[7];
      b[8] = a[8];
      return this;
    },
    setFromMatrix4: function(a) {
      a = a.elements;
      this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
      return this;
    },
    applyToBufferAttribute: function(a) {
      for (var b = 0, c = a.count; b < c; b++)
        (dc.x = a.getX(b)),
          (dc.y = a.getY(b)),
          (dc.z = a.getZ(b)),
          dc.applyMatrix3(this),
          a.setXYZ(b, dc.x, dc.y, dc.z);
      return a;
    },
    multiply: function(a) {
      return this.multiplyMatrices(this, a);
    },
    premultiply: function(a) {
      return this.multiplyMatrices(a, this);
    },
    multiplyMatrices: function(a, b) {
      var c = a.elements,
        d = b.elements;
      b = this.elements;
      a = c[0];
      var e = c[3],
        f = c[6],
        h = c[1],
        k = c[4],
        l = c[7],
        m = c[2],
        n = c[5];
      c = c[8];
      var q = d[0],
        t = d[3],
        r = d[6],
        u = d[1],
        v = d[4],
        A = d[7],
        C = d[2],
        z = d[5];
      d = d[8];
      b[0] = a * q + e * u + f * C;
      b[3] = a * t + e * v + f * z;
      b[6] = a * r + e * A + f * d;
      b[1] = h * q + k * u + l * C;
      b[4] = h * t + k * v + l * z;
      b[7] = h * r + k * A + l * d;
      b[2] = m * q + n * u + c * C;
      b[5] = m * t + n * v + c * z;
      b[8] = m * r + n * A + c * d;
      return this;
    },
    multiplyScalar: function(a) {
      var b = this.elements;
      b[0] *= a;
      b[3] *= a;
      b[6] *= a;
      b[1] *= a;
      b[4] *= a;
      b[7] *= a;
      b[2] *= a;
      b[5] *= a;
      b[8] *= a;
      return this;
    },
    determinant: function() {
      var a = this.elements,
        b = a[0],
        c = a[1],
        d = a[2],
        e = a[3],
        f = a[4],
        h = a[5],
        k = a[6],
        l = a[7];
      a = a[8];
      return (
        b * f * a - b * h * l - c * e * a + c * h * k + d * e * l - d * f * k
      );
    },
    getInverse: function(a, b) {
      a &&
        a.isMatrix4 &&
        console.error(
          "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
        );
      var c = a.elements;
      a = this.elements;
      var d = c[0],
        e = c[1],
        f = c[2],
        h = c[3],
        k = c[4],
        l = c[5],
        m = c[6],
        n = c[7];
      c = c[8];
      var q = c * k - l * n,
        t = l * m - c * h,
        r = n * h - k * m,
        u = d * q + e * t + f * r;
      if (0 === u) {
        if (!0 === b)
          throw Error(
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
          );
        console.warn(
          "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
        );
        return this.identity();
      }
      b = 1 / u;
      a[0] = q * b;
      a[1] = (f * n - c * e) * b;
      a[2] = (l * e - f * k) * b;
      a[3] = t * b;
      a[4] = (c * d - f * m) * b;
      a[5] = (f * h - l * d) * b;
      a[6] = r * b;
      a[7] = (e * m - n * d) * b;
      a[8] = (k * d - e * h) * b;
      return this;
    },
    transpose: function() {
      var a = this.elements;
      var b = a[1];
      a[1] = a[3];
      a[3] = b;
      b = a[2];
      a[2] = a[6];
      a[6] = b;
      b = a[5];
      a[5] = a[7];
      a[7] = b;
      return this;
    },
    getNormalMatrix: function(a) {
      return this.setFromMatrix4(a)
        .getInverse(this)
        .transpose();
    },
    transposeIntoArray: function(a) {
      var b = this.elements;
      a[0] = b[0];
      a[1] = b[3];
      a[2] = b[6];
      a[3] = b[1];
      a[4] = b[4];
      a[5] = b[7];
      a[6] = b[2];
      a[7] = b[5];
      a[8] = b[8];
      return this;
    },
    setUvTransform: function(a, b, c, d, e, f, h) {
      var k = Math.cos(e);
      e = Math.sin(e);
      this.set(
        c * k,
        c * e,
        -c * (k * f + e * h) + f + a,
        -d * e,
        d * k,
        -d * (-e * f + k * h) + h + b,
        0,
        0,
        1
      );
    },
    scale: function(a, b) {
      var c = this.elements;
      c[0] *= a;
      c[3] *= a;
      c[6] *= a;
      c[1] *= b;
      c[4] *= b;
      c[7] *= b;
      return this;
    },
    rotate: function(a) {
      var b = Math.cos(a);
      a = Math.sin(a);
      var c = this.elements,
        d = c[0],
        e = c[3],
        f = c[6],
        h = c[1],
        k = c[4],
        l = c[7];
      c[0] = b * d + a * h;
      c[3] = b * e + a * k;
      c[6] = b * f + a * l;
      c[1] = -a * d + b * h;
      c[4] = -a * e + b * k;
      c[7] = -a * f + b * l;
      return this;
    },
    translate: function(a, b) {
      var c = this.elements;
      c[0] += a * c[2];
      c[3] += a * c[5];
      c[6] += a * c[8];
      c[1] += b * c[2];
      c[4] += b * c[5];
      c[7] += b * c[8];
      return this;
    },
    equals: function(a) {
      var b = this.elements;
      a = a.elements;
      for (var c = 0; 9 > c; c++) if (b[c] !== a[c]) return !1;
      return !0;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      var c = this.elements;
      a[b] = c[0];
      a[b + 1] = c[1];
      a[b + 2] = c[2];
      a[b + 3] = c[3];
      a[b + 4] = c[4];
      a[b + 5] = c[5];
      a[b + 6] = c[6];
      a[b + 7] = c[7];
      a[b + 8] = c[8];
      return a;
    }
  });
  var mg,
    Qc = {
      getDataURL: function(a) {
        if ("undefined" == typeof HTMLCanvasElement) return a.src;
        if (!(a instanceof HTMLCanvasElement)) {
          void 0 === mg &&
            (mg = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "canvas"
            ));
          mg.width = a.width;
          mg.height = a.height;
          var b = mg.getContext("2d");
          a instanceof ImageData
            ? b.putImageData(a, 0, 0)
            : b.drawImage(a, 0, 0, a.width, a.height);
          a = mg;
        }
        return 2048 < a.width || 2048 < a.height
          ? a.toDataURL("image/jpeg", 0.6)
          : a.toDataURL("image/png");
      }
    },
    nn = 0;
  pa.DEFAULT_IMAGE = void 0;
  pa.DEFAULT_MAPPING = 300;
  pa.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: pa,
    isTexture: !0,
    updateMatrix: function() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.name = a.name;
      this.image = a.image;
      this.mipmaps = a.mipmaps.slice(0);
      this.mapping = a.mapping;
      this.wrapS = a.wrapS;
      this.wrapT = a.wrapT;
      this.magFilter = a.magFilter;
      this.minFilter = a.minFilter;
      this.anisotropy = a.anisotropy;
      this.format = a.format;
      this.type = a.type;
      this.offset.copy(a.offset);
      this.repeat.copy(a.repeat);
      this.center.copy(a.center);
      this.rotation = a.rotation;
      this.matrixAutoUpdate = a.matrixAutoUpdate;
      this.matrix.copy(a.matrix);
      this.generateMipmaps = a.generateMipmaps;
      this.premultiplyAlpha = a.premultiplyAlpha;
      this.flipY = a.flipY;
      this.unpackAlignment = a.unpackAlignment;
      this.encoding = a.encoding;
      return this;
    },
    toJSON: function(a) {
      var b = void 0 === a || "string" === typeof a;
      if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
      var c = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (void 0 !== this.image) {
        var d = this.image;
        void 0 === d.uuid && (d.uuid = ca.generateUUID());
        if (!b && void 0 === a.images[d.uuid]) {
          if (Array.isArray(d)) {
            var e = [];
            for (var f = 0, h = d.length; f < h; f++)
              e.push(Qc.getDataURL(d[f]));
          } else e = Qc.getDataURL(d);
          a.images[d.uuid] = { uuid: d.uuid, url: e };
        }
        c.image = d.uuid;
      }
      b || (a.textures[this.uuid] = c);
      return c;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(a) {
      if (300 !== this.mapping) return a;
      a.applyMatrix3(this.matrix);
      if (0 > a.x || 1 < a.x)
        switch (this.wrapS) {
          case 1e3:
            a.x -= Math.floor(a.x);
            break;
          case 1001:
            a.x = 0 > a.x ? 0 : 1;
            break;
          case 1002:
            a.x =
              1 === Math.abs(Math.floor(a.x) % 2)
                ? Math.ceil(a.x) - a.x
                : a.x - Math.floor(a.x);
        }
      if (0 > a.y || 1 < a.y)
        switch (this.wrapT) {
          case 1e3:
            a.y -= Math.floor(a.y);
            break;
          case 1001:
            a.y = 0 > a.y ? 0 : 1;
            break;
          case 1002:
            a.y =
              1 === Math.abs(Math.floor(a.y) % 2)
                ? Math.ceil(a.y) - a.y
                : a.y - Math.floor(a.y);
        }
      this.flipY && (a.y = 1 - a.y);
      return a;
    }
  });
  Object.defineProperty(pa.prototype, "needsUpdate", {
    set: function(a) {
      !0 === a && this.version++;
    }
  });
  Object.defineProperties(Ca.prototype, {
    width: {
      get: function() {
        return this.z;
      },
      set: function(a) {
        this.z = a;
      }
    },
    height: {
      get: function() {
        return this.w;
      },
      set: function(a) {
        this.w = a;
      }
    }
  });
  Object.assign(Ca.prototype, {
    isVector4: !0,
    set: function(a, b, c, d) {
      this.x = a;
      this.y = b;
      this.z = c;
      this.w = d;
      return this;
    },
    setScalar: function(a) {
      this.w = this.z = this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setZ: function(a) {
      this.z = a;
      return this;
    },
    setW: function(a) {
      this.w = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        case 2:
          this.z = b;
          break;
        case 3:
          this.w = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = void 0 !== a.w ? a.w : 1;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(a, b)
        );
      this.x += a.x;
      this.y += a.y;
      this.z += a.z;
      this.w += a.w;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      this.z += a;
      this.w += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      this.z += a.z * b;
      this.w += a.w * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b)
        return (
          console.warn(
            "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(a, b)
        );
      this.x -= a.x;
      this.y -= a.y;
      this.z -= a.z;
      this.w -= a.w;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      this.z -= a;
      this.w -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      this.z *= a;
      this.w *= a;
      return this;
    },
    applyMatrix4: function(a) {
      var b = this.x,
        c = this.y,
        d = this.z,
        e = this.w;
      a = a.elements;
      this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
      this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
      this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
      this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    setAxisAngleFromQuaternion: function(a) {
      this.w = 2 * Math.acos(a.w);
      var b = Math.sqrt(1 - a.w * a.w);
      1e-4 > b
        ? ((this.x = 1), (this.z = this.y = 0))
        : ((this.x = a.x / b), (this.y = a.y / b), (this.z = a.z / b));
      return this;
    },
    setAxisAngleFromRotationMatrix: function(a) {
      a = a.elements;
      var b = a[0];
      var c = a[4];
      var d = a[8],
        e = a[1],
        f = a[5],
        h = a[9];
      var k = a[2];
      var l = a[6];
      var m = a[10];
      if (
        0.01 > Math.abs(c - e) &&
        0.01 > Math.abs(d - k) &&
        0.01 > Math.abs(h - l)
      ) {
        if (
          0.1 > Math.abs(c + e) &&
          0.1 > Math.abs(d + k) &&
          0.1 > Math.abs(h + l) &&
          0.1 > Math.abs(b + f + m - 3)
        )
          return this.set(1, 0, 0, 0), this;
        a = Math.PI;
        b = (b + 1) / 2;
        f = (f + 1) / 2;
        m = (m + 1) / 2;
        c = (c + e) / 4;
        d = (d + k) / 4;
        h = (h + l) / 4;
        b > f && b > m
          ? 0.01 > b
            ? ((l = 0), (c = k = 0.707106781))
            : ((l = Math.sqrt(b)), (k = c / l), (c = d / l))
          : f > m
          ? 0.01 > f
            ? ((l = 0.707106781), (k = 0), (c = 0.707106781))
            : ((k = Math.sqrt(f)), (l = c / k), (c = h / k))
          : 0.01 > m
          ? ((k = l = 0.707106781), (c = 0))
          : ((c = Math.sqrt(m)), (l = d / c), (k = h / c));
        this.set(l, k, c, a);
        return this;
      }
      a = Math.sqrt((l - h) * (l - h) + (d - k) * (d - k) + (e - c) * (e - c));
      0.001 > Math.abs(a) && (a = 1);
      this.x = (l - h) / a;
      this.y = (d - k) / a;
      this.z = (e - c) / a;
      this.w = Math.acos((b + f + m - 1) / 2);
      return this;
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      this.z = Math.min(this.z, a.z);
      this.w = Math.min(this.w, a.w);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      this.z = Math.max(this.z, a.z);
      this.w = Math.max(this.w, a.w);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      this.z = Math.max(a.z, Math.min(b.z, this.z));
      this.w = Math.max(a.w, Math.min(b.w, this.w));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      this.z = Math.max(a, Math.min(b, this.z));
      this.w = Math.max(a, Math.min(b, this.w));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(
        Math.max(a, Math.min(b, c))
      );
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    },
    lengthSq: function() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    length: function() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    manhattanLength: function() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      this.z += (a.z - this.z) * b;
      this.w += (a.w - this.w) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a)
        .multiplyScalar(c)
        .add(a);
    },
    equals: function(a) {
      return (
        a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
      );
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      this.z = a[b + 2];
      this.w = a[b + 3];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      a[b + 2] = this.z;
      a[b + 3] = this.w;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        );
      this.x = a.getX(b);
      this.y = a.getY(b);
      this.z = a.getZ(b);
      this.w = a.getW(b);
      return this;
    }
  });
  Za.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: Za,
    isWebGLRenderTarget: !0,
    setSize: function(a, b) {
      if (this.width !== a || this.height !== b)
        (this.width = a),
          (this.height = b),
          (this.texture.image.width = a),
          (this.texture.image.height = b),
          this.dispose();
      this.viewport.set(0, 0, a, b);
      this.scissor.set(0, 0, a, b);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.width = a.width;
      this.height = a.height;
      this.viewport.copy(a.viewport);
      this.texture = a.texture.clone();
      this.depthBuffer = a.depthBuffer;
      this.stencilBuffer = a.stencilBuffer;
      this.depthTexture = a.depthTexture;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  Zk.prototype = Object.assign(Object.create(Za.prototype), {
    constructor: Zk,
    isWebGLMultisampleRenderTarget: !0,
    copy: function(a) {
      Za.prototype.copy.call(this, a);
      this.samples = a.samples;
      return this;
    }
  });
  var Cb = new r(),
    Aa = new fa(),
    To = new r(0, 0, 0),
    Uo = new r(1, 1, 1),
    He = new r(),
    jj = new r(),
    db = new r();
  Object.assign(fa.prototype, {
    isMatrix4: !0,
    set: function(a, b, c, d, e, f, h, k, l, m, n, q, t, r, u, v) {
      var y = this.elements;
      y[0] = a;
      y[4] = b;
      y[8] = c;
      y[12] = d;
      y[1] = e;
      y[5] = f;
      y[9] = h;
      y[13] = k;
      y[2] = l;
      y[6] = m;
      y[10] = n;
      y[14] = q;
      y[3] = t;
      y[7] = r;
      y[11] = u;
      y[15] = v;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new fa().fromArray(this.elements);
    },
    copy: function(a) {
      var b = this.elements;
      a = a.elements;
      b[0] = a[0];
      b[1] = a[1];
      b[2] = a[2];
      b[3] = a[3];
      b[4] = a[4];
      b[5] = a[5];
      b[6] = a[6];
      b[7] = a[7];
      b[8] = a[8];
      b[9] = a[9];
      b[10] = a[10];
      b[11] = a[11];
      b[12] = a[12];
      b[13] = a[13];
      b[14] = a[14];
      b[15] = a[15];
      return this;
    },
    copyPosition: function(a) {
      var b = this.elements;
      a = a.elements;
      b[12] = a[12];
      b[13] = a[13];
      b[14] = a[14];
      return this;
    },
    extractBasis: function(a, b, c) {
      a.setFromMatrixColumn(this, 0);
      b.setFromMatrixColumn(this, 1);
      c.setFromMatrixColumn(this, 2);
      return this;
    },
    makeBasis: function(a, b, c) {
      this.set(
        a.x,
        b.x,
        c.x,
        0,
        a.y,
        b.y,
        c.y,
        0,
        a.z,
        b.z,
        c.z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    },
    extractRotation: function(a) {
      var b = this.elements,
        c = a.elements,
        d = 1 / Cb.setFromMatrixColumn(a, 0).length(),
        e = 1 / Cb.setFromMatrixColumn(a, 1).length();
      a = 1 / Cb.setFromMatrixColumn(a, 2).length();
      b[0] = c[0] * d;
      b[1] = c[1] * d;
      b[2] = c[2] * d;
      b[3] = 0;
      b[4] = c[4] * e;
      b[5] = c[5] * e;
      b[6] = c[6] * e;
      b[7] = 0;
      b[8] = c[8] * a;
      b[9] = c[9] * a;
      b[10] = c[10] * a;
      b[11] = 0;
      b[12] = 0;
      b[13] = 0;
      b[14] = 0;
      b[15] = 1;
      return this;
    },
    makeRotationFromEuler: function(a) {
      (a && a.isEuler) ||
        console.error(
          "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
        );
      var b = this.elements,
        c = a.x,
        d = a.y,
        e = a.z,
        f = Math.cos(c);
      c = Math.sin(c);
      var h = Math.cos(d);
      d = Math.sin(d);
      var k = Math.cos(e);
      e = Math.sin(e);
      if ("XYZ" === a.order) {
        a = f * k;
        var l = f * e,
          m = c * k,
          n = c * e;
        b[0] = h * k;
        b[4] = -h * e;
        b[8] = d;
        b[1] = l + m * d;
        b[5] = a - n * d;
        b[9] = -c * h;
        b[2] = n - a * d;
        b[6] = m + l * d;
        b[10] = f * h;
      } else
        "YXZ" === a.order
          ? ((a = h * k),
            (l = h * e),
            (m = d * k),
            (n = d * e),
            (b[0] = a + n * c),
            (b[4] = m * c - l),
            (b[8] = f * d),
            (b[1] = f * e),
            (b[5] = f * k),
            (b[9] = -c),
            (b[2] = l * c - m),
            (b[6] = n + a * c),
            (b[10] = f * h))
          : "ZXY" === a.order
          ? ((a = h * k),
            (l = h * e),
            (m = d * k),
            (n = d * e),
            (b[0] = a - n * c),
            (b[4] = -f * e),
            (b[8] = m + l * c),
            (b[1] = l + m * c),
            (b[5] = f * k),
            (b[9] = n - a * c),
            (b[2] = -f * d),
            (b[6] = c),
            (b[10] = f * h))
          : "ZYX" === a.order
          ? ((a = f * k),
            (l = f * e),
            (m = c * k),
            (n = c * e),
            (b[0] = h * k),
            (b[4] = m * d - l),
            (b[8] = a * d + n),
            (b[1] = h * e),
            (b[5] = n * d + a),
            (b[9] = l * d - m),
            (b[2] = -d),
            (b[6] = c * h),
            (b[10] = f * h))
          : "YZX" === a.order
          ? ((a = f * h),
            (l = f * d),
            (m = c * h),
            (n = c * d),
            (b[0] = h * k),
            (b[4] = n - a * e),
            (b[8] = m * e + l),
            (b[1] = e),
            (b[5] = f * k),
            (b[9] = -c * k),
            (b[2] = -d * k),
            (b[6] = l * e + m),
            (b[10] = a - n * e))
          : "XZY" === a.order &&
            ((a = f * h),
            (l = f * d),
            (m = c * h),
            (n = c * d),
            (b[0] = h * k),
            (b[4] = -e),
            (b[8] = d * k),
            (b[1] = a * e + n),
            (b[5] = f * k),
            (b[9] = l * e - m),
            (b[2] = m * e - l),
            (b[6] = c * k),
            (b[10] = n * e + a));
      b[3] = 0;
      b[7] = 0;
      b[11] = 0;
      b[12] = 0;
      b[13] = 0;
      b[14] = 0;
      b[15] = 1;
      return this;
    },
    makeRotationFromQuaternion: function(a) {
      return this.compose(To, a, Uo);
    },
    lookAt: function(a, b, c) {
      var d = this.elements;
      db.subVectors(a, b);
      0 === db.lengthSq() && (db.z = 1);
      db.normalize();
      He.crossVectors(c, db);
      0 === He.lengthSq() &&
        (1 === Math.abs(c.z) ? (db.x += 1e-4) : (db.z += 1e-4),
        db.normalize(),
        He.crossVectors(c, db));
      He.normalize();
      jj.crossVectors(db, He);
      d[0] = He.x;
      d[4] = jj.x;
      d[8] = db.x;
      d[1] = He.y;
      d[5] = jj.y;
      d[9] = db.y;
      d[2] = He.z;
      d[6] = jj.z;
      d[10] = db.z;
      return this;
    },
    multiply: function(a, b) {
      return void 0 !== b
        ? (console.warn(
            "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
          ),
          this.multiplyMatrices(a, b))
        : this.multiplyMatrices(this, a);
    },
    premultiply: function(a) {
      return this.multiplyMatrices(a, this);
    },
    multiplyMatrices: function(a, b) {
      var c = a.elements,
        d = b.elements;
      b = this.elements;
      a = c[0];
      var e = c[4],
        f = c[8],
        h = c[12],
        k = c[1],
        l = c[5],
        m = c[9],
        n = c[13],
        q = c[2],
        t = c[6],
        r = c[10],
        u = c[14],
        v = c[3],
        A = c[7],
        C = c[11];
      c = c[15];
      var z = d[0],
        H = d[4],
        N = d[8],
        B = d[12],
        M = d[1],
        D = d[5],
        E = d[9],
        F = d[13],
        J = d[2],
        I = d[6],
        L = d[10],
        O = d[14],
        T = d[3],
        V = d[7],
        W = d[11];
      d = d[15];
      b[0] = a * z + e * M + f * J + h * T;
      b[4] = a * H + e * D + f * I + h * V;
      b[8] = a * N + e * E + f * L + h * W;
      b[12] = a * B + e * F + f * O + h * d;
      b[1] = k * z + l * M + m * J + n * T;
      b[5] = k * H + l * D + m * I + n * V;
      b[9] = k * N + l * E + m * L + n * W;
      b[13] = k * B + l * F + m * O + n * d;
      b[2] = q * z + t * M + r * J + u * T;
      b[6] = q * H + t * D + r * I + u * V;
      b[10] = q * N + t * E + r * L + u * W;
      b[14] = q * B + t * F + r * O + u * d;
      b[3] = v * z + A * M + C * J + c * T;
      b[7] = v * H + A * D + C * I + c * V;
      b[11] = v * N + A * E + C * L + c * W;
      b[15] = v * B + A * F + C * O + c * d;
      return this;
    },
    multiplyScalar: function(a) {
      var b = this.elements;
      b[0] *= a;
      b[4] *= a;
      b[8] *= a;
      b[12] *= a;
      b[1] *= a;
      b[5] *= a;
      b[9] *= a;
      b[13] *= a;
      b[2] *= a;
      b[6] *= a;
      b[10] *= a;
      b[14] *= a;
      b[3] *= a;
      b[7] *= a;
      b[11] *= a;
      b[15] *= a;
      return this;
    },
    applyToBufferAttribute: function(a) {
      for (var b = 0, c = a.count; b < c; b++)
        (Cb.x = a.getX(b)),
          (Cb.y = a.getY(b)),
          (Cb.z = a.getZ(b)),
          Cb.applyMatrix4(this),
          a.setXYZ(b, Cb.x, Cb.y, Cb.z);
      return a;
    },
    determinant: function() {
      var a = this.elements,
        b = a[0],
        c = a[4],
        d = a[8],
        e = a[12],
        f = a[1],
        h = a[5],
        k = a[9],
        l = a[13],
        m = a[2],
        n = a[6],
        q = a[10],
        t = a[14];
      return (
        a[3] *
          (+e * k * n -
            d * l * n -
            e * h * q +
            c * l * q +
            d * h * t -
            c * k * t) +
        a[7] *
          (+b * k * t -
            b * l * q +
            e * f * q -
            d * f * t +
            d * l * m -
            e * k * m) +
        a[11] *
          (+b * l * n -
            b * h * t -
            e * f * n +
            c * f * t +
            e * h * m -
            c * l * m) +
        a[15] *
          (-d * h * m -
            b * k * n +
            b * h * q +
            d * f * n -
            c * f * q +
            c * k * m)
      );
    },
    transpose: function() {
      var a = this.elements;
      var b = a[1];
      a[1] = a[4];
      a[4] = b;
      b = a[2];
      a[2] = a[8];
      a[8] = b;
      b = a[6];
      a[6] = a[9];
      a[9] = b;
      b = a[3];
      a[3] = a[12];
      a[12] = b;
      b = a[7];
      a[7] = a[13];
      a[13] = b;
      b = a[11];
      a[11] = a[14];
      a[14] = b;
      return this;
    },
    setPosition: function(a, b, c) {
      var d = this.elements;
      a.isVector3
        ? ((d[12] = a.x), (d[13] = a.y), (d[14] = a.z))
        : ((d[12] = a), (d[13] = b), (d[14] = c));
      return this;
    },
    getInverse: function(a, b) {
      var c = this.elements,
        d = a.elements;
      a = d[0];
      var e = d[1],
        f = d[2],
        h = d[3],
        k = d[4],
        l = d[5],
        m = d[6],
        n = d[7],
        q = d[8],
        t = d[9],
        r = d[10],
        u = d[11],
        v = d[12],
        A = d[13],
        C = d[14];
      d = d[15];
      var z =
          t * C * n - A * r * n + A * m * u - l * C * u - t * m * d + l * r * d,
        H =
          v * r * n - q * C * n - v * m * u + k * C * u + q * m * d - k * r * d,
        N =
          q * A * n - v * t * n + v * l * u - k * A * u - q * l * d + k * t * d,
        B =
          v * t * m - q * A * m - v * l * r + k * A * r + q * l * C - k * t * C,
        D = a * z + e * H + f * N + h * B;
      if (0 === D) {
        if (!0 === b)
          throw Error(
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
          );
        console.warn(
          "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
        );
        return this.identity();
      }
      b = 1 / D;
      c[0] = z * b;
      c[1] =
        (A * r * h -
          t * C * h -
          A * f * u +
          e * C * u +
          t * f * d -
          e * r * d) *
        b;
      c[2] =
        (l * C * h -
          A * m * h +
          A * f * n -
          e * C * n -
          l * f * d +
          e * m * d) *
        b;
      c[3] =
        (t * m * h -
          l * r * h -
          t * f * n +
          e * r * n +
          l * f * u -
          e * m * u) *
        b;
      c[4] = H * b;
      c[5] =
        (q * C * h -
          v * r * h +
          v * f * u -
          a * C * u -
          q * f * d +
          a * r * d) *
        b;
      c[6] =
        (v * m * h -
          k * C * h -
          v * f * n +
          a * C * n +
          k * f * d -
          a * m * d) *
        b;
      c[7] =
        (k * r * h -
          q * m * h +
          q * f * n -
          a * r * n -
          k * f * u +
          a * m * u) *
        b;
      c[8] = N * b;
      c[9] =
        (v * t * h -
          q * A * h -
          v * e * u +
          a * A * u +
          q * e * d -
          a * t * d) *
        b;
      c[10] =
        (k * A * h -
          v * l * h +
          v * e * n -
          a * A * n -
          k * e * d +
          a * l * d) *
        b;
      c[11] =
        (q * l * h -
          k * t * h -
          q * e * n +
          a * t * n +
          k * e * u -
          a * l * u) *
        b;
      c[12] = B * b;
      c[13] =
        (q * A * f -
          v * t * f +
          v * e * r -
          a * A * r -
          q * e * C +
          a * t * C) *
        b;
      c[14] =
        (v * l * f -
          k * A * f -
          v * e * m +
          a * A * m +
          k * e * C -
          a * l * C) *
        b;
      c[15] =
        (k * t * f -
          q * l * f +
          q * e * m -
          a * t * m -
          k * e * r +
          a * l * r) *
        b;
      return this;
    },
    scale: function(a) {
      var b = this.elements,
        c = a.x,
        d = a.y;
      a = a.z;
      b[0] *= c;
      b[4] *= d;
      b[8] *= a;
      b[1] *= c;
      b[5] *= d;
      b[9] *= a;
      b[2] *= c;
      b[6] *= d;
      b[10] *= a;
      b[3] *= c;
      b[7] *= d;
      b[11] *= a;
      return this;
    },
    getMaxScaleOnAxis: function() {
      var a = this.elements;
      return Math.sqrt(
        Math.max(
          a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
          a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
          a[8] * a[8] + a[9] * a[9] + a[10] * a[10]
        )
      );
    },
    makeTranslation: function(a, b, c) {
      this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
      return this;
    },
    makeRotationX: function(a) {
      var b = Math.cos(a);
      a = Math.sin(a);
      this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationY: function(a) {
      var b = Math.cos(a);
      a = Math.sin(a);
      this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationZ: function(a) {
      var b = Math.cos(a);
      a = Math.sin(a);
      this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationAxis: function(a, b) {
      var c = Math.cos(b);
      b = Math.sin(b);
      var d = 1 - c,
        e = a.x,
        f = a.y;
      a = a.z;
      var h = d * e,
        k = d * f;
      this.set(
        h * e + c,
        h * f - b * a,
        h * a + b * f,
        0,
        h * f + b * a,
        k * f + c,
        k * a - b * e,
        0,
        h * a - b * f,
        k * a + b * e,
        d * a * a + c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    },
    makeScale: function(a, b, c) {
      this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeShear: function(a, b, c) {
      this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
      return this;
    },
    compose: function(a, b, c) {
      var d = this.elements,
        e = b._x,
        f = b._y,
        h = b._z,
        k = b._w,
        l = e + e,
        m = f + f,
        n = h + h;
      b = e * l;
      var q = e * m;
      e *= n;
      var t = f * m;
      f *= n;
      h *= n;
      l *= k;
      m *= k;
      k *= n;
      n = c.x;
      var r = c.y;
      c = c.z;
      d[0] = (1 - (t + h)) * n;
      d[1] = (q + k) * n;
      d[2] = (e - m) * n;
      d[3] = 0;
      d[4] = (q - k) * r;
      d[5] = (1 - (b + h)) * r;
      d[6] = (f + l) * r;
      d[7] = 0;
      d[8] = (e + m) * c;
      d[9] = (f - l) * c;
      d[10] = (1 - (b + t)) * c;
      d[11] = 0;
      d[12] = a.x;
      d[13] = a.y;
      d[14] = a.z;
      d[15] = 1;
      return this;
    },
    decompose: function(a, b, c) {
      var d = this.elements,
        e = Cb.set(d[0], d[1], d[2]).length(),
        f = Cb.set(d[4], d[5], d[6]).length(),
        h = Cb.set(d[8], d[9], d[10]).length();
      0 > this.determinant() && (e = -e);
      a.x = d[12];
      a.y = d[13];
      a.z = d[14];
      Aa.copy(this);
      a = 1 / e;
      d = 1 / f;
      var k = 1 / h;
      Aa.elements[0] *= a;
      Aa.elements[1] *= a;
      Aa.elements[2] *= a;
      Aa.elements[4] *= d;
      Aa.elements[5] *= d;
      Aa.elements[6] *= d;
      Aa.elements[8] *= k;
      Aa.elements[9] *= k;
      Aa.elements[10] *= k;
      b.setFromRotationMatrix(Aa);
      c.x = e;
      c.y = f;
      c.z = h;
      return this;
    },
    makePerspective: function(a, b, c, d, e, f) {
      void 0 === f &&
        console.warn(
          "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
        );
      var h = this.elements;
      h[0] = (2 * e) / (b - a);
      h[4] = 0;
      h[8] = (b + a) / (b - a);
      h[12] = 0;
      h[1] = 0;
      h[5] = (2 * e) / (c - d);
      h[9] = (c + d) / (c - d);
      h[13] = 0;
      h[2] = 0;
      h[6] = 0;
      h[10] = -(f + e) / (f - e);
      h[14] = (-2 * f * e) / (f - e);
      h[3] = 0;
      h[7] = 0;
      h[11] = -1;
      h[15] = 0;
      return this;
    },
    makeOrthographic: function(a, b, c, d, e, f) {
      var h = this.elements,
        k = 1 / (b - a),
        l = 1 / (c - d),
        m = 1 / (f - e);
      h[0] = 2 * k;
      h[4] = 0;
      h[8] = 0;
      h[12] = -((b + a) * k);
      h[1] = 0;
      h[5] = 2 * l;
      h[9] = 0;
      h[13] = -((c + d) * l);
      h[2] = 0;
      h[6] = 0;
      h[10] = -2 * m;
      h[14] = -((f + e) * m);
      h[3] = 0;
      h[7] = 0;
      h[11] = 0;
      h[15] = 1;
      return this;
    },
    equals: function(a) {
      var b = this.elements;
      a = a.elements;
      for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return !1;
      return !0;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      var c = this.elements;
      a[b] = c[0];
      a[b + 1] = c[1];
      a[b + 2] = c[2];
      a[b + 3] = c[3];
      a[b + 4] = c[4];
      a[b + 5] = c[5];
      a[b + 6] = c[6];
      a[b + 7] = c[7];
      a[b + 8] = c[8];
      a[b + 9] = c[9];
      a[b + 10] = c[10];
      a[b + 11] = c[11];
      a[b + 12] = c[12];
      a[b + 13] = c[13];
      a[b + 14] = c[14];
      a[b + 15] = c[15];
      return a;
    }
  });
  var Am = new fa(),
    Bm = new mb();
  Od.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
  Od.DefaultOrder = "XYZ";
  Object.defineProperties(Od.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(a) {
        this._x = a;
        this._onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(a) {
        this._y = a;
        this._onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(a) {
        this._z = a;
        this._onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(a) {
        this._order = a;
        this._onChangeCallback();
      }
    }
  });
  Object.assign(Od.prototype, {
    isEuler: !0,
    set: function(a, b, c, d) {
      this._x = a;
      this._y = b;
      this._z = c;
      this._order = d || this._order;
      this._onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(a) {
      this._x = a._x;
      this._y = a._y;
      this._z = a._z;
      this._order = a._order;
      this._onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(a, b, c) {
      var d = ca.clamp,
        e = a.elements;
      a = e[0];
      var f = e[4],
        h = e[8],
        k = e[1],
        l = e[5],
        m = e[9],
        n = e[2],
        q = e[6];
      e = e[10];
      b = b || this._order;
      "XYZ" === b
        ? ((this._y = Math.asin(d(h, -1, 1))),
          0.9999999 > Math.abs(h)
            ? ((this._x = Math.atan2(-m, e)), (this._z = Math.atan2(-f, a)))
            : ((this._x = Math.atan2(q, l)), (this._z = 0)))
        : "YXZ" === b
        ? ((this._x = Math.asin(-d(m, -1, 1))),
          0.9999999 > Math.abs(m)
            ? ((this._y = Math.atan2(h, e)), (this._z = Math.atan2(k, l)))
            : ((this._y = Math.atan2(-n, a)), (this._z = 0)))
        : "ZXY" === b
        ? ((this._x = Math.asin(d(q, -1, 1))),
          0.9999999 > Math.abs(q)
            ? ((this._y = Math.atan2(-n, e)), (this._z = Math.atan2(-f, l)))
            : ((this._y = 0), (this._z = Math.atan2(k, a))))
        : "ZYX" === b
        ? ((this._y = Math.asin(-d(n, -1, 1))),
          0.9999999 > Math.abs(n)
            ? ((this._x = Math.atan2(q, e)), (this._z = Math.atan2(k, a)))
            : ((this._x = 0), (this._z = Math.atan2(-f, l))))
        : "YZX" === b
        ? ((this._z = Math.asin(d(k, -1, 1))),
          0.9999999 > Math.abs(k)
            ? ((this._x = Math.atan2(-m, l)), (this._y = Math.atan2(-n, a)))
            : ((this._x = 0), (this._y = Math.atan2(h, e))))
        : "XZY" === b
        ? ((this._z = Math.asin(-d(f, -1, 1))),
          0.9999999 > Math.abs(f)
            ? ((this._x = Math.atan2(q, l)), (this._y = Math.atan2(h, a)))
            : ((this._x = Math.atan2(-m, e)), (this._y = 0)))
        : console.warn(
            "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
              b
          );
      this._order = b;
      !1 !== c && this._onChangeCallback();
      return this;
    },
    setFromQuaternion: function(a, b, c) {
      Am.makeRotationFromQuaternion(a);
      return this.setFromRotationMatrix(Am, b, c);
    },
    setFromVector3: function(a, b) {
      return this.set(a.x, a.y, a.z, b || this._order);
    },
    reorder: function(a) {
      Bm.setFromEuler(this);
      return this.setFromQuaternion(Bm, a);
    },
    equals: function(a) {
      return (
        a._x === this._x &&
        a._y === this._y &&
        a._z === this._z &&
        a._order === this._order
      );
    },
    fromArray: function(a) {
      this._x = a[0];
      this._y = a[1];
      this._z = a[2];
      void 0 !== a[3] && (this._order = a[3]);
      this._onChangeCallback();
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this._x;
      a[b + 1] = this._y;
      a[b + 2] = this._z;
      a[b + 3] = this._order;
      return a;
    },
    toVector3: function(a) {
      return a
        ? a.set(this._x, this._y, this._z)
        : new r(this._x, this._y, this._z);
    },
    _onChange: function(a) {
      this._onChangeCallback = a;
      return this;
    },
    _onChangeCallback: function() {}
  });
  Object.assign($k.prototype, {
    set: function(a) {
      this.mask = (1 << a) | 0;
    },
    enable: function(a) {
      this.mask = this.mask | (1 << a) | 0;
    },
    enableAll: function() {
      this.mask = -1;
    },
    toggle: function(a) {
      this.mask ^= (1 << a) | 0;
    },
    disable: function(a) {
      this.mask &= ~((1 << a) | 0);
    },
    disableAll: function() {
      this.mask = 0;
    },
    test: function(a) {
      return 0 !== (this.mask & a.mask);
    }
  });
  var on = 0,
    Cm = new r(),
    Ie = new mb(),
    Id = new fa(),
    ng = new r(),
    tf = new r(),
    Vo = new r(),
    Wo = new mb(),
    Dm = new r(1, 0, 0),
    Em = new r(0, 1, 0),
    Fm = new r(0, 0, 1),
    Xo = { type: "added" },
    Yo = { type: "removed" };
  D.DefaultUp = new r(0, 1, 0);
  D.DefaultMatrixAutoUpdate = !0;
  D.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: D,
    isObject3D: !0,
    onBeforeRender: function() {},
    onAfterRender: function() {},
    applyMatrix: function(a) {
      this.matrixAutoUpdate && this.updateMatrix();
      this.matrix.premultiply(a);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(a) {
      this.quaternion.premultiply(a);
      return this;
    },
    setRotationFromAxisAngle: function(a, b) {
      this.quaternion.setFromAxisAngle(a, b);
    },
    setRotationFromEuler: function(a) {
      this.quaternion.setFromEuler(a, !0);
    },
    setRotationFromMatrix: function(a) {
      this.quaternion.setFromRotationMatrix(a);
    },
    setRotationFromQuaternion: function(a) {
      this.quaternion.copy(a);
    },
    rotateOnAxis: function(a, b) {
      Ie.setFromAxisAngle(a, b);
      this.quaternion.multiply(Ie);
      return this;
    },
    rotateOnWorldAxis: function(a, b) {
      Ie.setFromAxisAngle(a, b);
      this.quaternion.premultiply(Ie);
      return this;
    },
    rotateX: function(a) {
      return this.rotateOnAxis(Dm, a);
    },
    rotateY: function(a) {
      return this.rotateOnAxis(Em, a);
    },
    rotateZ: function(a) {
      return this.rotateOnAxis(Fm, a);
    },
    translateOnAxis: function(a, b) {
      Cm.copy(a).applyQuaternion(this.quaternion);
      this.position.add(Cm.multiplyScalar(b));
      return this;
    },
    translateX: function(a) {
      return this.translateOnAxis(Dm, a);
    },
    translateY: function(a) {
      return this.translateOnAxis(Em, a);
    },
    translateZ: function(a) {
      return this.translateOnAxis(Fm, a);
    },
    localToWorld: function(a) {
      return a.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(a) {
      return a.applyMatrix4(Id.getInverse(this.matrixWorld));
    },
    lookAt: function(a, b, c) {
      a.isVector3 ? ng.copy(a) : ng.set(a, b, c);
      a = this.parent;
      this.updateWorldMatrix(!0, !1);
      tf.setFromMatrixPosition(this.matrixWorld);
      this.isCamera || this.isLight
        ? Id.lookAt(tf, ng, this.up)
        : Id.lookAt(ng, tf, this.up);
      this.quaternion.setFromRotationMatrix(Id);
      a &&
        (Id.extractRotation(a.matrixWorld),
        Ie.setFromRotationMatrix(Id),
        this.quaternion.premultiply(Ie.inverse()));
    },
    add: function(a) {
      if (1 < arguments.length) {
        for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
        return this;
      }
      if (a === this)
        return (
          console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            a
          ),
          this
        );
      a && a.isObject3D
        ? (null !== a.parent && a.parent.remove(a),
          (a.parent = this),
          this.children.push(a),
          a.dispatchEvent(Xo))
        : console.error(
            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
            a
          );
      return this;
    },
    remove: function(a) {
      if (1 < arguments.length) {
        for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
        return this;
      }
      b = this.children.indexOf(a);
      -1 !== b &&
        ((a.parent = null), this.children.splice(b, 1), a.dispatchEvent(Yo));
      return this;
    },
    attach: function(a) {
      this.updateWorldMatrix(!0, !1);
      Id.getInverse(this.matrixWorld);
      null !== a.parent &&
        (a.parent.updateWorldMatrix(!0, !1), Id.multiply(a.parent.matrixWorld));
      a.applyMatrix(Id);
      a.updateWorldMatrix(!1, !1);
      this.add(a);
      return this;
    },
    getObjectById: function(a) {
      return this.getObjectByProperty("id", a);
    },
    getObjectByName: function(a) {
      return this.getObjectByProperty("name", a);
    },
    getObjectByProperty: function(a, b) {
      if (this[a] === b) return this;
      for (var c = 0, d = this.children.length; c < d; c++) {
        var e = this.children[c].getObjectByProperty(a, b);
        if (void 0 !== e) return e;
      }
    },
    getWorldPosition: function(a) {
      void 0 === a &&
        (console.warn(
          "THREE.Object3D: .getWorldPosition() target is now required"
        ),
        (a = new r()));
      this.updateMatrixWorld(!0);
      return a.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(a) {
      void 0 === a &&
        (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ),
        (a = new mb()));
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(tf, a, Vo);
      return a;
    },
    getWorldScale: function(a) {
      void 0 === a &&
        (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ),
        (a = new r()));
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(tf, Wo, a);
      return a;
    },
    getWorldDirection: function(a) {
      void 0 === a &&
        (console.warn(
          "THREE.Object3D: .getWorldDirection() target is now required"
        ),
        (a = new r()));
      this.updateMatrixWorld(!0);
      var b = this.matrixWorld.elements;
      return a.set(b[8], b[9], b[10]).normalize();
    },
    raycast: function() {},
    traverse: function(a) {
      a(this);
      for (var b = this.children, c = 0, d = b.length; c < d; c++)
        b[c].traverse(a);
    },
    traverseVisible: function(a) {
      if (!1 !== this.visible) {
        a(this);
        for (var b = this.children, c = 0, d = b.length; c < d; c++)
          b[c].traverseVisible(a);
      }
    },
    traverseAncestors: function(a) {
      var b = this.parent;
      null !== b && (a(b), b.traverseAncestors(a));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(a) {
      this.matrixAutoUpdate && this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || a)
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
          (this.matrixWorldNeedsUpdate = !1),
          (a = !0);
      for (var b = this.children, c = 0, d = b.length; c < d; c++)
        b[c].updateMatrixWorld(a);
    },
    updateWorldMatrix: function(a, b) {
      var c = this.parent;
      !0 === a && null !== c && c.updateWorldMatrix(!0, !1);
      this.matrixAutoUpdate && this.updateMatrix();
      null === this.parent
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          );
      if (!0 === b)
        for (a = this.children, b = 0, c = a.length; b < c; b++)
          a[b].updateWorldMatrix(!1, !0);
    },
    toJSON: function(a) {
      function b(b, c) {
        void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
        return c.uuid;
      }
      function c(a) {
        var b = [],
          c;
        for (c in a) {
          var d = a[c];
          delete d.metadata;
          b.push(d);
        }
        return b;
      }
      var d = void 0 === a || "string" === typeof a,
        e = {};
      d &&
        ((a = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {}
        }),
        (e.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        }));
      var f = {};
      f.uuid = this.uuid;
      f.type = this.type;
      "" !== this.name && (f.name = this.name);
      !0 === this.castShadow && (f.castShadow = !0);
      !0 === this.receiveShadow && (f.receiveShadow = !0);
      !1 === this.visible && (f.visible = !1);
      !1 === this.frustumCulled && (f.frustumCulled = !1);
      0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
      "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
      f.layers = this.layers.mask;
      f.matrix = this.matrix.toArray();
      !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1);
      this.isMesh && 0 !== this.drawMode && (f.drawMode = this.drawMode);
      if (this.isMesh || this.isLine || this.isPoints) {
        f.geometry = b(a.geometries, this.geometry);
        var h = this.geometry.parameters;
        if (void 0 !== h && void 0 !== h.shapes)
          if (((h = h.shapes), Array.isArray(h)))
            for (var k = 0, l = h.length; k < l; k++) b(a.shapes, h[k]);
          else b(a.shapes, h);
      }
      if (void 0 !== this.material)
        if (Array.isArray(this.material)) {
          h = [];
          k = 0;
          for (l = this.material.length; k < l; k++)
            h.push(b(a.materials, this.material[k]));
          f.material = h;
        } else f.material = b(a.materials, this.material);
      if (0 < this.children.length)
        for (f.children = [], k = 0; k < this.children.length; k++)
          f.children.push(this.children[k].toJSON(a).object);
      if (d) {
        d = c(a.geometries);
        k = c(a.materials);
        l = c(a.textures);
        var m = c(a.images);
        h = c(a.shapes);
        0 < d.length && (e.geometries = d);
        0 < k.length && (e.materials = k);
        0 < l.length && (e.textures = l);
        0 < m.length && (e.images = m);
        0 < h.length && (e.shapes = h);
      }
      e.object = f;
      return e;
    },
    clone: function(a) {
      return new this.constructor().copy(this, a);
    },
    copy: function(a, b) {
      void 0 === b && (b = !0);
      this.name = a.name;
      this.up.copy(a.up);
      this.position.copy(a.position);
      this.quaternion.copy(a.quaternion);
      this.scale.copy(a.scale);
      this.matrix.copy(a.matrix);
      this.matrixWorld.copy(a.matrixWorld);
      this.matrixAutoUpdate = a.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
      this.layers.mask = a.layers.mask;
      this.visible = a.visible;
      this.castShadow = a.castShadow;
      this.receiveShadow = a.receiveShadow;
      this.frustumCulled = a.frustumCulled;
      this.renderOrder = a.renderOrder;
      this.userData = JSON.parse(JSON.stringify(a.userData));
      if (!0 === b)
        for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
      return this;
    }
  });
  Kf.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Kf,
    isScene: !0,
    copy: function(a, b) {
      D.prototype.copy.call(this, a, b);
      null !== a.background && (this.background = a.background.clone());
      null !== a.fog && (this.fog = a.fog.clone());
      null !== a.overrideMaterial &&
        (this.overrideMaterial = a.overrideMaterial.clone());
      this.autoUpdate = a.autoUpdate;
      this.matrixAutoUpdate = a.matrixAutoUpdate;
      return this;
    },
    toJSON: function(a) {
      var b = D.prototype.toJSON.call(this, a);
      null !== this.background &&
        (b.object.background = this.background.toJSON(a));
      null !== this.fog && (b.object.fog = this.fog.toJSON());
      return b;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var Jd = [
      new r(),
      new r(),
      new r(),
      new r(),
      new r(),
      new r(),
      new r(),
      new r()
    ],
    Rc = new r(),
    og = new r(),
    ec = new r(),
    uf = new r(),
    Kd = new r(),
    Je = new r(),
    fc = new r(),
    vf = new r(),
    wf = new r(),
    pg = new r(),
    Pd = new r();
  Object.assign(dd.prototype, {
    isBox3: !0,
    set: function(a, b) {
      this.min.copy(a);
      this.max.copy(b);
      return this;
    },
    setFromArray: function(a) {
      for (
        var b = Infinity,
          c = Infinity,
          d = Infinity,
          e = -Infinity,
          f = -Infinity,
          h = -Infinity,
          k = 0,
          l = a.length;
        k < l;
        k += 3
      ) {
        var m = a[k],
          n = a[k + 1],
          q = a[k + 2];
        m < b && (b = m);
        n < c && (c = n);
        q < d && (d = q);
        m > e && (e = m);
        n > f && (f = n);
        q > h && (h = q);
      }
      this.min.set(b, c, d);
      this.max.set(e, f, h);
      return this;
    },
    setFromBufferAttribute: function(a) {
      for (
        var b = Infinity,
          c = Infinity,
          d = Infinity,
          e = -Infinity,
          f = -Infinity,
          h = -Infinity,
          k = 0,
          l = a.count;
        k < l;
        k++
      ) {
        var m = a.getX(k),
          n = a.getY(k),
          q = a.getZ(k);
        m < b && (b = m);
        n < c && (c = n);
        q < d && (d = q);
        m > e && (e = m);
        n > f && (f = n);
        q > h && (h = q);
      }
      this.min.set(b, c, d);
      this.max.set(e, f, h);
      return this;
    },
    setFromPoints: function(a) {
      this.makeEmpty();
      for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
      return this;
    },
    setFromCenterAndSize: function(a, b) {
      b = Rc.copy(b).multiplyScalar(0.5);
      this.min.copy(a).sub(b);
      this.max.copy(a).add(b);
      return this;
    },
    setFromObject: function(a) {
      this.makeEmpty();
      return this.expandByObject(a);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.min.copy(a.min);
      this.max.copy(a.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    },
    isEmpty: function() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    },
    getCenter: function(a) {
      void 0 === a &&
        (console.warn("THREE.Box3: .getCenter() target is now required"),
        (a = new r()));
      return this.isEmpty()
        ? a.set(0, 0, 0)
        : a.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(a) {
      void 0 === a &&
        (console.warn("THREE.Box3: .getSize() target is now required"),
        (a = new r()));
      return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
      this.min.min(a);
      this.max.max(a);
      return this;
    },
    expandByVector: function(a) {
      this.min.sub(a);
      this.max.add(a);
      return this;
    },
    expandByScalar: function(a) {
      this.min.addScalar(-a);
      this.max.addScalar(a);
      return this;
    },
    expandByObject: function(a) {
      var b;
      a.updateWorldMatrix(!1, !1);
      var c = a.geometry;
      if (void 0 !== c)
        if (c.isGeometry) {
          var d = c.vertices;
          c = 0;
          for (b = d.length; c < b; c++)
            Rc.copy(d[c]),
              Rc.applyMatrix4(a.matrixWorld),
              this.expandByPoint(Rc);
        } else if (
          c.isBufferGeometry &&
          ((d = c.attributes.position), void 0 !== d)
        )
          for (c = 0, b = d.count; c < b; c++)
            Rc.fromBufferAttribute(d, c).applyMatrix4(a.matrixWorld),
              this.expandByPoint(Rc);
      a = a.children;
      c = 0;
      for (b = a.length; c < b; c++) this.expandByObject(a[c]);
      return this;
    },
    containsPoint: function(a) {
      return a.x < this.min.x ||
        a.x > this.max.x ||
        a.y < this.min.y ||
        a.y > this.max.y ||
        a.z < this.min.z ||
        a.z > this.max.z
        ? !1
        : !0;
    },
    containsBox: function(a) {
      return (
        this.min.x <= a.min.x &&
        a.max.x <= this.max.x &&
        this.min.y <= a.min.y &&
        a.max.y <= this.max.y &&
        this.min.z <= a.min.z &&
        a.max.z <= this.max.z
      );
    },
    getParameter: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Box3: .getParameter() target is now required"),
        (b = new r()));
      return b.set(
        (a.x - this.min.x) / (this.max.x - this.min.x),
        (a.y - this.min.y) / (this.max.y - this.min.y),
        (a.z - this.min.z) / (this.max.z - this.min.z)
      );
    },
    intersectsBox: function(a) {
      return a.max.x < this.min.x ||
        a.min.x > this.max.x ||
        a.max.y < this.min.y ||
        a.min.y > this.max.y ||
        a.max.z < this.min.z ||
        a.min.z > this.max.z
        ? !1
        : !0;
    },
    intersectsSphere: function(a) {
      this.clampPoint(a.center, Rc);
      return Rc.distanceToSquared(a.center) <= a.radius * a.radius;
    },
    intersectsPlane: function(a) {
      if (0 < a.normal.x) {
        var b = a.normal.x * this.min.x;
        var c = a.normal.x * this.max.x;
      } else (b = a.normal.x * this.max.x), (c = a.normal.x * this.min.x);
      0 < a.normal.y
        ? ((b += a.normal.y * this.min.y), (c += a.normal.y * this.max.y))
        : ((b += a.normal.y * this.max.y), (c += a.normal.y * this.min.y));
      0 < a.normal.z
        ? ((b += a.normal.z * this.min.z), (c += a.normal.z * this.max.z))
        : ((b += a.normal.z * this.max.z), (c += a.normal.z * this.min.z));
      return b <= -a.constant && c >= -a.constant;
    },
    intersectsTriangle: function(a) {
      if (this.isEmpty()) return !1;
      this.getCenter(vf);
      wf.subVectors(this.max, vf);
      og.subVectors(a.a, vf);
      ec.subVectors(a.b, vf);
      uf.subVectors(a.c, vf);
      Kd.subVectors(ec, og);
      Je.subVectors(uf, ec);
      fc.subVectors(og, uf);
      a = [
        0,
        -Kd.z,
        Kd.y,
        0,
        -Je.z,
        Je.y,
        0,
        -fc.z,
        fc.y,
        Kd.z,
        0,
        -Kd.x,
        Je.z,
        0,
        -Je.x,
        fc.z,
        0,
        -fc.x,
        -Kd.y,
        Kd.x,
        0,
        -Je.y,
        Je.x,
        0,
        -fc.y,
        fc.x,
        0
      ];
      if (!vj(a, og, ec, uf, wf)) return !1;
      a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!vj(a, og, ec, uf, wf)) return !1;
      pg.crossVectors(Kd, Je);
      a = [pg.x, pg.y, pg.z];
      return vj(a, og, ec, uf, wf);
    },
    clampPoint: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Box3: .clampPoint() target is now required"),
        (b = new r()));
      return b.copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function(a) {
      return Rc.copy(a)
        .clamp(this.min, this.max)
        .sub(a)
        .length();
    },
    getBoundingSphere: function(a) {
      void 0 === a &&
        console.error(
          "THREE.Box3: .getBoundingSphere() target is now required"
        );
      this.getCenter(a.center);
      a.radius = 0.5 * this.getSize(Rc).length();
      return a;
    },
    intersect: function(a) {
      this.min.max(a.min);
      this.max.min(a.max);
      this.isEmpty() && this.makeEmpty();
      return this;
    },
    union: function(a) {
      this.min.min(a.min);
      this.max.max(a.max);
      return this;
    },
    applyMatrix4: function(a) {
      if (this.isEmpty()) return this;
      Jd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
      Jd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
      Jd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
      Jd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
      Jd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
      Jd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
      Jd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
      Jd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
      this.setFromPoints(Jd);
      return this;
    },
    translate: function(a) {
      this.min.add(a);
      this.max.add(a);
      return this;
    },
    equals: function(a) {
      return a.min.equals(this.min) && a.max.equals(this.max);
    }
  });
  var Zo = new dd();
  Object.assign(ed.prototype, {
    set: function(a, b) {
      this.center.copy(a);
      this.radius = b;
      return this;
    },
    setFromPoints: function(a, b) {
      var c = this.center;
      void 0 !== b ? c.copy(b) : Zo.setFromPoints(a).getCenter(c);
      for (var d = (b = 0), e = a.length; d < e; d++)
        b = Math.max(b, c.distanceToSquared(a[d]));
      this.radius = Math.sqrt(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.center.copy(a.center);
      this.radius = a.radius;
      return this;
    },
    empty: function() {
      return 0 >= this.radius;
    },
    containsPoint: function(a) {
      return a.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(a) {
      return a.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(a) {
      var b = this.radius + a.radius;
      return a.center.distanceToSquared(this.center) <= b * b;
    },
    intersectsBox: function(a) {
      return a.intersectsSphere(this);
    },
    intersectsPlane: function(a) {
      return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(a, b) {
      var c = this.center.distanceToSquared(a);
      void 0 === b &&
        (console.warn("THREE.Sphere: .clampPoint() target is now required"),
        (b = new r()));
      b.copy(a);
      c > this.radius * this.radius &&
        (b.sub(this.center).normalize(),
        b.multiplyScalar(this.radius).add(this.center));
      return b;
    },
    getBoundingBox: function(a) {
      void 0 === a &&
        (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
        (a = new dd()));
      a.set(this.center, this.center);
      a.expandByScalar(this.radius);
      return a;
    },
    applyMatrix4: function(a) {
      this.center.applyMatrix4(a);
      this.radius *= a.getMaxScaleOnAxis();
      return this;
    },
    translate: function(a) {
      this.center.add(a);
      return this;
    },
    equals: function(a) {
      return a.center.equals(this.center) && a.radius === this.radius;
    }
  });
  var Db = new r(),
    Kh = new r(),
    xf = new r(),
    Ke = new r(),
    lk = new r(),
    qg = new r(),
    kj = new r();
  Object.assign(Ob.prototype, {
    set: function(a, b) {
      this.origin.copy(a);
      this.direction.copy(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.origin.copy(a.origin);
      this.direction.copy(a.direction);
      return this;
    },
    at: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Ray: .at() target is now required"),
        (b = new r()));
      return b
        .copy(this.direction)
        .multiplyScalar(a)
        .add(this.origin);
    },
    lookAt: function(a) {
      this.direction
        .copy(a)
        .sub(this.origin)
        .normalize();
      return this;
    },
    recast: function(a) {
      this.origin.copy(this.at(a, Db));
      return this;
    },
    closestPointToPoint: function(a, b) {
      void 0 === b &&
        (console.warn(
          "THREE.Ray: .closestPointToPoint() target is now required"
        ),
        (b = new r()));
      b.subVectors(a, this.origin);
      a = b.dot(this.direction);
      return 0 > a
        ? b.copy(this.origin)
        : b
            .copy(this.direction)
            .multiplyScalar(a)
            .add(this.origin);
    },
    distanceToPoint: function(a) {
      return Math.sqrt(this.distanceSqToPoint(a));
    },
    distanceSqToPoint: function(a) {
      var b = Db.subVectors(a, this.origin).dot(this.direction);
      if (0 > b) return this.origin.distanceToSquared(a);
      Db.copy(this.direction)
        .multiplyScalar(b)
        .add(this.origin);
      return Db.distanceToSquared(a);
    },
    distanceSqToSegment: function(a, b, c, d) {
      Kh.copy(a)
        .add(b)
        .multiplyScalar(0.5);
      xf.copy(b)
        .sub(a)
        .normalize();
      Ke.copy(this.origin).sub(Kh);
      var e = 0.5 * a.distanceTo(b),
        f = -this.direction.dot(xf),
        h = Ke.dot(this.direction),
        k = -Ke.dot(xf),
        l = Ke.lengthSq(),
        m = Math.abs(1 - f * f);
      if (0 < m) {
        a = f * k - h;
        b = f * h - k;
        var n = e * m;
        0 <= a
          ? b >= -n
            ? b <= n
              ? ((e = 1 / m),
                (a *= e),
                (b *= e),
                (f = a * (a + f * b + 2 * h) + b * (f * a + b + 2 * k) + l))
              : ((b = e),
                (a = Math.max(0, -(f * b + h))),
                (f = -a * a + b * (b + 2 * k) + l))
            : ((b = -e),
              (a = Math.max(0, -(f * b + h))),
              (f = -a * a + b * (b + 2 * k) + l))
          : b <= -n
          ? ((a = Math.max(0, -(-f * e + h))),
            (b = 0 < a ? -e : Math.min(Math.max(-e, -k), e)),
            (f = -a * a + b * (b + 2 * k) + l))
          : b <= n
          ? ((a = 0),
            (b = Math.min(Math.max(-e, -k), e)),
            (f = b * (b + 2 * k) + l))
          : ((a = Math.max(0, -(f * e + h))),
            (b = 0 < a ? e : Math.min(Math.max(-e, -k), e)),
            (f = -a * a + b * (b + 2 * k) + l));
      } else
        (b = 0 < f ? -e : e),
          (a = Math.max(0, -(f * b + h))),
          (f = -a * a + b * (b + 2 * k) + l);
      c &&
        c
          .copy(this.direction)
          .multiplyScalar(a)
          .add(this.origin);
      d &&
        d
          .copy(xf)
          .multiplyScalar(b)
          .add(Kh);
      return f;
    },
    intersectSphere: function(a, b) {
      Db.subVectors(a.center, this.origin);
      var c = Db.dot(this.direction),
        d = Db.dot(Db) - c * c;
      a = a.radius * a.radius;
      if (d > a) return null;
      a = Math.sqrt(a - d);
      d = c - a;
      c += a;
      return 0 > d && 0 > c ? null : 0 > d ? this.at(c, b) : this.at(d, b);
    },
    intersectsSphere: function(a) {
      return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
    },
    distanceToPlane: function(a) {
      var b = a.normal.dot(this.direction);
      if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
      a = -(this.origin.dot(a.normal) + a.constant) / b;
      return 0 <= a ? a : null;
    },
    intersectPlane: function(a, b) {
      a = this.distanceToPlane(a);
      return null === a ? null : this.at(a, b);
    },
    intersectsPlane: function(a) {
      var b = a.distanceToPoint(this.origin);
      return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
    },
    intersectBox: function(a, b) {
      var c = 1 / this.direction.x;
      var d = 1 / this.direction.y;
      var e = 1 / this.direction.z,
        f = this.origin;
      if (0 <= c) {
        var h = (a.min.x - f.x) * c;
        c *= a.max.x - f.x;
      } else (h = (a.max.x - f.x) * c), (c *= a.min.x - f.x);
      if (0 <= d) {
        var k = (a.min.y - f.y) * d;
        d *= a.max.y - f.y;
      } else (k = (a.max.y - f.y) * d), (d *= a.min.y - f.y);
      if (h > d || k > c) return null;
      if (k > h || h !== h) h = k;
      if (d < c || c !== c) c = d;
      0 <= e
        ? ((k = (a.min.z - f.z) * e), (a = (a.max.z - f.z) * e))
        : ((k = (a.max.z - f.z) * e), (a = (a.min.z - f.z) * e));
      if (h > a || k > c) return null;
      if (k > h || h !== h) h = k;
      if (a < c || c !== c) c = a;
      return 0 > c ? null : this.at(0 <= h ? h : c, b);
    },
    intersectsBox: function(a) {
      return null !== this.intersectBox(a, Db);
    },
    intersectTriangle: function(a, b, c, d, e) {
      lk.subVectors(b, a);
      qg.subVectors(c, a);
      kj.crossVectors(lk, qg);
      b = this.direction.dot(kj);
      if (0 < b) {
        if (d) return null;
        d = 1;
      } else if (0 > b) (d = -1), (b = -b);
      else return null;
      Ke.subVectors(this.origin, a);
      a = d * this.direction.dot(qg.crossVectors(Ke, qg));
      if (0 > a) return null;
      c = d * this.direction.dot(lk.cross(Ke));
      if (0 > c || a + c > b) return null;
      a = -d * Ke.dot(kj);
      return 0 > a ? null : this.at(a / b, e);
    },
    applyMatrix4: function(a) {
      this.origin.applyMatrix4(a);
      this.direction.transformDirection(a);
      return this;
    },
    equals: function(a) {
      return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    }
  });
  var gc = new r(),
    Sc = new r(),
    Lh = new r(),
    Tc = new r(),
    Uc = new r(),
    yf = new r(),
    Gm = new r(),
    mk = new r(),
    lj = new r(),
    mj = new r();
  Object.assign(Ma, {
    getNormal: function(a, b, c, d) {
      void 0 === d &&
        (console.warn("THREE.Triangle: .getNormal() target is now required"),
        (d = new r()));
      d.subVectors(c, b);
      gc.subVectors(a, b);
      d.cross(gc);
      a = d.lengthSq();
      return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0);
    },
    getBarycoord: function(a, b, c, d, e) {
      gc.subVectors(d, b);
      Sc.subVectors(c, b);
      Lh.subVectors(a, b);
      a = gc.dot(gc);
      b = gc.dot(Sc);
      c = gc.dot(Lh);
      var f = Sc.dot(Sc);
      d = Sc.dot(Lh);
      var h = a * f - b * b;
      void 0 === e &&
        (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
        (e = new r()));
      if (0 === h) return e.set(-2, -1, -1);
      h = 1 / h;
      f = (f * c - b * d) * h;
      a = (a * d - b * c) * h;
      return e.set(1 - f - a, a, f);
    },
    containsPoint: function(a, b, c, d) {
      Ma.getBarycoord(a, b, c, d, Tc);
      return 0 <= Tc.x && 0 <= Tc.y && 1 >= Tc.x + Tc.y;
    },
    getUV: function(a, b, c, d, e, f, h, k) {
      this.getBarycoord(a, b, c, d, Tc);
      k.set(0, 0);
      k.addScaledVector(e, Tc.x);
      k.addScaledVector(f, Tc.y);
      k.addScaledVector(h, Tc.z);
      return k;
    },
    isFrontFacing: function(a, b, c, d) {
      gc.subVectors(c, b);
      Sc.subVectors(a, b);
      return 0 > gc.cross(Sc).dot(d) ? !0 : !1;
    }
  });
  Object.assign(Ma.prototype, {
    set: function(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    },
    setFromPointsAndIndices: function(a, b, c, d) {
      this.a.copy(a[b]);
      this.b.copy(a[c]);
      this.c.copy(a[d]);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.a.copy(a.a);
      this.b.copy(a.b);
      this.c.copy(a.c);
      return this;
    },
    getArea: function() {
      gc.subVectors(this.c, this.b);
      Sc.subVectors(this.a, this.b);
      return 0.5 * gc.cross(Sc).length();
    },
    getMidpoint: function(a) {
      void 0 === a &&
        (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
        (a = new r()));
      return a
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    },
    getNormal: function(a) {
      return Ma.getNormal(this.a, this.b, this.c, a);
    },
    getPlane: function(a) {
      void 0 === a &&
        (console.warn("THREE.Triangle: .getPlane() target is now required"),
        (a = new r()));
      return a.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(a, b) {
      return Ma.getBarycoord(a, this.a, this.b, this.c, b);
    },
    getUV: function(a, b, c, d, e) {
      return Ma.getUV(a, this.a, this.b, this.c, b, c, d, e);
    },
    containsPoint: function(a) {
      return Ma.containsPoint(a, this.a, this.b, this.c);
    },
    isFrontFacing: function(a) {
      return Ma.isFrontFacing(this.a, this.b, this.c, a);
    },
    intersectsBox: function(a) {
      return a.intersectsTriangle(this);
    },
    closestPointToPoint: function(a, b) {
      void 0 === b &&
        (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ),
        (b = new r()));
      var c = this.a,
        d = this.b,
        e = this.c;
      Uc.subVectors(d, c);
      yf.subVectors(e, c);
      mk.subVectors(a, c);
      var f = Uc.dot(mk),
        h = yf.dot(mk);
      if (0 >= f && 0 >= h) return b.copy(c);
      lj.subVectors(a, d);
      var k = Uc.dot(lj),
        l = yf.dot(lj);
      if (0 <= k && l <= k) return b.copy(d);
      var m = f * l - k * h;
      if (0 >= m && 0 <= f && 0 >= k)
        return (d = f / (f - k)), b.copy(c).addScaledVector(Uc, d);
      mj.subVectors(a, e);
      a = Uc.dot(mj);
      var n = yf.dot(mj);
      if (0 <= n && a <= n) return b.copy(e);
      f = a * h - f * n;
      if (0 >= f && 0 <= h && 0 >= n)
        return (m = h / (h - n)), b.copy(c).addScaledVector(yf, m);
      h = k * n - a * l;
      if (0 >= h && 0 <= l - k && 0 <= a - n)
        return (
          Gm.subVectors(e, d),
          (m = (l - k) / (l - k + (a - n))),
          b.copy(d).addScaledVector(Gm, m)
        );
      e = 1 / (h + f + m);
      d = f * e;
      m *= e;
      return b
        .copy(c)
        .addScaledVector(Uc, d)
        .addScaledVector(yf, m);
    },
    equals: function(a) {
      return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
    }
  });
  var $o = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    },
    rb = { h: 0, s: 0, l: 0 },
    rg = { h: 0, s: 0, l: 0 };
  Object.assign(L.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
      a && a.isColor
        ? this.copy(a)
        : "number" === typeof a
        ? this.setHex(a)
        : "string" === typeof a && this.setStyle(a);
      return this;
    },
    setScalar: function(a) {
      this.b = this.g = this.r = a;
      return this;
    },
    setHex: function(a) {
      a = Math.floor(a);
      this.r = ((a >> 16) & 255) / 255;
      this.g = ((a >> 8) & 255) / 255;
      this.b = (a & 255) / 255;
      return this;
    },
    setRGB: function(a, b, c) {
      this.r = a;
      this.g = b;
      this.b = c;
      return this;
    },
    setHSL: function(a, b, c) {
      a = ca.euclideanModulo(a, 1);
      b = ca.clamp(b, 0, 1);
      c = ca.clamp(c, 0, 1);
      0 === b
        ? (this.r = this.g = this.b = c)
        : ((b = 0.5 >= c ? c * (1 + b) : c + b - c * b),
          (c = 2 * c - b),
          (this.r = Eg(c, b, a + 1 / 3)),
          (this.g = Eg(c, b, a)),
          (this.b = Eg(c, b, a - 1 / 3)));
      return this;
    },
    setStyle: function(a) {
      function b(b) {
        void 0 !== b &&
          1 > parseFloat(b) &&
          console.warn(
            "THREE.Color: Alpha component of " + a + " will be ignored."
          );
      }
      var c;
      if ((c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a))) {
        var d = c[2];
        switch (c[1]) {
          case "rgb":
          case "rgba":
            if (
              (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                d
              ))
            )
              return (
                (this.r = Math.min(255, parseInt(c[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(c[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(c[3], 10)) / 255),
                b(c[5]),
                this
              );
            if (
              (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                d
              ))
            )
              return (
                (this.r = Math.min(100, parseInt(c[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(c[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(c[3], 10)) / 100),
                b(c[5]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                d
              ))
            ) {
              d = parseFloat(c[1]) / 360;
              var e = parseInt(c[2], 10) / 100,
                f = parseInt(c[3], 10) / 100;
              b(c[5]);
              return this.setHSL(d, e, f);
            }
        }
      } else if ((c = /^#([A-Fa-f0-9]+)$/.exec(a))) {
        c = c[1];
        d = c.length;
        if (3 === d)
          return (
            (this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255),
            (this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255),
            (this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255),
            this
          );
        if (6 === d)
          return (
            (this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255),
            (this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255),
            (this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255),
            this
          );
      }
      a &&
        0 < a.length &&
        ((c = $o[a]),
        void 0 !== c
          ? this.setHex(c)
          : console.warn("THREE.Color: Unknown color " + a));
      return this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(a) {
      this.r = a.r;
      this.g = a.g;
      this.b = a.b;
      return this;
    },
    copyGammaToLinear: function(a, b) {
      void 0 === b && (b = 2);
      this.r = Math.pow(a.r, b);
      this.g = Math.pow(a.g, b);
      this.b = Math.pow(a.b, b);
      return this;
    },
    copyLinearToGamma: function(a, b) {
      void 0 === b && (b = 2);
      b = 0 < b ? 1 / b : 1;
      this.r = Math.pow(a.r, b);
      this.g = Math.pow(a.g, b);
      this.b = Math.pow(a.b, b);
      return this;
    },
    convertGammaToLinear: function(a) {
      this.copyGammaToLinear(this, a);
      return this;
    },
    convertLinearToGamma: function(a) {
      this.copyLinearToGamma(this, a);
      return this;
    },
    copySRGBToLinear: function(a) {
      this.r = wj(a.r);
      this.g = wj(a.g);
      this.b = wj(a.b);
      return this;
    },
    copyLinearToSRGB: function(a) {
      this.r = xj(a.r);
      this.g = xj(a.g);
      this.b = xj(a.b);
      return this;
    },
    convertSRGBToLinear: function() {
      this.copySRGBToLinear(this);
      return this;
    },
    convertLinearToSRGB: function() {
      this.copyLinearToSRGB(this);
      return this;
    },
    getHex: function() {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(a) {
      void 0 === a &&
        (console.warn("THREE.Color: .getHSL() target is now required"),
        (a = { h: 0, s: 0, l: 0 }));
      var b = this.r,
        c = this.g,
        d = this.b,
        e = Math.max(b, c, d),
        f = Math.min(b, c, d),
        h,
        k = (f + e) / 2;
      if (f === e) f = h = 0;
      else {
        var l = e - f;
        f = 0.5 >= k ? l / (e + f) : l / (2 - e - f);
        switch (e) {
          case b:
            h = (c - d) / l + (c < d ? 6 : 0);
            break;
          case c:
            h = (d - b) / l + 2;
            break;
          case d:
            h = (b - c) / l + 4;
        }
        h /= 6;
      }
      a.h = h;
      a.s = f;
      a.l = k;
      return a;
    },
    getStyle: function() {
      return (
        "rgb(" +
        ((255 * this.r) | 0) +
        "," +
        ((255 * this.g) | 0) +
        "," +
        ((255 * this.b) | 0) +
        ")"
      );
    },
    offsetHSL: function(a, b, c) {
      this.getHSL(rb);
      rb.h += a;
      rb.s += b;
      rb.l += c;
      this.setHSL(rb.h, rb.s, rb.l);
      return this;
    },
    add: function(a) {
      this.r += a.r;
      this.g += a.g;
      this.b += a.b;
      return this;
    },
    addColors: function(a, b) {
      this.r = a.r + b.r;
      this.g = a.g + b.g;
      this.b = a.b + b.b;
      return this;
    },
    addScalar: function(a) {
      this.r += a;
      this.g += a;
      this.b += a;
      return this;
    },
    sub: function(a) {
      this.r = Math.max(0, this.r - a.r);
      this.g = Math.max(0, this.g - a.g);
      this.b = Math.max(0, this.b - a.b);
      return this;
    },
    multiply: function(a) {
      this.r *= a.r;
      this.g *= a.g;
      this.b *= a.b;
      return this;
    },
    multiplyScalar: function(a) {
      this.r *= a;
      this.g *= a;
      this.b *= a;
      return this;
    },
    lerp: function(a, b) {
      this.r += (a.r - this.r) * b;
      this.g += (a.g - this.g) * b;
      this.b += (a.b - this.b) * b;
      return this;
    },
    lerpHSL: function(a, b) {
      this.getHSL(rb);
      a.getHSL(rg);
      a = ca.lerp(rb.h, rg.h, b);
      var c = ca.lerp(rb.s, rg.s, b);
      b = ca.lerp(rb.l, rg.l, b);
      this.setHSL(a, c, b);
      return this;
    },
    equals: function(a) {
      return a.r === this.r && a.g === this.g && a.b === this.b;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.r = a[b];
      this.g = a[b + 1];
      this.b = a[b + 2];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.r;
      a[b + 1] = this.g;
      a[b + 2] = this.b;
      return a;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  Object.assign(Lf.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.a = a.a;
      this.b = a.b;
      this.c = a.c;
      this.normal.copy(a.normal);
      this.color.copy(a.color);
      this.materialIndex = a.materialIndex;
      for (var b = 0, c = a.vertexNormals.length; b < c; b++)
        this.vertexNormals[b] = a.vertexNormals[b].clone();
      b = 0;
      for (c = a.vertexColors.length; b < c; b++)
        this.vertexColors[b] = a.vertexColors[b].clone();
      return this;
    }
  });
  var pn = 0;
  T.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: T,
    isMaterial: !0,
    onBeforeCompile: function() {},
    setValues: function(a) {
      if (void 0 !== a)
        for (var b in a) {
          var c = a[b];
          if (void 0 === c)
            console.warn("THREE.Material: '" + b + "' parameter is undefined.");
          else if ("shading" === b)
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === c ? !0 : !1);
          else {
            var d = this[b];
            void 0 === d
              ? console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    b +
                    "' is not a property of this material."
                )
              : d && d.isColor
              ? d.set(c)
              : d && d.isVector3 && c && c.isVector3
              ? d.copy(c)
              : (this[b] = c);
          }
        }
    },
    toJSON: function(a) {
      function b(a) {
        var b = [],
          c;
        for (c in a) {
          var d = a[c];
          delete d.metadata;
          b.push(d);
        }
        return b;
      }
      var c = void 0 === a || "string" === typeof a;
      c && (a = { textures: {}, images: {} });
      var d = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      d.uuid = this.uuid;
      d.type = this.type;
      "" !== this.name && (d.name = this.name);
      this.color && this.color.isColor && (d.color = this.color.getHex());
      void 0 !== this.roughness && (d.roughness = this.roughness);
      void 0 !== this.metalness && (d.metalness = this.metalness);
      this.sheen && this.sheen.isColor && (d.sheen = this.sheen.getHex());
      this.emissive &&
        this.emissive.isColor &&
        (d.emissive = this.emissive.getHex());
      this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (d.emissiveIntensity = this.emissiveIntensity);
      this.specular &&
        this.specular.isColor &&
        (d.specular = this.specular.getHex());
      void 0 !== this.shininess && (d.shininess = this.shininess);
      void 0 !== this.clearcoat && (d.clearcoat = this.clearcoat);
      void 0 !== this.clearcoatRoughness &&
        (d.clearcoatRoughness = this.clearcoatRoughness);
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((d.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid),
        (d.clearcoatNormalScale = this.clearcoatNormalScale.toArray()));
      this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
      this.matcap &&
        this.matcap.isTexture &&
        (d.matcap = this.matcap.toJSON(a).uuid);
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (d.alphaMap = this.alphaMap.toJSON(a).uuid);
      this.lightMap &&
        this.lightMap.isTexture &&
        (d.lightMap = this.lightMap.toJSON(a).uuid);
      this.aoMap &&
        this.aoMap.isTexture &&
        ((d.aoMap = this.aoMap.toJSON(a).uuid),
        (d.aoMapIntensity = this.aoMapIntensity));
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((d.bumpMap = this.bumpMap.toJSON(a).uuid),
        (d.bumpScale = this.bumpScale));
      this.normalMap &&
        this.normalMap.isTexture &&
        ((d.normalMap = this.normalMap.toJSON(a).uuid),
        (d.normalMapType = this.normalMapType),
        (d.normalScale = this.normalScale.toArray()));
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((d.displacementMap = this.displacementMap.toJSON(a).uuid),
        (d.displacementScale = this.displacementScale),
        (d.displacementBias = this.displacementBias));
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
      this.specularMap &&
        this.specularMap.isTexture &&
        (d.specularMap = this.specularMap.toJSON(a).uuid);
      this.envMap &&
        this.envMap.isTexture &&
        ((d.envMap = this.envMap.toJSON(a).uuid),
        (d.reflectivity = this.reflectivity),
        (d.refractionRatio = this.refractionRatio),
        void 0 !== this.combine && (d.combine = this.combine),
        void 0 !== this.envMapIntensity &&
          (d.envMapIntensity = this.envMapIntensity));
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (d.gradientMap = this.gradientMap.toJSON(a).uuid);
      void 0 !== this.size && (d.size = this.size);
      void 0 !== this.sizeAttenuation &&
        (d.sizeAttenuation = this.sizeAttenuation);
      1 !== this.blending && (d.blending = this.blending);
      !0 === this.flatShading && (d.flatShading = this.flatShading);
      0 !== this.side && (d.side = this.side);
      0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
      1 > this.opacity && (d.opacity = this.opacity);
      !0 === this.transparent && (d.transparent = this.transparent);
      d.depthFunc = this.depthFunc;
      d.depthTest = this.depthTest;
      d.depthWrite = this.depthWrite;
      d.stencilWrite = this.stencilWrite;
      d.stencilWriteMask = this.stencilWriteMask;
      d.stencilFunc = this.stencilFunc;
      d.stencilRef = this.stencilRef;
      d.stencilFuncMask = this.stencilFuncMask;
      d.stencilFail = this.stencilFail;
      d.stencilZFail = this.stencilZFail;
      d.stencilZPass = this.stencilZPass;
      this.rotation && 0 !== this.rotation && (d.rotation = this.rotation);
      !0 === this.polygonOffset && (d.polygonOffset = !0);
      0 !== this.polygonOffsetFactor &&
        (d.polygonOffsetFactor = this.polygonOffsetFactor);
      0 !== this.polygonOffsetUnits &&
        (d.polygonOffsetUnits = this.polygonOffsetUnits);
      this.linewidth && 1 !== this.linewidth && (d.linewidth = this.linewidth);
      void 0 !== this.dashSize && (d.dashSize = this.dashSize);
      void 0 !== this.gapSize && (d.gapSize = this.gapSize);
      void 0 !== this.scale && (d.scale = this.scale);
      !0 === this.dithering && (d.dithering = !0);
      0 < this.alphaTest && (d.alphaTest = this.alphaTest);
      !0 === this.premultipliedAlpha &&
        (d.premultipliedAlpha = this.premultipliedAlpha);
      !0 === this.wireframe && (d.wireframe = this.wireframe);
      1 < this.wireframeLinewidth &&
        (d.wireframeLinewidth = this.wireframeLinewidth);
      "round" !== this.wireframeLinecap &&
        (d.wireframeLinecap = this.wireframeLinecap);
      "round" !== this.wireframeLinejoin &&
        (d.wireframeLinejoin = this.wireframeLinejoin);
      !0 === this.morphTargets && (d.morphTargets = !0);
      !0 === this.morphNormals && (d.morphNormals = !0);
      !0 === this.skinning && (d.skinning = !0);
      !1 === this.visible && (d.visible = !1);
      !1 === this.toneMapped && (d.toneMapped = !1);
      "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
      c &&
        ((c = b(a.textures)),
        (a = b(a.images)),
        0 < c.length && (d.textures = c),
        0 < a.length && (d.images = a));
      return d;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.name = a.name;
      this.fog = a.fog;
      this.blending = a.blending;
      this.side = a.side;
      this.flatShading = a.flatShading;
      this.vertexColors = a.vertexColors;
      this.opacity = a.opacity;
      this.transparent = a.transparent;
      this.blendSrc = a.blendSrc;
      this.blendDst = a.blendDst;
      this.blendEquation = a.blendEquation;
      this.blendSrcAlpha = a.blendSrcAlpha;
      this.blendDstAlpha = a.blendDstAlpha;
      this.blendEquationAlpha = a.blendEquationAlpha;
      this.depthFunc = a.depthFunc;
      this.depthTest = a.depthTest;
      this.depthWrite = a.depthWrite;
      this.stencilWrite = a.stencilWrite;
      this.stencilWriteMask = a.stencilWriteMask;
      this.stencilFunc = a.stencilFunc;
      this.stencilRef = a.stencilRef;
      this.stencilFuncMask = a.stencilFuncMask;
      this.stencilFail = a.stencilFail;
      this.stencilZFail = a.stencilZFail;
      this.stencilZPass = a.stencilZPass;
      this.colorWrite = a.colorWrite;
      this.precision = a.precision;
      this.polygonOffset = a.polygonOffset;
      this.polygonOffsetFactor = a.polygonOffsetFactor;
      this.polygonOffsetUnits = a.polygonOffsetUnits;
      this.dithering = a.dithering;
      this.alphaTest = a.alphaTest;
      this.premultipliedAlpha = a.premultipliedAlpha;
      this.visible = a.visible;
      this.toneMapped = a.toneMapped;
      this.userData = JSON.parse(JSON.stringify(a.userData));
      this.clipShadows = a.clipShadows;
      this.clipIntersection = a.clipIntersection;
      var b = a.clippingPlanes,
        c = null;
      if (null !== b) {
        var d = b.length;
        c = Array(d);
        for (var e = 0; e !== d; ++e) c[e] = b[e].clone();
      }
      this.clippingPlanes = c;
      this.shadowSide = a.shadowSide;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  vb.prototype = Object.create(T.prototype);
  vb.prototype.constructor = vb;
  vb.prototype.isMeshBasicMaterial = !0;
  vb.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    return this;
  };
  Object.defineProperty(ba.prototype, "needsUpdate", {
    set: function(a) {
      !0 === a && this.version++;
    }
  });
  Object.assign(ba.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {},
    setDynamic: function(a) {
      this.dynamic = a;
      return this;
    },
    copy: function(a) {
      this.name = a.name;
      this.array = new a.array.constructor(a.array);
      this.itemSize = a.itemSize;
      this.count = a.count;
      this.normalized = a.normalized;
      this.dynamic = a.dynamic;
      return this;
    },
    copyAt: function(a, b, c) {
      a *= this.itemSize;
      c *= b.itemSize;
      for (var d = 0, e = this.itemSize; d < e; d++)
        this.array[a + d] = b.array[c + d];
      return this;
    },
    copyArray: function(a) {
      this.array.set(a);
      return this;
    },
    copyColorsArray: function(a) {
      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        void 0 === f &&
          (console.warn(
            "THREE.BufferAttribute.copyColorsArray(): color is undefined",
            d
          ),
          (f = new L()));
        b[c++] = f.r;
        b[c++] = f.g;
        b[c++] = f.b;
      }
      return this;
    },
    copyVector2sArray: function(a) {
      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        void 0 === f &&
          (console.warn(
            "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
            d
          ),
          (f = new E()));
        b[c++] = f.x;
        b[c++] = f.y;
      }
      return this;
    },
    copyVector3sArray: function(a) {
      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        void 0 === f &&
          (console.warn(
            "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
            d
          ),
          (f = new r()));
        b[c++] = f.x;
        b[c++] = f.y;
        b[c++] = f.z;
      }
      return this;
    },
    copyVector4sArray: function(a) {
      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        void 0 === f &&
          (console.warn(
            "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
            d
          ),
          (f = new Ca()));
        b[c++] = f.x;
        b[c++] = f.y;
        b[c++] = f.z;
        b[c++] = f.w;
      }
      return this;
    },
    set: function(a, b) {
      void 0 === b && (b = 0);
      this.array.set(a, b);
      return this;
    },
    getX: function(a) {
      return this.array[a * this.itemSize];
    },
    setX: function(a, b) {
      this.array[a * this.itemSize] = b;
      return this;
    },
    getY: function(a) {
      return this.array[a * this.itemSize + 1];
    },
    setY: function(a, b) {
      this.array[a * this.itemSize + 1] = b;
      return this;
    },
    getZ: function(a) {
      return this.array[a * this.itemSize + 2];
    },
    setZ: function(a, b) {
      this.array[a * this.itemSize + 2] = b;
      return this;
    },
    getW: function(a) {
      return this.array[a * this.itemSize + 3];
    },
    setW: function(a, b) {
      this.array[a * this.itemSize + 3] = b;
      return this;
    },
    setXY: function(a, b, c) {
      a *= this.itemSize;
      this.array[a + 0] = b;
      this.array[a + 1] = c;
      return this;
    },
    setXYZ: function(a, b, c, d) {
      a *= this.itemSize;
      this.array[a + 0] = b;
      this.array[a + 1] = c;
      this.array[a + 2] = d;
      return this;
    },
    setXYZW: function(a, b, c, d, e) {
      a *= this.itemSize;
      this.array[a + 0] = b;
      this.array[a + 1] = c;
      this.array[a + 2] = d;
      this.array[a + 3] = e;
      return this;
    },
    onUpload: function(a) {
      this.onUploadCallback = a;
      return this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
    }
  });
  Sh.prototype = Object.create(ba.prototype);
  Sh.prototype.constructor = Sh;
  yj.prototype = Object.create(ba.prototype);
  yj.prototype.constructor = yj;
  zj.prototype = Object.create(ba.prototype);
  zj.prototype.constructor = zj;
  Th.prototype = Object.create(ba.prototype);
  Th.prototype.constructor = Th;
  fd.prototype = Object.create(ba.prototype);
  fd.prototype.constructor = fd;
  Uh.prototype = Object.create(ba.prototype);
  Uh.prototype.constructor = Uh;
  gd.prototype = Object.create(ba.prototype);
  gd.prototype.constructor = gd;
  O.prototype = Object.create(ba.prototype);
  O.prototype.constructor = O;
  Vh.prototype = Object.create(ba.prototype);
  Vh.prototype.constructor = Vh;
  Object.assign(al.prototype, {
    computeGroups: function(a) {
      var b = [],
        c = void 0;
      a = a.faces;
      for (var d = 0; d < a.length; d++) {
        var e = a[d];
        if (e.materialIndex !== c) {
          c = e.materialIndex;
          void 0 !== f && ((f.count = 3 * d - f.start), b.push(f));
          var f = { start: 3 * d, materialIndex: c };
        }
      }
      void 0 !== f && ((f.count = 3 * d - f.start), b.push(f));
      this.groups = b;
    },
    fromGeometry: function(a) {
      var b = a.faces,
        c = a.vertices,
        d = a.faceVertexUvs,
        e = d[0] && 0 < d[0].length,
        f = d[1] && 0 < d[1].length,
        h = a.morphTargets,
        k = h.length;
      if (0 < k) {
        var l = [];
        for (var m = 0; m < k; m++) l[m] = { name: h[m].name, data: [] };
        this.morphTargets.position = l;
      }
      var n = a.morphNormals,
        q = n.length;
      if (0 < q) {
        var t = [];
        for (m = 0; m < q; m++) t[m] = { name: n[m].name, data: [] };
        this.morphTargets.normal = t;
      }
      var r = a.skinIndices,
        u = a.skinWeights,
        v = r.length === c.length,
        A = u.length === c.length;
      0 < c.length &&
        0 === b.length &&
        console.error(
          "THREE.DirectGeometry: Faceless geometries are not supported."
        );
      for (m = 0; m < b.length; m++) {
        var C = b[m];
        this.vertices.push(c[C.a], c[C.b], c[C.c]);
        var z = C.vertexNormals;
        3 === z.length
          ? this.normals.push(z[0], z[1], z[2])
          : ((z = C.normal), this.normals.push(z, z, z));
        z = C.vertexColors;
        3 === z.length
          ? this.colors.push(z[0], z[1], z[2])
          : ((z = C.color), this.colors.push(z, z, z));
        !0 === e &&
          ((z = d[0][m]),
          void 0 !== z
            ? this.uvs.push(z[0], z[1], z[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                m
              ),
              this.uvs.push(new E(), new E(), new E())));
        !0 === f &&
          ((z = d[1][m]),
          void 0 !== z
            ? this.uvs2.push(z[0], z[1], z[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                m
              ),
              this.uvs2.push(new E(), new E(), new E())));
        for (z = 0; z < k; z++) {
          var H = h[z].vertices;
          l[z].data.push(H[C.a], H[C.b], H[C.c]);
        }
        for (z = 0; z < q; z++)
          (H = n[z].vertexNormals[m]), t[z].data.push(H.a, H.b, H.c);
        v && this.skinIndices.push(r[C.a], r[C.b], r[C.c]);
        A && this.skinWeights.push(u[C.a], u[C.b], u[C.c]);
      }
      this.computeGroups(a);
      this.verticesNeedUpdate = a.verticesNeedUpdate;
      this.normalsNeedUpdate = a.normalsNeedUpdate;
      this.colorsNeedUpdate = a.colorsNeedUpdate;
      this.uvsNeedUpdate = a.uvsNeedUpdate;
      this.groupsNeedUpdate = a.groupsNeedUpdate;
      null !== a.boundingSphere &&
        (this.boundingSphere = a.boundingSphere.clone());
      null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
      return this;
    }
  });
  var qn = 1,
    Vc = new fa(),
    nj = new D(),
    Mh = new r(),
    hc = new dd(),
    oj = new dd(),
    ic = new r();
  F.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: F,
    isBufferGeometry: !0,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(a) {
      Array.isArray(a)
        ? (this.index = new (65535 < bl(a) ? gd : fd)(a, 1))
        : (this.index = a);
    },
    addAttribute: function(a, b, c) {
      return (b && b.isBufferAttribute) || (b && b.isInterleavedBufferAttribute)
        ? "index" === a
          ? (console.warn(
              "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
            ),
            this.setIndex(b),
            this)
          : this.setAttribute(a, b)
        : (console.warn(
            "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
          ),
          this.addAttribute(a, new ba(b, c)));
    },
    getAttribute: function(a) {
      return this.attributes[a];
    },
    setAttribute: function(a, b) {
      this.attributes[a] = b;
      return this;
    },
    removeAttribute: function(a) {
      delete this.attributes[a];
      return this;
    },
    addGroup: function(a, b, c) {
      this.groups.push({
        start: a,
        count: b,
        materialIndex: void 0 !== c ? c : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(a, b) {
      this.drawRange.start = a;
      this.drawRange.count = b;
    },
    applyMatrix: function(a) {
      var b = this.attributes.position;
      void 0 !== b && (a.applyToBufferAttribute(b), (b.needsUpdate = !0));
      var c = this.attributes.normal;
      void 0 !== c &&
        ((b = new Ya().getNormalMatrix(a)),
        b.applyToBufferAttribute(c),
        (c.needsUpdate = !0));
      c = this.attributes.tangent;
      void 0 !== c &&
        ((b = new Ya().getNormalMatrix(a)),
        b.applyToBufferAttribute(c),
        (c.needsUpdate = !0));
      null !== this.boundingBox && this.computeBoundingBox();
      null !== this.boundingSphere && this.computeBoundingSphere();
      return this;
    },
    rotateX: function(a) {
      Vc.makeRotationX(a);
      this.applyMatrix(Vc);
      return this;
    },
    rotateY: function(a) {
      Vc.makeRotationY(a);
      this.applyMatrix(Vc);
      return this;
    },
    rotateZ: function(a) {
      Vc.makeRotationZ(a);
      this.applyMatrix(Vc);
      return this;
    },
    translate: function(a, b, c) {
      Vc.makeTranslation(a, b, c);
      this.applyMatrix(Vc);
      return this;
    },
    scale: function(a, b, c) {
      Vc.makeScale(a, b, c);
      this.applyMatrix(Vc);
      return this;
    },
    lookAt: function(a) {
      nj.lookAt(a);
      nj.updateMatrix();
      this.applyMatrix(nj.matrix);
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(Mh).negate();
      this.translate(Mh.x, Mh.y, Mh.z);
      return this;
    },
    setFromObject: function(a) {
      var b = a.geometry;
      if (a.isPoints || a.isLine) {
        a = new O(3 * b.vertices.length, 3);
        var c = new O(3 * b.colors.length, 3);
        this.addAttribute("position", a.copyVector3sArray(b.vertices));
        this.addAttribute("color", c.copyColorsArray(b.colors));
        b.lineDistances &&
          b.lineDistances.length === b.vertices.length &&
          ((a = new O(b.lineDistances.length, 1)),
          this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
        null !== b.boundingSphere &&
          (this.boundingSphere = b.boundingSphere.clone());
        null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
      } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
      return this;
    },
    setFromPoints: function(a) {
      for (var b = [], c = 0, d = a.length; c < d; c++) {
        var e = a[c];
        b.push(e.x, e.y, e.z || 0);
      }
      this.addAttribute("position", new O(b, 3));
      return this;
    },
    updateFromObject: function(a) {
      var b = a.geometry;
      if (a.isMesh) {
        var c = b.__directGeometry;
        !0 === b.elementsNeedUpdate &&
          ((c = void 0), (b.elementsNeedUpdate = !1));
        if (void 0 === c) return this.fromGeometry(b);
        c.verticesNeedUpdate = b.verticesNeedUpdate;
        c.normalsNeedUpdate = b.normalsNeedUpdate;
        c.colorsNeedUpdate = b.colorsNeedUpdate;
        c.uvsNeedUpdate = b.uvsNeedUpdate;
        c.groupsNeedUpdate = b.groupsNeedUpdate;
        b.verticesNeedUpdate = !1;
        b.normalsNeedUpdate = !1;
        b.colorsNeedUpdate = !1;
        b.uvsNeedUpdate = !1;
        b.groupsNeedUpdate = !1;
        b = c;
      }
      !0 === b.verticesNeedUpdate &&
        ((c = this.attributes.position),
        void 0 !== c && (c.copyVector3sArray(b.vertices), (c.needsUpdate = !0)),
        (b.verticesNeedUpdate = !1));
      !0 === b.normalsNeedUpdate &&
        ((c = this.attributes.normal),
        void 0 !== c && (c.copyVector3sArray(b.normals), (c.needsUpdate = !0)),
        (b.normalsNeedUpdate = !1));
      !0 === b.colorsNeedUpdate &&
        ((c = this.attributes.color),
        void 0 !== c && (c.copyColorsArray(b.colors), (c.needsUpdate = !0)),
        (b.colorsNeedUpdate = !1));
      b.uvsNeedUpdate &&
        ((c = this.attributes.uv),
        void 0 !== c && (c.copyVector2sArray(b.uvs), (c.needsUpdate = !0)),
        (b.uvsNeedUpdate = !1));
      b.lineDistancesNeedUpdate &&
        ((c = this.attributes.lineDistance),
        void 0 !== c && (c.copyArray(b.lineDistances), (c.needsUpdate = !0)),
        (b.lineDistancesNeedUpdate = !1));
      b.groupsNeedUpdate &&
        (b.computeGroups(a.geometry),
        (this.groups = b.groups),
        (b.groupsNeedUpdate = !1));
      return this;
    },
    fromGeometry: function(a) {
      a.__directGeometry = new al().fromGeometry(a);
      return this.fromDirectGeometry(a.__directGeometry);
    },
    fromDirectGeometry: function(a) {
      var b = new Float32Array(3 * a.vertices.length);
      this.addAttribute("position", new ba(b, 3).copyVector3sArray(a.vertices));
      0 < a.normals.length &&
        ((b = new Float32Array(3 * a.normals.length)),
        this.addAttribute("normal", new ba(b, 3).copyVector3sArray(a.normals)));
      0 < a.colors.length &&
        ((b = new Float32Array(3 * a.colors.length)),
        this.addAttribute("color", new ba(b, 3).copyColorsArray(a.colors)));
      0 < a.uvs.length &&
        ((b = new Float32Array(2 * a.uvs.length)),
        this.addAttribute("uv", new ba(b, 2).copyVector2sArray(a.uvs)));
      0 < a.uvs2.length &&
        ((b = new Float32Array(2 * a.uvs2.length)),
        this.addAttribute("uv2", new ba(b, 2).copyVector2sArray(a.uvs2)));
      this.groups = a.groups;
      for (var c in a.morphTargets) {
        b = [];
        for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
          var h = d[e],
            k = new O(3 * h.data.length, 3);
          k.name = h.name;
          b.push(k.copyVector3sArray(h.data));
        }
        this.morphAttributes[c] = b;
      }
      0 < a.skinIndices.length &&
        ((c = new O(4 * a.skinIndices.length, 4)),
        this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
      0 < a.skinWeights.length &&
        ((c = new O(4 * a.skinWeights.length, 4)),
        this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
      null !== a.boundingSphere &&
        (this.boundingSphere = a.boundingSphere.clone());
      null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
      return this;
    },
    computeBoundingBox: function() {
      null === this.boundingBox && (this.boundingBox = new dd());
      var a = this.attributes.position,
        b = this.morphAttributes.position;
      if (void 0 !== a) {
        if ((this.boundingBox.setFromBufferAttribute(a), b)) {
          a = 0;
          for (var c = b.length; a < c; a++)
            hc.setFromBufferAttribute(b[a]),
              this.boundingBox.expandByPoint(hc.min),
              this.boundingBox.expandByPoint(hc.max);
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    },
    computeBoundingSphere: function() {
      null === this.boundingSphere && (this.boundingSphere = new ed());
      var a = this.attributes.position,
        b = this.morphAttributes.position;
      if (a) {
        var c = this.boundingSphere.center;
        hc.setFromBufferAttribute(a);
        if (b)
          for (var d = 0, e = b.length; d < e; d++) {
            var f = b[d];
            oj.setFromBufferAttribute(f);
            hc.expandByPoint(oj.min);
            hc.expandByPoint(oj.max);
          }
        hc.getCenter(c);
        var h = 0;
        d = 0;
        for (e = a.count; d < e; d++)
          ic.fromBufferAttribute(a, d),
            (h = Math.max(h, c.distanceToSquared(ic)));
        if (b)
          for (d = 0, e = b.length; d < e; d++) {
            f = b[d];
            a = 0;
            for (var k = f.count; a < k; a++)
              ic.fromBufferAttribute(f, a),
                (h = Math.max(h, c.distanceToSquared(ic)));
          }
        this.boundingSphere.radius = Math.sqrt(h);
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
      }
    },
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
      var a = this.index,
        b = this.attributes;
      if (b.position) {
        var c = b.position.array;
        if (void 0 === b.normal)
          this.addAttribute("normal", new ba(new Float32Array(c.length), 3));
        else
          for (var d = b.normal.array, e = 0, f = d.length; e < f; e++)
            d[e] = 0;
        d = b.normal.array;
        var h = new r(),
          k = new r(),
          l = new r(),
          m = new r(),
          n = new r();
        if (a) {
          var q = a.array;
          e = 0;
          for (f = a.count; e < f; e += 3) {
            a = 3 * q[e + 0];
            var t = 3 * q[e + 1];
            var y = 3 * q[e + 2];
            h.fromArray(c, a);
            k.fromArray(c, t);
            l.fromArray(c, y);
            m.subVectors(l, k);
            n.subVectors(h, k);
            m.cross(n);
            d[a] += m.x;
            d[a + 1] += m.y;
            d[a + 2] += m.z;
            d[t] += m.x;
            d[t + 1] += m.y;
            d[t + 2] += m.z;
            d[y] += m.x;
            d[y + 1] += m.y;
            d[y + 2] += m.z;
          }
        } else
          for (e = 0, f = c.length; e < f; e += 9)
            h.fromArray(c, e),
              k.fromArray(c, e + 3),
              l.fromArray(c, e + 6),
              m.subVectors(l, k),
              n.subVectors(h, k),
              m.cross(n),
              (d[e] = m.x),
              (d[e + 1] = m.y),
              (d[e + 2] = m.z),
              (d[e + 3] = m.x),
              (d[e + 4] = m.y),
              (d[e + 5] = m.z),
              (d[e + 6] = m.x),
              (d[e + 7] = m.y),
              (d[e + 8] = m.z);
        this.normalizeNormals();
        b.normal.needsUpdate = !0;
      }
    },
    merge: function(a, b) {
      if (a && a.isBufferGeometry) {
        void 0 === b &&
          ((b = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        var c = this.attributes,
          d;
        for (d in c)
          if (void 0 !== a.attributes[d]) {
            var e = c[d].array,
              f = a.attributes[d],
              h = f.array,
              k = f.itemSize * b;
            f = Math.min(h.length, e.length - k);
            for (var l = 0; l < f; l++, k++) e[k] = h[l];
          }
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        a
      );
    },
    normalizeNormals: function() {
      for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++)
        (ic.x = a.getX(b)),
          (ic.y = a.getY(b)),
          (ic.z = a.getZ(b)),
          ic.normalize(),
          a.setXYZ(b, ic.x, ic.y, ic.z);
    },
    toNonIndexed: function() {
      function a(a, b) {
        var c = a.array;
        a = a.itemSize;
        for (
          var d = new c.constructor(b.length * a),
            e,
            f = 0,
            h = 0,
            k = b.length;
          h < k;
          h++
        ) {
          e = b[h] * a;
          for (var l = 0; l < a; l++) d[f++] = c[e++];
        }
        return new ba(d, a);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
          ),
          this
        );
      var b = new F(),
        c = this.index.array,
        d = this.attributes,
        e;
      for (e in d) {
        var f = d[e];
        f = a(f, c);
        b.addAttribute(e, f);
      }
      var h = this.morphAttributes;
      for (e in h) {
        var k = [],
          l = h[e];
        d = 0;
        for (var m = l.length; d < m; d++) (f = l[d]), (f = a(f, c)), k.push(f);
        b.morphAttributes[e] = k;
      }
      c = this.groups;
      d = 0;
      for (e = c.length; d < e; d++)
        (f = c[d]), b.addGroup(f.start, f.count, f.materialIndex);
      return b;
    },
    toJSON: function() {
      var a = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      a.uuid = this.uuid;
      a.type = this.type;
      "" !== this.name && (a.name = this.name);
      0 < Object.keys(this.userData).length && (a.userData = this.userData);
      if (void 0 !== this.parameters) {
        var b = this.parameters;
        for (m in b) void 0 !== b[m] && (a[m] = b[m]);
        return a;
      }
      a.data = { attributes: {} };
      b = this.index;
      null !== b &&
        (a.data.index = {
          type: b.array.constructor.name,
          array: Array.prototype.slice.call(b.array)
        });
      var c = this.attributes;
      for (m in c) {
        b = c[m];
        var d = b.toJSON();
        "" !== b.name && (d.name = b.name);
        a.data.attributes[m] = d;
      }
      c = {};
      var e = !1;
      for (m in this.morphAttributes) {
        for (
          var f = this.morphAttributes[m], h = [], k = 0, l = f.length;
          k < l;
          k++
        )
          (b = f[k]),
            (d = b.toJSON()),
            "" !== b.name && (d.name = b.name),
            h.push(d);
        0 < h.length && ((c[m] = h), (e = !0));
      }
      e && (a.data.morphAttributes = c);
      var m = this.groups;
      0 < m.length && (a.data.groups = JSON.parse(JSON.stringify(m)));
      m = this.boundingSphere;
      null !== m &&
        (a.data.boundingSphere = {
          center: m.center.toArray(),
          radius: m.radius
        });
      return a;
    },
    clone: function() {
      return new F().copy(this);
    },
    copy: function(a) {
      var b;
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingSphere = this.boundingBox = null;
      this.name = a.name;
      var c = a.index;
      null !== c && this.setIndex(c.clone());
      c = a.attributes;
      for (h in c) this.addAttribute(h, c[h].clone());
      var d = a.morphAttributes;
      for (h in d) {
        var e = [],
          f = d[h];
        c = 0;
        for (b = f.length; c < b; c++) e.push(f[c].clone());
        this.morphAttributes[h] = e;
      }
      var h = a.groups;
      c = 0;
      for (b = h.length; c < b; c++)
        (d = h[c]), this.addGroup(d.start, d.count, d.materialIndex);
      h = a.boundingBox;
      null !== h && (this.boundingBox = h.clone());
      h = a.boundingSphere;
      null !== h && (this.boundingSphere = h.clone());
      this.drawRange.start = a.drawRange.start;
      this.drawRange.count = a.drawRange.count;
      this.userData = a.userData;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var Hm = new fa(),
    Wc = new Ob(),
    pj = new ed(),
    Qe = new r(),
    Qd = new r(),
    Re = new r(),
    dl = new r(),
    el = new r(),
    fl = new r(),
    Wh = new r(),
    Xh = new r(),
    Yh = new r(),
    mc = new E(),
    nc = new E(),
    Pb = new E(),
    Of = new r(),
    Mf = new r();
  oa.prototype = Object.assign(Object.create(D.prototype), {
    constructor: oa,
    isMesh: !0,
    setDrawMode: function(a) {
      this.drawMode = a;
    },
    copy: function(a) {
      D.prototype.copy.call(this, a);
      this.drawMode = a.drawMode;
      void 0 !== a.morphTargetInfluences &&
        (this.morphTargetInfluences = a.morphTargetInfluences.slice());
      void 0 !== a.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          a.morphTargetDictionary
        ));
      return this;
    },
    updateMorphTargets: function() {
      var a = this.geometry;
      if (a.isBufferGeometry) {
        a = a.morphAttributes;
        var b = Object.keys(a);
        if (0 < b.length) {
          var c = a[b[0]];
          if (void 0 !== c)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                a = 0,
                b = c.length;
              a < b;
              a++
            ) {
              var d = c[a].name || String(a);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[d] = a;
            }
        }
      } else
        (a = a.morphTargets),
          void 0 !== a &&
            0 < a.length &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
    },
    raycast: function(a, b) {
      var c = this.geometry,
        d = this.material,
        e = this.matrixWorld;
      if (
        void 0 !== d &&
        (null === c.boundingSphere && c.computeBoundingSphere(),
        pj.copy(c.boundingSphere),
        pj.applyMatrix4(e),
        !1 !== a.ray.intersectsSphere(pj) &&
          (Hm.getInverse(e),
          Wc.copy(a.ray).applyMatrix4(Hm),
          null === c.boundingBox || !1 !== Wc.intersectsBox(c.boundingBox)))
      )
        if (c.isBufferGeometry) {
          var f = c.index;
          e = c.attributes.position;
          var h = c.morphAttributes.position,
            k = c.attributes.uv,
            l = c.attributes.uv2,
            m = c.groups,
            n = c.drawRange,
            q,
            t;
          if (null !== f)
            if (Array.isArray(d)) {
              var r = 0;
              for (q = m.length; r < q; r++) {
                var u = m[r];
                var v = d[u.materialIndex];
                var A = Math.max(u.start, n.start);
                for (
                  t = c = Math.min(u.start + u.count, n.start + n.count);
                  A < t;
                  A += 3
                ) {
                  c = f.getX(A);
                  var C = f.getX(A + 1);
                  var z = f.getX(A + 2);
                  if ((c = Nf(this, v, a, Wc, e, h, k, l, c, C, z)))
                    (c.faceIndex = Math.floor(A / 3)),
                      (c.face.materialIndex = u.materialIndex),
                      b.push(c);
                }
              }
            } else
              for (
                A = Math.max(0, n.start),
                  c = Math.min(f.count, n.start + n.count),
                  r = A,
                  q = c;
                r < q;
                r += 3
              ) {
                if (
                  ((c = f.getX(r)),
                  (C = f.getX(r + 1)),
                  (z = f.getX(r + 2)),
                  (c = Nf(this, d, a, Wc, e, h, k, l, c, C, z)))
                )
                  (c.faceIndex = Math.floor(r / 3)), b.push(c);
              }
          else if (void 0 !== e)
            if (Array.isArray(d))
              for (r = 0, q = m.length; r < q; r++)
                for (
                  u = m[r],
                    v = d[u.materialIndex],
                    A = Math.max(u.start, n.start),
                    t = c = Math.min(u.start + u.count, n.start + n.count);
                  A < t;
                  A += 3
                ) {
                  if (
                    ((c = A),
                    (C = A + 1),
                    (z = A + 2),
                    (c = Nf(this, v, a, Wc, e, h, k, l, c, C, z)))
                  )
                    (c.faceIndex = Math.floor(A / 3)),
                      (c.face.materialIndex = u.materialIndex),
                      b.push(c);
                }
            else
              for (
                A = Math.max(0, n.start),
                  c = Math.min(e.count, n.start + n.count),
                  r = A,
                  q = c;
                r < q;
                r += 3
              )
                if (
                  ((c = r),
                  (C = r + 1),
                  (z = r + 2),
                  (c = Nf(this, d, a, Wc, e, h, k, l, c, C, z)))
                )
                  (c.faceIndex = Math.floor(r / 3)), b.push(c);
        } else if (c.isGeometry)
          for (
            e = Array.isArray(d),
              h = c.vertices,
              k = c.faces,
              c = c.faceVertexUvs[0],
              0 < c.length && (f = c),
              r = 0,
              q = k.length;
            r < q;
            r++
          )
            if (
              ((u = k[r]),
              (c = e ? d[u.materialIndex] : d),
              void 0 !== c &&
                ((l = h[u.a]),
                (m = h[u.b]),
                (n = h[u.c]),
                (c = cl(this, c, a, Wc, l, m, n, Of))))
            )
              f &&
                f[r] &&
                ((v = f[r]),
                mc.copy(v[0]),
                nc.copy(v[1]),
                Pb.copy(v[2]),
                (c.uv = Ma.getUV(Of, l, m, n, mc, nc, Pb, new E()))),
                (c.face = u),
                (c.faceIndex = r),
                b.push(c);
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  var rn = 0,
    Xc = new fa(),
    qj = new D(),
    sg = new r();
  W.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: W,
    isGeometry: !0,
    applyMatrix: function(a) {
      for (
        var b = new Ya().getNormalMatrix(a), c = 0, d = this.vertices.length;
        c < d;
        c++
      )
        this.vertices[c].applyMatrix4(a);
      c = 0;
      for (d = this.faces.length; c < d; c++) {
        a = this.faces[c];
        a.normal.applyMatrix3(b).normalize();
        for (var e = 0, f = a.vertexNormals.length; e < f; e++)
          a.vertexNormals[e].applyMatrix3(b).normalize();
      }
      null !== this.boundingBox && this.computeBoundingBox();
      null !== this.boundingSphere && this.computeBoundingSphere();
      this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
      return this;
    },
    rotateX: function(a) {
      Xc.makeRotationX(a);
      this.applyMatrix(Xc);
      return this;
    },
    rotateY: function(a) {
      Xc.makeRotationY(a);
      this.applyMatrix(Xc);
      return this;
    },
    rotateZ: function(a) {
      Xc.makeRotationZ(a);
      this.applyMatrix(Xc);
      return this;
    },
    translate: function(a, b, c) {
      Xc.makeTranslation(a, b, c);
      this.applyMatrix(Xc);
      return this;
    },
    scale: function(a, b, c) {
      Xc.makeScale(a, b, c);
      this.applyMatrix(Xc);
      return this;
    },
    lookAt: function(a) {
      qj.lookAt(a);
      qj.updateMatrix();
      this.applyMatrix(qj.matrix);
      return this;
    },
    fromBufferGeometry: function(a) {
      function b(a, b, d, e) {
        var f =
            void 0 === k
              ? []
              : [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()],
          n =
            void 0 === h
              ? []
              : [
                  new r().fromArray(h, 3 * a),
                  new r().fromArray(h, 3 * b),
                  new r().fromArray(h, 3 * d)
                ];
        e = new Lf(a, b, d, n, f, e);
        c.faces.push(e);
        void 0 !== l &&
          c.faceVertexUvs[0].push([
            new E().fromArray(l, 2 * a),
            new E().fromArray(l, 2 * b),
            new E().fromArray(l, 2 * d)
          ]);
        void 0 !== m &&
          c.faceVertexUvs[1].push([
            new E().fromArray(m, 2 * a),
            new E().fromArray(m, 2 * b),
            new E().fromArray(m, 2 * d)
          ]);
      }
      var c = this,
        d = null !== a.index ? a.index.array : void 0,
        e = a.attributes;
      if (void 0 === e.position)
        return (
          console.error(
            "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
          ),
          this
        );
      var f = e.position.array,
        h = void 0 !== e.normal ? e.normal.array : void 0,
        k = void 0 !== e.color ? e.color.array : void 0,
        l = void 0 !== e.uv ? e.uv.array : void 0,
        m = void 0 !== e.uv2 ? e.uv2.array : void 0;
      void 0 !== m && (this.faceVertexUvs[1] = []);
      for (e = 0; e < f.length; e += 3)
        c.vertices.push(new r().fromArray(f, e)),
          void 0 !== k && c.colors.push(new L().fromArray(k, e));
      var n = a.groups;
      if (0 < n.length)
        for (e = 0; e < n.length; e++) {
          f = n[e];
          var q = f.start,
            t = q;
          for (q += f.count; t < q; t += 3)
            void 0 !== d
              ? b(d[t], d[t + 1], d[t + 2], f.materialIndex)
              : b(t, t + 1, t + 2, f.materialIndex);
        }
      else if (void 0 !== d)
        for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
      else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
      this.computeFaceNormals();
      null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
      null !== a.boundingSphere &&
        (this.boundingSphere = a.boundingSphere.clone());
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(sg).negate();
      this.translate(sg.x, sg.y, sg.z);
      return this;
    },
    normalize: function() {
      this.computeBoundingSphere();
      var a = this.boundingSphere.center,
        b = this.boundingSphere.radius;
      b = 0 === b ? 1 : 1 / b;
      var c = new fa();
      c.set(
        b,
        0,
        0,
        -b * a.x,
        0,
        b,
        0,
        -b * a.y,
        0,
        0,
        b,
        -b * a.z,
        0,
        0,
        0,
        1
      );
      this.applyMatrix(c);
      return this;
    },
    computeFaceNormals: function() {
      for (
        var a = new r(), b = new r(), c = 0, d = this.faces.length;
        c < d;
        c++
      ) {
        var e = this.faces[c],
          f = this.vertices[e.a],
          h = this.vertices[e.b];
        a.subVectors(this.vertices[e.c], h);
        b.subVectors(f, h);
        a.cross(b);
        a.normalize();
        e.normal.copy(a);
      }
    },
    computeVertexNormals: function(a) {
      void 0 === a && (a = !0);
      var b;
      var c = Array(this.vertices.length);
      var d = 0;
      for (b = this.vertices.length; d < b; d++) c[d] = new r();
      if (a) {
        var e = new r(),
          f = new r();
        a = 0;
        for (d = this.faces.length; a < d; a++) {
          b = this.faces[a];
          var h = this.vertices[b.a];
          var k = this.vertices[b.b];
          var l = this.vertices[b.c];
          e.subVectors(l, k);
          f.subVectors(h, k);
          e.cross(f);
          c[b.a].add(e);
          c[b.b].add(e);
          c[b.c].add(e);
        }
      } else
        for (
          this.computeFaceNormals(), a = 0, d = this.faces.length;
          a < d;
          a++
        )
          (b = this.faces[a]),
            c[b.a].add(b.normal),
            c[b.b].add(b.normal),
            c[b.c].add(b.normal);
      d = 0;
      for (b = this.vertices.length; d < b; d++) c[d].normalize();
      a = 0;
      for (d = this.faces.length; a < d; a++)
        (b = this.faces[a]),
          (h = b.vertexNormals),
          3 === h.length
            ? (h[0].copy(c[b.a]), h[1].copy(c[b.b]), h[2].copy(c[b.c]))
            : ((h[0] = c[b.a].clone()),
              (h[1] = c[b.b].clone()),
              (h[2] = c[b.c].clone()));
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function() {
      var a;
      this.computeFaceNormals();
      var b = 0;
      for (a = this.faces.length; b < a; b++) {
        var c = this.faces[b];
        var d = c.vertexNormals;
        3 === d.length
          ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal))
          : ((d[0] = c.normal.clone()),
            (d[1] = c.normal.clone()),
            (d[2] = c.normal.clone()));
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
      var a, b;
      var c = 0;
      for (b = this.faces.length; c < b; c++) {
        var d = this.faces[c];
        d.__originalFaceNormal
          ? d.__originalFaceNormal.copy(d.normal)
          : (d.__originalFaceNormal = d.normal.clone());
        d.__originalVertexNormals || (d.__originalVertexNormals = []);
        var e = 0;
        for (a = d.vertexNormals.length; e < a; e++)
          d.__originalVertexNormals[e]
            ? d.__originalVertexNormals[e].copy(d.vertexNormals[e])
            : (d.__originalVertexNormals[e] = d.vertexNormals[e].clone());
      }
      var f = new W();
      f.faces = this.faces;
      e = 0;
      for (a = this.morphTargets.length; e < a; e++) {
        if (!this.morphNormals[e]) {
          this.morphNormals[e] = {};
          this.morphNormals[e].faceNormals = [];
          this.morphNormals[e].vertexNormals = [];
          d = this.morphNormals[e].faceNormals;
          var h = this.morphNormals[e].vertexNormals;
          c = 0;
          for (b = this.faces.length; c < b; c++) {
            var k = new r();
            var l = { a: new r(), b: new r(), c: new r() };
            d.push(k);
            h.push(l);
          }
        }
        h = this.morphNormals[e];
        f.vertices = this.morphTargets[e].vertices;
        f.computeFaceNormals();
        f.computeVertexNormals();
        c = 0;
        for (b = this.faces.length; c < b; c++)
          (d = this.faces[c]),
            (k = h.faceNormals[c]),
            (l = h.vertexNormals[c]),
            k.copy(d.normal),
            l.a.copy(d.vertexNormals[0]),
            l.b.copy(d.vertexNormals[1]),
            l.c.copy(d.vertexNormals[2]);
      }
      c = 0;
      for (b = this.faces.length; c < b; c++)
        (d = this.faces[c]),
          (d.normal = d.__originalFaceNormal),
          (d.vertexNormals = d.__originalVertexNormals);
    },
    computeBoundingBox: function() {
      null === this.boundingBox && (this.boundingBox = new dd());
      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      null === this.boundingSphere && (this.boundingSphere = new ed());
      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(a, b, c) {
      if (a && a.isGeometry) {
        var d,
          e = this.vertices.length,
          f = this.vertices,
          h = a.vertices,
          k = this.faces,
          l = a.faces,
          m = this.colors,
          n = a.colors;
        void 0 === c && (c = 0);
        void 0 !== b && (d = new Ya().getNormalMatrix(b));
        for (var q = 0, t = h.length; q < t; q++) {
          var r = h[q].clone();
          void 0 !== b && r.applyMatrix4(b);
          f.push(r);
        }
        q = 0;
        for (t = n.length; q < t; q++) m.push(n[q].clone());
        q = 0;
        for (t = l.length; q < t; q++) {
          h = l[q];
          var u = h.vertexNormals;
          n = h.vertexColors;
          m = new Lf(h.a + e, h.b + e, h.c + e);
          m.normal.copy(h.normal);
          void 0 !== d && m.normal.applyMatrix3(d).normalize();
          b = 0;
          for (f = u.length; b < f; b++)
            (r = u[b].clone()),
              void 0 !== d && r.applyMatrix3(d).normalize(),
              m.vertexNormals.push(r);
          m.color.copy(h.color);
          b = 0;
          for (f = n.length; b < f; b++)
            (r = n[b]), m.vertexColors.push(r.clone());
          m.materialIndex = h.materialIndex + c;
          k.push(m);
        }
        q = 0;
        for (t = a.faceVertexUvs.length; q < t; q++)
          for (
            c = a.faceVertexUvs[q],
              void 0 === this.faceVertexUvs[q] && (this.faceVertexUvs[q] = []),
              b = 0,
              f = c.length;
            b < f;
            b++
          ) {
            d = c[b];
            e = [];
            k = 0;
            for (l = d.length; k < l; k++) e.push(d[k].clone());
            this.faceVertexUvs[q].push(e);
          }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          a
        );
    },
    mergeMesh: function(a) {
      a && a.isMesh
        ? (a.matrixAutoUpdate && a.updateMatrix(),
          this.merge(a.geometry, a.matrix))
        : console.error(
            "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
            a
          );
    },
    mergeVertices: function() {
      var a = {},
        b = [],
        c = [],
        d = Math.pow(10, 4),
        e;
      var f = 0;
      for (e = this.vertices.length; f < e; f++) {
        var h = this.vertices[f];
        h =
          Math.round(h.x * d) +
          "_" +
          Math.round(h.y * d) +
          "_" +
          Math.round(h.z * d);
        void 0 === a[h]
          ? ((a[h] = f), b.push(this.vertices[f]), (c[f] = b.length - 1))
          : (c[f] = c[a[h]]);
      }
      a = [];
      f = 0;
      for (e = this.faces.length; f < e; f++)
        for (
          d = this.faces[f],
            d.a = c[d.a],
            d.b = c[d.b],
            d.c = c[d.c],
            d = [d.a, d.b, d.c],
            h = 0;
          3 > h;
          h++
        )
          if (d[h] === d[(h + 1) % 3]) {
            a.push(f);
            break;
          }
      for (f = a.length - 1; 0 <= f; f--)
        for (
          d = a[f],
            this.faces.splice(d, 1),
            c = 0,
            e = this.faceVertexUvs.length;
          c < e;
          c++
        )
          this.faceVertexUvs[c].splice(d, 1);
      f = this.vertices.length - b.length;
      this.vertices = b;
      return f;
    },
    setFromPoints: function(a) {
      this.vertices = [];
      for (var b = 0, c = a.length; b < c; b++) {
        var d = a[b];
        this.vertices.push(new r(d.x, d.y, d.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
      a.sort(function(a, b) {
        return a.materialIndex - b.materialIndex;
      });
      var d = this.faceVertexUvs[0],
        e = this.faceVertexUvs[1],
        f,
        h;
      d && d.length === b && (f = []);
      e && e.length === b && (h = []);
      for (c = 0; c < b; c++) {
        var k = a[c]._id;
        f && f.push(d[k]);
        h && h.push(e[k]);
      }
      f && (this.faceVertexUvs[0] = f);
      h && (this.faceVertexUvs[1] = h);
    },
    toJSON: function() {
      function a(a, b, c) {
        return c ? a | (1 << b) : a & ~(1 << b);
      }
      function b(a) {
        var b = a.x.toString() + a.y.toString() + a.z.toString();
        if (void 0 !== m[b]) return m[b];
        m[b] = l.length / 3;
        l.push(a.x, a.y, a.z);
        return m[b];
      }
      function c(a) {
        var b = a.r.toString() + a.g.toString() + a.b.toString();
        if (void 0 !== q[b]) return q[b];
        q[b] = n.length;
        n.push(a.getHex());
        return q[b];
      }
      function d(a) {
        var b = a.x.toString() + a.y.toString();
        if (void 0 !== r[b]) return r[b];
        r[b] = t.length / 2;
        t.push(a.x, a.y);
        return r[b];
      }
      var e = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      e.uuid = this.uuid;
      e.type = this.type;
      "" !== this.name && (e.name = this.name);
      if (void 0 !== this.parameters) {
        var f = this.parameters,
          h;
        for (h in f) void 0 !== f[h] && (e[h] = f[h]);
        return e;
      }
      f = [];
      for (h = 0; h < this.vertices.length; h++) {
        var k = this.vertices[h];
        f.push(k.x, k.y, k.z);
      }
      k = [];
      var l = [],
        m = {},
        n = [],
        q = {},
        t = [],
        r = {};
      for (h = 0; h < this.faces.length; h++) {
        var u = this.faces[h],
          v = void 0 !== this.faceVertexUvs[0][h],
          A = 0 < u.normal.length(),
          C = 0 < u.vertexNormals.length,
          z = 1 !== u.color.r || 1 !== u.color.g || 1 !== u.color.b,
          H = 0 < u.vertexColors.length,
          D = 0;
        D = a(D, 0, 0);
        D = a(D, 1, !0);
        D = a(D, 2, !1);
        D = a(D, 3, v);
        D = a(D, 4, A);
        D = a(D, 5, C);
        D = a(D, 6, z);
        D = a(D, 7, H);
        k.push(D);
        k.push(u.a, u.b, u.c);
        k.push(u.materialIndex);
        v &&
          ((v = this.faceVertexUvs[0][h]), k.push(d(v[0]), d(v[1]), d(v[2])));
        A && k.push(b(u.normal));
        C && ((A = u.vertexNormals), k.push(b(A[0]), b(A[1]), b(A[2])));
        z && k.push(c(u.color));
        H && ((u = u.vertexColors), k.push(c(u[0]), c(u[1]), c(u[2])));
      }
      e.data = {};
      e.data.vertices = f;
      e.data.normals = l;
      0 < n.length && (e.data.colors = n);
      0 < t.length && (e.data.uvs = [t]);
      e.data.faces = k;
      return e;
    },
    clone: function() {
      return new W().copy(this);
    },
    copy: function(a) {
      var b, c, d;
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingSphere = this.boundingBox = null;
      this.name = a.name;
      var e = a.vertices;
      var f = 0;
      for (b = e.length; f < b; f++) this.vertices.push(e[f].clone());
      e = a.colors;
      f = 0;
      for (b = e.length; f < b; f++) this.colors.push(e[f].clone());
      e = a.faces;
      f = 0;
      for (b = e.length; f < b; f++) this.faces.push(e[f].clone());
      f = 0;
      for (b = a.faceVertexUvs.length; f < b; f++) {
        var h = a.faceVertexUvs[f];
        void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
        e = 0;
        for (c = h.length; e < c; e++) {
          var k = h[e],
            l = [];
          var m = 0;
          for (d = k.length; m < d; m++) l.push(k[m].clone());
          this.faceVertexUvs[f].push(l);
        }
      }
      m = a.morphTargets;
      f = 0;
      for (b = m.length; f < b; f++) {
        d = {};
        d.name = m[f].name;
        if (void 0 !== m[f].vertices)
          for (d.vertices = [], e = 0, c = m[f].vertices.length; e < c; e++)
            d.vertices.push(m[f].vertices[e].clone());
        if (void 0 !== m[f].normals)
          for (d.normals = [], e = 0, c = m[f].normals.length; e < c; e++)
            d.normals.push(m[f].normals[e].clone());
        this.morphTargets.push(d);
      }
      m = a.morphNormals;
      f = 0;
      for (b = m.length; f < b; f++) {
        d = {};
        if (void 0 !== m[f].vertexNormals)
          for (
            d.vertexNormals = [], e = 0, c = m[f].vertexNormals.length;
            e < c;
            e++
          )
            (h = m[f].vertexNormals[e]),
              (k = {}),
              (k.a = h.a.clone()),
              (k.b = h.b.clone()),
              (k.c = h.c.clone()),
              d.vertexNormals.push(k);
        if (void 0 !== m[f].faceNormals)
          for (
            d.faceNormals = [], e = 0, c = m[f].faceNormals.length;
            e < c;
            e++
          )
            d.faceNormals.push(m[f].faceNormals[e].clone());
        this.morphNormals.push(d);
      }
      e = a.skinWeights;
      f = 0;
      for (b = e.length; f < b; f++) this.skinWeights.push(e[f].clone());
      e = a.skinIndices;
      f = 0;
      for (b = e.length; f < b; f++) this.skinIndices.push(e[f].clone());
      e = a.lineDistances;
      f = 0;
      for (b = e.length; f < b; f++) this.lineDistances.push(e[f]);
      f = a.boundingBox;
      null !== f && (this.boundingBox = f.clone());
      f = a.boundingSphere;
      null !== f && (this.boundingSphere = f.clone());
      this.elementsNeedUpdate = a.elementsNeedUpdate;
      this.verticesNeedUpdate = a.verticesNeedUpdate;
      this.uvsNeedUpdate = a.uvsNeedUpdate;
      this.normalsNeedUpdate = a.normalsNeedUpdate;
      this.colorsNeedUpdate = a.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = a.groupsNeedUpdate;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var ap = (function(a) {
      function b(a, d, e, f, h, k) {
        ud(this, b);
        var c = ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this));
        c.type = "BoxGeometry";
        c.parameters = {
          width: a,
          height: d,
          depth: e,
          widthSegments: f,
          heightSegments: h,
          depthSegments: k
        };
        c.fromBufferGeometry(new Ig(a, d, e, f, h, k));
        c.mergeVertices();
        return c;
      }
      ue(b, a);
      return b;
    })(W),
    Ig = (function(a) {
      function b(a, d, e, f, h, k) {
        function c(a, b, c, d, e, f, h, k, l, m, D) {
          var z = f / l,
            B = h / m,
            C = f / 2,
            H = h / 2,
            E = k / 2;
          h = l + 1;
          var F = m + 1,
            N = (f = 0),
            M,
            I,
            J = new r();
          for (I = 0; I < F; I++) {
            var L = I * B - H;
            for (M = 0; M < h; M++)
              (J[a] = (M * z - C) * d),
                (J[b] = L * e),
                (J[c] = E),
                t.push(J.x, J.y, J.z),
                (J[a] = 0),
                (J[b] = 0),
                (J[c] = 0 < k ? 1 : -1),
                y.push(J.x, J.y, J.z),
                u.push(M / l),
                u.push(1 - I / m),
                (f += 1);
          }
          for (I = 0; I < m; I++)
            for (M = 0; M < l; M++)
              (a = v + M + h * (I + 1)),
                (b = v + (M + 1) + h * (I + 1)),
                (c = v + (M + 1) + h * I),
                q.push(v + M + h * I, a, c),
                q.push(a, b, c),
                (N += 6);
          n.addGroup(A, N, D);
          A += N;
          v += f;
        }
        ud(this, b);
        var m = ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this));
        m.type = "BoxBufferGeometry";
        m.parameters = {
          width: a,
          height: d,
          depth: e,
          widthSegments: f,
          heightSegments: h,
          depthSegments: k
        };
        var n = m;
        a = a || 1;
        d = d || 1;
        e = e || 1;
        f = Math.floor(f) || 1;
        h = Math.floor(h) || 1;
        k = Math.floor(k) || 1;
        var q = [],
          t = [],
          y = [],
          u = [],
          v = 0,
          A = 0;
        c("z", "y", "x", -1, -1, e, d, a, k, h, 0);
        c("z", "y", "x", 1, -1, e, d, -a, k, h, 1);
        c("x", "z", "y", 1, 1, a, e, d, f, k, 2);
        c("x", "z", "y", 1, -1, a, e, -d, f, k, 3);
        c("x", "y", "z", 1, -1, a, d, e, f, h, 4);
        c("x", "y", "z", -1, -1, a, d, -e, f, h, 5);
        m.setIndex(q);
        m.addAttribute("position", new O(t, 3));
        m.addAttribute("normal", new O(y, 3));
        m.addAttribute("uv", new O(u, 2));
        return m;
      }
      ue(b, a);
      return b;
    })(F),
    Nh = { clone: Se, merge: Oa };
  Pa.prototype = Object.create(T.prototype);
  Pa.prototype.constructor = Pa;
  Pa.prototype.isShaderMaterial = !0;
  Pa.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.fragmentShader = a.fragmentShader;
    this.vertexShader = a.vertexShader;
    this.uniforms = Se(a.uniforms);
    this.defines = Object.assign({}, a.defines);
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights;
    this.clipping = a.clipping;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.extensions = a.extensions;
    return this;
  };
  Pa.prototype.toJSON = function(a) {
    var b = T.prototype.toJSON.call(this, a);
    b.uniforms = {};
    for (var c in this.uniforms) {
      var d = this.uniforms[c].value;
      b.uniforms[c] =
        d && d.isTexture
          ? { type: "t", value: d.toJSON(a).uuid }
          : d && d.isColor
          ? { type: "c", value: d.getHex() }
          : d && d.isVector2
          ? { type: "v2", value: d.toArray() }
          : d && d.isVector3
          ? { type: "v3", value: d.toArray() }
          : d && d.isVector4
          ? { type: "v4", value: d.toArray() }
          : d && d.isMatrix3
          ? { type: "m3", value: d.toArray() }
          : d && d.isMatrix4
          ? { type: "m4", value: d.toArray() }
          : { value: d };
    }
    0 < Object.keys(this.defines).length && (b.defines = this.defines);
    b.vertexShader = this.vertexShader;
    b.fragmentShader = this.fragmentShader;
    a = {};
    for (var e in this.extensions) !0 === this.extensions[e] && (a[e] = !0);
    0 < Object.keys(a).length && (b.extensions = a);
    return b;
  };
  oc.prototype = Object.assign(Object.create(D.prototype), {
    constructor: oc,
    isCamera: !0,
    copy: function(a, b) {
      D.prototype.copy.call(this, a, b);
      this.matrixWorldInverse.copy(a.matrixWorldInverse);
      this.projectionMatrix.copy(a.projectionMatrix);
      this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function(a) {
      void 0 === a &&
        (console.warn(
          "THREE.Camera: .getWorldDirection() target is now required"
        ),
        (a = new r()));
      this.updateMatrixWorld(!0);
      var b = this.matrixWorld.elements;
      return a.set(-b[8], -b[9], -b[10]).normalize();
    },
    updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(this, a);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  Ua.prototype = Object.assign(Object.create(oc.prototype), {
    constructor: Ua,
    isPerspectiveCamera: !0,
    copy: function(a, b) {
      oc.prototype.copy.call(this, a, b);
      this.fov = a.fov;
      this.zoom = a.zoom;
      this.near = a.near;
      this.far = a.far;
      this.focus = a.focus;
      this.aspect = a.aspect;
      this.view = null === a.view ? null : Object.assign({}, a.view);
      this.filmGauge = a.filmGauge;
      this.filmOffset = a.filmOffset;
      return this;
    },
    setFocalLength: function(a) {
      a = (0.5 * this.getFilmHeight()) / a;
      this.fov = 2 * ca.RAD2DEG * Math.atan(a);
      this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var a = Math.tan(0.5 * ca.DEG2RAD * this.fov);
      return (0.5 * this.getFilmHeight()) / a;
    },
    getEffectiveFOV: function() {
      return (
        2 *
        ca.RAD2DEG *
        Math.atan(Math.tan(0.5 * ca.DEG2RAD * this.fov) / this.zoom)
      );
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(a, b, c, d, e, f) {
      this.aspect = a / b;
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        });
      this.view.enabled = !0;
      this.view.fullWidth = a;
      this.view.fullHeight = b;
      this.view.offsetX = c;
      this.view.offsetY = d;
      this.view.width = e;
      this.view.height = f;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      null !== this.view && (this.view.enabled = !1);
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var a = this.near,
        b = (a * Math.tan(0.5 * ca.DEG2RAD * this.fov)) / this.zoom,
        c = 2 * b,
        d = this.aspect * c,
        e = -0.5 * d,
        f = this.view;
      if (null !== this.view && this.view.enabled) {
        var h = f.fullWidth,
          k = f.fullHeight;
        e += (f.offsetX * d) / h;
        b -= (f.offsetY * c) / k;
        d *= f.width / h;
        c *= f.height / k;
      }
      f = this.filmOffset;
      0 !== f && (e += (a * f) / this.getFilmWidth());
      this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(a) {
      a = D.prototype.toJSON.call(this, a);
      a.object.fov = this.fov;
      a.object.zoom = this.zoom;
      a.object.near = this.near;
      a.object.far = this.far;
      a.object.focus = this.focus;
      a.object.aspect = this.aspect;
      null !== this.view && (a.object.view = Object.assign({}, this.view));
      a.object.filmGauge = this.filmGauge;
      a.object.filmOffset = this.filmOffset;
      return a;
    }
  });
  hd.prototype = Object.create(D.prototype);
  hd.prototype.constructor = hd;
  Rd.prototype = Object.create(Za.prototype);
  Rd.prototype.constructor = Rd;
  Rd.prototype.isWebGLRenderTargetCube = !0;
  Rd.prototype.fromEquirectangularTexture = function(a, b) {
    this.texture.type = b.type;
    this.texture.format = b.format;
    this.texture.encoding = b.encoding;
    var c = new Kf(),
      d = new Pa({
        type: "CubemapFromEquirect",
        uniforms: Se({ tEquirect: { value: null } }),
        vertexShader:
          "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        fragmentShader:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
        side: 1,
        blending: 0
      });
    d.uniforms.tEquirect.value = b;
    b = new oa(new Ig(5, 5, 5), d);
    c.add(b);
    d = new hd(1, 10, 1);
    d.renderTarget = this;
    d.renderTarget.texture.name = "CubeCameraTexture";
    d.update(a, c);
    b.geometry.dispose();
    b.material.dispose();
    return this;
  };
  pc.prototype = Object.create(pa.prototype);
  pc.prototype.constructor = pc;
  pc.prototype.isDataTexture = !0;
  var Mk = new r(),
    bp = new r(),
    cp = new Ya();
  Object.assign(qc.prototype, {
    isPlane: !0,
    set: function(a, b) {
      this.normal.copy(a);
      this.constant = b;
      return this;
    },
    setComponents: function(a, b, c, d) {
      this.normal.set(a, b, c);
      this.constant = d;
      return this;
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
      this.normal.copy(a);
      this.constant = -b.dot(this.normal);
      return this;
    },
    setFromCoplanarPoints: function(a, b, c) {
      b = Mk.subVectors(c, b)
        .cross(bp.subVectors(a, b))
        .normalize();
      this.setFromNormalAndCoplanarPoint(b, a);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.normal.copy(a.normal);
      this.constant = a.constant;
      return this;
    },
    normalize: function() {
      var a = 1 / this.normal.length();
      this.normal.multiplyScalar(a);
      this.constant *= a;
      return this;
    },
    negate: function() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    },
    distanceToPoint: function(a) {
      return this.normal.dot(a) + this.constant;
    },
    distanceToSphere: function(a) {
      return this.distanceToPoint(a.center) - a.radius;
    },
    projectPoint: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Plane: .projectPoint() target is now required"),
        (b = new r()));
      return b
        .copy(this.normal)
        .multiplyScalar(-this.distanceToPoint(a))
        .add(a);
    },
    intersectLine: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Plane: .intersectLine() target is now required"),
        (b = new r()));
      var c = a.delta(Mk),
        d = this.normal.dot(c);
      if (0 === d) {
        if (0 === this.distanceToPoint(a.start)) return b.copy(a.start);
      } else if (
        ((d = -(a.start.dot(this.normal) + this.constant) / d),
        !(0 > d || 1 < d))
      )
        return b
          .copy(c)
          .multiplyScalar(d)
          .add(a.start);
    },
    intersectsLine: function(a) {
      var b = this.distanceToPoint(a.start);
      a = this.distanceToPoint(a.end);
      return (0 > b && 0 < a) || (0 > a && 0 < b);
    },
    intersectsBox: function(a) {
      return a.intersectsPlane(this);
    },
    intersectsSphere: function(a) {
      return a.intersectsPlane(this);
    },
    coplanarPoint: function(a) {
      void 0 === a &&
        (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
        (a = new r()));
      return a.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function(a, b) {
      b = b || cp.getNormalMatrix(a);
      a = this.coplanarPoint(Mk).applyMatrix4(a);
      b = this.normal.applyMatrix3(b).normalize();
      this.constant = -a.dot(b);
      return this;
    },
    translate: function(a) {
      this.constant -= a.dot(this.normal);
      return this;
    },
    equals: function(a) {
      return a.normal.equals(this.normal) && a.constant === this.constant;
    }
  });
  var zf = new ed(),
    tg = new r();
  Object.assign(Fg.prototype, {
    set: function(a, b, c, d, e, f) {
      var h = this.planes;
      h[0].copy(a);
      h[1].copy(b);
      h[2].copy(c);
      h[3].copy(d);
      h[4].copy(e);
      h[5].copy(f);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
      return this;
    },
    setFromMatrix: function(a) {
      var b = this.planes,
        c = a.elements;
      a = c[0];
      var d = c[1],
        e = c[2],
        f = c[3],
        h = c[4],
        k = c[5],
        l = c[6],
        m = c[7],
        n = c[8],
        q = c[9],
        t = c[10],
        r = c[11],
        u = c[12],
        v = c[13],
        A = c[14];
      c = c[15];
      b[0].setComponents(f - a, m - h, r - n, c - u).normalize();
      b[1].setComponents(f + a, m + h, r + n, c + u).normalize();
      b[2].setComponents(f + d, m + k, r + q, c + v).normalize();
      b[3].setComponents(f - d, m - k, r - q, c - v).normalize();
      b[4].setComponents(f - e, m - l, r - t, c - A).normalize();
      b[5].setComponents(f + e, m + l, r + t, c + A).normalize();
      return this;
    },
    intersectsObject: function(a) {
      var b = a.geometry;
      null === b.boundingSphere && b.computeBoundingSphere();
      zf.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
      return this.intersectsSphere(zf);
    },
    intersectsSprite: function(a) {
      zf.center.set(0, 0, 0);
      zf.radius = 0.7071067811865476;
      zf.applyMatrix4(a.matrixWorld);
      return this.intersectsSphere(zf);
    },
    intersectsSphere: function(a) {
      var b = this.planes,
        c = a.center;
      a = -a.radius;
      for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
      return !0;
    },
    intersectsBox: function(a) {
      for (var b = this.planes, c = 0; 6 > c; c++) {
        var d = b[c];
        tg.x = 0 < d.normal.x ? a.max.x : a.min.x;
        tg.y = 0 < d.normal.y ? a.max.y : a.min.y;
        tg.z = 0 < d.normal.z ? a.max.z : a.min.z;
        if (0 > d.distanceToPoint(tg)) return !1;
      }
      return !0;
    },
    containsPoint: function(a) {
      for (var b = this.planes, c = 0; 6 > c; c++)
        if (0 > b[c].distanceToPoint(a)) return !1;
      return !0;
    }
  });
  var ha = {
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      begin_vertex: "vec3 transformed = vec3( position );",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
      color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
      color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
      common:
        "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      encodings_pars_fragment:
        "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_vertex:
        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
      map_particle_pars_fragment:
        "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
      normal_fragment_begin:
        "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      normal_fragment_maps:
        "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
      clearcoat_normalmap_pars_fragment:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
      uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
      uv_pars_vertex:
        "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
      uv_vertex:
        "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
      uv2_pars_fragment:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
      uv2_pars_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
      uv2_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_frag:
        "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      cube_frag:
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
      depth_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      normal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
      normal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
      shadow_vert:
        "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    },
    I = {
      common: {
        diffuse: { value: new L(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new Ya() },
        alphaMap: { value: null }
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 }
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new E(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 2.5e-4 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new L(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} }
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} }
        }
      },
      points: {
        diffuse: { value: new L(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        uvTransform: { value: new Ya() }
      },
      sprite: {
        diffuse: { value: new L(15658734) },
        opacity: { value: 1 },
        center: { value: new E(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        uvTransform: { value: new Ya() }
      }
    },
    hb = {
      basic: {
        uniforms: Oa([
          I.common,
          I.specularmap,
          I.envmap,
          I.aomap,
          I.lightmap,
          I.fog
        ]),
        vertexShader: ha.meshbasic_vert,
        fragmentShader: ha.meshbasic_frag
      },
      lambert: {
        uniforms: Oa([
          I.common,
          I.specularmap,
          I.envmap,
          I.aomap,
          I.lightmap,
          I.emissivemap,
          I.fog,
          I.lights,
          { emissive: { value: new L(0) } }
        ]),
        vertexShader: ha.meshlambert_vert,
        fragmentShader: ha.meshlambert_frag
      },
      phong: {
        uniforms: Oa([
          I.common,
          I.specularmap,
          I.envmap,
          I.aomap,
          I.lightmap,
          I.emissivemap,
          I.bumpmap,
          I.normalmap,
          I.displacementmap,
          I.gradientmap,
          I.fog,
          I.lights,
          {
            emissive: { value: new L(0) },
            specular: { value: new L(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ha.meshphong_vert,
        fragmentShader: ha.meshphong_frag
      },
      standard: {
        uniforms: Oa([
          I.common,
          I.envmap,
          I.aomap,
          I.lightmap,
          I.emissivemap,
          I.bumpmap,
          I.normalmap,
          I.displacementmap,
          I.roughnessmap,
          I.metalnessmap,
          I.fog,
          I.lights,
          {
            emissive: { value: new L(0) },
            roughness: { value: 0.5 },
            metalness: { value: 0.5 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ha.meshphysical_vert,
        fragmentShader: ha.meshphysical_frag
      },
      matcap: {
        uniforms: Oa([
          I.common,
          I.bumpmap,
          I.normalmap,
          I.displacementmap,
          I.fog,
          { matcap: { value: null } }
        ]),
        vertexShader: ha.meshmatcap_vert,
        fragmentShader: ha.meshmatcap_frag
      },
      points: {
        uniforms: Oa([I.points, I.fog]),
        vertexShader: ha.points_vert,
        fragmentShader: ha.points_frag
      },
      dashed: {
        uniforms: Oa([
          I.common,
          I.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ha.linedashed_vert,
        fragmentShader: ha.linedashed_frag
      },
      depth: {
        uniforms: Oa([I.common, I.displacementmap]),
        vertexShader: ha.depth_vert,
        fragmentShader: ha.depth_frag
      },
      normal: {
        uniforms: Oa([
          I.common,
          I.bumpmap,
          I.normalmap,
          I.displacementmap,
          { opacity: { value: 1 } }
        ]),
        vertexShader: ha.normal_vert,
        fragmentShader: ha.normal_frag
      },
      sprite: {
        uniforms: Oa([I.sprite, I.fog]),
        vertexShader: ha.sprite_vert,
        fragmentShader: ha.sprite_frag
      },
      background: {
        uniforms: { uvTransform: { value: new Ya() }, t2D: { value: null } },
        vertexShader: ha.background_vert,
        fragmentShader: ha.background_frag
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 }
        },
        vertexShader: ha.cube_vert,
        fragmentShader: ha.cube_frag
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: ha.equirect_vert,
        fragmentShader: ha.equirect_frag
      },
      distanceRGBA: {
        uniforms: Oa([
          I.common,
          I.displacementmap,
          {
            referencePosition: { value: new r() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ha.distanceRGBA_vert,
        fragmentShader: ha.distanceRGBA_frag
      },
      shadow: {
        uniforms: Oa([
          I.lights,
          I.fog,
          { color: { value: new L(0) }, opacity: { value: 1 } }
        ]),
        vertexShader: ha.shadow_vert,
        fragmentShader: ha.shadow_frag
      }
    };
  hb.physical = {
    uniforms: Oa([
      hb.standard.uniforms,
      {
        transparency: { value: 0 },
        clearcoat: { value: 0 },
        clearcoatRoughness: { value: 0 },
        sheen: { value: new L(0) },
        clearcoatNormalScale: { value: new E(1, 1) },
        clearcoatNormalMap: { value: null }
      }
    ]),
    vertexShader: ha.meshphysical_vert,
    fragmentShader: ha.meshphysical_frag
  };
  Hg.prototype = Object.create(W.prototype);
  Hg.prototype.constructor = Hg;
  id.prototype = Object.create(F.prototype);
  id.prototype.constructor = id;
  Sd.prototype = Object.create(pa.prototype);
  Sd.prototype.constructor = Sd;
  Sd.prototype.isCubeTexture = !0;
  Object.defineProperty(Sd.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(a) {
      this.image = a;
    }
  });
  jd.prototype = Object.create(pa.prototype);
  jd.prototype.constructor = jd;
  jd.prototype.isDataTexture2DArray = !0;
  kd.prototype = Object.create(pa.prototype);
  kd.prototype.constructor = kd;
  kd.prototype.isDataTexture3D = !0;
  var ml = new pa(),
    Nn = new jd(),
    Pn = new kd(),
    nl = new Sd(),
    gl = [],
    il = [],
    ll = new Float32Array(16),
    kl = new Float32Array(9),
    jl = new Float32Array(4);
  ol.prototype.updateCache = function(a) {
    var b = this.cache;
    a instanceof Float32Array &&
      b.length !== a.length &&
      (this.cache = new Float32Array(a.length));
    wb(b, a);
  };
  pl.prototype.setValue = function(a, b, c) {
    for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) {
      var h = d[e];
      h.setValue(a, b[h.id], c);
    }
  };
  var Aj = /([\w\d_]+)(\])?(\[|\.)?/g;
  Td.prototype.setValue = function(a, b, c, d) {
    b = this.map[b];
    void 0 !== b && b.setValue(a, c, d);
  };
  Td.prototype.setOptional = function(a, b, c) {
    b = b[c];
    void 0 !== b && this.setValue(a, c, b);
  };
  Td.upload = function(a, b, c, d) {
    for (var e = 0, f = b.length; e !== f; ++e) {
      var h = b[e],
        k = c[h.id];
      !1 !== k.needsUpdate && h.setValue(a, k.value, d);
    }
  };
  Td.seqWithValue = function(a, b) {
    for (var c = [], d = 0, e = a.length; d !== e; ++d) {
      var f = a[d];
      f.id in b && c.push(f);
    }
    return c;
  };
  var uo = 0,
    Zh = /^[ \t]*#include +<([\w\d./]+)>/gm,
    xl = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    Do = 0;
  ld.prototype = Object.create(T.prototype);
  ld.prototype.constructor = ld;
  ld.prototype.isMeshDepthMaterial = !0;
  ld.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.depthPacking = a.depthPacking;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    return this;
  };
  Te.prototype = Object.create(T.prototype);
  Te.prototype.constructor = Te;
  Te.prototype.isMeshDistanceMaterial = !0;
  Te.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.referencePosition.copy(a.referencePosition);
    this.nearDistance = a.nearDistance;
    this.farDistance = a.farDistance;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    return this;
  };
  Cj.prototype = Object.assign(Object.create(Za.prototype), {
    constructor: Cj,
    isWebGLMultiviewRenderTarget: !0,
    copy: function(a) {
      Za.prototype.copy.call(this, a);
      this.numViews = a.numViews;
      return this;
    },
    setNumViews: function(a) {
      this.numViews !== a && ((this.numViews = a), this.dispose());
      return this;
    }
  });
  md.prototype = Object.assign(Object.create(D.prototype), {
    constructor: md,
    isGroup: !0
  });
  Ue.prototype = Object.assign(Object.create(Ua.prototype), {
    constructor: Ue,
    isArrayCamera: !0
  });
  var Dl = new r(),
    El = new r();
  Object.assign(ai.prototype, lc.prototype);
  Object.assign(Fl.prototype, lc.prototype);
  Object.assign(bi.prototype, {
    isFogExp2: !0,
    clone: function() {
      return new bi(this.color, this.density);
    },
    toJSON: function() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  });
  Object.assign(ci.prototype, {
    isFog: !0,
    clone: function() {
      return new ci(this.color, this.near, this.far);
    },
    toJSON: function() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  });
  Object.defineProperty(Fb.prototype, "needsUpdate", {
    set: function(a) {
      !0 === a && this.version++;
    }
  });
  Object.assign(Fb.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {},
    setDynamic: function(a) {
      this.dynamic = a;
      return this;
    },
    copy: function(a) {
      this.array = new a.array.constructor(a.array);
      this.count = a.count;
      this.stride = a.stride;
      this.dynamic = a.dynamic;
      return this;
    },
    copyAt: function(a, b, c) {
      a *= this.stride;
      c *= b.stride;
      for (var d = 0, e = this.stride; d < e; d++)
        this.array[a + d] = b.array[c + d];
      return this;
    },
    set: function(a, b) {
      void 0 === b && (b = 0);
      this.array.set(a, b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(a) {
      this.onUploadCallback = a;
      return this;
    }
  });
  Object.defineProperties(Sf.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  });
  Object.assign(Sf.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(a, b) {
      this.data.array[a * this.data.stride + this.offset] = b;
      return this;
    },
    setY: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 1] = b;
      return this;
    },
    setZ: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 2] = b;
      return this;
    },
    setW: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 3] = b;
      return this;
    },
    getX: function(a) {
      return this.data.array[a * this.data.stride + this.offset];
    },
    getY: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 1];
    },
    getZ: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 2];
    },
    getW: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 3];
    },
    setXY: function(a, b, c) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      return this;
    },
    setXYZ: function(a, b, c, d) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      this.data.array[a + 2] = d;
      return this;
    },
    setXYZW: function(a, b, c, d, e) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      this.data.array[a + 2] = d;
      this.data.array[a + 3] = e;
      return this;
    }
  });
  Rb.prototype = Object.create(T.prototype);
  Rb.prototype.constructor = Rb;
  Rb.prototype.isSpriteMaterial = !0;
  Rb.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.rotation = a.rotation;
    this.sizeAttenuation = a.sizeAttenuation;
    return this;
  };
  var rc,
    Af = new r(),
    Yc = new r(),
    Le = new r(),
    sc = new E(),
    Vd = new E(),
    Il = new fa(),
    ug = new r(),
    Me = new r(),
    rj = new r(),
    Im = new E(),
    Nk = new E(),
    Jm = new E();
  di.prototype = Object.assign(Object.create(D.prototype), {
    constructor: di,
    isSprite: !0,
    raycast: function(a, b) {
      null === a.camera &&
        console.error(
          'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
        );
      Yc.setFromMatrixScale(this.matrixWorld);
      Il.copy(a.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(
        a.camera.matrixWorldInverse,
        this.matrixWorld
      );
      Le.setFromMatrixPosition(this.modelViewMatrix);
      a.camera.isPerspectiveCamera &&
        !1 === this.material.sizeAttenuation &&
        Yc.multiplyScalar(-Le.z);
      var c = this.material.rotation;
      if (0 !== c) {
        var d = Math.cos(c);
        var e = Math.sin(c);
      }
      c = this.center;
      Lg(ug.set(-0.5, -0.5, 0), Le, c, Yc, e, d);
      Lg(Me.set(0.5, -0.5, 0), Le, c, Yc, e, d);
      Lg(rj.set(0.5, 0.5, 0), Le, c, Yc, e, d);
      Im.set(0, 0);
      Nk.set(1, 0);
      Jm.set(1, 1);
      var f = a.ray.intersectTriangle(ug, Me, rj, !1, Af);
      if (
        null === f &&
        (Lg(Me.set(-0.5, 0.5, 0), Le, c, Yc, e, d),
        Nk.set(0, 1),
        (f = a.ray.intersectTriangle(ug, rj, Me, !1, Af)),
        null === f)
      )
        return;
      e = a.ray.origin.distanceTo(Af);
      e < a.near ||
        e > a.far ||
        b.push({
          distance: e,
          point: Af.clone(),
          uv: Ma.getUV(Af, ug, Me, rj, Im, Nk, Jm, new E()),
          face: null,
          object: this
        });
    },
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(a) {
      D.prototype.copy.call(this, a);
      void 0 !== a.center && this.center.copy(a.center);
      return this;
    }
  });
  var Bf = new r(),
    Km = new r();
  Mg.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Mg,
    isLOD: !0,
    copy: function(a) {
      D.prototype.copy.call(this, a, !1);
      a = a.levels;
      for (var b = 0, c = a.length; b < c; b++) {
        var d = a[b];
        this.addLevel(d.object.clone(), d.distance);
      }
      return this;
    },
    addLevel: function(a, b) {
      void 0 === b && (b = 0);
      b = Math.abs(b);
      for (
        var c = this.levels, d = 0;
        d < c.length && !(b < c[d].distance);
        d++
      );
      c.splice(d, 0, { distance: b, object: a });
      this.add(a);
      return this;
    },
    getObjectForDistance: function(a) {
      for (
        var b = this.levels, c = 1, d = b.length;
        c < d && !(a < b[c].distance);
        c++
      );
      return b[c - 1].object;
    },
    raycast: function(a, b) {
      Bf.setFromMatrixPosition(this.matrixWorld);
      var c = a.ray.origin.distanceTo(Bf);
      this.getObjectForDistance(c).raycast(a, b);
    },
    update: function(a) {
      var b = this.levels;
      if (1 < b.length) {
        Bf.setFromMatrixPosition(a.matrixWorld);
        Km.setFromMatrixPosition(this.matrixWorld);
        a = Bf.distanceTo(Km);
        b[0].object.visible = !0;
        for (var c = 1, d = b.length; c < d; c++)
          if (a >= b[c].distance)
            (b[c - 1].object.visible = !1), (b[c].object.visible = !0);
          else break;
        for (; c < d; c++) b[c].object.visible = !1;
      }
    },
    toJSON: function(a) {
      a = D.prototype.toJSON.call(this, a);
      a.object.levels = [];
      for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
        var e = b[c];
        a.object.levels.push({ object: e.object.uuid, distance: e.distance });
      }
      return a;
    }
  });
  Tf.prototype = Object.assign(Object.create(oa.prototype), {
    constructor: Tf,
    isSkinnedMesh: !0,
    bind: function(a, b) {
      this.skeleton = a;
      void 0 === b &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (b = this.matrixWorld));
      this.bindMatrix.copy(b);
      this.bindMatrixInverse.getInverse(b);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      for (
        var a = new Ca(),
          b = this.geometry.attributes.skinWeight,
          c = 0,
          d = b.count;
        c < d;
        c++
      ) {
        a.x = b.getX(c);
        a.y = b.getY(c);
        a.z = b.getZ(c);
        a.w = b.getW(c);
        var e = 1 / a.manhattanLength();
        Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0);
        b.setXYZW(c, a.x, a.y, a.z, a.w);
      }
    },
    updateMatrixWorld: function(a) {
      oa.prototype.updateMatrixWorld.call(this, a);
      "attached" === this.bindMode
        ? this.bindMatrixInverse.getInverse(this.matrixWorld)
        : "detached" === this.bindMode
        ? this.bindMatrixInverse.getInverse(this.bindMatrix)
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  var Lm = new fa(),
    dp = new fa();
  Object.assign(Ng.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var a = 0, b = this.bones.length; a < b; a++) {
        var c = new fa();
        this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
        this.boneInverses.push(c);
      }
    },
    pose: function() {
      var a, b;
      var c = 0;
      for (b = this.bones.length; c < b; c++)
        (a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
      c = 0;
      for (b = this.bones.length; c < b; c++)
        if ((a = this.bones[c]))
          a.parent && a.parent.isBone
            ? (a.matrix.getInverse(a.parent.matrixWorld),
              a.matrix.multiply(a.matrixWorld))
            : a.matrix.copy(a.matrixWorld),
            a.matrix.decompose(a.position, a.quaternion, a.scale);
    },
    update: function() {
      for (
        var a = this.bones,
          b = this.boneInverses,
          c = this.boneMatrices,
          d = this.boneTexture,
          e = 0,
          f = a.length;
        e < f;
        e++
      )
        Lm.multiplyMatrices(a[e] ? a[e].matrixWorld : dp, b[e]),
          Lm.toArray(c, 16 * e);
      void 0 !== d && (d.needsUpdate = !0);
    },
    clone: function() {
      return new Ng(this.bones, this.boneInverses);
    },
    getBoneByName: function(a) {
      for (var b = 0, c = this.bones.length; b < c; b++) {
        var d = this.bones[b];
        if (d.name === a) return d;
      }
    }
  });
  Jl.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Jl,
    isBone: !0
  });
  Kl.prototype = Object.assign(Object.create(oa.prototype), {
    constructor: Kl,
    isInstancedMesh: !0,
    raycast: function() {},
    setMatrixAt: function(a, b) {
      b.toArray(this.instanceMatrix.array, 16 * a);
    },
    updateMorphTargets: function() {}
  });
  qa.prototype = Object.create(T.prototype);
  qa.prototype.constructor = qa;
  qa.prototype.isLineBasicMaterial = !0;
  qa.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.linewidth = a.linewidth;
    this.linecap = a.linecap;
    this.linejoin = a.linejoin;
    return this;
  };
  var Mm = new r(),
    Nm = new r(),
    Om = new fa(),
    sj = new Ob(),
    Ne = new ed();
  $a.prototype = Object.assign(Object.create(D.prototype), {
    constructor: $a,
    isLine: !0,
    computeLineDistances: function() {
      var a = this.geometry;
      if (a.isBufferGeometry)
        if (null === a.index) {
          for (
            var b = a.attributes.position, c = [0], d = 1, e = b.count;
            d < e;
            d++
          )
            Mm.fromBufferAttribute(b, d - 1),
              Nm.fromBufferAttribute(b, d),
              (c[d] = c[d - 1]),
              (c[d] += Mm.distanceTo(Nm));
          a.addAttribute("lineDistance", new O(c, 1));
        } else
          console.warn(
            "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else if (a.isGeometry)
        for (
          b = a.vertices, c = a.lineDistances, c[0] = 0, d = 1, e = b.length;
          d < e;
          d++
        )
          (c[d] = c[d - 1]), (c[d] += b[d - 1].distanceTo(b[d]));
      return this;
    },
    raycast: function(a, b) {
      var c = a.linePrecision,
        d = this.geometry,
        e = this.matrixWorld;
      null === d.boundingSphere && d.computeBoundingSphere();
      Ne.copy(d.boundingSphere);
      Ne.applyMatrix4(e);
      Ne.radius += c;
      if (!1 !== a.ray.intersectsSphere(Ne)) {
        Om.getInverse(e);
        sj.copy(a.ray).applyMatrix4(Om);
        c /= (this.scale.x + this.scale.y + this.scale.z) / 3;
        c *= c;
        var f = new r(),
          h = new r();
        e = new r();
        var k = new r(),
          l = this && this.isLineSegments ? 2 : 1;
        if (d.isBufferGeometry) {
          var m = d.index,
            n = d.attributes.position.array;
          if (null !== m) {
            m = m.array;
            d = 0;
            for (var q = m.length - 1; d < q; d += l) {
              var t = m[d + 1];
              f.fromArray(n, 3 * m[d]);
              h.fromArray(n, 3 * t);
              t = sj.distanceSqToSegment(f, h, k, e);
              t > c ||
                (k.applyMatrix4(this.matrixWorld),
                (t = a.ray.origin.distanceTo(k)),
                t < a.near ||
                  t > a.far ||
                  b.push({
                    distance: t,
                    point: e.clone().applyMatrix4(this.matrixWorld),
                    index: d,
                    face: null,
                    faceIndex: null,
                    object: this
                  }));
            }
          } else
            for (d = 0, q = n.length / 3 - 1; d < q; d += l)
              f.fromArray(n, 3 * d),
                h.fromArray(n, 3 * d + 3),
                (t = sj.distanceSqToSegment(f, h, k, e)),
                t > c ||
                  (k.applyMatrix4(this.matrixWorld),
                  (t = a.ray.origin.distanceTo(k)),
                  t < a.near ||
                    t > a.far ||
                    b.push({
                      distance: t,
                      point: e.clone().applyMatrix4(this.matrixWorld),
                      index: d,
                      face: null,
                      faceIndex: null,
                      object: this
                    }));
        } else if (d.isGeometry)
          for (f = d.vertices, h = f.length, d = 0; d < h - 1; d += l)
            (t = sj.distanceSqToSegment(f[d], f[d + 1], k, e)),
              t > c ||
                (k.applyMatrix4(this.matrixWorld),
                (t = a.ray.origin.distanceTo(k)),
                t < a.near ||
                  t > a.far ||
                  b.push({
                    distance: t,
                    point: e.clone().applyMatrix4(this.matrixWorld),
                    index: d,
                    face: null,
                    faceIndex: null,
                    object: this
                  }));
      }
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  var tj = new r(),
    vg = new r();
  ra.prototype = Object.assign(Object.create($a.prototype), {
    constructor: ra,
    isLineSegments: !0,
    computeLineDistances: function() {
      var a = this.geometry;
      if (a.isBufferGeometry)
        if (null === a.index) {
          for (
            var b = a.attributes.position, c = [], d = 0, e = b.count;
            d < e;
            d += 2
          )
            tj.fromBufferAttribute(b, d),
              vg.fromBufferAttribute(b, d + 1),
              (c[d] = 0 === d ? 0 : c[d - 1]),
              (c[d + 1] = c[d] + tj.distanceTo(vg));
          a.addAttribute("lineDistance", new O(c, 1));
        } else
          console.warn(
            "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else if (a.isGeometry)
        for (
          b = a.vertices, c = a.lineDistances, d = 0, e = b.length;
          d < e;
          d += 2
        )
          tj.copy(b[d]),
            vg.copy(b[d + 1]),
            (c[d] = 0 === d ? 0 : c[d - 1]),
            (c[d + 1] = c[d] + tj.distanceTo(vg));
      return this;
    }
  });
  ei.prototype = Object.assign(Object.create($a.prototype), {
    constructor: ei,
    isLineLoop: !0
  });
  Wd.prototype = Object.create(T.prototype);
  Wd.prototype.constructor = Wd;
  Wd.prototype.isPointsMaterial = !0;
  Wd.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.size = a.size;
    this.sizeAttenuation = a.sizeAttenuation;
    this.morphTargets = a.morphTargets;
    return this;
  };
  var Pm = new fa(),
    Dj = new Ob(),
    Cf = new ed(),
    Df = new r();
  fi.prototype = Object.assign(Object.create(D.prototype), {
    constructor: fi,
    isPoints: !0,
    raycast: function(a, b) {
      var c = this.geometry,
        d = this.matrixWorld,
        e = a.params.Points.threshold;
      null === c.boundingSphere && c.computeBoundingSphere();
      Cf.copy(c.boundingSphere);
      Cf.applyMatrix4(d);
      Cf.radius += e;
      if (!1 !== a.ray.intersectsSphere(Cf))
        if (
          (Pm.getInverse(d),
          Dj.copy(a.ray).applyMatrix4(Pm),
          (e /= (this.scale.x + this.scale.y + this.scale.z) / 3),
          (e *= e),
          c.isBufferGeometry)
        ) {
          var f = c.index;
          c = c.attributes.position.array;
          if (null !== f) {
            var h = f.array;
            f = 0;
            for (var k = h.length; f < k; f++) {
              var l = h[f];
              Df.fromArray(c, 3 * l);
              gi(Df, l, e, d, a, b, this);
            }
          } else
            for (f = 0, h = c.length / 3; f < h; f++)
              Df.fromArray(c, 3 * f), gi(Df, f, e, d, a, b, this);
        } else
          for (c = c.vertices, f = 0, h = c.length; f < h; f++)
            gi(c[f], f, e, d, a, b, this);
    },
    updateMorphTargets: function() {
      var a = this.geometry;
      if (a.isBufferGeometry) {
        a = a.morphAttributes;
        var b = Object.keys(a);
        if (0 < b.length) {
          var c = a[b[0]];
          if (void 0 !== c)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                a = 0,
                b = c.length;
              a < b;
              a++
            ) {
              var d = c[a].name || String(a);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[d] = a;
            }
        }
      } else
        (a = a.morphTargets),
          void 0 !== a &&
            0 < a.length &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  Ll.prototype = Object.assign(Object.create(pa.prototype), {
    constructor: Ll,
    isVideoTexture: !0,
    update: function() {
      var a = this.image;
      a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  });
  Xd.prototype = Object.create(pa.prototype);
  Xd.prototype.constructor = Xd;
  Xd.prototype.isCompressedTexture = !0;
  Og.prototype = Object.create(pa.prototype);
  Og.prototype.constructor = Og;
  Og.prototype.isCanvasTexture = !0;
  Pg.prototype = Object.create(pa.prototype);
  Pg.prototype.constructor = Pg;
  Pg.prototype.isDepthTexture = !0;
  Uf.prototype = Object.create(F.prototype);
  Uf.prototype.constructor = Uf;
  Vf.prototype = Object.create(W.prototype);
  Vf.prototype.constructor = Vf;
  Yd.prototype = Object.create(F.prototype);
  Yd.prototype.constructor = Yd;
  Qg.prototype = Object.create(W.prototype);
  Qg.prototype.constructor = Qg;
  yb.prototype = Object.create(F.prototype);
  yb.prototype.constructor = yb;
  Ve.prototype = Object.create(W.prototype);
  Ve.prototype.constructor = Ve;
  Zd.prototype = Object.create(yb.prototype);
  Zd.prototype.constructor = Zd;
  We.prototype = Object.create(W.prototype);
  We.prototype.constructor = We;
  Sb.prototype = Object.create(yb.prototype);
  Sb.prototype.constructor = Sb;
  Rg.prototype = Object.create(W.prototype);
  Rg.prototype.constructor = Rg;
  nd.prototype = Object.create(yb.prototype);
  nd.prototype.constructor = nd;
  Sg.prototype = Object.create(W.prototype);
  Sg.prototype.constructor = Sg;
  $d.prototype = Object.create(yb.prototype);
  $d.prototype.constructor = $d;
  Wf.prototype = Object.create(W.prototype);
  Wf.prototype.constructor = Wf;
  tc.prototype = Object.create(F.prototype);
  tc.prototype.constructor = tc;
  tc.prototype.toJSON = function() {
    var a = F.prototype.toJSON.call(this);
    a.path = this.parameters.path.toJSON();
    return a;
  };
  Xf.prototype = Object.create(W.prototype);
  Xf.prototype.constructor = Xf;
  Tg.prototype = Object.create(F.prototype);
  Tg.prototype.constructor = Tg;
  Ug.prototype = Object.create(W.prototype);
  Ug.prototype.constructor = Ug;
  Vg.prototype = Object.create(F.prototype);
  Vg.prototype.constructor = Vg;
  var ep = {
      triangulate: function(a, b, c) {
        c = c || 2;
        var d = b && b.length,
          e = d ? b[0] * c : a.length,
          f = Ml(a, 0, e, c, !0),
          h = [];
        if (!f || f.next === f.prev) return h;
        var k;
        if (d) {
          var l = c;
          d = [];
          var m;
          var n = 0;
          for (m = b.length; n < m; n++) {
            var q = b[n] * l;
            var t = n < m - 1 ? b[n + 1] * l : a.length;
            q = Ml(a, q, t, l, !1);
            q === q.next && (q.steiner = !0);
            d.push(Mo(q));
          }
          d.sort(Ko);
          for (n = 0; n < d.length; n++) {
            b = d[n];
            l = f;
            if ((l = Lo(b, l))) (b = Pl(l, b)), Ye(b, b.next);
            f = Ye(f, f.next);
          }
        }
        if (a.length > 80 * c) {
          var r = (k = a[0]);
          var u = (d = a[1]);
          for (l = c; l < e; l += c)
            (n = a[l]),
              (b = a[l + 1]),
              n < r && (r = n),
              b < u && (u = b),
              n > k && (k = n),
              b > d && (d = b);
          k = Math.max(k - r, d - u);
          k = 0 !== k ? 1 / k : 0;
        }
        Ze(f, h, c, r, u, k);
        return h;
      }
    },
    be = {
      area: function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)
          c += a[d].x * a[e].y - a[e].x * a[d].y;
        return 0.5 * c;
      },
      isClockWise: function(a) {
        return 0 > be.area(a);
      },
      triangulateShape: function(a, b) {
        var c = [],
          d = [],
          e = [];
        Ql(a);
        Rl(c, a);
        var f = a.length;
        b.forEach(Ql);
        for (a = 0; a < b.length; a++)
          d.push(f), (f += b[a].length), Rl(c, b[a]);
        b = ep.triangulate(c, d);
        for (a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
        return e;
      }
    };
  Tb.prototype = Object.create(W.prototype);
  Tb.prototype.constructor = Tb;
  Tb.prototype.toJSON = function() {
    var a = W.prototype.toJSON.call(this);
    return Sl(this.parameters.shapes, this.parameters.options, a);
  };
  vc.prototype = Object.create(F.prototype);
  vc.prototype.constructor = vc;
  vc.prototype.toJSON = function() {
    var a = F.prototype.toJSON.call(this);
    return Sl(this.parameters.shapes, this.parameters.options, a);
  };
  var No = {
    generateTopUV: function(a, b, c, d, e) {
      a = b[3 * d];
      d = b[3 * d + 1];
      var f = b[3 * e];
      e = b[3 * e + 1];
      return [new E(b[3 * c], b[3 * c + 1]), new E(a, d), new E(f, e)];
    },
    generateSideWallUV: function(a, b, c, d, e, f) {
      a = b[3 * c];
      var h = b[3 * c + 1];
      c = b[3 * c + 2];
      var k = b[3 * d],
        l = b[3 * d + 1];
      d = b[3 * d + 2];
      var m = b[3 * e],
        n = b[3 * e + 1];
      e = b[3 * e + 2];
      var q = b[3 * f],
        t = b[3 * f + 1];
      b = b[3 * f + 2];
      return 0.01 > Math.abs(h - l)
        ? [new E(a, 1 - c), new E(k, 1 - d), new E(m, 1 - e), new E(q, 1 - b)]
        : [new E(h, 1 - c), new E(l, 1 - d), new E(n, 1 - e), new E(t, 1 - b)];
    }
  };
  ji.prototype = Object.create(W.prototype);
  ji.prototype.constructor = ji;
  ce.prototype = Object.create(vc.prototype);
  ce.prototype.constructor = ce;
  ki.prototype = Object.create(W.prototype);
  ki.prototype.constructor = ki;
  de.prototype = Object.create(F.prototype);
  de.prototype.constructor = de;
  li.prototype = Object.create(W.prototype);
  li.prototype.constructor = li;
  ee.prototype = Object.create(F.prototype);
  ee.prototype.constructor = ee;
  $e.prototype = Object.create(W.prototype);
  $e.prototype.constructor = $e;
  af.prototype = Object.create(F.prototype);
  af.prototype.constructor = af;
  wc.prototype = Object.create(W.prototype);
  wc.prototype.constructor = wc;
  wc.prototype.toJSON = function() {
    var a = W.prototype.toJSON.call(this);
    return Tl(this.parameters.shapes, a);
  };
  Ub.prototype = Object.create(F.prototype);
  Ub.prototype.constructor = Ub;
  Ub.prototype.toJSON = function() {
    var a = F.prototype.toJSON.call(this);
    return Tl(this.parameters.shapes, a);
  };
  Wg.prototype = Object.create(F.prototype);
  Wg.prototype.constructor = Wg;
  xc.prototype = Object.create(W.prototype);
  xc.prototype.constructor = xc;
  fe.prototype = Object.create(F.prototype);
  fe.prototype.constructor = fe;
  Xg.prototype = Object.create(xc.prototype);
  Xg.prototype.constructor = Xg;
  mi.prototype = Object.create(fe.prototype);
  mi.prototype.constructor = mi;
  Yg.prototype = Object.create(W.prototype);
  Yg.prototype.constructor = Yg;
  Yf.prototype = Object.create(F.prototype);
  Yf.prototype.constructor = Yf;
  var eb = Object.freeze({
    WireframeGeometry: Uf,
    ParametricGeometry: Vf,
    ParametricBufferGeometry: Yd,
    TetrahedronGeometry: Ve,
    TetrahedronBufferGeometry: Zd,
    OctahedronGeometry: We,
    OctahedronBufferGeometry: Sb,
    IcosahedronGeometry: Rg,
    IcosahedronBufferGeometry: nd,
    DodecahedronGeometry: Sg,
    DodecahedronBufferGeometry: $d,
    PolyhedronGeometry: Qg,
    PolyhedronBufferGeometry: yb,
    TubeGeometry: Wf,
    TubeBufferGeometry: tc,
    TorusKnotGeometry: Xf,
    TorusKnotBufferGeometry: Tg,
    TorusGeometry: Ug,
    TorusBufferGeometry: Vg,
    TextGeometry: ji,
    TextBufferGeometry: ce,
    SphereGeometry: ki,
    SphereBufferGeometry: de,
    RingGeometry: li,
    RingBufferGeometry: ee,
    PlaneGeometry: Hg,
    PlaneBufferGeometry: id,
    LatheGeometry: $e,
    LatheBufferGeometry: af,
    ShapeGeometry: wc,
    ShapeBufferGeometry: Ub,
    ExtrudeGeometry: Tb,
    ExtrudeBufferGeometry: vc,
    EdgesGeometry: Wg,
    ConeGeometry: Xg,
    ConeBufferGeometry: mi,
    CylinderGeometry: xc,
    CylinderBufferGeometry: fe,
    CircleGeometry: Yg,
    CircleBufferGeometry: Yf,
    BoxGeometry: ap,
    BoxBufferGeometry: Ig
  });
  yc.prototype = Object.create(T.prototype);
  yc.prototype.constructor = yc;
  yc.prototype.isShadowMaterial = !0;
  yc.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    return this;
  };
  pd.prototype = Object.create(Pa.prototype);
  pd.prototype.constructor = pd;
  pd.prototype.isRawShaderMaterial = !0;
  zc.prototype = Object.create(T.prototype);
  zc.prototype.constructor = zc;
  zc.prototype.isMeshStandardMaterial = !0;
  zc.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.defines = { STANDARD: "" };
    this.color.copy(a.color);
    this.roughness = a.roughness;
    this.metalness = a.metalness;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.roughnessMap = a.roughnessMap;
    this.metalnessMap = a.metalnessMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.envMapIntensity = a.envMapIntensity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Vb.prototype = Object.create(zc.prototype);
  Vb.prototype.constructor = Vb;
  Vb.prototype.isMeshPhysicalMaterial = !0;
  Vb.prototype.copy = function(a) {
    zc.prototype.copy.call(this, a);
    this.defines = { STANDARD: "", PHYSICAL: "" };
    this.reflectivity = a.reflectivity;
    this.clearcoat = a.clearcoat;
    this.clearcoatRoughness = a.clearcoatRoughness;
    this.sheen = a.sheen ? (this.sheen || new L()).copy(a.sheen) : null;
    this.clearcoatNormalMap = a.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
    this.transparency = a.transparency;
    return this;
  };
  Ac.prototype = Object.create(T.prototype);
  Ac.prototype.constructor = Ac;
  Ac.prototype.isMeshPhongMaterial = !0;
  Ac.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Bc.prototype = Object.create(Ac.prototype);
  Bc.prototype.constructor = Bc;
  Bc.prototype.isMeshToonMaterial = !0;
  Bc.prototype.copy = function(a) {
    Ac.prototype.copy.call(this, a);
    this.gradientMap = a.gradientMap;
    return this;
  };
  Wb.prototype = Object.create(T.prototype);
  Wb.prototype.constructor = Wb;
  Wb.prototype.isMeshNormalMaterial = !0;
  Wb.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  bf.prototype = Object.create(T.prototype);
  bf.prototype.constructor = bf;
  bf.prototype.isMeshLambertMaterial = !0;
  bf.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Cc.prototype = Object.create(T.prototype);
  Cc.prototype.constructor = Cc;
  Cc.prototype.isMeshMatcapMaterial = !0;
  Cc.prototype.copy = function(a) {
    T.prototype.copy.call(this, a);
    this.defines = { MATCAP: "" };
    this.color.copy(a.color);
    this.matcap = a.matcap;
    this.map = a.map;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.alphaMap = a.alphaMap;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Dc.prototype = Object.create(qa.prototype);
  Dc.prototype.constructor = Dc;
  Dc.prototype.isLineDashedMaterial = !0;
  Dc.prototype.copy = function(a) {
    qa.prototype.copy.call(this, a);
    this.scale = a.scale;
    this.dashSize = a.dashSize;
    this.gapSize = a.gapSize;
    return this;
  };
  var fp = Object.freeze({
      ShadowMaterial: yc,
      SpriteMaterial: Rb,
      RawShaderMaterial: pd,
      ShaderMaterial: Pa,
      PointsMaterial: Wd,
      MeshPhysicalMaterial: Vb,
      MeshStandardMaterial: zc,
      MeshPhongMaterial: Ac,
      MeshToonMaterial: Bc,
      MeshNormalMaterial: Wb,
      MeshLambertMaterial: bf,
      MeshDepthMaterial: ld,
      MeshDistanceMaterial: Te,
      MeshBasicMaterial: vb,
      MeshMatcapMaterial: Cc,
      LineDashedMaterial: Dc,
      LineBasicMaterial: qa,
      Material: T
    }),
    Wa = {
      arraySlice: function(a, b, c) {
        return Wa.isTypedArray(a)
          ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length))
          : a.slice(b, c);
      },
      convertArray: function(a, b, c) {
        return !a || (!c && a.constructor === b)
          ? a
          : "number" === typeof b.BYTES_PER_ELEMENT
          ? new b(a)
          : Array.prototype.slice.call(a);
      },
      isTypedArray: function(a) {
        return ArrayBuffer.isView(a) && !(a instanceof DataView);
      },
      getKeyframeOrder: function(a) {
        for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
        c.sort(function(b, c) {
          return a[b] - a[c];
        });
        return c;
      },
      sortedArray: function(a, b, c) {
        for (
          var d = a.length, e = new a.constructor(d), f = 0, h = 0;
          h !== d;
          ++f
        )
          for (var k = c[f] * b, l = 0; l !== b; ++l) e[h++] = a[k + l];
        return e;
      },
      flattenJSON: function(a, b, c, d) {
        for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; ) f = a[e++];
        if (void 0 !== f) {
          var h = f[d];
          if (void 0 !== h)
            if (Array.isArray(h)) {
              do
                (h = f[d]),
                  void 0 !== h && (b.push(f.time), c.push.apply(c, h)),
                  (f = a[e++]);
              while (void 0 !== f);
            } else if (void 0 !== h.toArray) {
              do
                (h = f[d]),
                  void 0 !== h && (b.push(f.time), h.toArray(c, c.length)),
                  (f = a[e++]);
              while (void 0 !== f);
            } else {
              do
                (h = f[d]),
                  void 0 !== h && (b.push(f.time), c.push(h)),
                  (f = a[e++]);
              while (void 0 !== f);
            }
        }
      }
    };
  Object.assign(Gb.prototype, {
    evaluate: function(a) {
      var b = this.parameterPositions,
        c = this._cachedIndex,
        d = b[c],
        e = b[c - 1];
      a: {
        b: {
          c: {
            d: if (!(a < d)) {
              for (var f = c + 2; ; ) {
                if (void 0 === d) {
                  if (a < e) break d;
                  this._cachedIndex = c = b.length;
                  return this.afterEnd_(c - 1, a, e);
                }
                if (c === f) break;
                e = d;
                d = b[++c];
                if (a < d) break b;
              }
              d = b.length;
              break c;
            }
            if (a >= e) break a;
            else {
              f = b[1];
              a < f && ((c = 2), (e = f));
              for (f = c - 2; ; ) {
                if (void 0 === e)
                  return (this._cachedIndex = 0), this.beforeStart_(0, a, d);
                if (c === f) break;
                d = e;
                e = b[--c - 1];
                if (a >= e) break b;
              }
              d = c;
              c = 0;
            }
          }
          for (; c < d; ) (e = (c + d) >>> 1), a < b[e] ? (d = e) : (c = e + 1);
          d = b[c];
          e = b[c - 1];
          if (void 0 === e)
            return (this._cachedIndex = 0), this.beforeStart_(0, a, d);
          if (void 0 === d)
            return (
              (this._cachedIndex = c = b.length), this.afterEnd_(c - 1, e, a)
            );
        }
        this._cachedIndex = c;
        this.intervalChanged_(c, e, d);
      }
      return this.interpolate_(c, e, a, d);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(a) {
      var b = this.resultBuffer,
        c = this.sampleValues,
        d = this.valueSize;
      a *= d;
      for (var e = 0; e !== d; ++e) b[e] = c[a + e];
      return b;
    },
    interpolate_: function() {
      throw Error("call to abstract method");
    },
    intervalChanged_: function() {}
  });
  Object.assign(Gb.prototype, {
    beforeStart_: Gb.prototype.copySampleValue_,
    afterEnd_: Gb.prototype.copySampleValue_
  });
  ni.prototype = Object.assign(Object.create(Gb.prototype), {
    constructor: ni,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function(a, b, c) {
      var d = this.parameterPositions,
        e = a - 2,
        f = a + 1,
        h = d[e],
        k = d[f];
      if (void 0 === h)
        switch (this.getSettings_().endingStart) {
          case 2401:
            e = a;
            h = 2 * b - c;
            break;
          case 2402:
            e = d.length - 2;
            h = b + d[e] - d[e + 1];
            break;
          default:
            (e = a), (h = c);
        }
      if (void 0 === k)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            f = a;
            k = 2 * c - b;
            break;
          case 2402:
            f = 1;
            k = c + d[1] - d[0];
            break;
          default:
            (f = a - 1), (k = b);
        }
      a = 0.5 * (c - b);
      d = this.valueSize;
      this._weightPrev = a / (b - h);
      this._weightNext = a / (k - c);
      this._offsetPrev = e * d;
      this._offsetNext = f * d;
    },
    interpolate_: function(a, b, c, d) {
      var e = this.resultBuffer,
        f = this.sampleValues,
        h = this.valueSize;
      a *= h;
      var k = a - h,
        l = this._offsetPrev,
        m = this._offsetNext,
        n = this._weightPrev,
        q = this._weightNext,
        t = (c - b) / (d - b);
      c = t * t;
      d = c * t;
      b = -n * d + 2 * n * c - n * t;
      n = (1 + n) * d + (-1.5 - 2 * n) * c + (-0.5 + n) * t + 1;
      t = (-1 - q) * d + (1.5 + q) * c + 0.5 * t;
      q = q * d - q * c;
      for (c = 0; c !== h; ++c)
        e[c] = b * f[l + c] + n * f[k + c] + t * f[a + c] + q * f[m + c];
      return e;
    }
  });
  cf.prototype = Object.assign(Object.create(Gb.prototype), {
    constructor: cf,
    interpolate_: function(a, b, c, d) {
      var e = this.resultBuffer,
        f = this.sampleValues,
        h = this.valueSize;
      a *= h;
      var k = a - h;
      b = (c - b) / (d - b);
      c = 1 - b;
      for (d = 0; d !== h; ++d) e[d] = f[k + d] * c + f[a + d] * b;
      return e;
    }
  });
  oi.prototype = Object.assign(Object.create(Gb.prototype), {
    constructor: oi,
    interpolate_: function(a) {
      return this.copySampleValue_(a - 1);
    }
  });
  Object.assign(kb, {
    toJSON: function(a) {
      var b = a.constructor;
      if (void 0 !== b.toJSON) b = b.toJSON(a);
      else {
        b = {
          name: a.name,
          times: Wa.convertArray(a.times, Array),
          values: Wa.convertArray(a.values, Array)
        };
        var c = a.getInterpolation();
        c !== a.DefaultInterpolation && (b.interpolation = c);
      }
      b.type = a.ValueTypeName;
      return b;
    }
  });
  Object.assign(kb.prototype, {
    constructor: kb,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(a) {
      return new oi(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodLinear: function(a) {
      return new cf(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodSmooth: function(a) {
      return new ni(this.times, this.values, this.getValueSize(), a);
    },
    setInterpolation: function(a) {
      switch (a) {
        case 2300:
          var b = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          b = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          b = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === b) {
        b =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant)
          if (a !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else throw Error(b);
        console.warn("THREE.KeyframeTrack:", b);
        return this;
      }
      this.createInterpolant = b;
      return this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(a) {
      if (0 !== a)
        for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
      return this;
    },
    scale: function(a) {
      if (1 !== a)
        for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
      return this;
    },
    trim: function(a, b) {
      for (
        var c = this.times, d = c.length, e = 0, f = d - 1;
        e !== d && c[e] < a;

      )
        ++e;
      for (; -1 !== f && c[f] > b; ) --f;
      ++f;
      if (0 !== e || f !== d)
        e >= f && ((f = Math.max(f, 1)), (e = f - 1)),
          (a = this.getValueSize()),
          (this.times = Wa.arraySlice(c, e, f)),
          (this.values = Wa.arraySlice(this.values, e * a, f * a));
      return this;
    },
    validate: function() {
      var a = !0,
        b = this.getValueSize();
      0 !== b - Math.floor(b) &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (a = !1));
      var c = this.times;
      b = this.values;
      var d = c.length;
      0 === d &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (a = !1));
      for (var e = null, f = 0; f !== d; f++) {
        var h = c[f];
        if ("number" === typeof h && isNaN(h)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            f,
            h
          );
          a = !1;
          break;
        }
        if (null !== e && e > h) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            f,
            h,
            e
          );
          a = !1;
          break;
        }
        e = h;
      }
      if (void 0 !== b && Wa.isTypedArray(b))
        for (f = 0, c = b.length; f !== c; ++f)
          if (((d = b[f]), isNaN(d))) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              f,
              d
            );
            a = !1;
            break;
          }
      return a;
    },
    optimize: function() {
      for (
        var a = this.times,
          b = this.values,
          c = this.getValueSize(),
          d = 2302 === this.getInterpolation(),
          e = 1,
          f = a.length - 1,
          h = 1;
        h < f;
        ++h
      ) {
        var k = !1,
          l = a[h];
        if (l !== a[h + 1] && (1 !== h || l !== l[0]))
          if (d) k = !0;
          else {
            var m = h * c,
              n = m - c,
              q = m + c;
            for (l = 0; l !== c; ++l) {
              var t = b[m + l];
              if (t !== b[n + l] || t !== b[q + l]) {
                k = !0;
                break;
              }
            }
          }
        if (k) {
          if (h !== e)
            for (a[e] = a[h], k = h * c, m = e * c, l = 0; l !== c; ++l)
              b[m + l] = b[k + l];
          ++e;
        }
      }
      if (0 < f) {
        a[e] = a[f];
        k = f * c;
        m = e * c;
        for (l = 0; l !== c; ++l) b[m + l] = b[k + l];
        ++e;
      }
      e !== a.length &&
        ((this.times = Wa.arraySlice(a, 0, e)),
        (this.values = Wa.arraySlice(b, 0, e * c)));
      return this;
    },
    clone: function() {
      var a = Wa.arraySlice(this.times, 0),
        b = Wa.arraySlice(this.values, 0);
      a = new this.constructor(this.name, a, b);
      a.createInterpolant = this.createInterpolant;
      return a;
    }
  });
  Zg.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: Zg,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  Ej.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: Ej,
    ValueTypeName: "color"
  });
  qd.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: qd,
    ValueTypeName: "number"
  });
  Fj.prototype = Object.assign(Object.create(Gb.prototype), {
    constructor: Fj,
    interpolate_: function(a, b, c, d) {
      var e = this.resultBuffer,
        f = this.sampleValues,
        h = this.valueSize;
      a *= h;
      b = (c - b) / (d - b);
      for (c = a + h; a !== c; a += 4) mb.slerpFlat(e, 0, f, a - h, f, a, b);
      return e;
    }
  });
  pi.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: pi,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function(a) {
      return new Fj(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodSmooth: void 0
  });
  Gj.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: Gj,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  ge.prototype = Object.assign(Object.create(kb.prototype), {
    constructor: ge,
    ValueTypeName: "vector"
  });
  Object.assign(Xb, {
    parse: function(a) {
      for (
        var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length;
        e !== f;
        ++e
      )
        b.push(Po(c[e]).scale(d));
      return new Xb(a.name, a.duration, b);
    },
    toJSON: function(a) {
      var b = [],
        c = a.tracks;
      a = { name: a.name, duration: a.duration, tracks: b, uuid: a.uuid };
      for (var d = 0, e = c.length; d !== e; ++d) b.push(kb.toJSON(c[d]));
      return a;
    },
    CreateFromMorphTargetSequence: function(a, b, c, d) {
      for (var e = b.length, f = [], h = 0; h < e; h++) {
        var k = [],
          l = [];
        k.push((h + e - 1) % e, h, (h + 1) % e);
        l.push(0, 1, 0);
        var m = Wa.getKeyframeOrder(k);
        k = Wa.sortedArray(k, 1, m);
        l = Wa.sortedArray(l, 1, m);
        d || 0 !== k[0] || (k.push(e), l.push(l[0]));
        f.push(
          new qd(".morphTargetInfluences[" + b[h].name + "]", k, l).scale(1 / c)
        );
      }
      return new Xb(a, -1, f);
    },
    findByName: function(a, b) {
      var c = a;
      Array.isArray(a) ||
        (c = (a.geometry && a.geometry.animations) || a.animations);
      for (a = 0; a < c.length; a++) if (c[a].name === b) return c[a];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(a, b, c) {
      for (
        var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, h = a.length;
        f < h;
        f++
      ) {
        var k = a[f],
          l = k.name.match(e);
        if (l && 1 < l.length) {
          var m = l[1];
          (l = d[m]) || (d[m] = l = []);
          l.push(k);
        }
      }
      a = [];
      for (m in d) a.push(Xb.CreateFromMorphTargetSequence(m, d[m], b, c));
      return a;
    },
    parseAnimation: function(a, b) {
      if (!a)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      var c = function(a, b, c, d, e) {
          if (0 !== c.length) {
            var f = [],
              h = [];
            Wa.flattenJSON(c, f, h, d);
            0 !== f.length && e.push(new a(b, f, h));
          }
        },
        d = [],
        e = a.name || "default",
        f = a.length || -1,
        h = a.fps || 30;
      a = a.hierarchy || [];
      for (var k = 0; k < a.length; k++) {
        var l = a[k].keys;
        if (l && 0 !== l.length)
          if (l[0].morphTargets) {
            f = {};
            for (var m = 0; m < l.length; m++)
              if (l[m].morphTargets)
                for (var n = 0; n < l[m].morphTargets.length; n++)
                  f[l[m].morphTargets[n]] = -1;
            for (var q in f) {
              var t = [],
                r = [];
              for (n = 0; n !== l[m].morphTargets.length; ++n) {
                var u = l[m];
                t.push(u.time);
                r.push(u.morphTarget === q ? 1 : 0);
              }
              d.push(new qd(".morphTargetInfluence[" + q + "]", t, r));
            }
            f = f.length * (h || 1);
          } else
            (m = ".bones[" + b[k].name + "]"),
              c(ge, m + ".position", l, "pos", d),
              c(pi, m + ".quaternion", l, "rot", d),
              c(ge, m + ".scale", l, "scl", d);
      }
      return 0 === d.length ? null : new Xb(e, f, d);
    }
  });
  Object.assign(Xb.prototype, {
    resetDuration: function() {
      for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
        var d = this.tracks[b];
        a = Math.max(a, d.times[d.times.length - 1]);
      }
      this.duration = a;
      return this;
    },
    trim: function() {
      for (var a = 0; a < this.tracks.length; a++)
        this.tracks[a].trim(0, this.duration);
      return this;
    },
    validate: function() {
      for (var a = !0, b = 0; b < this.tracks.length; b++)
        a = a && this.tracks[b].validate();
      return a;
    },
    optimize: function() {
      for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
      return this;
    },
    clone: function() {
      for (var a = [], b = 0; b < this.tracks.length; b++)
        a.push(this.tracks[b].clone());
      return new Xb(this.name, this.duration, a);
    }
  });
  var Ef = {
      enabled: !1,
      files: {},
      add: function(a, b) {
        !1 !== this.enabled && (this.files[a] = b);
      },
      get: function(a) {
        if (!1 !== this.enabled) return this.files[a];
      },
      remove: function(a) {
        delete this.files[a];
      },
      clear: function() {
        this.files = {};
      }
    },
    Qo = new Ul();
  Object.assign(sa.prototype, {
    load: function() {},
    parse: function() {},
    setCrossOrigin: function(a) {
      this.crossOrigin = a;
      return this;
    },
    setPath: function(a) {
      this.path = a;
      return this;
    },
    setResourcePath: function(a) {
      this.resourcePath = a;
      return this;
    }
  });
  var jc = {};
  Ec.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Ec,
    load: function(a, b, c, d) {
      void 0 === a && (a = "");
      void 0 !== this.path && (a = this.path + a);
      a = this.manager.resolveURL(a);
      var e = this,
        f = Ef.get(a);
      if (void 0 !== f)
        return (
          e.manager.itemStart(a),
          setTimeout(function() {
            b && b(f);
            e.manager.itemEnd(a);
          }, 0),
          f
        );
      if (void 0 !== jc[a])
        jc[a].push({ onLoad: b, onProgress: c, onError: d });
      else {
        var h = a.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (h) {
          c = h[1];
          var k = !!h[2];
          h = h[3];
          h = decodeURIComponent(h);
          k && (h = atob(h));
          try {
            var l = (this.responseType || "").toLowerCase();
            switch (l) {
              case "arraybuffer":
              case "blob":
                var m = new Uint8Array(h.length);
                for (k = 0; k < h.length; k++) m[k] = h.charCodeAt(k);
                var n =
                  "blob" === l ? new Blob([m.buffer], { type: c }) : m.buffer;
                break;
              case "document":
                n = new DOMParser().parseFromString(h, c);
                break;
              case "json":
                n = JSON.parse(h);
                break;
              default:
                n = h;
            }
            setTimeout(function() {
              b && b(n);
              e.manager.itemEnd(a);
            }, 0);
          } catch (t) {
            setTimeout(function() {
              d && d(t);
              e.manager.itemError(a);
              e.manager.itemEnd(a);
            }, 0);
          }
        } else {
          jc[a] = [];
          jc[a].push({ onLoad: b, onProgress: c, onError: d });
          var q = new XMLHttpRequest();
          q.open("GET", a, !0);
          q.addEventListener(
            "load",
            function(b) {
              var c = this.response;
              Ef.add(a, c);
              var d = jc[a];
              delete jc[a];
              if (200 === this.status || 0 === this.status) {
                0 === this.status &&
                  console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var f = 0, h = d.length; f < h; f++) {
                  var k = d[f];
                  if (k.onLoad) k.onLoad(c);
                }
              } else {
                f = 0;
                for (h = d.length; f < h; f++)
                  if (((k = d[f]), k.onError)) k.onError(b);
                e.manager.itemError(a);
              }
              e.manager.itemEnd(a);
            },
            !1
          );
          q.addEventListener(
            "progress",
            function(b) {
              for (var c = jc[a], d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                if (f.onProgress) f.onProgress(b);
              }
            },
            !1
          );
          q.addEventListener(
            "error",
            function(b) {
              var c = jc[a];
              delete jc[a];
              for (var d = 0, f = c.length; d < f; d++) {
                var h = c[d];
                if (h.onError) h.onError(b);
              }
              e.manager.itemError(a);
              e.manager.itemEnd(a);
            },
            !1
          );
          q.addEventListener(
            "abort",
            function(b) {
              var c = jc[a];
              delete jc[a];
              for (var d = 0, f = c.length; d < f; d++) {
                var h = c[d];
                if (h.onError) h.onError(b);
              }
              e.manager.itemError(a);
              e.manager.itemEnd(a);
            },
            !1
          );
          void 0 !== this.responseType && (q.responseType = this.responseType);
          void 0 !== this.withCredentials &&
            (q.withCredentials = this.withCredentials);
          q.overrideMimeType &&
            q.overrideMimeType(
              void 0 !== this.mimeType ? this.mimeType : "text/plain"
            );
          for (k in this.requestHeader)
            q.setRequestHeader(k, this.requestHeader[k]);
          q.send(null);
        }
        e.manager.itemStart(a);
        return q;
      }
    },
    setResponseType: function(a) {
      this.responseType = a;
      return this;
    },
    setWithCredentials: function(a) {
      this.withCredentials = a;
      return this;
    },
    setMimeType: function(a) {
      this.mimeType = a;
      return this;
    },
    setRequestHeader: function(a) {
      this.requestHeader = a;
      return this;
    }
  });
  Vl.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Vl,
    load: function(a, b, c, d) {
      var e = this,
        f = new Ec(e.manager);
      f.setPath(e.path);
      f.load(
        a,
        function(a) {
          b(e.parse(JSON.parse(a)));
        },
        c,
        d
      );
    },
    parse: function(a) {
      for (var b = [], c = 0; c < a.length; c++) {
        var d = Xb.parse(a[c]);
        b.push(d);
      }
      return b;
    }
  });
  Wl.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Wl,
    load: function(a, b, c, d) {
      function e(e) {
        l.load(
          a[e],
          function(a) {
            a = f.parse(a, !0);
            h[e] = {
              width: a.width,
              height: a.height,
              format: a.format,
              mipmaps: a.mipmaps
            };
            m += 1;
            6 === m &&
              (1 === a.mipmapCount && (k.minFilter = 1006),
              (k.format = a.format),
              (k.needsUpdate = !0),
              b && b(k));
          },
          c,
          d
        );
      }
      var f = this,
        h = [],
        k = new Xd();
      k.image = h;
      var l = new Ec(this.manager);
      l.setPath(this.path);
      l.setResponseType("arraybuffer");
      if (Array.isArray(a))
        for (var m = 0, n = 0, q = a.length; n < q; ++n) e(n);
      else
        l.load(
          a,
          function(a) {
            a = f.parse(a, !0);
            if (a.isCubemap)
              for (
                var c = a.mipmaps.length / a.mipmapCount, d = 0;
                d < c;
                d++
              ) {
                h[d] = { mipmaps: [] };
                for (var e = 0; e < a.mipmapCount; e++)
                  h[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]),
                    (h[d].format = a.format),
                    (h[d].width = a.width),
                    (h[d].height = a.height);
              }
            else
              (k.image.width = a.width),
                (k.image.height = a.height),
                (k.mipmaps = a.mipmaps);
            1 === a.mipmapCount && (k.minFilter = 1006);
            k.format = a.format;
            k.needsUpdate = !0;
            b && b(k);
          },
          c,
          d
        );
      return k;
    }
  });
  Xl.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Xl,
    load: function(a, b, c, d) {
      var e = this,
        f = new pc(),
        h = new Ec(this.manager);
      h.setResponseType("arraybuffer");
      h.setPath(this.path);
      h.load(
        a,
        function(a) {
          if ((a = e.parse(a)))
            void 0 !== a.image
              ? (f.image = a.image)
              : void 0 !== a.data &&
                ((f.image.width = a.width),
                (f.image.height = a.height),
                (f.image.data = a.data)),
              (f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001),
              (f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001),
              (f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006),
              (f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008),
              (f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1),
              void 0 !== a.format && (f.format = a.format),
              void 0 !== a.type && (f.type = a.type),
              void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps),
              1 === a.mipmapCount && (f.minFilter = 1006),
              (f.needsUpdate = !0),
              b && b(f, a);
        },
        c,
        d
      );
      return f;
    }
  });
  he.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: he,
    load: function(a, b, c, d) {
      function e() {
        l.removeEventListener("load", e, !1);
        l.removeEventListener("error", f, !1);
        Ef.add(a, this);
        b && b(this);
        h.manager.itemEnd(a);
      }
      function f(b) {
        l.removeEventListener("load", e, !1);
        l.removeEventListener("error", f, !1);
        d && d(b);
        h.manager.itemError(a);
        h.manager.itemEnd(a);
      }
      void 0 !== this.path && (a = this.path + a);
      a = this.manager.resolveURL(a);
      var h = this,
        k = Ef.get(a);
      if (void 0 !== k)
        return (
          h.manager.itemStart(a),
          setTimeout(function() {
            b && b(k);
            h.manager.itemEnd(a);
          }, 0),
          k
        );
      var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      l.addEventListener("load", e, !1);
      l.addEventListener("error", f, !1);
      "data:" !== a.substr(0, 5) &&
        void 0 !== this.crossOrigin &&
        (l.crossOrigin = this.crossOrigin);
      h.manager.itemStart(a);
      l.src = a;
      return l;
    }
  });
  qi.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: qi,
    load: function(a, b, c, d) {
      function e(c) {
        h.load(
          a[c],
          function(a) {
            f.images[c] = a;
            k++;
            6 === k && ((f.needsUpdate = !0), b && b(f));
          },
          void 0,
          d
        );
      }
      var f = new Sd(),
        h = new he(this.manager);
      h.setCrossOrigin(this.crossOrigin);
      h.setPath(this.path);
      var k = 0;
      for (c = 0; c < a.length; ++c) e(c);
      return f;
    }
  });
  $g.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: $g,
    load: function(a, b, c, d) {
      var e = new pa(),
        f = new he(this.manager);
      f.setCrossOrigin(this.crossOrigin);
      f.setPath(this.path);
      f.load(
        a,
        function(c) {
          e.image = c;
          c =
            0 < a.search(/\.jpe?g($|\?)/i) ||
            0 === a.search(/^data:image\/jpeg/);
          e.format = c ? 1022 : 1023;
          e.needsUpdate = !0;
          void 0 !== b && b(e);
        },
        c,
        d
      );
      return e;
    }
  });
  Object.assign(V.prototype, {
    getPoint: function() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    },
    getPointAt: function(a, b) {
      a = this.getUtoTmapping(a);
      return this.getPoint(a, b);
    },
    getPoints: function(a) {
      void 0 === a && (a = 5);
      for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
      return b;
    },
    getSpacedPoints: function(a) {
      void 0 === a && (a = 5);
      for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
      return b;
    },
    getLength: function() {
      var a = this.getLengths();
      return a[a.length - 1];
    },
    getLengths: function(a) {
      void 0 === a && (a = this.arcLengthDivisions);
      if (
        this.cacheArcLengths &&
        this.cacheArcLengths.length === a + 1 &&
        !this.needsUpdate
      )
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      var b = [],
        c = this.getPoint(0),
        d,
        e = 0;
      b.push(0);
      for (d = 1; d <= a; d++) {
        var f = this.getPoint(d / a);
        e += f.distanceTo(c);
        b.push(e);
        c = f;
      }
      return (this.cacheArcLengths = b);
    },
    updateArcLengths: function() {
      this.needsUpdate = !0;
      this.getLengths();
    },
    getUtoTmapping: function(a, b) {
      var c = this.getLengths(),
        d = c.length;
      b = b ? b : a * c[d - 1];
      for (var e = 0, f = d - 1, h; e <= f; )
        if (((a = Math.floor(e + (f - e) / 2)), (h = c[a] - b), 0 > h))
          e = a + 1;
        else if (0 < h) f = a - 1;
        else {
          f = a;
          break;
        }
      a = f;
      if (c[a] === b) return a / (d - 1);
      e = c[a];
      return (a + (b - e) / (c[a + 1] - e)) / (d - 1);
    },
    getTangent: function(a) {
      var b = a - 1e-4;
      a += 1e-4;
      0 > b && (b = 0);
      1 < a && (a = 1);
      b = this.getPoint(b);
      return this.getPoint(a)
        .clone()
        .sub(b)
        .normalize();
    },
    getTangentAt: function(a) {
      a = this.getUtoTmapping(a);
      return this.getTangent(a);
    },
    computeFrenetFrames: function(a, b) {
      var c = new r(),
        d = [],
        e = [],
        f = [],
        h = new r(),
        k = new fa(),
        l;
      for (l = 0; l <= a; l++) {
        var m = l / a;
        d[l] = this.getTangentAt(m);
        d[l].normalize();
      }
      e[0] = new r();
      f[0] = new r();
      l = Number.MAX_VALUE;
      m = Math.abs(d[0].x);
      var n = Math.abs(d[0].y),
        q = Math.abs(d[0].z);
      m <= l && ((l = m), c.set(1, 0, 0));
      n <= l && ((l = n), c.set(0, 1, 0));
      q <= l && c.set(0, 0, 1);
      h.crossVectors(d[0], c).normalize();
      e[0].crossVectors(d[0], h);
      f[0].crossVectors(d[0], e[0]);
      for (l = 1; l <= a; l++)
        (e[l] = e[l - 1].clone()),
          (f[l] = f[l - 1].clone()),
          h.crossVectors(d[l - 1], d[l]),
          h.length() > Number.EPSILON &&
            (h.normalize(),
            (c = Math.acos(ca.clamp(d[l - 1].dot(d[l]), -1, 1))),
            e[l].applyMatrix4(k.makeRotationAxis(h, c))),
          f[l].crossVectors(d[l], e[l]);
      if (!0 === b)
        for (
          c = Math.acos(ca.clamp(e[0].dot(e[a]), -1, 1)),
            c /= a,
            0 < d[0].dot(h.crossVectors(e[0], e[a])) && (c = -c),
            l = 1;
          l <= a;
          l++
        )
          e[l].applyMatrix4(k.makeRotationAxis(d[l], c * l)),
            f[l].crossVectors(d[l], e[l]);
      return { tangents: d, normals: e, binormals: f };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.arcLengthDivisions = a.arcLengthDivisions;
      return this;
    },
    toJSON: function() {
      var a = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
      };
      a.arcLengthDivisions = this.arcLengthDivisions;
      a.type = this.type;
      return a;
    },
    fromJSON: function(a) {
      this.arcLengthDivisions = a.arcLengthDivisions;
      return this;
    }
  });
  Hb.prototype = Object.create(V.prototype);
  Hb.prototype.constructor = Hb;
  Hb.prototype.isEllipseCurve = !0;
  Hb.prototype.getPoint = function(a, b) {
    b = b || new E();
    for (
      var c = 2 * Math.PI,
        d = this.aEndAngle - this.aStartAngle,
        e = Math.abs(d) < Number.EPSILON;
      0 > d;

    )
      d += c;
    for (; d > c; ) d -= c;
    d < Number.EPSILON && (d = e ? 0 : c);
    !0 !== this.aClockwise || e || (d = d === c ? -c : d - c);
    c = this.aStartAngle + a * d;
    a = this.aX + this.xRadius * Math.cos(c);
    var f = this.aY + this.yRadius * Math.sin(c);
    0 !== this.aRotation &&
      ((c = Math.cos(this.aRotation)),
      (d = Math.sin(this.aRotation)),
      (e = a - this.aX),
      (f -= this.aY),
      (a = e * c - f * d + this.aX),
      (f = e * d + f * c + this.aY));
    return b.set(a, f);
  };
  Hb.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  Hb.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.aX = this.aX;
    a.aY = this.aY;
    a.xRadius = this.xRadius;
    a.yRadius = this.yRadius;
    a.aStartAngle = this.aStartAngle;
    a.aEndAngle = this.aEndAngle;
    a.aClockwise = this.aClockwise;
    a.aRotation = this.aRotation;
    return a;
  };
  Hb.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  ie.prototype = Object.create(Hb.prototype);
  ie.prototype.constructor = ie;
  ie.prototype.isArcCurve = !0;
  var wg = new r(),
    Ok = new ah(),
    Pk = new ah(),
    Qk = new ah();
  Yb.prototype = Object.create(V.prototype);
  Yb.prototype.constructor = Yb;
  Yb.prototype.isCatmullRomCurve3 = !0;
  Yb.prototype.getPoint = function(a, b) {
    b = b || new r();
    var c = this.points,
      d = c.length;
    a *= d - (this.closed ? 0 : 1);
    var e = Math.floor(a);
    a -= e;
    this.closed
      ? (e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d)
      : 0 === a && e === d - 1 && ((e = d - 2), (a = 1));
    if (this.closed || 0 < e) var f = c[(e - 1) % d];
    else wg.subVectors(c[0], c[1]).add(c[0]), (f = wg);
    var h = c[e % d];
    var k = c[(e + 1) % d];
    this.closed || e + 2 < d
      ? (c = c[(e + 2) % d])
      : (wg.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), (c = wg));
    if ("centripetal" === this.curveType || "chordal" === this.curveType) {
      var l = "chordal" === this.curveType ? 0.5 : 0.25;
      d = Math.pow(f.distanceToSquared(h), l);
      e = Math.pow(h.distanceToSquared(k), l);
      l = Math.pow(k.distanceToSquared(c), l);
      1e-4 > e && (e = 1);
      1e-4 > d && (d = e);
      1e-4 > l && (l = e);
      Ok.initNonuniformCatmullRom(f.x, h.x, k.x, c.x, d, e, l);
      Pk.initNonuniformCatmullRom(f.y, h.y, k.y, c.y, d, e, l);
      Qk.initNonuniformCatmullRom(f.z, h.z, k.z, c.z, d, e, l);
    } else
      "catmullrom" === this.curveType &&
        (Ok.initCatmullRom(f.x, h.x, k.x, c.x, this.tension),
        Pk.initCatmullRom(f.y, h.y, k.y, c.y, this.tension),
        Qk.initCatmullRom(f.z, h.z, k.z, c.z, this.tension));
    b.set(Ok.calc(a), Pk.calc(a), Qk.calc(a));
    return b;
  };
  Yb.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++)
      this.points.push(a.points[b].clone());
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Yb.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++)
      a.points.push(this.points[b].toArray());
    a.closed = this.closed;
    a.curveType = this.curveType;
    a.tension = this.tension;
    return a;
  };
  Yb.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var d = a.points[b];
      this.points.push(new r().fromArray(d));
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Fc.prototype = Object.create(V.prototype);
  Fc.prototype.constructor = Fc;
  Fc.prototype.isCubicBezierCurve = !0;
  Fc.prototype.getPoint = function(a, b) {
    b = b || new E();
    var c = this.v0,
      d = this.v1,
      e = this.v2,
      f = this.v3;
    b.set(je(a, c.x, d.x, e.x, f.x), je(a, c.y, d.y, e.y, f.y));
    return b;
  };
  Fc.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  Fc.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  Fc.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  Gc.prototype = Object.create(V.prototype);
  Gc.prototype.constructor = Gc;
  Gc.prototype.isCubicBezierCurve3 = !0;
  Gc.prototype.getPoint = function(a, b) {
    b = b || new r();
    var c = this.v0,
      d = this.v1,
      e = this.v2,
      f = this.v3;
    b.set(
      je(a, c.x, d.x, e.x, f.x),
      je(a, c.y, d.y, e.y, f.y),
      je(a, c.z, d.z, e.z, f.z)
    );
    return b;
  };
  Gc.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  Gc.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  Gc.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  zb.prototype = Object.create(V.prototype);
  zb.prototype.constructor = zb;
  zb.prototype.isLineCurve = !0;
  zb.prototype.getPoint = function(a, b) {
    b = b || new E();
    1 === a
      ? b.copy(this.v2)
      : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  zb.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  zb.prototype.getTangent = function() {
    return this.v2
      .clone()
      .sub(this.v1)
      .normalize();
  };
  zb.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  zb.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  zb.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Hc.prototype = Object.create(V.prototype);
  Hc.prototype.constructor = Hc;
  Hc.prototype.isLineCurve3 = !0;
  Hc.prototype.getPoint = function(a, b) {
    b = b || new r();
    1 === a
      ? b.copy(this.v2)
      : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  Hc.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  Hc.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Hc.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Hc.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Ic.prototype = Object.create(V.prototype);
  Ic.prototype.constructor = Ic;
  Ic.prototype.isQuadraticBezierCurve = !0;
  Ic.prototype.getPoint = function(a, b) {
    b = b || new E();
    var c = this.v0,
      d = this.v1,
      e = this.v2;
    b.set(df(a, c.x, d.x, e.x), df(a, c.y, d.y, e.y));
    return b;
  };
  Ic.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Ic.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Ic.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Ib.prototype = Object.create(V.prototype);
  Ib.prototype.constructor = Ib;
  Ib.prototype.isQuadraticBezierCurve3 = !0;
  Ib.prototype.getPoint = function(a, b) {
    b = b || new r();
    var c = this.v0,
      d = this.v1,
      e = this.v2;
    b.set(df(a, c.x, d.x, e.x), df(a, c.y, d.y, e.y), df(a, c.z, d.z, e.z));
    return b;
  };
  Ib.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Ib.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Ib.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Jc.prototype = Object.create(V.prototype);
  Jc.prototype.constructor = Jc;
  Jc.prototype.isSplineCurve = !0;
  Jc.prototype.getPoint = function(a, b) {
    b = b || new E();
    var c = this.points,
      d = (c.length - 1) * a;
    a = Math.floor(d);
    d -= a;
    var e = c[0 === a ? a : a - 1],
      f = c[a],
      h = c[a > c.length - 2 ? c.length - 1 : a + 1];
    c = c[a > c.length - 3 ? c.length - 1 : a + 2];
    b.set(Yl(d, e.x, f.x, h.x, c.x), Yl(d, e.y, f.y, h.y, c.y));
    return b;
  };
  Jc.prototype.copy = function(a) {
    V.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++)
      this.points.push(a.points[b].clone());
    return this;
  };
  Jc.prototype.toJSON = function() {
    var a = V.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++)
      a.points.push(this.points[b].toArray());
    return a;
  };
  Jc.prototype.fromJSON = function(a) {
    V.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var d = a.points[b];
      this.points.push(new E().fromArray(d));
    }
    return this;
  };
  var Rk = Object.freeze({
    ArcCurve: ie,
    CatmullRomCurve3: Yb,
    CubicBezierCurve: Fc,
    CubicBezierCurve3: Gc,
    EllipseCurve: Hb,
    LineCurve: zb,
    LineCurve3: Hc,
    QuadraticBezierCurve: Ic,
    QuadraticBezierCurve3: Ib,
    SplineCurve: Jc
  });
  ke.prototype = Object.assign(Object.create(V.prototype), {
    constructor: ke,
    add: function(a) {
      this.curves.push(a);
    },
    closePath: function() {
      var a = this.curves[0].getPoint(0),
        b = this.curves[this.curves.length - 1].getPoint(1);
      a.equals(b) || this.curves.push(new zb(b, a));
    },
    getPoint: function(a) {
      var b = a * this.getLength(),
        c = this.getCurveLengths();
      for (a = 0; a < c.length; ) {
        if (c[a] >= b)
          return (
            (b = c[a] - b),
            (a = this.curves[a]),
            (c = a.getLength()),
            a.getPointAt(0 === c ? 0 : 1 - b / c)
          );
        a++;
      }
      return null;
    },
    getLength: function() {
      var a = this.getCurveLengths();
      return a[a.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = !0;
      this.cacheLengths = null;
      this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)
        (b += this.curves[c].getLength()), a.push(b);
      return (this.cacheLengths = a);
    },
    getSpacedPoints: function(a) {
      void 0 === a && (a = 40);
      for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
      this.autoClose && b.push(b[0]);
      return b;
    },
    getPoints: function(a) {
      a = a || 12;
      for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) {
        var f = e[d];
        f = f.getPoints(
          f && f.isEllipseCurve
            ? 2 * a
            : f && (f.isLineCurve || f.isLineCurve3)
            ? 1
            : f && f.isSplineCurve
            ? a * f.points.length
            : a
        );
        for (var h = 0; h < f.length; h++) {
          var k = f[h];
          (c && c.equals(k)) || (b.push(k), (c = k));
        }
      }
      this.autoClose &&
        1 < b.length &&
        !b[b.length - 1].equals(b[0]) &&
        b.push(b[0]);
      return b;
    },
    copy: function(a) {
      V.prototype.copy.call(this, a);
      this.curves = [];
      for (var b = 0, c = a.curves.length; b < c; b++)
        this.curves.push(a.curves[b].clone());
      this.autoClose = a.autoClose;
      return this;
    },
    toJSON: function() {
      var a = V.prototype.toJSON.call(this);
      a.autoClose = this.autoClose;
      a.curves = [];
      for (var b = 0, c = this.curves.length; b < c; b++)
        a.curves.push(this.curves[b].toJSON());
      return a;
    },
    fromJSON: function(a) {
      V.prototype.fromJSON.call(this, a);
      this.autoClose = a.autoClose;
      this.curves = [];
      for (var b = 0, c = a.curves.length; b < c; b++) {
        var d = a.curves[b];
        this.curves.push(new Rk[d.type]().fromJSON(d));
      }
      return this;
    }
  });
  Kc.prototype = Object.assign(Object.create(ke.prototype), {
    constructor: Kc,
    setFromPoints: function(a) {
      this.moveTo(a[0].x, a[0].y);
      for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);
    },
    moveTo: function(a, b) {
      this.currentPoint.set(a, b);
    },
    lineTo: function(a, b) {
      var c = new zb(this.currentPoint.clone(), new E(a, b));
      this.curves.push(c);
      this.currentPoint.set(a, b);
    },
    quadraticCurveTo: function(a, b, c, d) {
      a = new Ic(this.currentPoint.clone(), new E(a, b), new E(c, d));
      this.curves.push(a);
      this.currentPoint.set(c, d);
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
      a = new Fc(
        this.currentPoint.clone(),
        new E(a, b),
        new E(c, d),
        new E(e, f)
      );
      this.curves.push(a);
      this.currentPoint.set(e, f);
    },
    splineThru: function(a) {
      var b = [this.currentPoint.clone()].concat(a);
      b = new Jc(b);
      this.curves.push(b);
      this.currentPoint.copy(a[a.length - 1]);
    },
    arc: function(a, b, c, d, e, f) {
      this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f);
    },
    absarc: function(a, b, c, d, e, f) {
      this.absellipse(a, b, c, c, d, e, f);
    },
    ellipse: function(a, b, c, d, e, f, h, k) {
      this.absellipse(
        a + this.currentPoint.x,
        b + this.currentPoint.y,
        c,
        d,
        e,
        f,
        h,
        k
      );
    },
    absellipse: function(a, b, c, d, e, f, h, k) {
      a = new Hb(a, b, c, d, e, f, h, k);
      0 < this.curves.length &&
        ((b = a.getPoint(0)),
        b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
      this.curves.push(a);
      a = a.getPoint(1);
      this.currentPoint.copy(a);
    },
    copy: function(a) {
      ke.prototype.copy.call(this, a);
      this.currentPoint.copy(a.currentPoint);
      return this;
    },
    toJSON: function() {
      var a = ke.prototype.toJSON.call(this);
      a.currentPoint = this.currentPoint.toArray();
      return a;
    },
    fromJSON: function(a) {
      ke.prototype.fromJSON.call(this, a);
      this.currentPoint.fromArray(a.currentPoint);
      return this;
    }
  });
  rd.prototype = Object.assign(Object.create(Kc.prototype), {
    constructor: rd,
    getPointsHoles: function(a) {
      for (var b = [], c = 0, d = this.holes.length; c < d; c++)
        b[c] = this.holes[c].getPoints(a);
      return b;
    },
    extractPoints: function(a) {
      return { shape: this.getPoints(a), holes: this.getPointsHoles(a) };
    },
    copy: function(a) {
      Kc.prototype.copy.call(this, a);
      this.holes = [];
      for (var b = 0, c = a.holes.length; b < c; b++)
        this.holes.push(a.holes[b].clone());
      return this;
    },
    toJSON: function() {
      var a = Kc.prototype.toJSON.call(this);
      a.uuid = this.uuid;
      a.holes = [];
      for (var b = 0, c = this.holes.length; b < c; b++)
        a.holes.push(this.holes[b].toJSON());
      return a;
    },
    fromJSON: function(a) {
      Kc.prototype.fromJSON.call(this, a);
      this.uuid = a.uuid;
      this.holes = [];
      for (var b = 0, c = a.holes.length; b < c; b++) {
        var d = a.holes[b];
        this.holes.push(new Kc().fromJSON(d));
      }
      return this;
    }
  });
  da.prototype = Object.assign(Object.create(D.prototype), {
    constructor: da,
    isLight: !0,
    copy: function(a) {
      D.prototype.copy.call(this, a);
      this.color.copy(a.color);
      this.intensity = a.intensity;
      return this;
    },
    toJSON: function(a) {
      a = D.prototype.toJSON.call(this, a);
      a.object.color = this.color.getHex();
      a.object.intensity = this.intensity;
      void 0 !== this.groundColor &&
        (a.object.groundColor = this.groundColor.getHex());
      void 0 !== this.distance && (a.object.distance = this.distance);
      void 0 !== this.angle && (a.object.angle = this.angle);
      void 0 !== this.decay && (a.object.decay = this.decay);
      void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
      void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
      return a;
    }
  });
  bh.prototype = Object.assign(Object.create(da.prototype), {
    constructor: bh,
    isHemisphereLight: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.groundColor.copy(a.groundColor);
      return this;
    }
  });
  Object.assign(sd.prototype, {
    _projScreenMatrix: new fa(),
    _lightPositionWorld: new r(),
    _lookTarget: new r(),
    getViewportCount: function() {
      return this._viewportCount;
    },
    getFrustum: function() {
      return this._frustum;
    },
    updateMatrices: function(a) {
      var b = this.camera,
        c = this.matrix,
        d = this._projScreenMatrix,
        e = this._lookTarget,
        f = this._lightPositionWorld;
      f.setFromMatrixPosition(a.matrixWorld);
      b.position.copy(f);
      e.setFromMatrixPosition(a.target.matrixWorld);
      b.lookAt(e);
      b.updateMatrixWorld();
      d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      this._frustum.setFromMatrix(d);
      c.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      c.multiply(b.projectionMatrix);
      c.multiply(b.matrixWorldInverse);
    },
    getViewport: function(a) {
      return this._viewports[a];
    },
    getFrameExtents: function() {
      return this._frameExtents;
    },
    copy: function(a) {
      this.camera = a.camera.clone();
      this.bias = a.bias;
      this.radius = a.radius;
      this.mapSize.copy(a.mapSize);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var a = {};
      0 !== this.bias && (a.bias = this.bias);
      1 !== this.radius && (a.radius = this.radius);
      if (512 !== this.mapSize.x || 512 !== this.mapSize.y)
        a.mapSize = this.mapSize.toArray();
      a.camera = this.camera.toJSON(!1).object;
      delete a.camera.matrix;
      return a;
    }
  });
  ch.prototype = Object.assign(Object.create(sd.prototype), {
    constructor: ch,
    isSpotLightShadow: !0,
    updateMatrices: function(a, b, c) {
      var d = this.camera,
        e = 2 * ca.RAD2DEG * a.angle,
        f = this.mapSize.width / this.mapSize.height,
        h = a.distance || d.far;
      if (e !== d.fov || f !== d.aspect || h !== d.far)
        (d.fov = e), (d.aspect = f), (d.far = h), d.updateProjectionMatrix();
      sd.prototype.updateMatrices.call(this, a, b, c);
    }
  });
  dh.prototype = Object.assign(Object.create(da.prototype), {
    constructor: dh,
    isSpotLight: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.distance = a.distance;
      this.angle = a.angle;
      this.penumbra = a.penumbra;
      this.decay = a.decay;
      this.target = a.target.clone();
      this.shadow = a.shadow.clone();
      return this;
    }
  });
  eh.prototype = Object.assign(Object.create(sd.prototype), {
    constructor: eh,
    isPointLightShadow: !0,
    updateMatrices: function(a, b, c) {
      b = this.camera;
      var d = this.matrix,
        e = this._lightPositionWorld,
        f = this._lookTarget,
        h = this._projScreenMatrix;
      e.setFromMatrixPosition(a.matrixWorld);
      b.position.copy(e);
      f.copy(b.position);
      f.add(this._cubeDirections[c]);
      b.up.copy(this._cubeUps[c]);
      b.lookAt(f);
      b.updateMatrixWorld();
      d.makeTranslation(-e.x, -e.y, -e.z);
      h.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      this._frustum.setFromMatrix(h);
    }
  });
  Hj.prototype = Object.assign(Object.create(da.prototype), {
    constructor: Hj,
    isPointLight: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.distance = a.distance;
      this.decay = a.decay;
      this.shadow = a.shadow.clone();
      return this;
    }
  });
  Zf.prototype = Object.assign(Object.create(oc.prototype), {
    constructor: Zf,
    isOrthographicCamera: !0,
    copy: function(a, b) {
      oc.prototype.copy.call(this, a, b);
      this.left = a.left;
      this.right = a.right;
      this.top = a.top;
      this.bottom = a.bottom;
      this.near = a.near;
      this.far = a.far;
      this.zoom = a.zoom;
      this.view = null === a.view ? null : Object.assign({}, a.view);
      return this;
    },
    setViewOffset: function(a, b, c, d, e, f) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        });
      this.view.enabled = !0;
      this.view.fullWidth = a;
      this.view.fullHeight = b;
      this.view.offsetX = c;
      this.view.offsetY = d;
      this.view.width = e;
      this.view.height = f;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      null !== this.view && (this.view.enabled = !1);
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var a = (this.right - this.left) / (2 * this.zoom),
        b = (this.top - this.bottom) / (2 * this.zoom),
        c = (this.right + this.left) / 2,
        d = (this.top + this.bottom) / 2,
        e = c - a;
      c += a;
      a = d + b;
      b = d - b;
      if (null !== this.view && this.view.enabled) {
        c = this.zoom / (this.view.width / this.view.fullWidth);
        b = this.zoom / (this.view.height / this.view.fullHeight);
        var f = (this.right - this.left) / this.view.width;
        d = (this.top - this.bottom) / this.view.height;
        e += (this.view.offsetX / c) * f;
        c = e + (this.view.width / c) * f;
        a -= (this.view.offsetY / b) * d;
        b = a - (this.view.height / b) * d;
      }
      this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(a) {
      a = D.prototype.toJSON.call(this, a);
      a.object.zoom = this.zoom;
      a.object.left = this.left;
      a.object.right = this.right;
      a.object.top = this.top;
      a.object.bottom = this.bottom;
      a.object.near = this.near;
      a.object.far = this.far;
      null !== this.view && (a.object.view = Object.assign({}, this.view));
      return a;
    }
  });
  ri.prototype = Object.assign(Object.create(sd.prototype), {
    constructor: ri,
    isDirectionalLightShadow: !0,
    updateMatrices: function(a, b, c) {
      sd.prototype.updateMatrices.call(this, a, b, c);
    }
  });
  si.prototype = Object.assign(Object.create(da.prototype), {
    constructor: si,
    isDirectionalLight: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.target = a.target.clone();
      this.shadow = a.shadow.clone();
      return this;
    }
  });
  fh.prototype = Object.assign(Object.create(da.prototype), {
    constructor: fh,
    isAmbientLight: !0
  });
  ti.prototype = Object.assign(Object.create(da.prototype), {
    constructor: ti,
    isRectAreaLight: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.width = a.width;
      this.height = a.height;
      return this;
    },
    toJSON: function(a) {
      a = da.prototype.toJSON.call(this, a);
      a.object.width = this.width;
      a.object.height = this.height;
      return a;
    }
  });
  ui.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: ui,
    load: function(a, b, c, d) {
      var e = this,
        f = new Ec(e.manager);
      f.setPath(e.path);
      f.load(
        a,
        function(a) {
          b(e.parse(JSON.parse(a)));
        },
        c,
        d
      );
    },
    parse: function(a) {
      function b(a) {
        void 0 === c[a] &&
          console.warn("THREE.MaterialLoader: Undefined texture", a);
        return c[a];
      }
      var c = this.textures,
        d = new fp[a.type]();
      void 0 !== a.uuid && (d.uuid = a.uuid);
      void 0 !== a.name && (d.name = a.name);
      void 0 !== a.color && d.color.setHex(a.color);
      void 0 !== a.roughness && (d.roughness = a.roughness);
      void 0 !== a.metalness && (d.metalness = a.metalness);
      void 0 !== a.sheen && (d.sheen = new L().setHex(a.sheen));
      void 0 !== a.emissive && d.emissive.setHex(a.emissive);
      void 0 !== a.specular && d.specular.setHex(a.specular);
      void 0 !== a.shininess && (d.shininess = a.shininess);
      void 0 !== a.clearcoat && (d.clearcoat = a.clearcoat);
      void 0 !== a.clearcoatRoughness &&
        (d.clearcoatRoughness = a.clearcoatRoughness);
      void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
      void 0 !== a.fog && (d.fog = a.fog);
      void 0 !== a.flatShading && (d.flatShading = a.flatShading);
      void 0 !== a.blending && (d.blending = a.blending);
      void 0 !== a.combine && (d.combine = a.combine);
      void 0 !== a.side && (d.side = a.side);
      void 0 !== a.opacity && (d.opacity = a.opacity);
      void 0 !== a.transparent && (d.transparent = a.transparent);
      void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
      void 0 !== a.depthTest && (d.depthTest = a.depthTest);
      void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
      void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
      void 0 !== a.stencilWrite && (d.stencilWrite = a.stencilWrite);
      void 0 !== a.stencilWriteMask &&
        (d.stencilWriteMask = a.stencilWriteMask);
      void 0 !== a.stencilFunc && (d.stencilFunc = a.stencilFunc);
      void 0 !== a.stencilRef && (d.stencilRef = a.stencilRef);
      void 0 !== a.stencilFuncMask && (d.stencilFuncMask = a.stencilFuncMask);
      void 0 !== a.stencilFail && (d.stencilFail = a.stencilFail);
      void 0 !== a.stencilZFail && (d.stencilZFail = a.stencilZFail);
      void 0 !== a.stencilZPass && (d.stencilZPass = a.stencilZPass);
      void 0 !== a.wireframe && (d.wireframe = a.wireframe);
      void 0 !== a.wireframeLinewidth &&
        (d.wireframeLinewidth = a.wireframeLinewidth);
      void 0 !== a.wireframeLinecap &&
        (d.wireframeLinecap = a.wireframeLinecap);
      void 0 !== a.wireframeLinejoin &&
        (d.wireframeLinejoin = a.wireframeLinejoin);
      void 0 !== a.rotation && (d.rotation = a.rotation);
      1 !== a.linewidth && (d.linewidth = a.linewidth);
      void 0 !== a.dashSize && (d.dashSize = a.dashSize);
      void 0 !== a.gapSize && (d.gapSize = a.gapSize);
      void 0 !== a.scale && (d.scale = a.scale);
      void 0 !== a.polygonOffset && (d.polygonOffset = a.polygonOffset);
      void 0 !== a.polygonOffsetFactor &&
        (d.polygonOffsetFactor = a.polygonOffsetFactor);
      void 0 !== a.polygonOffsetUnits &&
        (d.polygonOffsetUnits = a.polygonOffsetUnits);
      void 0 !== a.skinning && (d.skinning = a.skinning);
      void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
      void 0 !== a.morphNormals && (d.morphNormals = a.morphNormals);
      void 0 !== a.dithering && (d.dithering = a.dithering);
      void 0 !== a.visible && (d.visible = a.visible);
      void 0 !== a.toneMapped && (d.toneMapped = a.toneMapped);
      void 0 !== a.userData && (d.userData = a.userData);
      if (void 0 !== a.uniforms)
        for (var e in a.uniforms) {
          var f = a.uniforms[e];
          d.uniforms[e] = {};
          switch (f.type) {
            case "t":
              d.uniforms[e].value = b(f.value);
              break;
            case "c":
              d.uniforms[e].value = new L().setHex(f.value);
              break;
            case "v2":
              d.uniforms[e].value = new E().fromArray(f.value);
              break;
            case "v3":
              d.uniforms[e].value = new r().fromArray(f.value);
              break;
            case "v4":
              d.uniforms[e].value = new Ca().fromArray(f.value);
              break;
            case "m3":
              d.uniforms[e].value = new Ya().fromArray(f.value);
            case "m4":
              d.uniforms[e].value = new fa().fromArray(f.value);
              break;
            default:
              d.uniforms[e].value = f.value;
          }
        }
      void 0 !== a.defines && (d.defines = a.defines);
      void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
      void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
      if (void 0 !== a.extensions)
        for (var h in a.extensions) d.extensions[h] = a.extensions[h];
      void 0 !== a.shading && (d.flatShading = 1 === a.shading);
      void 0 !== a.size && (d.size = a.size);
      void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
      void 0 !== a.map && (d.map = b(a.map));
      void 0 !== a.matcap && (d.matcap = b(a.matcap));
      void 0 !== a.alphaMap &&
        ((d.alphaMap = b(a.alphaMap)), (d.transparent = !0));
      void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
      void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
      void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
      void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType);
      void 0 !== a.normalScale &&
        ((e = a.normalScale),
        !1 === Array.isArray(e) && (e = [e, e]),
        (d.normalScale = new E().fromArray(e)));
      void 0 !== a.displacementMap &&
        (d.displacementMap = b(a.displacementMap));
      void 0 !== a.displacementScale &&
        (d.displacementScale = a.displacementScale);
      void 0 !== a.displacementBias &&
        (d.displacementBias = a.displacementBias);
      void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
      void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
      void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
      void 0 !== a.emissiveIntensity &&
        (d.emissiveIntensity = a.emissiveIntensity);
      void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
      void 0 !== a.envMap && (d.envMap = b(a.envMap));
      void 0 !== a.envMapIntensity && (d.envMapIntensity = a.envMapIntensity);
      void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
      void 0 !== a.refractionRatio && (d.refractionRatio = a.refractionRatio);
      void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
      void 0 !== a.lightMapIntensity &&
        (d.lightMapIntensity = a.lightMapIntensity);
      void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
      void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
      void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
      void 0 !== a.clearcoatNormalMap &&
        (d.clearcoatNormalMap = b(a.clearcoatNormalMap));
      void 0 !== a.clearcoatNormalScale &&
        (d.clearcoatNormalScale = new E().fromArray(a.clearcoatNormalScale));
      return d;
    },
    setTextures: function(a) {
      this.textures = a;
      return this;
    }
  });
  var Qm = {
    decodeText: function(a) {
      if ("undefined" !== typeof TextDecoder)
        return new TextDecoder().decode(a);
      for (var b = "", c = 0, d = a.length; c < d; c++)
        b += String.fromCharCode(a[c]);
      try {
        return decodeURIComponent(escape(b));
      } catch (e) {
        return b;
      }
    },
    extractUrlBase: function(a) {
      var b = a.lastIndexOf("/");
      return -1 === b ? "./" : a.substr(0, b + 1);
    }
  };
  vi.prototype = Object.assign(Object.create(F.prototype), {
    constructor: vi,
    isInstancedBufferGeometry: !0,
    copy: function(a) {
      F.prototype.copy.call(this, a);
      this.maxInstancedCount = a.maxInstancedCount;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var a = F.prototype.toJSON.call(this);
      a.maxInstancedCount = this.maxInstancedCount;
      a.isInstancedBufferGeometry = !0;
      return a;
    }
  });
  Ij.prototype = Object.assign(Object.create(ba.prototype), {
    constructor: Ij,
    isInstancedBufferAttribute: !0,
    copy: function(a) {
      ba.prototype.copy.call(this, a);
      this.meshPerAttribute = a.meshPerAttribute;
      return this;
    },
    toJSON: function() {
      var a = ba.prototype.toJSON.call(this);
      a.meshPerAttribute = this.meshPerAttribute;
      a.isInstancedBufferAttribute = !0;
      return a;
    }
  });
  wi.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: wi,
    load: function(a, b, c, d) {
      var e = this,
        f = new Ec(e.manager);
      f.setPath(e.path);
      f.load(
        a,
        function(a) {
          b(e.parse(JSON.parse(a)));
        },
        c,
        d
      );
    },
    parse: function(a) {
      var b = a.isInstancedBufferGeometry ? new vi() : new F(),
        c = a.data.index;
      if (void 0 !== c) {
        var d = new Sk[c.type](c.array);
        b.setIndex(new ba(d, 1));
      }
      c = a.data.attributes;
      for (var e in c) {
        var f = c[e];
        d = new Sk[f.type](f.array);
        d = new (f.isInstancedBufferAttribute ? Ij : ba)(
          d,
          f.itemSize,
          f.normalized
        );
        void 0 !== f.name && (d.name = f.name);
        b.addAttribute(e, d);
      }
      var h = a.data.morphAttributes;
      if (h)
        for (e in h) {
          var k = h[e],
            l = [];
          c = 0;
          for (var m = k.length; c < m; c++)
            (f = k[c]),
              (d = new Sk[f.type](f.array)),
              (d = new ba(d, f.itemSize, f.normalized)),
              void 0 !== f.name && (d.name = f.name),
              l.push(d);
          b.morphAttributes[e] = l;
        }
      e = a.data.groups || a.data.drawcalls || a.data.offsets;
      if (void 0 !== e)
        for (c = 0, f = e.length; c !== f; ++c)
          (d = e[c]), b.addGroup(d.start, d.count, d.materialIndex);
      c = a.data.boundingSphere;
      void 0 !== c &&
        ((e = new r()),
        void 0 !== c.center && e.fromArray(c.center),
        (b.boundingSphere = new ed(e, c.radius)));
      a.name && (b.name = a.name);
      a.userData && (b.userData = a.userData);
      return b;
    }
  });
  var Sk = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray:
      "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };
  Jj.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Jj,
    load: function(a, b, c, d) {
      var e = this,
        f = "" === this.path ? Qm.extractUrlBase(a) : this.path;
      this.resourcePath = this.resourcePath || f;
      f = new Ec(e.manager);
      f.setPath(this.path);
      f.load(
        a,
        function(c) {
          var f = null;
          try {
            f = JSON.parse(c);
          } catch (l) {
            void 0 !== d && d(l);
            console.error(
              "THREE:ObjectLoader: Can't parse " + a + ".",
              l.message
            );
            return;
          }
          c = f.metadata;
          void 0 === c ||
          void 0 === c.type ||
          "geometry" === c.type.toLowerCase()
            ? console.error("THREE.ObjectLoader: Can't load " + a)
            : e.parse(f, b);
        },
        c,
        d
      );
    },
    parse: function(a, b) {
      var c = this.parseShape(a.shapes);
      c = this.parseGeometries(a.geometries, c);
      var d = this.parseImages(a.images, function() {
        void 0 !== b && b(e);
      });
      d = this.parseTextures(a.textures, d);
      d = this.parseMaterials(a.materials, d);
      var e = this.parseObject(a.object, c, d);
      a.animations && (e.animations = this.parseAnimations(a.animations));
      (void 0 !== a.images && 0 !== a.images.length) || void 0 === b || b(e);
      return e;
    },
    parseShape: function(a) {
      var b = {};
      if (void 0 !== a)
        for (var c = 0, d = a.length; c < d; c++) {
          var e = new rd().fromJSON(a[c]);
          b[e.uuid] = e;
        }
      return b;
    },
    parseGeometries: function(a, b) {
      var c = {};
      if (void 0 !== a)
        for (var d = new wi(), e = 0, f = a.length; e < f; e++) {
          var h = a[e];
          switch (h.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              var k = new eb[h.type](
                h.width,
                h.height,
                h.widthSegments,
                h.heightSegments
              );
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              k = new eb[h.type](
                h.width,
                h.height,
                h.depth,
                h.widthSegments,
                h.heightSegments,
                h.depthSegments
              );
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              k = new eb[h.type](
                h.radius,
                h.segments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              k = new eb[h.type](
                h.radiusTop,
                h.radiusBottom,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              k = new eb[h.type](
                h.radius,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              k = new eb[h.type](
                h.radius,
                h.widthSegments,
                h.heightSegments,
                h.phiStart,
                h.phiLength,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              k = new eb[h.type](h.radius, h.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              k = new eb[h.type](
                h.innerRadius,
                h.outerRadius,
                h.thetaSegments,
                h.phiSegments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              k = new eb[h.type](
                h.radius,
                h.tube,
                h.radialSegments,
                h.tubularSegments,
                h.arc
              );
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              k = new eb[h.type](
                h.radius,
                h.tube,
                h.tubularSegments,
                h.radialSegments,
                h.p,
                h.q
              );
              break;
            case "TubeGeometry":
            case "TubeBufferGeometry":
              k = new eb[h.type](
                new Rk[h.path.type]().fromJSON(h.path),
                h.tubularSegments,
                h.radius,
                h.radialSegments,
                h.closed
              );
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              k = new eb[h.type](h.points, h.segments, h.phiStart, h.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              k = new eb[h.type](h.vertices, h.indices, h.radius, h.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              k = [];
              for (var l = 0, m = h.shapes.length; l < m; l++) {
                var n = b[h.shapes[l]];
                k.push(n);
              }
              k = new eb[h.type](k, h.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              k = [];
              l = 0;
              for (m = h.shapes.length; l < m; l++)
                (n = b[h.shapes[l]]), k.push(n);
              l = h.options.extrudePath;
              void 0 !== l &&
                (h.options.extrudePath = new Rk[l.type]().fromJSON(l));
              k = new eb[h.type](k, h.options);
              break;
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              k = d.parse(h);
              break;
            case "Geometry":
              "THREE" in window && "LegacyJSONLoader" in THREE
                ? (k = new THREE.LegacyJSONLoader().parse(h, this.resourcePath)
                    .geometry)
                : console.error(
                    'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
                  );
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"'
              );
              continue;
          }
          k.uuid = h.uuid;
          void 0 !== h.name && (k.name = h.name);
          !0 === k.isBufferGeometry &&
            void 0 !== h.userData &&
            (k.userData = h.userData);
          c[h.uuid] = k;
        }
      return c;
    },
    parseMaterials: function(a, b) {
      var c = {},
        d = {};
      if (void 0 !== a) {
        var e = new ui();
        e.setTextures(b);
        b = 0;
        for (var f = a.length; b < f; b++) {
          var h = a[b];
          if ("MultiMaterial" === h.type) {
            for (var k = [], l = 0; l < h.materials.length; l++) {
              var m = h.materials[l];
              void 0 === c[m.uuid] && (c[m.uuid] = e.parse(m));
              k.push(c[m.uuid]);
            }
            d[h.uuid] = k;
          } else
            void 0 === c[h.uuid] && (c[h.uuid] = e.parse(h)),
              (d[h.uuid] = c[h.uuid]);
        }
      }
      return d;
    },
    parseAnimations: function(a) {
      for (var b = [], c = 0; c < a.length; c++) {
        var d = a[c],
          e = Xb.parse(d);
        void 0 !== d.uuid && (e.uuid = d.uuid);
        b.push(e);
      }
      return b;
    },
    parseImages: function(a, b) {
      function c(a) {
        d.manager.itemStart(a);
        return f.load(
          a,
          function() {
            d.manager.itemEnd(a);
          },
          void 0,
          function() {
            d.manager.itemError(a);
            d.manager.itemEnd(a);
          }
        );
      }
      var d = this,
        e = {};
      if (void 0 !== a && 0 < a.length) {
        b = new Ul(b);
        var f = new he(b);
        f.setCrossOrigin(this.crossOrigin);
        b = 0;
        for (var h = a.length; b < h; b++) {
          var k = a[b],
            l = k.url;
          if (Array.isArray(l)) {
            e[k.uuid] = [];
            for (var m = 0, n = l.length; m < n; m++) {
              var q = l[m];
              q = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(q) ? q : d.resourcePath + q;
              e[k.uuid].push(c(q));
            }
          } else
            (q = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url)
              ? k.url
              : d.resourcePath + k.url),
              (e[k.uuid] = c(q));
        }
      }
      return e;
    },
    parseTextures: function(a, b) {
      function c(a, b) {
        if ("number" === typeof a) return a;
        console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          a
        );
        return b[a];
      }
      var d = {};
      if (void 0 !== a)
        for (var e = 0, f = a.length; e < f; e++) {
          var h = a[e];
          void 0 === h.image &&
            console.warn(
              'THREE.ObjectLoader: No "image" specified for',
              h.uuid
            );
          void 0 === b[h.image] &&
            console.warn("THREE.ObjectLoader: Undefined image", h.image);
          var k = Array.isArray(b[h.image])
            ? new Sd(b[h.image])
            : new pa(b[h.image]);
          k.needsUpdate = !0;
          k.uuid = h.uuid;
          void 0 !== h.name && (k.name = h.name);
          void 0 !== h.mapping && (k.mapping = c(h.mapping, gp));
          void 0 !== h.offset && k.offset.fromArray(h.offset);
          void 0 !== h.repeat && k.repeat.fromArray(h.repeat);
          void 0 !== h.center && k.center.fromArray(h.center);
          void 0 !== h.rotation && (k.rotation = h.rotation);
          void 0 !== h.wrap &&
            ((k.wrapS = c(h.wrap[0], Rm)), (k.wrapT = c(h.wrap[1], Rm)));
          void 0 !== h.format && (k.format = h.format);
          void 0 !== h.type && (k.type = h.type);
          void 0 !== h.encoding && (k.encoding = h.encoding);
          void 0 !== h.minFilter && (k.minFilter = c(h.minFilter, Sm));
          void 0 !== h.magFilter && (k.magFilter = c(h.magFilter, Sm));
          void 0 !== h.anisotropy && (k.anisotropy = h.anisotropy);
          void 0 !== h.flipY && (k.flipY = h.flipY);
          void 0 !== h.premultiplyAlpha &&
            (k.premultiplyAlpha = h.premultiplyAlpha);
          void 0 !== h.unpackAlignment &&
            (k.unpackAlignment = h.unpackAlignment);
          d[h.uuid] = k;
        }
      return d;
    },
    parseObject: function(a, b, c) {
      function d(a) {
        void 0 === b[a] &&
          console.warn("THREE.ObjectLoader: Undefined geometry", a);
        return b[a];
      }
      function e(a) {
        if (void 0 !== a) {
          if (Array.isArray(a)) {
            for (var b = [], d = 0, e = a.length; d < e; d++) {
              var f = a[d];
              void 0 === c[f] &&
                console.warn("THREE.ObjectLoader: Undefined material", f);
              b.push(c[f]);
            }
            return b;
          }
          void 0 === c[a] &&
            console.warn("THREE.ObjectLoader: Undefined material", a);
          return c[a];
        }
      }
      switch (a.type) {
        case "Scene":
          var f = new Kf();
          void 0 !== a.background &&
            Number.isInteger(a.background) &&
            (f.background = new L(a.background));
          void 0 !== a.fog &&
            ("Fog" === a.fog.type
              ? (f.fog = new ci(a.fog.color, a.fog.near, a.fog.far))
              : "FogExp2" === a.fog.type &&
                (f.fog = new bi(a.fog.color, a.fog.density)));
          break;
        case "PerspectiveCamera":
          f = new Ua(a.fov, a.aspect, a.near, a.far);
          void 0 !== a.focus && (f.focus = a.focus);
          void 0 !== a.zoom && (f.zoom = a.zoom);
          void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
          void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
          void 0 !== a.view && (f.view = Object.assign({}, a.view));
          break;
        case "OrthographicCamera":
          f = new Zf(a.left, a.right, a.top, a.bottom, a.near, a.far);
          void 0 !== a.zoom && (f.zoom = a.zoom);
          void 0 !== a.view && (f.view = Object.assign({}, a.view));
          break;
        case "AmbientLight":
          f = new fh(a.color, a.intensity);
          break;
        case "DirectionalLight":
          f = new si(a.color, a.intensity);
          break;
        case "PointLight":
          f = new Hj(a.color, a.intensity, a.distance, a.decay);
          break;
        case "RectAreaLight":
          f = new ti(a.color, a.intensity, a.width, a.height);
          break;
        case "SpotLight":
          f = new dh(
            a.color,
            a.intensity,
            a.distance,
            a.angle,
            a.penumbra,
            a.decay
          );
          break;
        case "HemisphereLight":
          f = new bh(a.color, a.groundColor, a.intensity);
          break;
        case "SkinnedMesh":
          console.warn(
            "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
          );
        case "Mesh":
          f = d(a.geometry);
          var h = e(a.material);
          f = f.bones && 0 < f.bones.length ? new Tf(f, h) : new oa(f, h);
          void 0 !== a.drawMode && f.setDrawMode(a.drawMode);
          break;
        case "LOD":
          f = new Mg();
          break;
        case "Line":
          f = new $a(d(a.geometry), e(a.material), a.mode);
          break;
        case "LineLoop":
          f = new ei(d(a.geometry), e(a.material));
          break;
        case "LineSegments":
          f = new ra(d(a.geometry), e(a.material));
          break;
        case "PointCloud":
        case "Points":
          f = new fi(d(a.geometry), e(a.material));
          break;
        case "Sprite":
          f = new di(e(a.material));
          break;
        case "Group":
          f = new md();
          break;
        default:
          f = new D();
      }
      f.uuid = a.uuid;
      void 0 !== a.name && (f.name = a.name);
      void 0 !== a.matrix
        ? (f.matrix.fromArray(a.matrix),
          void 0 !== a.matrixAutoUpdate &&
            (f.matrixAutoUpdate = a.matrixAutoUpdate),
          f.matrixAutoUpdate &&
            f.matrix.decompose(f.position, f.quaternion, f.scale))
        : (void 0 !== a.position && f.position.fromArray(a.position),
          void 0 !== a.rotation && f.rotation.fromArray(a.rotation),
          void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion),
          void 0 !== a.scale && f.scale.fromArray(a.scale));
      void 0 !== a.castShadow && (f.castShadow = a.castShadow);
      void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow);
      a.shadow &&
        (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias),
        void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius),
        void 0 !== a.shadow.mapSize &&
          f.shadow.mapSize.fromArray(a.shadow.mapSize),
        void 0 !== a.shadow.camera &&
          (f.shadow.camera = this.parseObject(a.shadow.camera)));
      void 0 !== a.visible && (f.visible = a.visible);
      void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
      void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
      void 0 !== a.userData && (f.userData = a.userData);
      void 0 !== a.layers && (f.layers.mask = a.layers);
      if (void 0 !== a.children) {
        h = a.children;
        for (var k = 0; k < h.length; k++) f.add(this.parseObject(h[k], b, c));
      }
      if ("LOD" === a.type)
        for (a = a.levels, h = 0; h < a.length; h++) {
          k = a[h];
          var l = f.getObjectByProperty("uuid", k.object);
          void 0 !== l && f.addLevel(l, k.distance);
        }
      return f;
    }
  });
  var gp = {
      UVMapping: 300,
      CubeReflectionMapping: 301,
      CubeRefractionMapping: 302,
      EquirectangularReflectionMapping: 303,
      EquirectangularRefractionMapping: 304,
      SphericalReflectionMapping: 305,
      CubeUVReflectionMapping: 306,
      CubeUVRefractionMapping: 307
    },
    Rm = {
      RepeatWrapping: 1e3,
      ClampToEdgeWrapping: 1001,
      MirroredRepeatWrapping: 1002
    },
    Sm = {
      NearestFilter: 1003,
      NearestMipmapNearestFilter: 1004,
      NearestMipmapLinearFilter: 1005,
      LinearFilter: 1006,
      LinearMipmapNearestFilter: 1007,
      LinearMipmapLinearFilter: 1008
    };
  Zl.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Zl,
    setOptions: function(a) {
      this.options = a;
      return this;
    },
    load: function(a, b, c, d) {
      void 0 === a && (a = "");
      void 0 !== this.path && (a = this.path + a);
      a = this.manager.resolveURL(a);
      var e = this,
        f = Ef.get(a);
      if (void 0 !== f)
        return (
          e.manager.itemStart(a),
          setTimeout(function() {
            b && b(f);
            e.manager.itemEnd(a);
          }, 0),
          f
        );
      fetch(a)
        .then(function(a) {
          return a.blob();
        })
        .then(function(a) {
          return void 0 === e.options
            ? createImageBitmap(a)
            : createImageBitmap(a, e.options);
        })
        .then(function(c) {
          Ef.add(a, c);
          b && b(c);
          e.manager.itemEnd(a);
        })
        .catch(function(b) {
          d && d(b);
          e.manager.itemError(a);
          e.manager.itemEnd(a);
        });
      e.manager.itemStart(a);
    }
  });
  Object.assign($l.prototype, {
    moveTo: function(a, b) {
      this.currentPath = new Kc();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(a, b);
    },
    lineTo: function(a, b) {
      this.currentPath.lineTo(a, b);
    },
    quadraticCurveTo: function(a, b, c, d) {
      this.currentPath.quadraticCurveTo(a, b, c, d);
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
      this.currentPath.bezierCurveTo(a, b, c, d, e, f);
    },
    splineThru: function(a) {
      this.currentPath.splineThru(a);
    },
    toShapes: function(a, b) {
      function c(a) {
        for (var b = [], c = 0, d = a.length; c < d; c++) {
          var e = a[c],
            f = new rd();
          f.curves = e.curves;
          b.push(f);
        }
        return b;
      }
      function d(a, b) {
        for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
          var h = b[e],
            k = b[f],
            l = k.x - h.x,
            m = k.y - h.y;
          if (Math.abs(m) > Number.EPSILON) {
            if (
              (0 > m && ((h = b[f]), (l = -l), (k = b[e]), (m = -m)),
              !(a.y < h.y || a.y > k.y))
            )
              if (a.y === h.y) {
                if (a.x === h.x) return !0;
              } else {
                e = m * (a.x - h.x) - l * (a.y - h.y);
                if (0 === e) return !0;
                0 > e || (d = !d);
              }
          } else if (
            a.y === h.y &&
            ((k.x <= a.x && a.x <= h.x) || (h.x <= a.x && a.x <= k.x))
          )
            return !0;
        }
        return d;
      }
      var e = be.isClockWise,
        f = this.subPaths;
      if (0 === f.length) return [];
      if (!0 === b) return c(f);
      b = [];
      if (1 === f.length) {
        var h = f[0];
        var k = new rd();
        k.curves = h.curves;
        b.push(k);
        return b;
      }
      var l = !e(f[0].getPoints());
      l = a ? !l : l;
      k = [];
      var m = [],
        n = [],
        q = 0;
      m[q] = void 0;
      n[q] = [];
      for (var r = 0, y = f.length; r < y; r++) {
        h = f[r];
        var u = h.getPoints();
        var v = e(u);
        (v = a ? !v : v)
          ? (!l && m[q] && q++,
            (m[q] = { s: new rd(), p: u }),
            (m[q].s.curves = h.curves),
            l && q++,
            (n[q] = []))
          : n[q].push({ h: h, p: u[0] });
      }
      if (!m[0]) return c(f);
      if (1 < m.length) {
        r = !1;
        a = [];
        e = 0;
        for (f = m.length; e < f; e++) k[e] = [];
        e = 0;
        for (f = m.length; e < f; e++)
          for (h = n[e], v = 0; v < h.length; v++) {
            l = h[v];
            q = !0;
            for (u = 0; u < m.length; u++)
              d(l.p, m[u].p) &&
                (e !== u && a.push({ froms: e, tos: u, hole: v }),
                q ? ((q = !1), k[u].push(l)) : (r = !0));
            q && k[e].push(l);
          }
        0 < a.length && (r || (n = k));
      }
      r = 0;
      for (e = m.length; r < e; r++)
        for (k = m[r].s, b.push(k), a = n[r], f = 0, h = a.length; f < h; f++)
          k.holes.push(a[f].h);
      return b;
    }
  });
  Object.assign(am.prototype, {
    isFont: !0,
    generateShapes: function(a, b) {
      void 0 === b && (b = 100);
      var c = [],
        d = b;
      b = this.data;
      var e = Array.from ? Array.from(a) : String(a).split("");
      d /= b.resolution;
      var f =
        (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
      a = [];
      for (var h = 0, k = 0, l = 0; l < e.length; l++) {
        var m = e[l];
        if ("\n" === m) (h = 0), (k -= f);
        else {
          var n = m;
          m = d;
          var q = h,
            r = k,
            y = b,
            u = y.glyphs[n] || y.glyphs["?"];
          if (u) {
            n = new $l();
            if (u.o) {
              y = u._cachedOutline || (u._cachedOutline = u.o.split(" "));
              for (var v = 0, A = y.length; v < A; )
                switch (y[v++]) {
                  case "m":
                    var C = y[v++] * m + q;
                    var z = y[v++] * m + r;
                    n.moveTo(C, z);
                    break;
                  case "l":
                    C = y[v++] * m + q;
                    z = y[v++] * m + r;
                    n.lineTo(C, z);
                    break;
                  case "q":
                    var D = y[v++] * m + q;
                    var E = y[v++] * m + r;
                    var B = y[v++] * m + q;
                    var F = y[v++] * m + r;
                    n.quadraticCurveTo(B, F, D, E);
                    break;
                  case "b":
                    (D = y[v++] * m + q),
                      (E = y[v++] * m + r),
                      (B = y[v++] * m + q),
                      (F = y[v++] * m + r),
                      (C = y[v++] * m + q),
                      (z = y[v++] * m + r),
                      n.bezierCurveTo(B, F, C, z, D, E);
                }
            }
            m = { offsetX: u.ha * m, path: n };
          } else
            console.error(
              'THREE.Font: character "' +
                n +
                '" does not exists in font family ' +
                y.familyName +
                "."
            ),
              (m = void 0);
          h += m.offsetX;
          a.push(m.path);
        }
      }
      b = 0;
      for (e = a.length; b < e; b++)
        Array.prototype.push.apply(c, a[b].toShapes());
      return c;
    }
  });
  bm.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: bm,
    load: function(a, b, c, d) {
      var e = this,
        f = new Ec(this.manager);
      f.setPath(this.path);
      f.load(
        a,
        function(a) {
          try {
            var c = JSON.parse(a);
          } catch (l) {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ),
              (c = JSON.parse(a.substring(65, a.length - 2)));
          }
          a = e.parse(c);
          b && b(a);
        },
        c,
        d
      );
    },
    parse: function(a) {
      return new am(a);
    }
  });
  var Oh,
    fm = {
      getContext: function() {
        void 0 === Oh &&
          (Oh = new (window.AudioContext || window.webkitAudioContext)());
        return Oh;
      },
      setContext: function(a) {
        Oh = a;
      }
    };
  Kj.prototype = Object.assign(Object.create(sa.prototype), {
    constructor: Kj,
    load: function(a, b, c, d) {
      var e = new Ec(this.manager);
      e.setResponseType("arraybuffer");
      e.setPath(this.path);
      e.load(
        a,
        function(a) {
          a = a.slice(0);
          fm.getContext().decodeAudioData(a, function(a) {
            b(a);
          });
        },
        c,
        d
      );
    }
  });
  Object.assign(Lj.prototype, {
    isSphericalHarmonics3: !0,
    set: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
      return this;
    },
    zero: function() {
      for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
      return this;
    },
    getAt: function(a, b) {
      var c = a.x,
        d = a.y;
      a = a.z;
      var e = this.coefficients;
      b.copy(e[0]).multiplyScalar(0.282095);
      b.addScale(e[1], 0.488603 * d);
      b.addScale(e[2], 0.488603 * a);
      b.addScale(e[3], 0.488603 * c);
      b.addScale(e[4], 1.092548 * c * d);
      b.addScale(e[5], 1.092548 * d * a);
      b.addScale(e[6], 0.315392 * (3 * a * a - 1));
      b.addScale(e[7], 1.092548 * c * a);
      b.addScale(e[8], 0.546274 * (c * c - d * d));
      return b;
    },
    getIrradianceAt: function(a, b) {
      var c = a.x,
        d = a.y;
      a = a.z;
      var e = this.coefficients;
      b.copy(e[0]).multiplyScalar(0.886227);
      b.addScale(e[1], 1.023328 * d);
      b.addScale(e[2], 1.023328 * a);
      b.addScale(e[3], 1.023328 * c);
      b.addScale(e[4], 0.858086 * c * d);
      b.addScale(e[5], 0.858086 * d * a);
      b.addScale(e[6], 0.743125 * a * a - 0.247708);
      b.addScale(e[7], 0.858086 * c * a);
      b.addScale(e[8], 0.429043 * (c * c - d * d));
      return b;
    },
    add: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].add(a.coefficients[b]);
      return this;
    },
    scale: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
      return this;
    },
    lerp: function(a, b) {
      for (var c = 0; 9 > c; c++)
        this.coefficients[c].lerp(a.coefficients[c], b);
      return this;
    },
    equals: function(a) {
      for (var b = 0; 9 > b; b++)
        if (!this.coefficients[b].equals(a.coefficients[b])) return !1;
      return !0;
    },
    copy: function(a) {
      return this.set(a.coefficients);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      for (var c = this.coefficients, d = 0; 9 > d; d++)
        c[d].fromArray(a, b + 3 * d);
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      for (var c = this.coefficients, d = 0; 9 > d; d++)
        c[d].toArray(a, b + 3 * d);
      return a;
    }
  });
  Object.assign(Lj, {
    getBasisAt: function(a, b) {
      var c = a.x,
        d = a.y;
      a = a.z;
      b[0] = 0.282095;
      b[1] = 0.488603 * d;
      b[2] = 0.488603 * a;
      b[3] = 0.488603 * c;
      b[4] = 1.092548 * c * d;
      b[5] = 1.092548 * d * a;
      b[6] = 0.315392 * (3 * a * a - 1);
      b[7] = 1.092548 * c * a;
      b[8] = 0.546274 * (c * c - d * d);
    }
  });
  Lc.prototype = Object.assign(Object.create(da.prototype), {
    constructor: Lc,
    isLightProbe: !0,
    copy: function(a) {
      da.prototype.copy.call(this, a);
      this.sh.copy(a.sh);
      this.intensity = a.intensity;
      return this;
    },
    toJSON: function(a) {
      return da.prototype.toJSON.call(this, a);
    }
  });
  cm.prototype = Object.assign(Object.create(Lc.prototype), {
    constructor: cm,
    isHemisphereLightProbe: !0,
    copy: function(a) {
      Lc.prototype.copy.call(this, a);
      return this;
    },
    toJSON: function(a) {
      return Lc.prototype.toJSON.call(this, a);
    }
  });
  dm.prototype = Object.assign(Object.create(Lc.prototype), {
    constructor: dm,
    isAmbientLightProbe: !0,
    copy: function(a) {
      Lc.prototype.copy.call(this, a);
      return this;
    },
    toJSON: function(a) {
      return Lc.prototype.toJSON.call(this, a);
    }
  });
  var Tm = new fa(),
    Um = new fa();
  Object.assign(
    function() {
      this.type = "StereoCamera";
      this.aspect = 1;
      this.eyeSep = 0.064;
      this.cameraL = new Ua();
      this.cameraL.layers.enable(1);
      this.cameraL.matrixAutoUpdate = !1;
      this.cameraR = new Ua();
      this.cameraR.layers.enable(2);
      this.cameraR.matrixAutoUpdate = !1;
      this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      };
    }.prototype,
    {
      update: function(a) {
        var b = this._cache;
        if (
          b.focus !== a.focus ||
          b.fov !== a.fov ||
          b.aspect !== a.aspect * this.aspect ||
          b.near !== a.near ||
          b.far !== a.far ||
          b.zoom !== a.zoom ||
          b.eyeSep !== this.eyeSep
        ) {
          b.focus = a.focus;
          b.fov = a.fov;
          b.aspect = a.aspect * this.aspect;
          b.near = a.near;
          b.far = a.far;
          b.zoom = a.zoom;
          b.eyeSep = this.eyeSep;
          var c = a.projectionMatrix.clone(),
            d = b.eyeSep / 2,
            e = (d * b.near) / b.focus,
            f = (b.near * Math.tan(ca.DEG2RAD * b.fov * 0.5)) / b.zoom;
          Um.elements[12] = -d;
          Tm.elements[12] = d;
          d = -f * b.aspect + e;
          var h = f * b.aspect + e;
          c.elements[0] = (2 * b.near) / (h - d);
          c.elements[8] = (h + d) / (h - d);
          this.cameraL.projectionMatrix.copy(c);
          d = -f * b.aspect - e;
          h = f * b.aspect - e;
          c.elements[0] = (2 * b.near) / (h - d);
          c.elements[8] = (h + d) / (h - d);
          this.cameraR.projectionMatrix.copy(c);
        }
        this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(Um);
        this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(Tm);
      }
    }
  );
  Object.assign(Mj.prototype, {
    start: function() {
      this.oldTime = this.startTime = ("undefined" === typeof performance
        ? Date
        : performance
      ).now();
      this.elapsedTime = 0;
      this.running = !0;
    },
    stop: function() {
      this.getElapsedTime();
      this.autoStart = this.running = !1;
    },
    getElapsedTime: function() {
      this.getDelta();
      return this.elapsedTime;
    },
    getDelta: function() {
      var a = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        var b = ("undefined" === typeof performance ? Date : performance).now();
        a = (b - this.oldTime) / 1e3;
        this.oldTime = b;
        this.elapsedTime += a;
      }
      return a;
    }
  });
  var Ld = new r(),
    Vm = new mb(),
    hp = new r(),
    Md = new r();
  em.prototype = Object.assign(Object.create(D.prototype), {
    constructor: em,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      null !== this.filter &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null));
      return this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(a) {
      null !== this.filter
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination);
      this.filter = a;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(a) {
      this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
      return this;
    },
    updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(this, a);
      a = this.context.listener;
      var b = this.up;
      this.timeDelta = this._clock.getDelta();
      this.matrixWorld.decompose(Ld, Vm, hp);
      Md.set(0, 0, -1).applyQuaternion(Vm);
      if (a.positionX) {
        var c = this.context.currentTime + this.timeDelta;
        a.positionX.linearRampToValueAtTime(Ld.x, c);
        a.positionY.linearRampToValueAtTime(Ld.y, c);
        a.positionZ.linearRampToValueAtTime(Ld.z, c);
        a.forwardX.linearRampToValueAtTime(Md.x, c);
        a.forwardY.linearRampToValueAtTime(Md.y, c);
        a.forwardZ.linearRampToValueAtTime(Md.z, c);
        a.upX.linearRampToValueAtTime(b.x, c);
        a.upY.linearRampToValueAtTime(b.y, c);
        a.upZ.linearRampToValueAtTime(b.z, c);
      } else
        a.setPosition(Ld.x, Ld.y, Ld.z),
          a.setOrientation(Md.x, Md.y, Md.z, b.x, b.y, b.z);
    }
  });
  td.prototype = Object.assign(Object.create(D.prototype), {
    constructor: td,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(a) {
      this.hasPlaybackControl = !1;
      this.sourceType = "audioNode";
      this.source = a;
      this.connect();
      return this;
    },
    setMediaElementSource: function(a) {
      this.hasPlaybackControl = !1;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(a);
      this.connect();
      return this;
    },
    setMediaStreamSource: function(a) {
      this.hasPlaybackControl = !1;
      this.sourceType = "mediaStreamNode";
      this.source = this.context.createMediaStreamSource(a);
      this.connect();
      return this;
    },
    setBuffer: function(a) {
      this.buffer = a;
      this.sourceType = "buffer";
      this.autoplay && this.play();
      return this;
    },
    play: function() {
      if (!0 === this.isPlaying)
        console.warn("THREE.Audio: Audio is already playing.");
      else if (!1 === this.hasPlaybackControl)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else {
        var a = this.context.createBufferSource();
        a.buffer = this.buffer;
        a.loop = this.loop;
        a.onended = this.onEnded.bind(this);
        this.startTime = this.context.currentTime;
        a.start(this.startTime, this.offset, this.duration);
        this.isPlaying = !0;
        this.source = a;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
    },
    pause: function() {
      if (!1 === this.hasPlaybackControl)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return (
          !0 === this.isPlaying &&
            (this.source.stop(),
            (this.source.onended = null),
            (this.offset +=
              (this.context.currentTime - this.startTime) * this.playbackRate),
            (this.isPlaying = !1)),
          this
        );
    },
    stop: function() {
      if (!1 === this.hasPlaybackControl)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return (
          this.source.stop(),
          (this.source.onended = null),
          (this.offset = 0),
          (this.isPlaying = !1),
          this
        );
    },
    connect: function() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var a = 1, b = this.filters.length; a < b; a++)
          this.filters[a - 1].connect(this.filters[a]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this;
    },
    disconnect: function() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var a = 1, b = this.filters.length; a < b; a++)
          this.filters[a - 1].disconnect(this.filters[a]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(a) {
      a || (a = []);
      !0 === this.isPlaying
        ? (this.disconnect(), (this.filters = a), this.connect())
        : (this.filters = a);
      return this;
    },
    setDetune: function(a) {
      this.detune = a;
      if (void 0 !== this.source.detune)
        return (
          !0 === this.isPlaying &&
            this.source.detune.setTargetAtTime(
              this.detune,
              this.context.currentTime,
              0.01
            ),
          this
        );
    },
    getDetune: function() {
      return this.detune;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(a) {
      return this.setFilters(a ? [a] : []);
    },
    setPlaybackRate: function(a) {
      if (!1 === this.hasPlaybackControl)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return (
          (this.playbackRate = a),
          !0 === this.isPlaying &&
            this.source.playbackRate.setTargetAtTime(
              this.playbackRate,
              this.context.currentTime,
              0.01
            ),
          this
        );
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = !1;
    },
    getLoop: function() {
      return !1 === this.hasPlaybackControl
        ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
        : this.loop;
    },
    setLoop: function(a) {
      if (!1 === this.hasPlaybackControl)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return (
          (this.loop = a),
          !0 === this.isPlaying && (this.source.loop = this.loop),
          this
        );
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(a) {
      this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
      return this;
    }
  });
  var Zc = new r(),
    Wm = new mb(),
    ip = new r(),
    Mb = new r();
  gm.prototype = Object.assign(Object.create(td.prototype), {
    constructor: gm,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(a) {
      this.panner.refDistance = a;
      return this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(a) {
      this.panner.rolloffFactor = a;
      return this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(a) {
      this.panner.distanceModel = a;
      return this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(a) {
      this.panner.maxDistance = a;
      return this;
    },
    setDirectionalCone: function(a, b, c) {
      this.panner.coneInnerAngle = a;
      this.panner.coneOuterAngle = b;
      this.panner.coneOuterGain = c;
      return this;
    },
    updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(this, a);
      if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
        if (
          (this.matrixWorld.decompose(Zc, Wm, ip),
          Mb.set(0, 0, 1).applyQuaternion(Wm),
          (a = this.panner),
          a.positionX)
        ) {
          var b = this.context.currentTime + this.listener.timeDelta;
          a.positionX.linearRampToValueAtTime(Zc.x, b);
          a.positionY.linearRampToValueAtTime(Zc.y, b);
          a.positionZ.linearRampToValueAtTime(Zc.z, b);
          a.orientationX.linearRampToValueAtTime(Mb.x, b);
          a.orientationY.linearRampToValueAtTime(Mb.y, b);
          a.orientationZ.linearRampToValueAtTime(Mb.z, b);
        } else
          a.setPosition(Zc.x, Zc.y, Zc.z), a.setOrientation(Mb.x, Mb.y, Mb.z);
    }
  });
  Object.assign(hm.prototype, {
    getFrequencyData: function() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    },
    getAverageFrequency: function() {
      for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)
        a += b[c];
      return a / b.length;
    }
  });
  Object.assign(im.prototype, {
    accumulate: function(a, b) {
      var c = this.buffer,
        d = this.valueSize;
      a = a * d + d;
      var e = this.cumulativeWeight;
      if (0 === e) {
        for (e = 0; e !== d; ++e) c[a + e] = c[e];
        e = b;
      } else (e += b), this._mixBufferRegion(c, a, 0, b / e, d);
      this.cumulativeWeight = e;
    },
    apply: function(a) {
      var b = this.valueSize,
        c = this.buffer;
      a = a * b + b;
      var d = this.cumulativeWeight,
        e = this.binding;
      this.cumulativeWeight = 0;
      1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
      d = b;
      for (var f = b + b; d !== f; ++d)
        if (c[d] !== c[d + b]) {
          e.setValue(c, a);
          break;
        }
    },
    saveOriginalState: function() {
      var a = this.buffer,
        b = this.valueSize,
        c = 3 * b;
      this.binding.getValue(a, c);
      for (var d = b; d !== c; ++d) a[d] = a[c + (d % b)];
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(a, b, c, d, e) {
      if (0.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
    },
    _slerp: function(a, b, c, d) {
      mb.slerpFlat(a, b, a, b, a, c, d);
    },
    _lerp: function(a, b, c, d, e) {
      for (var f = 1 - d, h = 0; h !== e; ++h) {
        var k = b + h;
        a[k] = a[k] * f + a[c + h] * d;
      }
    }
  });
  var jp = /[\[\]\.:\/]/g,
    kp = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
    lp = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    mp = /(WCOD+)?/.source.replace("WCOD", kp),
    np = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    op = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    pp = new RegExp("^" + lp + mp + np + op + "$"),
    qp = ["material", "materials", "bones"];
  Object.assign(jm.prototype, {
    getValue: function(a, b) {
      this.bind();
      var c = this._bindings[this._targetGroup.nCachedObjects_];
      void 0 !== c && c.getValue(a, b);
    },
    setValue: function(a, b) {
      for (
        var c = this._bindings,
          d = this._targetGroup.nCachedObjects_,
          e = c.length;
        d !== e;
        ++d
      )
        c[d].setValue(a, b);
    },
    bind: function() {
      for (
        var a = this._bindings,
          b = this._targetGroup.nCachedObjects_,
          c = a.length;
        b !== c;
        ++b
      )
        a[b].bind();
    },
    unbind: function() {
      for (
        var a = this._bindings,
          b = this._targetGroup.nCachedObjects_,
          c = a.length;
        b !== c;
        ++b
      )
        a[b].unbind();
    }
  });
  Object.assign(Ha, {
    Composite: jm,
    create: function(a, b, c) {
      return a && a.isAnimationObjectGroup
        ? new Ha.Composite(a, b, c)
        : new Ha(a, b, c);
    },
    sanitizeNodeName: function(a) {
      return a.replace(/\s/g, "_").replace(jp, "");
    },
    parseTrackName: function(a) {
      var b = pp.exec(a);
      if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a);
      b = {
        nodeName: b[2],
        objectName: b[3],
        objectIndex: b[4],
        propertyName: b[5],
        propertyIndex: b[6]
      };
      var c = b.nodeName && b.nodeName.lastIndexOf(".");
      if (void 0 !== c && -1 !== c) {
        var d = b.nodeName.substring(c + 1);
        -1 !== qp.indexOf(d) &&
          ((b.nodeName = b.nodeName.substring(0, c)), (b.objectName = d));
      }
      if (null === b.propertyName || 0 === b.propertyName.length)
        throw Error(
          "PropertyBinding: can not parse propertyName from trackName: " + a
        );
      return b;
    },
    findNode: function(a, b) {
      if (
        !b ||
        "" === b ||
        "root" === b ||
        "." === b ||
        -1 === b ||
        b === a.name ||
        b === a.uuid
      )
        return a;
      if (a.skeleton) {
        var c = a.skeleton.getBoneByName(b);
        if (void 0 !== c) return c;
      }
      return a.children &&
        (a = (function f(a) {
          for (var c = 0; c < a.length; c++) {
            var e = a[c];
            if (e.name === b || e.uuid === b || (e = f(e.children))) return e;
          }
          return null;
        })(a.children))
        ? a
        : null;
    }
  });
  Object.assign(Ha.prototype, {
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function(a, b) {
        a[b] = this.node[this.propertyName];
      },
      function(a, b) {
        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
          a[b++] = c[d];
      },
      function(a, b) {
        a[b] = this.resolvedProperty[this.propertyIndex];
      },
      function(a, b) {
        this.resolvedProperty.toArray(a, b);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function(a, b) {
          this.targetObject[this.propertyName] = a[b];
        },
        function(a, b) {
          this.targetObject[this.propertyName] = a[b];
          this.targetObject.needsUpdate = !0;
        },
        function(a, b) {
          this.targetObject[this.propertyName] = a[b];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(a, b) {
          for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
            c[d] = a[b++];
        },
        function(a, b) {
          for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
            c[d] = a[b++];
          this.targetObject.needsUpdate = !0;
        },
        function(a, b) {
          for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)
            c[d] = a[b++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(a, b) {
          this.resolvedProperty[this.propertyIndex] = a[b];
        },
        function(a, b) {
          this.resolvedProperty[this.propertyIndex] = a[b];
          this.targetObject.needsUpdate = !0;
        },
        function(a, b) {
          this.resolvedProperty[this.propertyIndex] = a[b];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(a, b) {
          this.resolvedProperty.fromArray(a, b);
        },
        function(a, b) {
          this.resolvedProperty.fromArray(a, b);
          this.targetObject.needsUpdate = !0;
        },
        function(a, b) {
          this.resolvedProperty.fromArray(a, b);
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ]
    ],
    getValue: function(a, b) {
      this.bind();
      this.getValue(a, b);
    },
    setValue: function(a, b) {
      this.bind();
      this.setValue(a, b);
    },
    bind: function() {
      var a = this.node,
        b = this.parsedPath,
        c = b.objectName,
        d = b.propertyName,
        e = b.propertyIndex;
      a ||
        (this.node = a =
          Ha.findNode(this.rootNode, b.nodeName) || this.rootNode);
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (a) {
        if (c) {
          var f = b.objectIndex;
          switch (c) {
            case "materials":
              if (!a.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!a.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              a = a.material.materials;
              break;
            case "bones":
              if (!a.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              a = a.skeleton.bones;
              for (c = 0; c < a.length; c++)
                if (a[c].name === f) {
                  f = c;
                  break;
                }
              break;
            default:
              if (void 0 === a[c]) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              a = a[c];
          }
          if (void 0 !== f) {
            if (void 0 === a[f]) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                a
              );
              return;
            }
            a = a[f];
          }
        }
        f = a[d];
        if (void 0 === f)
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              b.nodeName +
              "." +
              d +
              " but it wasn't found.",
            a
          );
        else {
          b = this.Versioning.None;
          this.targetObject = a;
          void 0 !== a.needsUpdate
            ? (b = this.Versioning.NeedsUpdate)
            : void 0 !== a.matrixWorldNeedsUpdate &&
              (b = this.Versioning.MatrixWorldNeedsUpdate);
          c = this.BindingType.Direct;
          if (void 0 !== e) {
            if ("morphTargetInfluences" === d) {
              if (!a.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (a.geometry.isBufferGeometry) {
                if (!a.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                for (
                  c = 0;
                  c < this.node.geometry.morphAttributes.position.length;
                  c++
                )
                  if (a.geometry.morphAttributes.position[c].name === e) {
                    e = c;
                    break;
                  }
              } else {
                if (!a.geometry.morphTargets) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                    this
                  );
                  return;
                }
                for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                  if (a.geometry.morphTargets[c].name === e) {
                    e = c;
                    break;
                  }
              }
            }
            c = this.BindingType.ArrayElement;
            this.resolvedProperty = f;
            this.propertyIndex = e;
          } else
            void 0 !== f.fromArray && void 0 !== f.toArray
              ? ((c = this.BindingType.HasFromToArray),
                (this.resolvedProperty = f))
              : Array.isArray(f)
              ? ((c = this.BindingType.EntireArray),
                (this.resolvedProperty = f))
              : (this.propertyName = d);
          this.getValue = this.GetterByBindingType[c];
          this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
        }
      } else
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path +
            " but it wasn't found."
        );
    },
    unbind: function() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  });
  Object.assign(Ha.prototype, {
    _getValue_unbound: Ha.prototype.getValue,
    _setValue_unbound: Ha.prototype.setValue
  });
  Object.assign(
    function() {
      this.uuid = ca.generateUUID();
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0;
      var a = {};
      this._indicesByUUID = a;
      for (var b = 0, c = arguments.length; b !== c; ++b)
        a[arguments[b].uuid] = b;
      this._paths = [];
      this._parsedPaths = [];
      this._bindings = [];
      this._bindingsIndicesByPath = {};
      var d = this;
      this.stats = {
        objects: {
          get total() {
            return d._objects.length;
          },
          get inUse() {
            return this.total - d.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return d._bindings.length;
        }
      };
    }.prototype,
    {
      isAnimationObjectGroup: !0,
      add: function() {
        for (
          var a = this._objects,
            b = a.length,
            c = this.nCachedObjects_,
            d = this._indicesByUUID,
            e = this._paths,
            f = this._parsedPaths,
            h = this._bindings,
            k = h.length,
            l = void 0,
            m = 0,
            n = arguments.length;
          m !== n;
          ++m
        ) {
          var q = arguments[m],
            r = q.uuid,
            y = d[r];
          if (void 0 === y) {
            y = b++;
            d[r] = y;
            a.push(q);
            r = 0;
            for (var u = k; r !== u; ++r) h[r].push(new Ha(q, e[r], f[r]));
          } else if (y < c) {
            l = a[y];
            var v = --c;
            u = a[v];
            d[u.uuid] = y;
            a[y] = u;
            d[r] = v;
            a[v] = q;
            r = 0;
            for (u = k; r !== u; ++r) {
              var A = h[r],
                C = A[y];
              A[y] = A[v];
              void 0 === C && (C = new Ha(q, e[r], f[r]));
              A[v] = C;
            }
          } else
            a[y] !== l &&
              console.error(
                "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
              );
        }
        this.nCachedObjects_ = c;
      },
      remove: function() {
        for (
          var a = this._objects,
            b = this.nCachedObjects_,
            c = this._indicesByUUID,
            d = this._bindings,
            e = d.length,
            f = 0,
            h = arguments.length;
          f !== h;
          ++f
        ) {
          var k = arguments[f],
            l = k.uuid,
            m = c[l];
          if (void 0 !== m && m >= b) {
            var n = b++,
              q = a[n];
            c[q.uuid] = m;
            a[m] = q;
            c[l] = n;
            a[n] = k;
            k = 0;
            for (l = e; k !== l; ++k) {
              q = d[k];
              var r = q[m];
              q[m] = q[n];
              q[n] = r;
            }
          }
        }
        this.nCachedObjects_ = b;
      },
      uncache: function() {
        for (
          var a = this._objects,
            b = a.length,
            c = this.nCachedObjects_,
            d = this._indicesByUUID,
            e = this._bindings,
            f = e.length,
            h = 0,
            k = arguments.length;
          h !== k;
          ++h
        ) {
          var l = arguments[h].uuid,
            m = d[l];
          if (void 0 !== m)
            if ((delete d[l], m < c)) {
              l = --c;
              var n = a[l],
                q = --b,
                r = a[q];
              d[n.uuid] = m;
              a[m] = n;
              d[r.uuid] = l;
              a[l] = r;
              a.pop();
              n = 0;
              for (r = f; n !== r; ++n) {
                var y = e[n],
                  u = y[q];
                y[m] = y[l];
                y[l] = u;
                y.pop();
              }
            } else
              for (
                q = --b,
                  r = a[q],
                  d[r.uuid] = m,
                  a[m] = r,
                  a.pop(),
                  n = 0,
                  r = f;
                n !== r;
                ++n
              )
                (y = e[n]), (y[m] = y[q]), y.pop();
        }
        this.nCachedObjects_ = c;
      },
      subscribe_: function(a, b) {
        var c = this._bindingsIndicesByPath,
          d = c[a],
          e = this._bindings;
        if (void 0 !== d) return e[d];
        var f = this._paths,
          h = this._parsedPaths,
          k = this._objects,
          l = this.nCachedObjects_,
          m = Array(k.length);
        d = e.length;
        c[a] = d;
        f.push(a);
        h.push(b);
        e.push(m);
        c = l;
        for (d = k.length; c !== d; ++c) m[c] = new Ha(k[c], a, b);
        return m;
      },
      unsubscribe_: function(a) {
        var b = this._bindingsIndicesByPath,
          c = b[a];
        if (void 0 !== c) {
          var d = this._paths,
            e = this._parsedPaths,
            f = this._bindings,
            h = f.length - 1,
            k = f[h];
          b[a[h]] = c;
          f[c] = k;
          f.pop();
          e[c] = e[h];
          e.pop();
          d[c] = d[h];
          d.pop();
        }
      }
    }
  );
  Object.assign(km.prototype, {
    play: function() {
      this._mixer._activateAction(this);
      return this;
    },
    stop: function() {
      this._mixer._deactivateAction(this);
      return this.reset();
    },
    reset: function() {
      this.paused = !1;
      this.enabled = !0;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    },
    isRunning: function() {
      return (
        this.enabled &&
        !this.paused &&
        0 !== this.timeScale &&
        null === this._startTime &&
        this._mixer._isActiveAction(this)
      );
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(a) {
      this._startTime = a;
      return this;
    },
    setLoop: function(a, b) {
      this.loop = a;
      this.repetitions = b;
      return this;
    },
    setEffectiveWeight: function(a) {
      this.weight = a;
      this._effectiveWeight = this.enabled ? a : 0;
      return this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(a) {
      return this._scheduleFading(a, 0, 1);
    },
    fadeOut: function(a) {
      return this._scheduleFading(a, 1, 0);
    },
    crossFadeFrom: function(a, b, c) {
      a.fadeOut(b);
      this.fadeIn(b);
      if (c) {
        c = this._clip.duration;
        var d = a._clip.duration,
          e = c / d;
        a.warp(1, d / c, b);
        this.warp(e, 1, b);
      }
      return this;
    },
    crossFadeTo: function(a, b, c) {
      return a.crossFadeFrom(this, b, c);
    },
    stopFading: function() {
      var a = this._weightInterpolant;
      null !== a &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(a));
      return this;
    },
    setEffectiveTimeScale: function(a) {
      this.timeScale = a;
      this._effectiveTimeScale = this.paused ? 0 : a;
      return this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(a) {
      this.timeScale = this._clip.duration / a;
      return this.stopWarping();
    },
    syncWith: function(a) {
      this.time = a.time;
      this.timeScale = a.timeScale;
      return this.stopWarping();
    },
    halt: function(a) {
      return this.warp(this._effectiveTimeScale, 0, a);
    },
    warp: function(a, b, c) {
      var d = this._mixer,
        e = d.time,
        f = this._timeScaleInterpolant,
        h = this.timeScale;
      null === f &&
        (this._timeScaleInterpolant = f = d._lendControlInterpolant());
      d = f.parameterPositions;
      f = f.sampleValues;
      d[0] = e;
      d[1] = e + c;
      f[0] = a / h;
      f[1] = b / h;
      return this;
    },
    stopWarping: function() {
      var a = this._timeScaleInterpolant;
      null !== a &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(a));
      return this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(a, b, c, d) {
      if (this.enabled) {
        var e = this._startTime;
        if (null !== e) {
          b = (a - e) * c;
          if (0 > b || 0 === c) return;
          this._startTime = null;
          b *= c;
        }
        b *= this._updateTimeScale(a);
        c = this._updateTime(b);
        a = this._updateWeight(a);
        if (0 < a) {
          b = this._interpolants;
          e = this._propertyBindings;
          for (var f = 0, h = b.length; f !== h; ++f)
            b[f].evaluate(c), e[f].accumulate(d, a);
        }
      } else this._updateWeight(a);
    },
    _updateWeight: function(a) {
      var b = 0;
      if (this.enabled) {
        b = this.weight;
        var c = this._weightInterpolant;
        if (null !== c) {
          var d = c.evaluate(a)[0];
          b *= d;
          a > c.parameterPositions[1] &&
            (this.stopFading(), 0 === d && (this.enabled = !1));
        }
      }
      return (this._effectiveWeight = b);
    },
    _updateTimeScale: function(a) {
      var b = 0;
      if (!this.paused) {
        b = this.timeScale;
        var c = this._timeScaleInterpolant;
        if (null !== c) {
          var d = c.evaluate(a)[0];
          b *= d;
          a > c.parameterPositions[1] &&
            (this.stopWarping(),
            0 === b ? (this.paused = !0) : (this.timeScale = b));
        }
      }
      return (this._effectiveTimeScale = b);
    },
    _updateTime: function(a) {
      var b = this.time + a,
        c = this._clip.duration,
        d = this.loop,
        e = this._loopCount,
        f = 2202 === d;
      if (0 === a) return -1 === e ? b : f && 1 === (e & 1) ? c - b : b;
      if (2200 === d)
        a: {
          if (
            (-1 === e && ((this._loopCount = 0), this._setEndings(!0, !0, !1)),
            b >= c)
          )
            b = c;
          else if (0 > b) b = 0;
          else {
            this.time = b;
            break a;
          }
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1);
          this.time = b;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 > a ? -1 : 1
          });
        }
      else {
        -1 === e &&
          (0 <= a
            ? ((e = 0), this._setEndings(!0, 0 === this.repetitions, f))
            : this._setEndings(0 === this.repetitions, !0, f));
        if (b >= c || 0 > b) {
          d = Math.floor(b / c);
          b -= c * d;
          e += Math.abs(d);
          var h = this.repetitions - e;
          0 >= h
            ? (this.clampWhenFinished
                ? (this.paused = !0)
                : (this.enabled = !1),
              (this.time = b = 0 < a ? c : 0),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 < a ? 1 : -1
              }))
            : (1 === h
                ? ((a = 0 > a), this._setEndings(a, !a, f))
                : this._setEndings(!1, !1, f),
              (this._loopCount = e),
              (this.time = b),
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: d
              }));
        } else this.time = b;
        if (f && 1 === (e & 1)) return c - b;
      }
      return b;
    },
    _setEndings: function(a, b, c) {
      var d = this._interpolantSettings;
      c
        ? ((d.endingStart = 2401), (d.endingEnd = 2401))
        : ((d.endingStart = a ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
          (d.endingEnd = b ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
    },
    _scheduleFading: function(a, b, c) {
      var d = this._mixer,
        e = d.time,
        f = this._weightInterpolant;
      null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
      d = f.parameterPositions;
      f = f.sampleValues;
      d[0] = e;
      f[0] = b;
      d[1] = e + a;
      f[1] = c;
      return this;
    }
  });
  lm.prototype = Object.assign(Object.create(lc.prototype), {
    constructor: lm,
    _bindAction: function(a, b) {
      var c = a._localRoot || this._root,
        d = a._clip.tracks,
        e = d.length,
        f = a._propertyBindings;
      a = a._interpolants;
      var h = c.uuid,
        k = this._bindingsByRootAndName,
        l = k[h];
      void 0 === l && ((l = {}), (k[h] = l));
      for (k = 0; k !== e; ++k) {
        var m = d[k],
          n = m.name,
          q = l[n];
        if (void 0 === q) {
          q = f[k];
          if (void 0 !== q) {
            null === q._cacheIndex &&
              (++q.referenceCount, this._addInactiveBinding(q, h, n));
            continue;
          }
          q = new im(
            Ha.create(c, n, b && b._propertyBindings[k].binding.parsedPath),
            m.ValueTypeName,
            m.getValueSize()
          );
          ++q.referenceCount;
          this._addInactiveBinding(q, h, n);
        }
        f[k] = q;
        a[k].resultBuffer = q.buffer;
      }
    },
    _activateAction: function(a) {
      if (!this._isActiveAction(a)) {
        if (null === a._cacheIndex) {
          var b = (a._localRoot || this._root).uuid,
            c = a._clip.uuid,
            d = this._actionsByClip[c];
          this._bindAction(a, d && d.knownActions[0]);
          this._addInactiveAction(a, c, b);
        }
        b = a._propertyBindings;
        c = 0;
        for (d = b.length; c !== d; ++c) {
          var e = b[c];
          0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
        }
        this._lendAction(a);
      }
    },
    _deactivateAction: function(a) {
      if (this._isActiveAction(a)) {
        for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
          var e = b[c];
          0 === --e.useCount &&
            (e.restoreOriginalState(), this._takeBackBinding(e));
        }
        this._takeBackAction(a);
      }
    },
    _initMemoryManager: function() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      var a = this;
      this.stats = {
        actions: {
          get total() {
            return a._actions.length;
          },
          get inUse() {
            return a._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return a._bindings.length;
          },
          get inUse() {
            return a._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return a._controlInterpolants.length;
          },
          get inUse() {
            return a._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(a) {
      a = a._cacheIndex;
      return null !== a && a < this._nActiveActions;
    },
    _addInactiveAction: function(a, b, c) {
      var d = this._actions,
        e = this._actionsByClip,
        f = e[b];
      void 0 === f
        ? ((f = { knownActions: [a], actionByRoot: {} }),
          (a._byClipCacheIndex = 0),
          (e[b] = f))
        : ((b = f.knownActions), (a._byClipCacheIndex = b.length), b.push(a));
      a._cacheIndex = d.length;
      d.push(a);
      f.actionByRoot[c] = a;
    },
    _removeInactiveAction: function(a) {
      var b = this._actions,
        c = b[b.length - 1],
        d = a._cacheIndex;
      c._cacheIndex = d;
      b[d] = c;
      b.pop();
      a._cacheIndex = null;
      b = a._clip.uuid;
      c = this._actionsByClip;
      d = c[b];
      var e = d.knownActions,
        f = e[e.length - 1],
        h = a._byClipCacheIndex;
      f._byClipCacheIndex = h;
      e[h] = f;
      e.pop();
      a._byClipCacheIndex = null;
      delete d.actionByRoot[(a._localRoot || this._root).uuid];
      0 === e.length && delete c[b];
      this._removeInactiveBindingsForAction(a);
    },
    _removeInactiveBindingsForAction: function(a) {
      a = a._propertyBindings;
      for (var b = 0, c = a.length; b !== c; ++b) {
        var d = a[b];
        0 === --d.referenceCount && this._removeInactiveBinding(d);
      }
    },
    _lendAction: function(a) {
      var b = this._actions,
        c = a._cacheIndex,
        d = this._nActiveActions++,
        e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _takeBackAction: function(a) {
      var b = this._actions,
        c = a._cacheIndex,
        d = --this._nActiveActions,
        e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _addInactiveBinding: function(a, b, c) {
      var d = this._bindingsByRootAndName,
        e = d[b],
        f = this._bindings;
      void 0 === e && ((e = {}), (d[b] = e));
      e[c] = a;
      a._cacheIndex = f.length;
      f.push(a);
    },
    _removeInactiveBinding: function(a) {
      var b = this._bindings,
        c = a.binding,
        d = c.rootNode.uuid;
      c = c.path;
      var e = this._bindingsByRootAndName,
        f = e[d],
        h = b[b.length - 1];
      a = a._cacheIndex;
      h._cacheIndex = a;
      b[a] = h;
      b.pop();
      delete f[c];
      0 === Object.keys(f).length && delete e[d];
    },
    _lendBinding: function(a) {
      var b = this._bindings,
        c = a._cacheIndex,
        d = this._nActiveBindings++,
        e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _takeBackBinding: function(a) {
      var b = this._bindings,
        c = a._cacheIndex,
        d = --this._nActiveBindings,
        e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _lendControlInterpolant: function() {
      var a = this._controlInterpolants,
        b = this._nActiveControlInterpolants++,
        c = a[b];
      void 0 === c &&
        ((c = new cf(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (c.__cacheIndex = b),
        (a[b] = c));
      return c;
    },
    _takeBackControlInterpolant: function(a) {
      var b = this._controlInterpolants,
        c = a.__cacheIndex,
        d = --this._nActiveControlInterpolants,
        e = b[d];
      a.__cacheIndex = d;
      b[d] = a;
      e.__cacheIndex = c;
      b[c] = e;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(a, b) {
      var c = b || this._root,
        d = c.uuid;
      c = "string" === typeof a ? Xb.findByName(c, a) : a;
      a = null !== c ? c.uuid : a;
      var e = this._actionsByClip[a],
        f = null;
      if (void 0 !== e) {
        f = e.actionByRoot[d];
        if (void 0 !== f) return f;
        f = e.knownActions[0];
        null === c && (c = f._clip);
      }
      if (null === c) return null;
      b = new km(this, c, b);
      this._bindAction(b, f);
      this._addInactiveAction(b, a, d);
      return b;
    },
    existingAction: function(a, b) {
      var c = b || this._root;
      b = c.uuid;
      c = "string" === typeof a ? Xb.findByName(c, a) : a;
      a = this._actionsByClip[c ? c.uuid : a];
      return void 0 !== a ? a.actionByRoot[b] || null : null;
    },
    stopAllAction: function() {
      for (
        var a = this._actions,
          b = this._nActiveActions,
          c = this._bindings,
          d = this._nActiveBindings,
          e = (this._nActiveBindings = this._nActiveActions = 0);
        e !== b;
        ++e
      )
        a[e].reset();
      for (e = 0; e !== d; ++e) c[e].useCount = 0;
      return this;
    },
    update: function(a) {
      a *= this.timeScale;
      for (
        var b = this._actions,
          c = this._nActiveActions,
          d = (this.time += a),
          e = Math.sign(a),
          f = (this._accuIndex ^= 1),
          h = 0;
        h !== c;
        ++h
      )
        b[h]._update(d, a, e, f);
      a = this._bindings;
      b = this._nActiveBindings;
      for (h = 0; h !== b; ++h) a[h].apply(f);
      return this;
    },
    setTime: function(a) {
      for (var b = (this.time = 0); b < this._actions.length; b++)
        this._actions[b].time = 0;
      return this.update(a);
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(a) {
      var b = this._actions;
      a = a.uuid;
      var c = this._actionsByClip,
        d = c[a];
      if (void 0 !== d) {
        d = d.knownActions;
        for (var e = 0, f = d.length; e !== f; ++e) {
          var h = d[e];
          this._deactivateAction(h);
          var k = h._cacheIndex,
            l = b[b.length - 1];
          h._cacheIndex = null;
          h._byClipCacheIndex = null;
          l._cacheIndex = k;
          b[k] = l;
          b.pop();
          this._removeInactiveBindingsForAction(h);
        }
        delete c[a];
      }
    },
    uncacheRoot: function(a) {
      a = a.uuid;
      var b = this._actionsByClip;
      for (d in b) {
        var c = b[d].actionByRoot[a];
        void 0 !== c &&
          (this._deactivateAction(c), this._removeInactiveAction(c));
      }
      var d = this._bindingsByRootAndName[a];
      if (void 0 !== d)
        for (var e in d)
          (a = d[e]), a.restoreOriginalState(), this._removeInactiveBinding(a);
    },
    uncacheAction: function(a, b) {
      a = this.existingAction(a, b);
      null !== a && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
  });
  mm.prototype = Object.assign(Object.create(Fb.prototype), {
    constructor: mm,
    isInstancedInterleavedBuffer: !0,
    copy: function(a) {
      Fb.prototype.copy.call(this, a);
      this.meshPerAttribute = a.meshPerAttribute;
      return this;
    }
  });
  Object.assign(
    function(a, b, c, d) {
      this.ray = new Ob(a, b);
      this.near = c || 0;
      this.far = d || Infinity;
      this.camera = null;
      this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {}
      };
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function() {
            console.warn(
              "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
            );
            return this.Points;
          }
        }
      });
    }.prototype,
    {
      linePrecision: 1,
      set: function(a, b) {
        this.ray.set(a, b);
      },
      setFromCamera: function(a, b) {
        b && b.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld),
            this.ray.direction
              .set(a.x, a.y, 0.5)
              .unproject(b)
              .sub(this.ray.origin)
              .normalize(),
            (this.camera = b))
          : b && b.isOrthographicCamera
          ? (this.ray.origin
              .set(a.x, a.y, (b.near + b.far) / (b.near - b.far))
              .unproject(b),
            this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld),
            (this.camera = b))
          : console.error("THREE.Raycaster: Unsupported camera type.");
      },
      intersectObject: function(a, b, c) {
        c = c || [];
        Nj(a, this, c, b);
        c.sort(nm);
        return c;
      },
      intersectObjects: function(a, b, c) {
        c = c || [];
        if (!1 === Array.isArray(a))
          return (
            console.warn(
              "THREE.Raycaster.intersectObjects: objects is not an Array."
            ),
            c
          );
        for (var d = 0, e = a.length; d < e; d++) Nj(a[d], this, c, b);
        c.sort(nm);
        return c;
      }
    }
  );
  Object.assign(
    function(a, b, c) {
      this.radius = void 0 !== a ? a : 1;
      this.phi = void 0 !== b ? b : 0;
      this.theta = void 0 !== c ? c : 0;
      return this;
    }.prototype,
    {
      set: function(a, b, c) {
        this.radius = a;
        this.phi = b;
        this.theta = c;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(a) {
        this.radius = a.radius;
        this.phi = a.phi;
        this.theta = a.theta;
        return this;
      },
      makeSafe: function() {
        this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));
        return this;
      },
      setFromVector3: function(a) {
        return this.setFromCartesianCoords(a.x, a.y, a.z);
      },
      setFromCartesianCoords: function(a, b, c) {
        this.radius = Math.sqrt(a * a + b * b + c * c);
        0 === this.radius
          ? (this.phi = this.theta = 0)
          : ((this.theta = Math.atan2(a, c)),
            (this.phi = Math.acos(ca.clamp(b / this.radius, -1, 1))));
        return this;
      }
    }
  );
  Object.assign(
    function(a, b, c) {
      this.radius = void 0 !== a ? a : 1;
      this.theta = void 0 !== b ? b : 0;
      this.y = void 0 !== c ? c : 0;
      return this;
    }.prototype,
    {
      set: function(a, b, c) {
        this.radius = a;
        this.theta = b;
        this.y = c;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(a) {
        this.radius = a.radius;
        this.theta = a.theta;
        this.y = a.y;
        return this;
      },
      setFromVector3: function(a) {
        return this.setFromCartesianCoords(a.x, a.y, a.z);
      },
      setFromCartesianCoords: function(a, b, c) {
        this.radius = Math.sqrt(a * a + c * c);
        this.theta = Math.atan2(a, c);
        this.y = b;
        return this;
      }
    }
  );
  var Xm = new E();
  Object.assign(om.prototype, {
    set: function(a, b) {
      this.min.copy(a);
      this.max.copy(b);
      return this;
    },
    setFromPoints: function(a) {
      this.makeEmpty();
      for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
      return this;
    },
    setFromCenterAndSize: function(a, b) {
      b = Xm.copy(b).multiplyScalar(0.5);
      this.min.copy(a).sub(b);
      this.max.copy(a).add(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.min.copy(a.min);
      this.max.copy(a.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(a) {
      void 0 === a &&
        (console.warn("THREE.Box2: .getCenter() target is now required"),
        (a = new E()));
      return this.isEmpty()
        ? a.set(0, 0)
        : a.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(a) {
      void 0 === a &&
        (console.warn("THREE.Box2: .getSize() target is now required"),
        (a = new E()));
      return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
      this.min.min(a);
      this.max.max(a);
      return this;
    },
    expandByVector: function(a) {
      this.min.sub(a);
      this.max.add(a);
      return this;
    },
    expandByScalar: function(a) {
      this.min.addScalar(-a);
      this.max.addScalar(a);
      return this;
    },
    containsPoint: function(a) {
      return a.x < this.min.x ||
        a.x > this.max.x ||
        a.y < this.min.y ||
        a.y > this.max.y
        ? !1
        : !0;
    },
    containsBox: function(a) {
      return (
        this.min.x <= a.min.x &&
        a.max.x <= this.max.x &&
        this.min.y <= a.min.y &&
        a.max.y <= this.max.y
      );
    },
    getParameter: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Box2: .getParameter() target is now required"),
        (b = new E()));
      return b.set(
        (a.x - this.min.x) / (this.max.x - this.min.x),
        (a.y - this.min.y) / (this.max.y - this.min.y)
      );
    },
    intersectsBox: function(a) {
      return a.max.x < this.min.x ||
        a.min.x > this.max.x ||
        a.max.y < this.min.y ||
        a.min.y > this.max.y
        ? !1
        : !0;
    },
    clampPoint: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Box2: .clampPoint() target is now required"),
        (b = new E()));
      return b.copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function(a) {
      return Xm.copy(a)
        .clamp(this.min, this.max)
        .sub(a)
        .length();
    },
    intersect: function(a) {
      this.min.max(a.min);
      this.max.min(a.max);
      return this;
    },
    union: function(a) {
      this.min.min(a.min);
      this.max.max(a.max);
      return this;
    },
    translate: function(a) {
      this.min.add(a);
      this.max.add(a);
      return this;
    },
    equals: function(a) {
      return a.min.equals(this.min) && a.max.equals(this.max);
    }
  });
  var Ym = new r(),
    xg = new r();
  Object.assign(pm.prototype, {
    set: function(a, b) {
      this.start.copy(a);
      this.end.copy(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.start.copy(a.start);
      this.end.copy(a.end);
      return this;
    },
    getCenter: function(a) {
      void 0 === a &&
        (console.warn("THREE.Line3: .getCenter() target is now required"),
        (a = new r()));
      return a.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(a) {
      void 0 === a &&
        (console.warn("THREE.Line3: .delta() target is now required"),
        (a = new r()));
      return a.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(a, b) {
      void 0 === b &&
        (console.warn("THREE.Line3: .at() target is now required"),
        (b = new r()));
      return this.delta(b)
        .multiplyScalar(a)
        .add(this.start);
    },
    closestPointToPointParameter: function(a, b) {
      Ym.subVectors(a, this.start);
      xg.subVectors(this.end, this.start);
      a = xg.dot(xg);
      a = xg.dot(Ym) / a;
      b && (a = ca.clamp(a, 0, 1));
      return a;
    },
    closestPointToPoint: function(a, b, c) {
      a = this.closestPointToPointParameter(a, b);
      void 0 === c &&
        (console.warn(
          "THREE.Line3: .closestPointToPoint() target is now required"
        ),
        (c = new r()));
      return this.delta(c)
        .multiplyScalar(a)
        .add(this.start);
    },
    applyMatrix4: function(a) {
      this.start.applyMatrix4(a);
      this.end.applyMatrix4(a);
      return this;
    },
    equals: function(a) {
      return a.start.equals(this.start) && a.end.equals(this.end);
    }
  });
  xi.prototype = Object.create(D.prototype);
  xi.prototype.constructor = xi;
  xi.prototype.isImmediateRenderObject = !0;
  var $c = new r(),
    kc = new r(),
    Tk = new Ya(),
    rp = ["a", "b", "c"];
  gh.prototype = Object.create(ra.prototype);
  gh.prototype.constructor = gh;
  gh.prototype.update = function() {
    this.object.updateMatrixWorld(!0);
    Tk.getNormalMatrix(this.object.matrixWorld);
    var a = this.object.matrixWorld,
      b = this.geometry.attributes.position,
      c = this.object.geometry;
    if (c && c.isGeometry)
      for (
        var d = c.vertices, e = c.faces, f = (c = 0), h = e.length;
        f < h;
        f++
      )
        for (var k = e[f], l = 0, m = k.vertexNormals.length; l < m; l++) {
          var n = k.vertexNormals[l];
          $c.copy(d[k[rp[l]]]).applyMatrix4(a);
          kc.copy(n)
            .applyMatrix3(Tk)
            .normalize()
            .multiplyScalar(this.size)
            .add($c);
          b.setXYZ(c, $c.x, $c.y, $c.z);
          c += 1;
          b.setXYZ(c, kc.x, kc.y, kc.z);
          c += 1;
        }
    else if (c && c.isBufferGeometry)
      for (
        d = c.attributes.position,
          e = c.attributes.normal,
          l = c = 0,
          m = d.count;
        l < m;
        l++
      )
        $c.set(d.getX(l), d.getY(l), d.getZ(l)).applyMatrix4(a),
          kc.set(e.getX(l), e.getY(l), e.getZ(l)),
          kc
            .applyMatrix3(Tk)
            .normalize()
            .multiplyScalar(this.size)
            .add($c),
          b.setXYZ(c, $c.x, $c.y, $c.z),
          (c += 1),
          b.setXYZ(c, kc.x, kc.y, kc.z),
          (c += 1);
    b.needsUpdate = !0;
  };
  var Zm = new r();
  le.prototype = Object.create(D.prototype);
  le.prototype.constructor = le;
  le.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  le.prototype.update = function() {
    this.light.updateMatrixWorld();
    var a = this.light.distance ? this.light.distance : 1e3,
      b = a * Math.tan(this.light.angle);
    this.cone.scale.set(b, b, a);
    Zm.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(Zm);
    void 0 !== this.color
      ? this.cone.material.color.set(this.color)
      : this.cone.material.color.copy(this.light.color);
  };
  var Oe = new r(),
    Ph = new fa(),
    Uk = new fa();
  me.prototype = Object.create(ra.prototype);
  me.prototype.constructor = me;
  me.prototype.updateMatrixWorld = function(a) {
    var b = this.bones,
      c = this.geometry,
      d = c.getAttribute("position");
    Uk.getInverse(this.root.matrixWorld);
    for (var e = 0, f = 0; e < b.length; e++) {
      var h = b[e];
      h.parent &&
        h.parent.isBone &&
        (Ph.multiplyMatrices(Uk, h.matrixWorld),
        Oe.setFromMatrixPosition(Ph),
        d.setXYZ(f, Oe.x, Oe.y, Oe.z),
        Ph.multiplyMatrices(Uk, h.parent.matrixWorld),
        Oe.setFromMatrixPosition(Ph),
        d.setXYZ(f + 1, Oe.x, Oe.y, Oe.z),
        (f += 2));
    }
    c.getAttribute("position").needsUpdate = !0;
    D.prototype.updateMatrixWorld.call(this, a);
  };
  ne.prototype = Object.create(oa.prototype);
  ne.prototype.constructor = ne;
  ne.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  ne.prototype.update = function() {
    void 0 !== this.color
      ? this.material.color.set(this.color)
      : this.material.color.copy(this.light.color);
  };
  oe.prototype = Object.create($a.prototype);
  oe.prototype.constructor = oe;
  oe.prototype.update = function() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (void 0 !== this.color)
      this.material.color.set(this.color),
        this.children[0].material.color.set(this.color);
    else {
      this.material.color
        .copy(this.light.color)
        .multiplyScalar(this.light.intensity);
      var a = this.material.color,
        b = Math.max(a.r, a.g, a.b);
      1 < b && a.multiplyScalar(1 / b);
      this.children[0].material.color.copy(this.material.color);
    }
  };
  oe.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  var sp = new r(),
    $m = new L(),
    an = new L();
  pe.prototype = Object.create(D.prototype);
  pe.prototype.constructor = pe;
  pe.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  pe.prototype.update = function() {
    var a = this.children[0];
    if (void 0 !== this.color) this.material.color.set(this.color);
    else {
      var b = a.geometry.getAttribute("color");
      $m.copy(this.light.color);
      an.copy(this.light.groundColor);
      for (var c = 0, d = b.count; c < d; c++) {
        var e = c < d / 2 ? $m : an;
        b.setXYZ(c, e.r, e.g, e.b);
      }
      b.needsUpdate = !0;
    }
    a.lookAt(sp.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
  qe.prototype = Object.create(oa.prototype);
  qe.prototype.constructor = qe;
  qe.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  qe.prototype.onBeforeRender = function() {
    this.position.copy(this.lightProbe.position);
    this.scale.set(1, 1, 1).multiplyScalar(this.size);
    this.material.uniforms.intensity.value = this.lightProbe.intensity;
  };
  Oj.prototype = Object.assign(Object.create(ra.prototype), {
    constructor: Oj,
    copy: function(a) {
      ra.prototype.copy.call(this, a);
      this.geometry.copy(a.geometry);
      this.material.copy(a.material);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  Pj.prototype = Object.create(ra.prototype);
  Pj.prototype.constructor = Pj;
  re.prototype = Object.create($a.prototype);
  re.prototype.constructor = re;
  re.prototype.update = function() {
    function a(a, b, d, e) {
      d = (b - a) / d;
      y.setXYZ(l, 0, 0, 0);
      m++;
      for (n = a; n < b; n += d)
        (q = l + m),
          y.setXYZ(q, Math.sin(n) * c, 0, Math.cos(n) * c),
          y.setXYZ(
            q + 1,
            Math.sin(Math.min(n + d, b)) * c,
            0,
            Math.cos(Math.min(n + d, b)) * c
          ),
          y.setXYZ(q + 2, 0, 0, 0),
          (m += 3);
      r.addGroup(l, m, e);
      l += m;
      m = 0;
    }
    var b = this.audio,
      c = this.range,
      d = this.divisionsInnerAngle,
      e = this.divisionsOuterAngle,
      f = ca.degToRad(b.panner.coneInnerAngle);
    b = ca.degToRad(b.panner.coneOuterAngle);
    var h = f / 2,
      k = b / 2,
      l = 0,
      m = 0,
      n,
      q,
      r = this.geometry,
      y = r.attributes.position;
    r.clearGroups();
    a(-k, -h, e, 0);
    a(-h, h, d, 1);
    a(h, k, e, 0);
    y.needsUpdate = !0;
    f === b && (this.material[0].visible = !1);
  };
  re.prototype.dispose = function() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  };
  var Ff = new r(),
    Qh = new r(),
    bn = new Ya();
  hh.prototype = Object.create(ra.prototype);
  hh.prototype.constructor = hh;
  hh.prototype.update = function() {
    this.object.updateMatrixWorld(!0);
    bn.getNormalMatrix(this.object.matrixWorld);
    var a = this.object.matrixWorld,
      b = this.geometry.attributes.position,
      c = this.object.geometry,
      d = c.vertices;
    c = c.faces;
    for (var e = 0, f = 0, h = c.length; f < h; f++) {
      var k = c[f],
        l = k.normal;
      Ff.copy(d[k.a])
        .add(d[k.b])
        .add(d[k.c])
        .divideScalar(3)
        .applyMatrix4(a);
      Qh.copy(l)
        .applyMatrix3(bn)
        .normalize()
        .multiplyScalar(this.size)
        .add(Ff);
      b.setXYZ(e, Ff.x, Ff.y, Ff.z);
      e += 1;
      b.setXYZ(e, Qh.x, Qh.y, Qh.z);
      e += 1;
    }
    b.needsUpdate = !0;
  };
  var cn = new r(),
    Rh = new r(),
    dn = new r();
  se.prototype = Object.create(D.prototype);
  se.prototype.constructor = se;
  se.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  se.prototype.update = function() {
    cn.setFromMatrixPosition(this.light.matrixWorld);
    Rh.setFromMatrixPosition(this.light.target.matrixWorld);
    dn.subVectors(Rh, cn);
    this.lightPlane.lookAt(Rh);
    void 0 !== this.color
      ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color))
      : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color));
    this.targetLine.lookAt(Rh);
    this.targetLine.scale.z = dn.length();
  };
  var yi = new r(),
    Ta = new oc();
  ih.prototype = Object.create(ra.prototype);
  ih.prototype.constructor = ih;
  ih.prototype.update = function() {
    var a = this.geometry,
      b = this.pointMap;
    Ta.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    Ia("c", b, a, Ta, 0, 0, -1);
    Ia("t", b, a, Ta, 0, 0, 1);
    Ia("n1", b, a, Ta, -1, -1, -1);
    Ia("n2", b, a, Ta, 1, -1, -1);
    Ia("n3", b, a, Ta, -1, 1, -1);
    Ia("n4", b, a, Ta, 1, 1, -1);
    Ia("f1", b, a, Ta, -1, -1, 1);
    Ia("f2", b, a, Ta, 1, -1, 1);
    Ia("f3", b, a, Ta, -1, 1, 1);
    Ia("f4", b, a, Ta, 1, 1, 1);
    Ia("u1", b, a, Ta, 0.7, 1.1, -1);
    Ia("u2", b, a, Ta, -0.7, 1.1, -1);
    Ia("u3", b, a, Ta, 0, 2, -1);
    Ia("cf1", b, a, Ta, -1, 0, 1);
    Ia("cf2", b, a, Ta, 1, 0, 1);
    Ia("cf3", b, a, Ta, 0, -1, 1);
    Ia("cf4", b, a, Ta, 0, 1, 1);
    Ia("cn1", b, a, Ta, -1, 0, -1);
    Ia("cn2", b, a, Ta, 1, 0, -1);
    Ia("cn3", b, a, Ta, 0, -1, -1);
    Ia("cn4", b, a, Ta, 0, 1, -1);
    a.getAttribute("position").needsUpdate = !0;
  };
  var yg = new dd();
  Mc.prototype = Object.create(ra.prototype);
  Mc.prototype.constructor = Mc;
  Mc.prototype.update = function(a) {
    void 0 !== a &&
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    void 0 !== this.object && yg.setFromObject(this.object);
    if (!yg.isEmpty()) {
      a = yg.min;
      var b = yg.max,
        c = this.geometry.attributes.position,
        d = c.array;
      d[0] = b.x;
      d[1] = b.y;
      d[2] = b.z;
      d[3] = a.x;
      d[4] = b.y;
      d[5] = b.z;
      d[6] = a.x;
      d[7] = a.y;
      d[8] = b.z;
      d[9] = b.x;
      d[10] = a.y;
      d[11] = b.z;
      d[12] = b.x;
      d[13] = b.y;
      d[14] = a.z;
      d[15] = a.x;
      d[16] = b.y;
      d[17] = a.z;
      d[18] = a.x;
      d[19] = a.y;
      d[20] = a.z;
      d[21] = b.x;
      d[22] = a.y;
      d[23] = a.z;
      c.needsUpdate = !0;
      this.geometry.computeBoundingSphere();
    }
  };
  Mc.prototype.setFromObject = function(a) {
    this.object = a;
    this.update();
    return this;
  };
  Mc.prototype.copy = function(a) {
    ra.prototype.copy.call(this, a);
    this.object = a.object;
    return this;
  };
  Mc.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  zi.prototype = Object.create(ra.prototype);
  zi.prototype.constructor = zi;
  zi.prototype.updateMatrixWorld = function(a) {
    var b = this.box;
    b.isEmpty() ||
      (b.getCenter(this.position),
      b.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      D.prototype.updateMatrixWorld.call(this, a));
  };
  ef.prototype = Object.create($a.prototype);
  ef.prototype.constructor = ef;
  ef.prototype.updateMatrixWorld = function(a) {
    var b = -this.plane.constant;
    1e-8 > Math.abs(b) && (b = 1e-8);
    this.scale.set(0.5 * this.size, 0.5 * this.size, b);
    this.children[0].material.side = 0 > b ? 1 : 0;
    this.lookAt(this.plane.normal);
    D.prototype.updateMatrixWorld.call(this, a);
  };
  var en = new r(),
    ff,
    Qj;
  te.prototype = Object.create(D.prototype);
  te.prototype.constructor = te;
  te.prototype.setDirection = function(a) {
    0.99999 < a.y
      ? this.quaternion.set(0, 0, 0, 1)
      : -0.99999 > a.y
      ? this.quaternion.set(1, 0, 0, 0)
      : (en.set(a.z, 0, -a.x).normalize(),
        this.quaternion.setFromAxisAngle(en, Math.acos(a.y)));
  };
  te.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = 0.2 * a);
    void 0 === c && (c = 0.2 * b);
    this.line.scale.set(1, Math.max(1e-4, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix();
  };
  te.prototype.setColor = function(a) {
    this.line.material.color.set(a);
    this.cone.material.color.set(a);
  };
  te.prototype.copy = function(a) {
    D.prototype.copy.call(this, a, !1);
    this.line.copy(a.line);
    this.cone.copy(a.cone);
    return this;
  };
  te.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  Rj.prototype = Object.create(ra.prototype);
  Rj.prototype.constructor = Rj;
  V.create = function(a, b) {
    a.prototype = Object.create(V.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a;
  };
  Object.assign(ke.prototype, {
    createPointsGeometry: function(a) {
      console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      a = this.getPoints(a);
      return this.createGeometry(a);
    },
    createSpacedPointsGeometry: function(a) {
      console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      a = this.getSpacedPoints(a);
      return this.createGeometry(a);
    },
    createGeometry: function(a) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      for (var b = new W(), c = 0, d = a.length; c < d; c++) {
        var e = a[c];
        b.vertices.push(new r(e.x, e.y, e.z || 0));
      }
      return b;
    }
  });
  Object.assign(Kc.prototype, {
    fromPoints: function(a) {
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      );
      this.setFromPoints(a);
    }
  });
  rm.prototype = Object.create(Yb.prototype);
  Object.assign(rm.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    }
  });
  Oj.prototype.setColors = function() {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  };
  me.prototype.update = function() {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  };
  Object.assign(sa.prototype, {
    extractUrlBase: function(a) {
      console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      );
      return Qm.extractUrlBase(a);
    }
  });
  sa.Handlers = {
    add: function() {
      console.error(
        "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
      );
    },
    get: function() {
      console.error(
        "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
      );
    }
  };
  Object.assign(Jj.prototype, {
    setTexturePath: function(a) {
      console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      );
      return this.setResourcePath(a);
    }
  });
  Object.assign(om.prototype, {
    center: function(a) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(a);
    },
    empty: function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(a) {
      console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      );
      return this.intersectsBox(a);
    },
    size: function(a) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(a);
    }
  });
  Object.assign(dd.prototype, {
    center: function(a) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(a);
    },
    empty: function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(a) {
      console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      );
      return this.intersectsBox(a);
    },
    isIntersectionSphere: function(a) {
      console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      );
      return this.intersectsSphere(a);
    },
    size: function(a) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(a);
    }
  });
  pm.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  };
  Object.assign(ca, {
    random16: function() {
      console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      );
      return Math.random();
    },
    nearestPowerOfTwo: function(a) {
      console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      );
      return ca.floorPowerOfTwo(a);
    },
    nextPowerOfTwo: function(a) {
      console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      );
      return ca.ceilPowerOfTwo(a);
    }
  });
  Object.assign(Ya.prototype, {
    flattenToArrayOffset: function(a, b) {
      console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      );
      return this.toArray(a, b);
    },
    multiplyVector3: function(a) {
      console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      );
      return a.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(a) {
      console.warn(
        "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      );
      return this.applyToBufferAttribute(a);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  });
  Object.assign(fa.prototype, {
    extractPosition: function(a) {
      console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      );
      return this.copyPosition(a);
    },
    flattenToArrayOffset: function(a, b) {
      console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      );
      return this.toArray(a, b);
    },
    getPosition: function() {
      console.warn(
        "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
      );
      return new r().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(a) {
      console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      );
      return this.makeRotationFromQuaternion(a);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(a) {
      console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      );
      return a.applyMatrix4(this);
    },
    multiplyVector4: function(a) {
      console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      );
      return a.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(a) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      );
      a.transformDirection(this);
    },
    crossVector: function(a) {
      console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      );
      return a.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(a) {
      console.warn(
        "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      );
      return this.applyToBufferAttribute(a);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(a, b, c, d, e, f) {
      console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      );
      return this.makePerspective(a, b, d, c, e, f);
    }
  });
  qc.prototype.isIntersectionLine = function(a) {
    console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    );
    return this.intersectsLine(a);
  };
  mb.prototype.multiplyVector3 = function(a) {
    console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    );
    return a.applyQuaternion(this);
  };
  Object.assign(Ob.prototype, {
    isIntersectionBox: function(a) {
      console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      );
      return this.intersectsBox(a);
    },
    isIntersectionPlane: function(a) {
      console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      );
      return this.intersectsPlane(a);
    },
    isIntersectionSphere: function(a) {
      console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      );
      return this.intersectsSphere(a);
    }
  });
  Object.assign(Ma.prototype, {
    area: function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    },
    barycoordFromPoint: function(a, b) {
      console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      );
      return this.getBarycoord(a, b);
    },
    midpoint: function(a) {
      console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      );
      return this.getMidpoint(a);
    },
    normal: function(a) {
      console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      );
      return this.getNormal(a);
    },
    plane: function(a) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(a);
    }
  });
  Object.assign(Ma, {
    barycoordFromPoint: function(a, b, c, d, e) {
      console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      );
      return Ma.getBarycoord(a, b, c, d, e);
    },
    normal: function(a, b, c, d) {
      console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      );
      return Ma.getNormal(a, b, c, d);
    }
  });
  Object.assign(rd.prototype, {
    extractAllPoints: function(a) {
      console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      );
      return this.extractPoints(a);
    },
    extrude: function(a) {
      console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      );
      return new Tb(this, a);
    },
    makeGeometry: function(a) {
      console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      );
      return new wc(this, a);
    }
  });
  Object.assign(E.prototype, {
    fromAttribute: function(a, b, c) {
      console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      );
      return this.fromBufferAttribute(a, b, c);
    },
    distanceToManhattan: function(a) {
      console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      );
      return this.manhattanDistanceTo(a);
    },
    lengthManhattan: function() {
      console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      );
      return this.manhattanLength();
    }
  });
  Object.assign(r.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function() {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function(a) {
      console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      );
      return this.setFromMatrixPosition(a);
    },
    getScaleFromMatrix: function(a) {
      console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      );
      return this.setFromMatrixScale(a);
    },
    getColumnFromMatrix: function(a, b) {
      console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      );
      return this.setFromMatrixColumn(b, a);
    },
    applyProjection: function(a) {
      console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      );
      return this.applyMatrix4(a);
    },
    fromAttribute: function(a, b, c) {
      console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      );
      return this.fromBufferAttribute(a, b, c);
    },
    distanceToManhattan: function(a) {
      console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      );
      return this.manhattanDistanceTo(a);
    },
    lengthManhattan: function() {
      console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      );
      return this.manhattanLength();
    }
  });
  Object.assign(Ca.prototype, {
    fromAttribute: function(a, b, c) {
      console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      );
      return this.fromBufferAttribute(a, b, c);
    },
    lengthManhattan: function() {
      console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      );
      return this.manhattanLength();
    }
  });
  Object.assign(W.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
  });
  Object.assign(D.prototype, {
    getChildByName: function(a) {
      console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      );
      return this.getObjectByName(a);
    },
    renderDepth: function() {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function(a, b) {
      console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      );
      return this.translateOnAxis(b, a);
    },
    getWorldRotation: function() {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    }
  });
  Object.defineProperties(D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(a) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = a;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      }
    }
  });
  Object.defineProperties(Mg.prototype, {
    objects: {
      get: function() {
        console.warn("THREE.LOD: .objects has been renamed to .levels.");
        return this.levels;
      }
    }
  });
  Object.defineProperty(Ng.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  });
  Tf.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(V.prototype, "__arcLengthDivisions", {
    get: function() {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      );
      return this.arcLengthDivisions;
    },
    set: function(a) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      );
      this.arcLengthDivisions = a;
    }
  });
  Ua.prototype.setLens = function(a, b) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    );
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a);
  };
  Object.defineProperties(da.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        );
        this.shadow.camera.fov = a;
      }
    },
    shadowCameraLeft: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        );
        this.shadow.camera.left = a;
      }
    },
    shadowCameraRight: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        );
        this.shadow.camera.right = a;
      }
    },
    shadowCameraTop: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        );
        this.shadow.camera.top = a;
      }
    },
    shadowCameraBottom: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        );
        this.shadow.camera.bottom = a;
      }
    },
    shadowCameraNear: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        );
        this.shadow.camera.near = a;
      }
    },
    shadowCameraFar: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        );
        this.shadow.camera.far = a;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      }
    },
    shadowBias: {
      set: function(a) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = a;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        );
        this.shadow.mapSize.width = a;
      }
    },
    shadowMapHeight: {
      set: function(a) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        );
        this.shadow.mapSize.height = a;
      }
    }
  });
  Object.defineProperties(ba.prototype, {
    length: {
      get: function() {
        console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        );
        return this.array.length;
      }
    }
  });
  Object.assign(ba.prototype, {
    copyIndicesArray: function() {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    },
    setArray: function(a) {
      console.warn(
        "THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
      );
      this.count = void 0 !== a ? a.length / this.itemSize : 0;
      this.array = a;
      return this;
    }
  });
  Object.assign(F.prototype, {
    addIndex: function(a) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      );
      this.setIndex(a);
    },
    addDrawCall: function(a, b, c) {
      void 0 !== c &&
        console.warn(
          "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
        );
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(a, b);
    },
    clearDrawCalls: function() {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      );
      this.clearGroups();
    },
    computeTangents: function() {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  });
  Object.defineProperties(F.prototype, {
    drawcalls: {
      get: function() {
        console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        );
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        );
        return this.groups;
      }
    }
  });
  Object.assign(Fb.prototype, {
    setArray: function(a) {
      console.warn(
        "THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
      );
      this.count = void 0 !== a ? a.length / this.stride : 0;
      this.array = a;
      return this;
    }
  });
  Object.assign(vc.prototype, {
    getArrays: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    }
  });
  Object.defineProperties(T.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new L();
      }
    },
    shading: {
      get: function() {
        console.error(
          "THREE." +
            this.type +
            ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function(a) {
        console.warn(
          "THREE." +
            this.type +
            ": .shading has been removed. Use the boolean .flatShading instead."
        );
        this.flatShading = 1 === a;
      }
    },
    stencilMask: {
      get: function() {
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        );
        return this.stencilFuncMask;
      },
      set: function(a) {
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        );
        this.stencilFuncMask = a;
      }
    }
  });
  Object.defineProperties(Ac.prototype, {
    metal: {
      get: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        );
        return !1;
      },
      set: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      }
    }
  });
  Object.defineProperties(Pa.prototype, {
    derivatives: {
      get: function() {
        console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        );
        return this.extensions.derivatives;
      },
      set: function(a) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        );
        this.extensions.derivatives = a;
      }
    }
  });
  Object.assign(Gl.prototype, {
    clearTarget: function(a, b, c, d) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      );
      this.setRenderTarget(a);
      this.clear(b, c, d);
    },
    animate: function(a) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      );
      this.setAnimationLoop(a);
    },
    getCurrentRenderTarget: function() {
      console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      );
      return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      );
      return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      );
      return this.capabilities.precision;
    },
    resetGLState: function() {
      console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      );
      return this.state.reset();
    },
    supportsFloatTextures: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      );
      return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      );
      return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      );
      return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      );
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      );
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      );
      return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      );
      return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      );
      return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(a) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      );
      this.setScissorTest(a);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function() {
      console.warn(
        "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
      );
    },
    setTexture: function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    },
    getActiveMipMapLevel: function() {
      console.warn(
        "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
      );
      return this.getActiveMipmapLevel();
    }
  });
  Object.defineProperties(Gl.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        );
        this.shadowMap.enabled = a;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        );
        this.shadowMap.type = a;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    context: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
        );
        return this.getContext();
      }
    }
  });
  Object.defineProperties(Al.prototype, {
    cullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      }
    }
  });
  Object.defineProperties(Rd.prototype, {
    activeCubeFace: {
      set: function() {
        console.warn(
          "THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
        );
      }
    },
    activeMipMapLevel: {
      set: function() {
        console.warn(
          "THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
        );
      }
    }
  });
  Object.defineProperties(Za.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(a) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = a;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(a) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = a;
      }
    },
    magFilter: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        );
        return this.texture.magFilter;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        );
        this.texture.magFilter = a;
      }
    },
    minFilter: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        );
        return this.texture.minFilter;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        );
        this.texture.minFilter = a;
      }
    },
    anisotropy: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        );
        return this.texture.anisotropy;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        );
        this.texture.anisotropy = a;
      }
    },
    offset: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        );
        return this.texture.offset;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        );
        this.texture.offset = a;
      }
    },
    repeat: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        );
        return this.texture.repeat;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        );
        this.texture.repeat = a;
      }
    },
    format: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        );
        return this.texture.format;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        );
        this.texture.format = a;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(a) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = a;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        );
        return this.texture.generateMipmaps;
      },
      set: function(a) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        );
        this.texture.generateMipmaps = a;
      }
    }
  });
  Object.defineProperties(ai.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  });
  td.prototype.load = function(a) {
    console.warn(
      "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    var b = this;
    new Kj().load(a, function(a) {
      b.setBuffer(a);
    });
    return this;
  };
  hm.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  hd.prototype.updateCubeMap = function(a, b) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(a, b);
  };
  Qc.crossOrigin = void 0;
  Qc.loadTexture = function(a, b, c, d) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    var e = new $g();
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a;
  };
  Qc.loadTextureCube = function(a, b, c, d) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    var e = new qi();
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a;
  };
  Qc.loadCompressedTexture = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  };
  Qc.loadCompressedTextureCube = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  };
  "undefined" !== typeof __THREE_DEVTOOLS__ &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent("register", { detail: { revision: "109" } })
    );
  Object.assign(Na.prototype, {
    setSize: function() {},
    render: function() {
      console.error(
        "THREE.Pass: .render() must be implemented in derived pass."
      );
    }
  });
  Na.FullScreenQuad = (function() {
    var a = new Zf(-1, 1, 1, -1, 0, 1),
      b = new id(2, 2),
      c = function(a) {
        this._mesh = new oa(b, a);
      };
    Object.defineProperty(c.prototype, "material", {
      get: function() {
        return this._mesh.material;
      },
      set: function(a) {
        this._mesh.material = a;
      }
    });
    Object.assign(c.prototype, {
      render: function(b) {
        b.render(this._mesh, a);
      }
    });
    return c;
  })();
  var zg = function(a, b, c, d, e) {
    Na.call(this);
    this.scene = a;
    this.camera = b;
    this.overrideMaterial = c;
    this.clearColor = d;
    this.clearAlpha = void 0 !== e ? e : 0;
    this.clear = !0;
    this.needsSwap = this.clearDepth = !1;
  };
  zg.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: zg,
    render: function(a, b, c) {
      b = a.autoClear;
      a.autoClear = !1;
      this.scene.overrideMaterial = this.overrideMaterial;
      if (this.clearColor) {
        var d = a.getClearColor().getHex();
        var e = a.getClearAlpha();
        a.setClearColor(this.clearColor, this.clearAlpha);
      }
      this.clearDepth && a.clearDepth();
      a.setRenderTarget(this.renderToScreen ? null : c);
      this.clear &&
        a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
      a.render(this.scene, this.camera);
      this.clearColor && a.setClearColor(d, e);
      this.scene.overrideMaterial = null;
      a.autoClear = b;
    }
  });
  var Gf = {
      uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
      vertexShader:
        "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader:
        "uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tgl_FragColor = opacity * texel;\n}"
    },
    Ag = {
      shaderID: "luminosityHighPass",
      uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1 },
        smoothWidth: { value: 1 },
        defaultColor: { value: new L(0) },
        defaultOpacity: { value: 0 }
      },
      vertexShader:
        "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader:
        "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( texel.xyz, luma );\n\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\tgl_FragColor = mix( outputColor, texel, alpha );\n}"
    },
    Pe = function(a, b, c, d) {
      Na.call(this);
      this.strength = void 0 !== b ? b : 1;
      this.radius = c;
      this.threshold = d;
      this.resolution = void 0 !== a ? new E(a.x, a.y) : new E(256, 256);
      this.clearColor = new L(0, 0, 0);
      var e = { minFilter: 1006, magFilter: 1006, format: 1023 };
      this.renderTargetsHorizontal = [];
      this.renderTargetsVertical = [];
      this.nMips = 5;
      a = Math.round(this.resolution.x / 2);
      c = Math.round(this.resolution.y / 2);
      this.renderTargetBright = new Za(a, c, e);
      this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
      this.renderTargetBright.texture.generateMipmaps = !1;
      for (var f = 0; f < this.nMips; f++) {
        var h = new Za(a, c, e);
        h.texture.name = "UnrealBloomPass.h" + f;
        h.texture.generateMipmaps = !1;
        this.renderTargetsHorizontal.push(h);
        h = new Za(a, c, e);
        h.texture.name = "UnrealBloomPass.v" + f;
        h.texture.generateMipmaps = !1;
        this.renderTargetsVertical.push(h);
        a = Math.round(a / 2);
        c = Math.round(c / 2);
      }
      void 0 === Ag &&
        console.error("UnrealBloomPass relies on LuminosityHighPassShader");
      this.highPassUniforms = Nh.clone(Ag.uniforms);
      this.highPassUniforms.luminosityThreshold.value = d;
      this.highPassUniforms.smoothWidth.value = 0.01;
      this.materialHighPassFilter = new Pa({
        uniforms: this.highPassUniforms,
        vertexShader: Ag.vertexShader,
        fragmentShader: Ag.fragmentShader,
        defines: {}
      });
      this.separableBlurMaterials = [];
      d = [3, 5, 7, 9, 11];
      a = Math.round(this.resolution.x / 2);
      c = Math.round(this.resolution.y / 2);
      for (f = 0; f < this.nMips; f++)
        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(d[f])),
          (this.separableBlurMaterials[f].uniforms.texSize.value = new E(a, c)),
          (a = Math.round(a / 2)),
          (c = Math.round(c / 2));
      this.compositeMaterial = this.getCompositeMaterial(this.nMips);
      this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture;
      this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture;
      this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture;
      this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture;
      this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture;
      this.compositeMaterial.uniforms.bloomStrength.value = b;
      this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
      this.compositeMaterial.needsUpdate = !0;
      this.compositeMaterial.uniforms.bloomFactors.value = [
        1,
        0.8,
        0.6,
        0.4,
        0.2
      ];
      this.bloomTintColors = [
        new r(1, 1, 1),
        new r(1, 1, 1),
        new r(1, 1, 1),
        new r(1, 1, 1),
        new r(1, 1, 1)
      ];
      this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
      void 0 === Gf && console.error("UnrealBloomPass relies on CopyShader");
      this.copyUniforms = Nh.clone(Gf.uniforms);
      this.copyUniforms.opacity.value = 1;
      this.materialCopy = new Pa({
        uniforms: this.copyUniforms,
        vertexShader: Gf.vertexShader,
        fragmentShader: Gf.fragmentShader,
        blending: 2,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
      });
      this.enabled = !0;
      this.needsSwap = !1;
      this.oldClearColor = new L();
      this.oldClearAlpha = 1;
      this.basic = new vb();
      this.fsQuad = new Na.FullScreenQuad(null);
    };
  Pe.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Pe,
    dispose: function() {
      for (var a = 0; a < this.renderTargetsHorizontal.length; a++)
        this.renderTargetsHorizontal[a].dispose();
      for (a = 0; a < this.renderTargetsVertical.length; a++)
        this.renderTargetsVertical[a].dispose();
      this.renderTargetBright.dispose();
    },
    setSize: function(a, b) {
      a = Math.round(a / 2);
      b = Math.round(b / 2);
      this.renderTargetBright.setSize(a, b);
      for (var c = 0; c < this.nMips; c++)
        this.renderTargetsHorizontal[c].setSize(a, b),
          this.renderTargetsVertical[c].setSize(a, b),
          (this.separableBlurMaterials[c].uniforms.texSize.value = new E(a, b)),
          (a = Math.round(a / 2)),
          (b = Math.round(b / 2));
    },
    render: function(a, b, c, d, e) {
      this.oldClearColor.copy(a.getClearColor());
      this.oldClearAlpha = a.getClearAlpha();
      b = a.autoClear;
      a.autoClear = !1;
      a.setClearColor(this.clearColor, 0);
      e && a.state.buffers.stencil.setTest(!1);
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = c.texture),
        a.setRenderTarget(null),
        a.clear(),
        this.fsQuad.render(a));
      this.highPassUniforms.tDiffuse.value = c.texture;
      this.highPassUniforms.luminosityThreshold.value = this.threshold;
      this.fsQuad.material = this.materialHighPassFilter;
      a.setRenderTarget(this.renderTargetBright);
      a.clear();
      this.fsQuad.render(a);
      d = this.renderTargetBright;
      for (var f = 0; f < this.nMips; f++)
        (this.fsQuad.material = this.separableBlurMaterials[f]),
          (this.separableBlurMaterials[f].uniforms.colorTexture.value =
            d.texture),
          (this.separableBlurMaterials[f].uniforms.direction.value =
            Pe.BlurDirectionX),
          a.setRenderTarget(this.renderTargetsHorizontal[f]),
          a.clear(),
          this.fsQuad.render(a),
          (this.separableBlurMaterials[
            f
          ].uniforms.colorTexture.value = this.renderTargetsHorizontal[
            f
          ].texture),
          (this.separableBlurMaterials[f].uniforms.direction.value =
            Pe.BlurDirectionY),
          a.setRenderTarget(this.renderTargetsVertical[f]),
          a.clear(),
          this.fsQuad.render(a),
          (d = this.renderTargetsVertical[f]);
      this.fsQuad.material = this.compositeMaterial;
      this.compositeMaterial.uniforms.bloomStrength.value = this.strength;
      this.compositeMaterial.uniforms.bloomRadius.value = this.radius;
      this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
      a.setRenderTarget(this.renderTargetsHorizontal[0]);
      a.clear();
      this.fsQuad.render(a);
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture;
      e && a.state.buffers.stencil.setTest(!0);
      this.renderToScreen ? a.setRenderTarget(null) : a.setRenderTarget(c);
      this.fsQuad.render(a);
      a.setClearColor(this.oldClearColor, this.oldClearAlpha);
      a.autoClear = b;
    },
    getSeperableBlurMaterial: function(a) {
      return new Pa({
        defines: { KERNEL_RADIUS: a, SIGMA: a },
        uniforms: {
          colorTexture: { value: null },
          texSize: { value: new E(0.5, 0.5) },
          direction: { value: new E(0.5, 0.5) }
        },
        vertexShader:
          "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
        fragmentShader:
          "#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
      });
    },
    getCompositeMaterial: function(a) {
      return new Pa({
        defines: { NUM_MIPS: a },
        uniforms: {
          blurTexture1: { value: null },
          blurTexture2: { value: null },
          blurTexture3: { value: null },
          blurTexture4: { value: null },
          blurTexture5: { value: null },
          dirtTexture: { value: null },
          bloomStrength: { value: 1 },
          bloomFactors: { value: null },
          bloomTintColors: { value: null },
          bloomRadius: { value: 0 }
        },
        vertexShader:
          "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
        fragmentShader:
          "varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"
      });
    }
  });
  Pe.BlurDirectionX = new E(1, 0);
  Pe.BlurDirectionY = new E(0, 1);
  var Bg = function(a, b) {
    Na.call(this);
    this.textureID = void 0 !== b ? b : "tDiffuse";
    a instanceof Pa
      ? ((this.uniforms = a.uniforms), (this.material = a))
      : a &&
        ((this.uniforms = Nh.clone(a.uniforms)),
        (this.material = new Pa({
          defines: Object.assign({}, a.defines),
          uniforms: this.uniforms,
          vertexShader: a.vertexShader,
          fragmentShader: a.fragmentShader
        })));
    this.fsQuad = new Na.FullScreenQuad(this.material);
  };
  Bg.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Bg,
    render: function(a, b, c) {
      this.uniforms[this.textureID] &&
        (this.uniforms[this.textureID].value = c.texture);
      this.fsQuad.material = this.material;
      this.renderToScreen
        ? a.setRenderTarget(null)
        : (a.setRenderTarget(b),
          this.clear &&
            a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil));
      this.fsQuad.render(a);
    }
  });
  var Hf = function(a, b) {
    Na.call(this);
    this.scene = a;
    this.camera = b;
    this.clear = !0;
    this.inverse = this.needsSwap = !1;
  };
  Hf.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Hf,
    render: function(a, b, c) {
      var d = a.getContext(),
        e = a.state;
      e.buffers.color.setMask(!1);
      e.buffers.depth.setMask(!1);
      e.buffers.color.setLocked(!0);
      e.buffers.depth.setLocked(!0);
      if (this.inverse) {
        var f = 0;
        var h = 1;
      } else (f = 1), (h = 0);
      e.buffers.stencil.setTest(!0);
      e.buffers.stencil.setOp(d.REPLACE, d.REPLACE, d.REPLACE);
      e.buffers.stencil.setFunc(d.ALWAYS, f, 4294967295);
      e.buffers.stencil.setClear(h);
      e.buffers.stencil.setLocked(!0);
      a.setRenderTarget(c);
      this.clear && a.clear();
      a.render(this.scene, this.camera);
      a.setRenderTarget(b);
      this.clear && a.clear();
      a.render(this.scene, this.camera);
      e.buffers.color.setLocked(!1);
      e.buffers.depth.setLocked(!1);
      e.buffers.stencil.setLocked(!1);
      e.buffers.stencil.setFunc(d.EQUAL, 1, 4294967295);
      e.buffers.stencil.setOp(d.KEEP, d.KEEP, d.KEEP);
      e.buffers.stencil.setLocked(!0);
    }
  });
  var Vk = function() {
    Na.call(this);
    this.needsSwap = !1;
  };
  Vk.prototype = Object.create(Na.prototype);
  Object.assign(Vk.prototype, {
    render: function(a) {
      a.state.buffers.stencil.setLocked(!1);
      a.state.buffers.stencil.setTest(!1);
    }
  });
  var fn = function(a, b) {
    this.renderer = a;
    void 0 === b
      ? ((b = a.getSize(new E())),
        (this._pixelRatio = a.getPixelRatio()),
        (this._width = b.width),
        (this._height = b.height),
        (b = new Za(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          { minFilter: 1006, magFilter: 1006, format: 1023, stencilBuffer: !1 }
        )),
        (b.texture.name = "EffectComposer.rt1"))
      : ((this._pixelRatio = 1),
        (this._width = b.width),
        (this._height = b.height));
    this.renderTarget1 = b;
    this.renderTarget2 = b.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = !0;
    this.passes = [];
    void 0 === Gf && console.error("THREE.EffectComposer relies on CopyShader");
    void 0 === Bg && console.error("THREE.EffectComposer relies on ShaderPass");
    this.copyPass = new Bg(Gf);
    this.clock = new Mj();
  };
  Object.assign(fn.prototype, {
    swapBuffers: function() {
      var a = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = a;
    },
    addPass: function(a) {
      this.passes.push(a);
      a.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
    },
    insertPass: function(a, b) {
      this.passes.splice(b, 0, a);
    },
    isLastEnabledPass: function(a) {
      for (a += 1; a < this.passes.length; a++)
        if (this.passes[a].enabled) return !1;
      return !0;
    },
    render: function(a) {
      void 0 === a && (a = this.clock.getDelta());
      var b = this.renderer.getRenderTarget(),
        c = !1,
        d,
        e = this.passes.length;
      for (d = 0; d < e; d++) {
        var f = this.passes[d];
        if (!1 !== f.enabled) {
          f.renderToScreen = this.renderToScreen && this.isLastEnabledPass(d);
          f.render(this.renderer, this.writeBuffer, this.readBuffer, a, c);
          if (f.needsSwap) {
            if (c) {
              var h = this.renderer.getContext(),
                k = this.renderer.state.buffers.stencil;
              k.setFunc(h.NOTEQUAL, 1, 4294967295);
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                a
              );
              k.setFunc(h.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== Hf &&
            (f instanceof Hf ? (c = !0) : f instanceof Vk && (c = !1));
        }
      }
      this.renderer.setRenderTarget(b);
    },
    reset: function(a) {
      void 0 === a &&
        ((a = this.renderer.getSize(new E())),
        (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = a.width),
        (this._height = a.height),
        (a = this.renderTarget1.clone()),
        a.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        ));
      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.renderTarget1 = a;
      this.renderTarget2 = a.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
    },
    setSize: function(a, b) {
      this._width = a;
      this._height = b;
      a = this._width * this._pixelRatio;
      b = this._height * this._pixelRatio;
      this.renderTarget1.setSize(a, b);
      this.renderTarget2.setSize(a, b);
      for (var c = 0; c < this.passes.length; c++) this.passes[c].setSize(a, b);
    },
    setPixelRatio: function(a) {
      this._pixelRatio = a;
      this.setSize(this._width, this._height);
    }
  });
  var gn = function() {
    this.needsSwap = this.enabled = !0;
    this.renderToScreen = this.clear = !1;
  };
  Object.assign(gn.prototype, {
    setSize: function() {},
    render: function() {
      console.error(
        "THREE.Pass: .render() must be implemented in derived pass."
      );
    }
  });
  gn.FullScreenQuad = (function() {
    var a = new Zf(-1, 1, 1, -1, 0, 1),
      b = new id(2, 2),
      c = function(a) {
        this._mesh = new oa(b, a);
      };
    Object.defineProperty(c.prototype, "material", {
      get: function() {
        return this._mesh.material;
      },
      set: function(a) {
        this._mesh.material = a;
      }
    });
    Object.assign(c.prototype, {
      render: function(b) {
        b.render(this._mesh, a);
      }
    });
    return c;
  })();
  var tp = (function(a) {
    function b(a) {
      ud(this, b);
      return ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this, a));
    }
    ue(b, a);
    Nc(b, [
      {
        key: "initialize",
        value: function(a) {
          var b = a.camera,
            c = a.renderer;
          if (!this._initialize) {
            this.scene = a.scene;
            this.camera = b;
            this.renderer = c;
            a = this.options.passes;
            this._initialize = !0;
            this.renderScene = new zg(this.scene, this.camera);
            b = new fn(this.renderer);
            b.addPass(this.renderScene);
            this.passes = [];
            if (a)
              for (c = 0; c < a.length; c++) {
                var f = a[c];
                if ("unrealBloom" === f.name) {
                  var h = new Pe(
                      new ja.Vector2(window.innerWidth, window.innerHeight),
                      1.5,
                      0.4,
                      0.85
                    ),
                    k;
                  for (k in f) h[k] = f[k];
                  b.addPass(h);
                }
              }
            this.composer = b;
          }
        }
      },
      {
        key: "addRender",
        value: function(a) {
          this.renderScene && this.renderScene.addRender(a);
        }
      },
      {
        key: "render",
        value: function() {
          this.composer.render(this.scene, this.camera);
        }
      }
    ]);
    return b;
  })(hj);
  Pe.prototype.getSeperableBlurMaterial = function(a) {
    return new ja.ShaderMaterial({
      defines: { KERNEL_RADIUS: a, SIGMA: a },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new ja.Vector2(0.5, 0.5) },
        direction: { value: new ja.Vector2(0.5, 0.5) }
      },
      vertexShader:
        "varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }",
      fragmentShader:
        "#include <common>            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;            uniform vec2 direction;                        float gaussianPdf(in float x, in float sigma) {                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;            }            void main() {\n                vec2 invSize = 1.0 / texSize;                float fSigma = float(SIGMA);                float weightSum = gaussianPdf(0.0, fSigma);                vec4 diffuseSum = texture2D( colorTexture, vUv).rgba * weightSum;                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {                    float x = float(i);                    float w = gaussianPdf(x, fSigma);                    vec2 uvOffset = direction * invSize * x;                    vec4 sample1 = texture2D( colorTexture, vUv + uvOffset).rgba;                    vec4 sample2 = texture2D( colorTexture, vUv - uvOffset).rgba;                    diffuseSum += (sample1 + sample2) * w;                    weightSum += 2.0 * w;                }                gl_FragColor = vec4(diffuseSum/weightSum);\n            }"
    });
  };
  zg.prototype.addRender = function(a) {
    this.renderCbk = a;
  };
  zg.prototype.render = function(a, b, c) {
    b = a.autoClear;
    a.autoClear = !1;
    this.scene.overrideMaterial = this.overrideMaterial;
    if (this.clearColor) {
      var d = a.getClearColor().getHex();
      var e = a.getClearAlpha();
      a.setClearColor(this.clearColor, this.clearAlpha);
    }
    this.clearDepth && a.clearDepth();
    a.setRenderTarget(this.renderToScreen ? null : c);
    this.clear &&
      a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
    a.render(this.scene, this.camera);
    this.renderCbk && this.renderCbk();
    this.clearColor && a.setClearColor(d, e);
    this.scene.overrideMaterial = null;
    a.autoClear = b;
  };
  var up = (function(a) {
      function b(a) {
        ud(this, b);
        a = ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this, a));
        a.time = 0;
        a.autoUpdate = !0;
        return a;
      }
      ue(b, a);
      Nc(b, [
        {
          key: "getDefaultOptions",
          value: function() {
            return {
              totalRadian: Math.PI,
              color: 16711680,
              radius: 50,
              step: 0.1
            };
          }
        },
        {
          key: "initialize",
          value: function(a) {
            this.threeLayer = a;
            this.addOverlay();
          }
        },
        {
          key: "onChanged",
          value: function(a, b) {
            this.threeLayer && (this.removeOverlay(), this.addOverlay());
          }
        },
        {
          key: "onDestroy",
          value: function() {
            this.removeOverlay();
          }
        },
        {
          key: "render",
          value: function() {
            this.time += this.options.step / 10;
            1 < this.time && (this.time = 0);
            for (var a = this.shapeMarker.children, b = 0; b < a.length; b++)
              a[b].material.uniforms.periodRatio.value = this.time;
          }
        },
        {
          key: "removeOverlay",
          value: function() {
            this.threeLayer.remove(this.shapeMarker);
          }
        },
        {
          key: "addOverlay",
          value: function() {
            this.shapeMarker = new ja.Group();
            for (
              var a = this.threeLayer, b = this.getData(), e = 0;
              e < b.length;
              e++
            ) {
              var f = a.normizedPoint(b[e].geometry.coordinates);
              f = this.create3dCanvasRipple({
                originalData: b[e],
                normizedData: f
              });
              this.shapeMarker.add(f);
            }
            a.add(this.shapeMarker);
          }
        },
        {
          key: "create3dCanvasRipple",
          value: function(a) {
            var b = this.options,
              c = b.totalRadian,
              f = b.color;
            b = b.size;
            var h = a.originalData;
            a = a.normizedData;
            "[object Function]" === Object.prototype.toString.call(f) &&
              (f = f(h));
            b =
              "[object Function]" === Object.prototype.toString.call(b)
                ? b(h)
                : Number(b);
            h = {
              totalRadian: { type: "f", value: c },
              glowColor: { type: "c", value: new ja.Color(f) },
              radius: { type: "f", value: b },
              periodRatio: { type: "f", value: 0 }
            };
            f = new ja.Geometry();
            for (var k = c / (b / 2), l = k; l <= c; l += k) {
              var m = b * Math.sin(l),
                n = b * Math.cos(l);
              f.vertices.push(new ja.Vector3(0, 0, l / c));
              f.vertices.push(new ja.Vector3(n, m, l / c));
            }
            c = 0;
            for (b = f.vertices.length; c < b - 2; ++c)
              f.faces.push(new ja.Face3(c, c + 1, c + 3));
            c = new ja.ShaderMaterial({
              uniforms: h,
              vertexShader:
                "varying vec4 vFragColor;varying vec4 vPosition;uniform float radius;uniform float totalRadian;uniform float periodRatio;uniform vec3 glowColor;void main(){float radian=radians(360.0*periodRatio);float s=sin(radian);float c=cos(radian);vec2 rotatedPostion=vec2(position.x*s+position.y*c,position.y*s-position.x*c);gl_Position=projectionMatrix*modelViewMatrix*vec4(rotatedPostion,0,1.0);vFragColor=vec4(glowColor,pow(position.z,1.3));}",
              fragmentShader:
                "varying vec4 vFragColor;void main(){gl_FragColor=vFragColor;}",
              blending: ja.NormalBlending,
              transparent: !0,
              depthWrite: !1
            });
            c = new ja.Mesh(f, c);
            c.position.set(a[0], a[1], a[2] || 0);
            return c;
          }
        }
      ]);
      return b;
    })(hj),
    hn = ad(function(a, b) {
      (function() {
        function c() {
          this.positions = [];
          this.previous = [];
          this.next = [];
          this.side = [];
          this.width = [];
          this.indices_array = [];
          this.uvs = [];
          this.counters = [];
          this.geometry = new f.BufferGeometry();
          this.widthCallback = null;
          this.matrixWorld = new f.Matrix4();
        }
        function d(a, b, c, d, e) {
          a = a.subarray || a.slice ? a : a.buffer;
          c = c.subarray || c.slice ? c : c.buffer;
          a = b
            ? a.subarray
              ? a.subarray(b, e && b + e)
              : a.slice(b, e && b + e)
            : a;
          if (c.set) c.set(a, d);
          else for (b = 0; b < a.length; b++) c[b + d] = a[b];
          return c;
        }
        function e(a) {
          f.ShaderMaterial.call(this, {
            uniforms: Object.assign({}, f.UniformsLib.fog, {
              lineWidth: { value: 1 },
              map: { value: null },
              useMap: { value: 0 },
              alphaMap: { value: null },
              useAlphaMap: { value: 0 },
              color: { value: new f.Color(16777215) },
              opacity: { value: 1 },
              resolution: { value: new f.Vector2(1, 1) },
              sizeAttenuation: { value: 1 },
              near: { value: 1 },
              far: { value: 1 },
              dashArray: { value: 0 },
              dashOffset: { value: 0 },
              dashRatio: { value: 0.5 },
              useDash: { value: 0 },
              visibility: { value: 1 },
              alphaTest: { value: 0 },
              repeat: { value: new f.Vector2(1, 1) }
            }),
            vertexShader: f.ShaderChunk.meshline_vert,
            fragmentShader: f.ShaderChunk.meshline_frag
          });
          this.type = "MeshLineMaterial";
          Object.defineProperties(this, {
            lineWidth: {
              enumerable: !0,
              get: function() {
                return this.uniforms.lineWidth.value;
              },
              set: function(a) {
                this.uniforms.lineWidth.value = a;
              }
            },
            map: {
              enumerable: !0,
              get: function() {
                return this.uniforms.map.value;
              },
              set: function(a) {
                this.uniforms.map.value = a;
              }
            },
            useMap: {
              enumerable: !0,
              get: function() {
                return this.uniforms.useMap.value;
              },
              set: function(a) {
                this.uniforms.useMap.value = a;
              }
            },
            alphaMap: {
              enumerable: !0,
              get: function() {
                return this.uniforms.alphaMap.value;
              },
              set: function(a) {
                this.uniforms.alphaMap.value = a;
              }
            },
            useAlphaMap: {
              enumerable: !0,
              get: function() {
                return this.uniforms.useAlphaMap.value;
              },
              set: function(a) {
                this.uniforms.useAlphaMap.value = a;
              }
            },
            color: {
              enumerable: !0,
              get: function() {
                return this.uniforms.color.value;
              },
              set: function(a) {
                this.uniforms.color.value = a;
              }
            },
            opacity: {
              enumerable: !0,
              get: function() {
                return this.uniforms.opacity.value;
              },
              set: function(a) {
                this.uniforms.opacity.value = a;
              }
            },
            resolution: {
              enumerable: !0,
              get: function() {
                return this.uniforms.resolution.value;
              },
              set: function(a) {
                this.uniforms.resolution.value.copy(a);
              }
            },
            sizeAttenuation: {
              enumerable: !0,
              get: function() {
                return this.uniforms.sizeAttenuation.value;
              },
              set: function(a) {
                this.uniforms.sizeAttenuation.value = a;
              }
            },
            near: {
              enumerable: !0,
              get: function() {
                return this.uniforms.near.value;
              },
              set: function(a) {
                this.uniforms.near.value = a;
              }
            },
            far: {
              enumerable: !0,
              get: function() {
                return this.uniforms.far.value;
              },
              set: function(a) {
                this.uniforms.far.value = a;
              }
            },
            dashArray: {
              enumerable: !0,
              get: function() {
                return this.uniforms.dashArray.value;
              },
              set: function(a) {
                this.uniforms.dashArray.value = a;
                this.useDash = 0 !== a ? 1 : 0;
              }
            },
            dashOffset: {
              enumerable: !0,
              get: function() {
                return this.uniforms.dashOffset.value;
              },
              set: function(a) {
                this.uniforms.dashOffset.value = a;
              }
            },
            dashRatio: {
              enumerable: !0,
              get: function() {
                return this.uniforms.dashRatio.value;
              },
              set: function(a) {
                this.uniforms.dashRatio.value = a;
              }
            },
            useDash: {
              enumerable: !0,
              get: function() {
                return this.uniforms.useDash.value;
              },
              set: function(a) {
                this.uniforms.useDash.value = a;
              }
            },
            visibility: {
              enumerable: !0,
              get: function() {
                return this.uniforms.visibility.value;
              },
              set: function(a) {
                this.uniforms.visibility.value = a;
              }
            },
            alphaTest: {
              enumerable: !0,
              get: function() {
                return this.uniforms.alphaTest.value;
              },
              set: function(a) {
                this.uniforms.alphaTest.value = a;
              }
            },
            repeat: {
              enumerable: !0,
              get: function() {
                return this.uniforms.repeat.value;
              },
              set: function(a) {
                this.uniforms.repeat.value.copy(a);
              }
            }
          });
          this.setValues(a);
        }
        var f = ("undefined" !== typeof If && vm) || this.THREE;
        if (!f) throw Error("MeshLine requires three.js");
        c.prototype.setMatrixWorld = function(a) {
          this.matrixWorld = a;
        };
        c.prototype.setGeometry = function(a, b) {
          this.widthCallback = b;
          this.positions = [];
          this.counters = [];
          if (a instanceof f.Geometry)
            for (var c = 0; c < a.vertices.length; c++) {
              var d = a.vertices[c];
              b = c / a.vertices.length;
              this.positions.push(d.x, d.y, d.z);
              this.positions.push(d.x, d.y, d.z);
              this.counters.push(b);
              this.counters.push(b);
            }
          if (a instanceof Float32Array || a instanceof Array)
            for (c = 0; c < a.length; c += 3)
              (b = c / a.length),
                this.positions.push(a[c], a[c + 1], a[c + 2]),
                this.positions.push(a[c], a[c + 1], a[c + 2]),
                this.counters.push(b),
                this.counters.push(b);
          this.process();
        };
        c.prototype.raycast = (function() {
          var a = new f.Matrix4(),
            b = new f.Ray(),
            c = new f.Sphere();
          return function(d, e) {
            var h = d.linePrecision;
            h *= h;
            var k = this.geometry;
            null === k.boundingSphere && k.computeBoundingSphere();
            c.copy(k.boundingSphere);
            c.applyMatrix4(this.matrixWorld);
            if (!1 !== d.ray.intersectSphere(c)) {
              a.getInverse(this.matrixWorld);
              b.copy(d.ray).applyMatrix4(a);
              var l = new f.Vector3(),
                m = new f.Vector3(),
                n = new f.Vector3(),
                r = new f.Vector3(),
                C = this instanceof f.LineSegments ? 2 : 1;
              if (k instanceof f.BufferGeometry) {
                var z = k.index,
                  D = k.attributes;
                if (null !== z) {
                  k = z.array;
                  D = D.position.array;
                  z = 0;
                  for (var E = k.length - 1; z < E; z += C) {
                    var B = k[z + 1];
                    l.fromArray(D, 3 * k[z]);
                    m.fromArray(D, 3 * B);
                    B = b.distanceSqToSegment(l, m, r, n);
                    B > h ||
                      (r.applyMatrix4(this.matrixWorld),
                      (B = d.ray.origin.distanceTo(r)),
                      B < d.near ||
                        B > d.far ||
                        e.push({
                          distance: B,
                          point: n.clone().applyMatrix4(this.matrixWorld),
                          index: z,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
                  }
                } else
                  for (
                    D = D.position.array, z = 0, E = D.length / 3 - 1;
                    z < E;
                    z += C
                  )
                    l.fromArray(D, 3 * z),
                      m.fromArray(D, 3 * z + 3),
                      (B = b.distanceSqToSegment(l, m, r, n)),
                      B > h ||
                        (r.applyMatrix4(this.matrixWorld),
                        (B = d.ray.origin.distanceTo(r)),
                        B < d.near ||
                          B > d.far ||
                          e.push({
                            distance: B,
                            point: n.clone().applyMatrix4(this.matrixWorld),
                            index: z,
                            face: null,
                            faceIndex: null,
                            object: this
                          }));
              } else if (k instanceof f.Geometry)
                for (l = k.vertices, m = l.length, z = 0; z < m - 1; z += C)
                  (B = b.distanceSqToSegment(l[z], l[z + 1], r, n)),
                    B > h ||
                      (r.applyMatrix4(this.matrixWorld),
                      (B = d.ray.origin.distanceTo(r)),
                      B < d.near ||
                        B > d.far ||
                        e.push({
                          distance: B,
                          point: n.clone().applyMatrix4(this.matrixWorld),
                          index: z,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
            }
          };
        })();
        c.prototype.compareV3 = function(a, b) {
          a *= 6;
          b *= 6;
          return (
            this.positions[a] === this.positions[b] &&
            this.positions[a + 1] === this.positions[b + 1] &&
            this.positions[a + 2] === this.positions[b + 2]
          );
        };
        c.prototype.copyV3 = function(a) {
          a *= 6;
          return [
            this.positions[a],
            this.positions[a + 1],
            this.positions[a + 2]
          ];
        };
        c.prototype.process = function() {
          var a = this.positions.length / 6;
          this.previous = [];
          this.next = [];
          this.side = [];
          this.width = [];
          this.indices_array = [];
          this.uvs = [];
          for (var b = 0; b < a; b++) this.side.push(1), this.side.push(-1);
          for (b = 0; b < a; b++) {
            var c = this.widthCallback ? this.widthCallback(b / (a - 1)) : 1;
            this.width.push(c);
            this.width.push(c);
          }
          for (b = 0; b < a; b++)
            this.uvs.push(b / (a - 1), 0), this.uvs.push(b / (a - 1), 1);
          c = this.compareV3(0, a - 1) ? this.copyV3(a - 2) : this.copyV3(0);
          this.previous.push(c[0], c[1], c[2]);
          this.previous.push(c[0], c[1], c[2]);
          for (b = 0; b < a - 1; b++)
            (c = this.copyV3(b)),
              this.previous.push(c[0], c[1], c[2]),
              this.previous.push(c[0], c[1], c[2]);
          for (b = 1; b < a; b++)
            (c = this.copyV3(b)),
              this.next.push(c[0], c[1], c[2]),
              this.next.push(c[0], c[1], c[2]);
          c = this.compareV3(a - 1, 0) ? this.copyV3(1) : this.copyV3(a - 1);
          this.next.push(c[0], c[1], c[2]);
          this.next.push(c[0], c[1], c[2]);
          for (b = 0; b < a - 1; b++)
            (c = 2 * b),
              this.indices_array.push(c, c + 1, c + 2),
              this.indices_array.push(c + 2, c + 1, c + 3);
          this.attributes
            ? (this.attributes.position.copyArray(
                new Float32Array(this.positions)
              ),
              (this.attributes.position.needsUpdate = !0),
              this.attributes.previous.copyArray(
                new Float32Array(this.previous)
              ),
              (this.attributes.previous.needsUpdate = !0),
              this.attributes.next.copyArray(new Float32Array(this.next)),
              (this.attributes.next.needsUpdate = !0),
              this.attributes.side.copyArray(new Float32Array(this.side)),
              (this.attributes.side.needsUpdate = !0),
              this.attributes.width.copyArray(new Float32Array(this.width)),
              (this.attributes.width.needsUpdate = !0),
              this.attributes.uv.copyArray(new Float32Array(this.uvs)),
              (this.attributes.uv.needsUpdate = !0),
              this.attributes.index.copyArray(
                new Uint16Array(this.indices_array)
              ),
              (this.attributes.index.needsUpdate = !0))
            : (this.attributes = {
                position: new f.BufferAttribute(
                  new Float32Array(this.positions),
                  3
                ),
                previous: new f.BufferAttribute(
                  new Float32Array(this.previous),
                  3
                ),
                next: new f.BufferAttribute(new Float32Array(this.next), 3),
                side: new f.BufferAttribute(new Float32Array(this.side), 1),
                width: new f.BufferAttribute(new Float32Array(this.width), 1),
                uv: new f.BufferAttribute(new Float32Array(this.uvs), 2),
                index: new f.BufferAttribute(
                  new Uint16Array(this.indices_array),
                  1
                ),
                counters: new f.BufferAttribute(
                  new Float32Array(this.counters),
                  1
                )
              });
          this.geometry.addAttribute("position", this.attributes.position);
          this.geometry.addAttribute("previous", this.attributes.previous);
          this.geometry.addAttribute("next", this.attributes.next);
          this.geometry.addAttribute("side", this.attributes.side);
          this.geometry.addAttribute("width", this.attributes.width);
          this.geometry.addAttribute("uv", this.attributes.uv);
          this.geometry.addAttribute("counters", this.attributes.counters);
          this.geometry.setIndex(this.attributes.index);
        };
        c.prototype.advance = function(a) {
          var b = this.attributes.position.array,
            c = this.attributes.next.array,
            e = b.length;
          d(b, 0, this.attributes.previous.array, 0, e);
          d(b, 6, b, 0, e - 6);
          b[e - 6] = a.x;
          b[e - 5] = a.y;
          b[e - 4] = a.z;
          b[e - 3] = a.x;
          b[e - 2] = a.y;
          b[e - 1] = a.z;
          d(b, 6, c, 0, e - 6);
          c[e - 6] = a.x;
          c[e - 5] = a.y;
          c[e - 4] = a.z;
          c[e - 3] = a.x;
          c[e - 2] = a.y;
          c[e - 1] = a.z;
          this.attributes.position.needsUpdate = !0;
          this.attributes.previous.needsUpdate = !0;
          this.attributes.next.needsUpdate = !0;
        };
        f.ShaderChunk.meshline_vert = [
          "",
          f.ShaderChunk.logdepthbuf_pars_vertex,
          f.ShaderChunk.fog_pars_vertex,
          "\r\nattribute vec3 previous;\r\nattribute vec3 next;\r\nattribute float side;\r\nattribute float width;\r\nattribute float counters;\r\n\r\nuniform vec2 resolution;\r\nuniform float lineWidth;\r\nuniform vec3 color;\r\nuniform float opacity;\r\nuniform float near;\r\nuniform float far;\r\nuniform float sizeAttenuation;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nvarying float vCounters;\r\n\r\nvec2 fix( vec4 i, float aspect ) {\r\n\r\n    vec2 res = i.xy / i.w;\r\n    res.x *= aspect;\r\n\t vCounters = counters;\r\n    return res;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    float aspect = resolution.x / resolution.y;\r\n    float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);\r\n\r\n    vColor = vec4( color, opacity );\r\n    vUV = uv;\r\n\r\n    mat4 m = projectionMatrix * modelViewMatrix;\r\n    vec4 finalPosition = m * vec4( position, 1.0 );\r\n    vec4 prevPos = m * vec4( previous, 1.0 );\r\n    vec4 nextPos = m * vec4( next, 1.0 );\r\n\r\n    vec2 currentP = fix( finalPosition, aspect );\r\n    vec2 prevP = fix( prevPos, aspect );\r\n    vec2 nextP = fix( nextPos, aspect );\r\n\r\n    float pixelWidth = finalPosition.w * pixelWidthRatio;\r\n    float w = 1.8 * pixelWidth * lineWidth * width;\r\n\r\n    if( sizeAttenuation == 1. ) {\r\n        w = 1.8 * lineWidth * width;\r\n    }\r\n\r\n    vec2 dir;\r\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\r\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\r\n    else {\r\n        vec2 dir1 = normalize( currentP - prevP );\r\n        vec2 dir2 = normalize( nextP - currentP );\r\n        dir = normalize( dir1 + dir2 );\r\n\r\n        vec2 perp = vec2( -dir1.y, dir1.x );\r\n        vec2 miter = vec2( -dir.y, dir.x );\r\n        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\r\n\r\n    }\r\n\r\n    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;\r\n    vec2 normal = vec2( -dir.y, dir.x );\r\n    normal.x /= aspect;\r\n    normal *= .5 * w;\r\n\r\n    vec4 offset = vec4( normal * side, 0.0, 1.0 );\r\n    finalPosition.xy += offset.xy;\r\n\r\n    gl_Position = finalPosition;\r\n",
          f.ShaderChunk.logdepthbuf_vertex,
          f.ShaderChunk.fog_vertex &&
            "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
          f.ShaderChunk.fog_vertex,
          "}"
        ].join("\r\n");
        f.ShaderChunk.meshline_frag = [
          "",
          f.ShaderChunk.fog_pars_fragment,
          f.ShaderChunk.logdepthbuf_pars_fragment,
          "\r\nuniform sampler2D map;\r\nuniform sampler2D alphaMap;\r\nuniform float useMap;\r\nuniform float useAlphaMap;\r\nuniform float useDash;\r\nuniform float dashArray;\r\nuniform float dashOffset;\r\nuniform float dashRatio;\r\nuniform float visibility;\r\nuniform float alphaTest;\r\nuniform vec2 repeat;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nvarying float vCounters;\r\n\r\nvoid main() {\r\n",
          f.ShaderChunk.logdepthbuf_fragment,
          "\r\n    vec4 c = vColor;\r\n    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );\r\n    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;\r\n    if( c.a < alphaTest ) discard;\r\n    if( useDash == 1. ){\r\n        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\r\n    }\r\n    gl_FragColor = c;\r\n    gl_FragColor.a *= step(vCounters, visibility);\r\n",
          f.ShaderChunk.fog_fragment,
          "}"
        ].join("\r\n");
        e.prototype = Object.create(f.ShaderMaterial.prototype);
        e.prototype.constructor = e;
        e.prototype.isMeshLineMaterial = !0;
        e.prototype.copy = function(a) {
          f.ShaderMaterial.prototype.copy.call(this, a);
          this.lineWidth = a.lineWidth;
          this.map = a.map;
          this.useMap = a.useMap;
          this.alphaMap = a.alphaMap;
          this.useAlphaMap = a.useAlphaMap;
          this.color.copy(a.color);
          this.opacity = a.opacity;
          this.resolution.copy(a.resolution);
          this.sizeAttenuation = a.sizeAttenuation;
          this.near = a.near;
          this.far = a.far;
          this.dashArray.copy(a.dashArray);
          this.dashOffset.copy(a.dashOffset);
          this.dashRatio.copy(a.dashRatio);
          this.useDash = a.useDash;
          this.visibility = a.visibility;
          this.alphaTest = a.alphaTest;
          this.repeat.copy(a.repeat);
          return this;
        };
        a.exports && (b = a.exports = { MeshLine: c, MeshLineMaterial: e });
        b.MeshLine = c;
        b.MeshLineMaterial = e;
      }.call(sm));
    }),
    vp = hn.MeshLine,
    wp = hn.MeshLineMaterial,
    xp = (function(a) {
      function b(a) {
        ud(this, b);
        a = ve(this, (b.__proto__ || Object.getPrototypeOf(b)).call(this, a));
        a.staticDashArray = 2;
        a.time = 0;
        a.autoUpdate = !0;
        return a;
      }
      ue(b, a);
      Nc(b, [
        {
          key: "getDefaultOptions",
          value: function() {
            return {
              color: 16777215,
              textureColor: 16777215,
              textureWidth: 10,
              textureLength: 30,
              step: 0.1
            };
          }
        },
        {
          key: "initialize",
          value: function(a) {
            this.threeLayer = a;
            this.addOverlay();
          }
        },
        {
          key: "onChanged",
          value: function(a, b) {
            this.threeLayer && (this.removeOverlay(), this.addOverlay());
          }
        },
        {
          key: "onDestroy",
          value: function() {
            this.removeOverlay();
          }
        },
        {
          key: "render",
          value: function() {
            var a = this.getOptions(),
              b = a.textureWidth,
              e = a.style;
            a = a.step / 10;
            this.time += a;
            2 < this.time && (this.time = 0);
            for (var f = this.flyLine.children, h = 0; h < f.length; h++) {
              var k = f[h],
                l = k.hash;
              k.children[0].material.uniforms.lineWidth.value =
                b * (1 + 0.2 * Math.sin(5 * this.time));
              k.children[0].material.uniforms.dashOffset.value =
                "chaos" === e
                  ? k.children[0].material.uniforms.dashOffset.value - a
                  : (this.staticDashArray + l) * (1 - this.time / 2);
            }
          }
        },
        {
          key: "removeOverlay",
          value: function() {
            this.threeLayer.remove(this.flyLine);
          }
        },
        {
          key: "addOverlay",
          value: function() {
            var a = this;
            this.flyLine = new ja.Group();
            var b = this.threeLayer,
              e = new ja.TextureLoader(),
              f = this.getData();
            e.load(
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFkAAABZCAQAAAD/AkAkAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBA3y7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BUNTVQYqg4jIKAX08EGIIUByaVEZhMXIwMDAIMCgxeDHUMmwiuEBozRjFOM8xqdMhkwNTJeYNZgbme+y2LDMY2VmzWa9yubEtoldhX0mhwBHJycrZzMXM1cbNzf3RB4pnqW8xryH+IL5nvFXCwgJrBZ0E3wk1CisKHxYJF2UV3SrWJw4p/hWiRRJYcmjUhXSutJPZObIhsoJyp2V71HwUeRVvKA0RTlKRUnltepWtUZ1Pw1Zjbea+7QmaqfqWOsK6b7SO6I/36DGMMrI0ljS+LfJPdPDZivM+y0qLBOtfKwtbFRtRexY7L7aP3e47XjB6ZjzXpetruvdVrov9VjkudBrgfdCn8W+y/xW+a8P2Bq4N+hY8PmQW6HPwr5EMEUKRilFG8e4xUbF5cW3JMxO3Jx0Nvl5KlOaXLpNRlRmVdas7D059/KY8tULfAqLi2YXHy55WyZR7lJRWDmv6mz131q9uvj6SQ3HGn83G7Skt85ru94h2Ond1d59uJehz76/bsK+if8nO05pnXpiOu+M4JmzZj2aozW3ZN6+BVwLwxYtXvxxqcOyCcsfrjRe1br65lrddU3rb2402NSx+cFWq21Tt3/Y6btr1R6Oven7jh9QP9h56PURv6Obj4ufqD355LT3mS3nZM+3X/h0Ke7yqasW15bdEL3ZeuvrnfS7N+/7PDjwyPTx6qeKz2a+EHzZ9Zr5Td3bn+9LP3z6VPD53de8b+9+5P/88Lv4z7d/Vf//AwAqvx2K829RWwAAOGtpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTktMDYtMjdUMTk6MzE6MTUrMDg6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxOS0wOC0xOVQxNjo1Nzo1MCswODowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTktMDgtMTlUMTY6NTc6NTArMDg6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjE8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5Eb3QgR2FpbiAxNSU8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjQ5MmI1NTQ1LWIwNmQtNGI0Yi1iMWExLTZiN2NiNzExNzA5MjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo0OTJiNTU0NS1iMDZkLTRiNGItYjFhMS02YjdjYjcxMTcwOTI8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo0OTJiNTU0NS1iMDZkLTRiNGItYjFhMS02YjdjYjcxMTcwOTI8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NDkyYjU1NDUtYjA2ZC00YjRiLWIxYTEtNmI3Y2I3MTE3MDkyPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE5LTA2LTI3VDE5OjMxOjE1KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT42NTUzNTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODk8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODk8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PnHlyVkAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAFaZJREFUeNp8W+1661prZAA5p2/v/1p7tgUz/cFakuzsNnkS24ktITR8DYD/GMxMBrP1KLPHKzOZ/frLvPp6Dwyw61+QYDJIZmaC7PF1n88M66yfx/ybJPOYsI9jmT0+Oh/EdaDPA5rJAJhBj9/rIzJgPqL1bskgm++Pc9jHGbDOa7/E3RLlp5DfmsRDxPvKr8/D3EwADGbA0rQM12ckmDBaltmIrP3q0qT+cgc+FXW/ys833B9+iq1vPWC+4QaDw8zcDJBtaDwv1wSTltCSTDAR0kPj+Dr/8yL2830P8hspf8PalxZ8C2uOLTw2kjFalwESYKPTEXppV0aDCTQTIdMH1L70igdE5yu//4Cv3/r4nxx+iXqLDvgCxbY/2KjepC32aBuUjJBRbgRsXunW5aft4Bdk8qlX/MWGb7sVLAzmdgmNuMR1wAwuAz6RtLyGJMwPIQnNQJtL1gaby3ic+xPlWGaw7sN/vozPHq7lcW23qG4OwOXucsAcwIVr4PtwkBYoTEYTZTSJRslaMhpF4/zXfsmCDyNcWH4CHr88r+YOY4nocAvAwoEA1gUMSC6RsR3FdnIyM1KQLeE4jzCpzY1Go8FofMaG572+Bc/9Qh9Af3pec/lo12FhjoCbu9tcwBL7FhmQ+fOeUTKTgqLJaVK7jGoCBESYINgtygXRbzdgpnFyf/vHdV+XuIjRsDncY/7isC24wy5obAuEli8esSXRpBYRaiM9SFob5WibyAMjOD7E/hoZH1r+hPuy38GqW8AtsAUNC3N3OOYCFrpH4AsaWwKN8ZlE0UQ3SnLRqXYKRrQMENQGg8x4h3d8uV6MlvEVPNYlALAwt4AjRmTM7/0Y5h5wwHxp3AwY32wmAXJRbiIFGkWESCLUbECSqwlAbfB9d2E9Tz+ThHmW9itzsB3htrhuYYGEeyAsPCzcEQh3C/fRuAHumOC9QspybyGZkbKmRCMJquVwBWvFTwikRvSRpudGfUbhlRb9zZkYLt0OJMIDgXS3hHuM8AgPuDsCMPgyQ8dHdjAYNm+lk9QSmKG2gqt7h6O+RJyUiib8cr0aJ4dHzjZeWBdSEQgkHIn0gHtauiMjlp7dw5fvcIfDAML3aWQmkSZSFJ2imsFGC3QvIiAQhkDvezOGC/WkrvhMPn+nHbLxt+YIpA0E0sID4Yn0hPsSGbEEjhiRxwQXtsa5mShRbJrUbAUazpCjCThdMCO0sOwmsxCs4Lch3v45n3nbupmh8b2xvEUiEUhkBA6Eh4cnwtMHGBHLCBFu8jBd2JCZSDNSTJLd3iTam0XQDYSD5mbY0fwKHCEz23C5DTHtKyWSL1Sm+QiGwAiYSE8PT2SEH+6eHhFwRDoC8Bhv4ZdzHz2LEkmqg+xuVTvc2qtg0Py4QHlZCjS7ywHciNadyd2Fy8oWYqKcBdLCEoEDgfTDM9IDGekRR4SHu4enuzvcHYA7VtSUzEyUtJBMdnd70629regBOGGYdHqlq6Nwn0TKzFp6Bpb8cnGwOxwvLxFpGYERNz3j8Mj0wyPSwyMGKg6PFVLCDBSwcwtRarLZHt7sdu8qoL2BGoO9sU9zSXdNKaEfr8b8LqHHXa0ot9xYWvrh6elHBI7MET7SM0fkDF8AWVJvxz5hz0i2ktUaHbd7lzkBx0TqJULLRVv1iplMoAA3gXfISz2Dx0ovcXuDGDNDDpbj8CMz0o/IyIzIiMgFEB+B4bi0IJoosilFNaNZ3eUInO04hS2JDHKj+bYByelwk7TqnOXT8i5Che3cDLaEHm/sGaPbIzKPyEw/MjPjiMjwjIhwj4CHb0+3Y99AuUgyqtUVKA+Uw88yQ8NMFps2EAWBCsgIV5hsMH1BJe9cHG4ud7cdhgOBiEB6IiLz8BH4yCMyjojjyPTMiMj0CIfHhBOs9GqULDLIZkd3R5dXAeeuHc1k1qsMkGxii4wWJsjcJIG70sKN5VUSjdm5uYeF5/qdcXh4+hHHCJxHHpl5RB6ZGbEBDXfE5MwTyKzFlpLd1dnVZ5nDDYKjtiu0pUWFkG2iO2Nr12Q0H++hncnJYOZT2K8kPnYm4TmojiMyMjIzM17HEZnHK/OIyDzS48gY/wy4G4Cdc7JJsburq70B93IAqB3QzQSdclq2QBA5gjp6qh2XRKxCJy+BAVhgR7wV/5AeEZE+ZnbEEUe88jgyXkceR+aRkXkc602DZphjDJ+kwGJ3dTDrbINX2MqrYcOCTb5Ho6iEnHQPUoQQlMkIN+oBDAiAlnoc22e4X143xkNkxnHkccRxHJmv10bIOI8jgHB3X/XfpEStYHd21+ko4HTAzl0ValyKgp2YtIlKEIQjnJyLc0k+BW1ePs6Hi5iEc+fEK+WMHUQiMyMHwT/HcRz5Oo7MjHxFhke6e2L5ZmsjpV5aPt0bqyIwrKKbkESGjLmqbRKNQJvDBbhgbpwS7Sa4lvu/yk/Il8COGCfnGeED5SOP15FHvn6OzNdxHEeMz8t4BZDuAGgwjrvQu7urw6sc70UjDKlIUQeVkhgtVzC85RYKJxshocUxaDl6ar/F+wDaNXP4VCCOxIJGhI9vyPHFR74yj9dxjLYj8xUZrwiECzE0kGRFMbv63e7nHH3oI711TMrEIMnw9NFvINBwjLtc3IloPjFwp/jbS47wq2r2cI/JHWJ9HbeWX0fmkT/Hz5HHT74y/Ge7Z5+kCGojqzPOPvqPT2B0mCgZqSS7GQwFgwFHOunuCrS5hTUgx7I1AZDSDDDIfQmNxbqtGmPgsUAxITojI+OVmcfxc/wcr/w5/skjjzgyPPyY9NXcWuLJiurw081g/06FRErsg8ruFNmd3h6RbLkHR8vAIBnyeZywOmwRVmWMuXFwwH1xFAFf+YNHICImVOdx5E8cmcdP/uTrOPIVR7wiw1c9ZZI1g2T3n45aJK/1oIEkg+HpjXR6RLT7VO2Ll1q1PAHaUDo7X8aDhbDNuWHy3yXs+omcZCKOmDTjyP+KV/7kz3HEP3nkMQkHHDCa6dSri2/fJzAjmaKioyKj82hGBr1HNYH2YacGRTcD5dYGc1PqpjHGJndyBKyE3d3DxkMvPx3pERlx5JGvfB3HkfHP8cpX/GTEy+FhhBmZOv2gD+xANZkSWQxmM8/2SQMjvFaR4E5350iyhBa07pEsr3YBFiJgbu5L4NH3KNknho+G4xUZR/xELLFf+U++BtFze0AjWz/xpwwOmcSUkcWMV3Qwu9PPVaEvNsTducC5uEBoSbcSVeRiDQbR0Lobi6ryGyaOjeqpU33iS2S84oifeOVPvo6fCH9FuLuZGUmdbQgsUo6lI4sDitPdERHtiEFEBAEX/BITO5++mb6V4m9OfneW1u3wpeNlj4jROOArIEasciV9BM945SvC5+Y1TwFmPoQcO1+shbBBbnjMkVEBmJk7Yun5EhaAAFeP0Dlk1BS5Uyn64wp9E8c+iam7Y1jQQI7GwyP9le6ZEf/kT8yFAKaTwQmzzWR7+BGHv90nrHvA4RFYDg1Y53b0k62eltZWLXJfyTxeNPzie9e1TtPpOuCUSz4AwcDkiMTg+zXe2doOnc02FSOS3enliKx0dyz9Yt3bUYsmNl4qG/F360iyCSXP5o92i8zcdlAEYIttm/QAudKROWQMvwiPQPhg29wQMoZS7YeXJ05f3K87Eg9q1zEeZXWH8GjE2ePZIr4spw36kPtJfq5i/bogzIVwHXtALnMD0sMcB2KVYgZTGLxVi+DYDmkljhftv06L3X/7e8vy4r6H79OSFZsv+W5hTfJxkdJbJZuyNAujfCU86z7FZSCr5IHFZdy7Gfs8C/RsdMs2IWP2aMzBzHGzqqabEMOjcfHRTVktUcOQ8uvfNJ+WiMF63tLrrcJql8h4t09sMUGP7iLtq521OnKXAhdpmFcTXA/qbxEJplUPaeozrdrSbJ1PXB2FVstkbLWCRrPpL5VqsolpklCCWty1rMYZzNH3swdAtUiyD3t7ElwPAnof0VaJK9JkEqlNC4qiJOP8sVQ66YwGrNwPtMiT1SebZMtIlVqQqdWi9crqqEsvsinxpKtJj6fUujtSl2o3QhYHeLcZNeXjCFuiyGLrVChVHVEsRp9QKYJttNabZxerTxaLRbV6Lo7klE27zSYZOefSOuMWZ2l0qTmxbooWCHRRrKsXOt1Qradzm2VkF0V1sbqrPPrtY9MMajiVU83qP3X2WWcXyWapmy3Otbe2klfXVVwiTwvZlr7Gw1Gme7jhmpDYGsbc9pXbSpKaPbVcd5NqvjsYxTgZ7YiFq2Z4AJBa50Cjz57f766ev3WTJdFGfo7sxrmzW88myGYQgpueSegGhNaboMuuuPHaHDqwSZI13E80m+8OnO4w0Mza2sPHpGmD5j911r/17ndVn11d3SRr+GZqHVQcYteoMZy5lN0Dt82l5uXJ1ryEVktxVZskxWZsRHR3d/WxhP5TCYdDZYt5r2ZMbKRRLXbxT737Xe86+11njc7fXV3VQzBeX2PVdtnPnjDQNkUzS9NMTNieS+FNh2C6+ZSa0Wyxu8nuPjv6LA/UCfhwglDrUMbZ6YBbG9QsVZ/97n/Ps99n97vO6q7uZnV3s2rfui01L3dEexjjaBXKzeJhT6XYoj/oNLKnK6MmR1DWGd5V5e5xBv7HrcZfkj/qzsir9psDNM9+19l/6l1/zj911nm+q+rskZnkxgnVTUnLkZsuYHNNzQwnZ9MWdNudZmE1b3XBdx41FEpXhZe7n+7l+NdMbtSLzYyjI9Y8iVHFJvnu7nef55/6t8466yzWWV3dVQvavdwHbVz2CD2a5vIcazomtbyFBA3wJbVCVIuaW9bdaB+Bq8JR7jPscAXbF5XdFetqJo1iS6o+eXbVu97979nnn/Ndf6r6rKqqrupmVxd7hB5gWLP1cLGXtVli+QvtMZqWy0msHhKaJWewu7vc345yR6OA90qwKLGz+Ipoj3SbxFRtI8J7HF2966z3edZ51nme1XVWn8PitorN7lJbs9kTBGzpeY2eDDBmLMwIiEZQAo3WCrELwWaQ3ajwdrh7Tda5CgOa5bRNKyoysk7ffWyJakrvLladfZ5nvavOd73rfZ7nAvRApBewx+mTJRnVo+UJxPMs70C9yEiaSCO6I8mGq7vgQgXaqxfpbYun5/KfFRkV4eHpWlpeHWCSZ1dXnd1V9T7f53n22edZ3X2yu7pY7LEXUW0t3t8bsLjNb/SsPXGyQOFNR9NZNmA4+64jxkUuQJHNiIx0D0c4sHLagYxGpu6qs6rfZ53vqrPOs/qcK2GxOXgme+VKrbYl8uWCd6tyD4StcTB3giLpzYIz0PRqOGrxgDi1+03U8D8e5Rnu4YZ0rjSgJYkn1c2zq7vOqgXj8+xzIL2/VSrOT2tFw0kgV0TcM5+rgymjiBYwV+iCoGCtAtD7rry12TFKZDa7IzJqdXjeU9+sONBNsavZZ/eYXJ1nnb1+94riA40BxuiYNKqtbfrxxG7vTOw2GkS4hDYX1XRra4COlncBsIbt0mYnzSGJHRGnD0ERfndXR881gZ7d3ed4tz7PlXCclwkuR8diT3ZrC9P2GJCyR0OYcBsnB7Wv3r1KoKMMZjUd8Z3tWcpEZZKd4RGIXETNbgtwZcHj2tndxd6BZFvkJB0nWxsYrakJOJndGm3l1wAlJtGeVGE1WawFeSMWVYqzH2OKE0ZJdgyrEhE1zIzv0nGC7OTETTZZVcWu4gSRc4Hi7OLJnjpgw2L5jdb2yruH/Si+OTWxj18GIGfHEAMFW6SH9rwQqWxmsDticWvYdMrMm9nOsMgmW6xJhqq7z64qVp1cJvdwc2W9vre4tOcIyWMMhoK7WnBY071sWkEQaG4NM1iNyBkyOplBZ/TQozdNdZWPU8JM6O/mFpm14kt18WT1ElulW8+3V37MF+XHCLkw/6baYKVFdNH2NIetxN8psvsIRjM8ejP9j/G+Paezq9spZap5pZ19srpHYI6oZa1Ws3TnzrwnyvE9dIaBx9AMvYpCOLipj5ndXPmgK6VgINLX8NlquQ+fDKNJEKf62klmTy5RrVrBo3SyVGyeavbWsvXyGbv4e45cP6aUqUl9DYY9ET2j0zZu3Q9Z7FAaMzqiQDgsws1W4+vXONTyAWQ1VexuTiq0DE/b9ErNtrLmwvFzmPICxp7J0BJ6QCtYY5rHtnl/SuZUBkmnh0dHOEfH6HgQmct1ThE3Kd3S9DKyFTpO9nJwrbZSkVZaI4BG8ZMI03Po7LoW3hsLMgPlBtHCSCTWaLrTyPDwNaKGxZ3vhYKlhB0CV4U0WZIukY1dap7iaJhtVNnkFz3ziPqY9sXXbNFGDC/Wy9ws2cO1IdxmstRaKaIVcsZw/Vy9lSd9uga4hmhaVc7ibqZ4alsA0XJuorXauByc9LEF8TGLj8eA3/jBx17ORTfRnCa2AmJ7gMLM2vIxeo01gI/LN+9Wn6jJ05o9RRMHu+TyFSt/611A4UFfXljGx1ztRSZyDY2NrsylcJl6WtQEEaKXwnpNjOPS8T2oKswgsMjhQ0T1ZKSDWbaNppd+t8jg9hPfO0SJ7xWiazzcekhlaQh5GAVCTdBH6FKA0663Nctx0c8SIK7CQTRT06wlEkU9wsWIv7XbIvre7nmOd9rnyPXvlRObdE+LrpZJ7iEhjGzEjGuir24sNPw+9uQSNsO30XxNXJA7fxgPbFdCb42VUfwet1/zGJ8O5GvwVpeLkZkEJxFGhbtRjT3UczVv71n8Ndp+i0wN57uL0Kk4JmjsNIxDMeE55fvtzzYwPveiHrtRspYgBWQutzCZGxlr2CTQM7lsV+9qxtqvPHxF1E1Qa1Eq4vTfd0Y8hekeaMdjOQdfC3Wpryn8z2lhTbI0qwQTzsIodwkIcQYcgXZA7qaZZ7Hd1ZdwM93CKokok/UIP+5MmtrDiC8Rn6s5q9/3n79un/3an1nDldPftpltXmtHPr2bq21jeGxPXATwVOOPzZ2pmvfuzipJv8/8uSR5TXDZx5Lg5z7j5UeknvE6iDMdOZdgFt0j/AxPb/PDpLh7FO6Kgqv8nDpee9VIF6/5+z5/ozmfzRN97d19LdPxGuXknq4iZsTbXPdILx5belrUju4Ghj1McUjL5yba54oZ7HvtzAz//X+sUX3uUD5S1Onir2GeGUPY3a61NfCx1DQdAU3nzO5a7lrk0u9lLvs/1+c+Fo5kn5b6uaH0EF97j3YXXuYyAQ5TC4+moi5k6OpxbSH3LOfXeuS3NN9Lt2b41LL+HwP8vaE2c1UDib0KamsrZAbbLye3auEb07haCb/vrv3l2ccm4H++vPG3cL/2Vr83AlcIkeBrTck+VLXjmO5+gX5tHeO5D/Crg/25Hpr4tVpsX3smf19ctAc7MHMR40rus16a0d7Ffu6ufK6c2od/+BtYbif3vwMADydd0XelVe4AAAAASUVORK5CYII=",
              function(c) {
                for (var d = 0; d < f.length; d++) {
                  var e = f[d].geometry.coordinates.map(function(a) {
                    return new (Function.prototype.bind.apply(
                      ja.Vector3,
                      [null].concat(tm(b.normizedPoint(a)))
                    ))();
                  });
                  e = a.createFlyLine({
                    originalData: f[d],
                    curveData: e,
                    texture: c
                  });
                  a.flyLine.add(e);
                }
                b.add(a.flyLine);
              }
            );
          }
        },
        {
          key: "createFlyLine",
          value: function(a) {
            var b = this.options,
              c = b.color,
              f = b.textureColor,
              h = b.textureWidth,
              k = a.originalData,
              l = a.curveData;
            a = a.texture;
            var m = Math.random();
            b = Math.min(1, 1 - b.textureLength / 100);
            b = Math.max(0, b);
            "[object Function]" === Object.prototype.toString.call(c) &&
              (c = c(k));
            "[object Function]" === Object.prototype.toString.call(f) &&
              (f = f(k));
            k = new ja.Geometry();
            k.vertices = l;
            k.verticesNeedUpdate = !0;
            c = new ja.LineBasicMaterial({
              linewidth: 1,
              color: new ja.Color(c),
              blending: ja.AdditiveBlending,
              depthTest: !0,
              depthWrite: !1,
              transparent: !0,
              opacity: 0.3,
              linecap: "round",
              linejoin: "round"
            });
            c = new ja.Line(k, c);
            c.renderDepth = !1;
            c.hash = m;
            k = new vp();
            for (var n = new ja.Geometry(), q = 0; q < l.length; q++) {
              var r = l[q];
              n.vertices.push(new ja.Vector3(r.x, r.y, r.z));
            }
            k.setGeometry(n, function(a) {
              return 1 - a;
            });
            f = new wp({
              map: a,
              useMap: !0,
              color: new ja.Color(f),
              opacity: 1,
              dashArray: this.staticDashArray + m,
              dashOffset: 0,
              dashRatio: b,
              sizeAttenuation: !0,
              lineWidth: h,
              depthWrite: !1,
              depthTest: !0,
              alphaTest: !1,
              transparent: !0,
              blending: ja.AdditiveBlending,
              side: ja.DoubleSide
            });
            f = new ja.Mesh(k.geometry, f);
            c.add(f);
            return c;
          }
        }
      ]);
      return b;
    })(hj);
  Nb.THREE = ja;
  Nb.PostProcessing = tp;
  Nb.FanLayer = up;
  Nb.FlyLineLayer = xp;
  Nb.ThreeLayer = ym;
  Object.defineProperty(Nb, "__esModule", { value: !0 });
});
